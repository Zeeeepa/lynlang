// Regular Expression Module for Zen
// Provides basic regex pattern matching capabilities

{ allocate_raw, deallocate_raw } = import("memory.zen")

strlen = (str: RawPtr<i8>) i64 {
    inline.c("""
        return strlen(${str.addr});
    """)
}

// Regex pattern types
RegexNode: Literal(ch: i8)
    | Dot                           // . matches any character
    | CharClass(chars: RawPtr<i8>, negated: bool)  // [abc] or [^abc]
    | Star(child: Ptr<RegexNode>)       // * zero or more
| Plus(child: Ptr<RegexNode>)       // + one or more
| Question(child: Ptr<RegexNode>)   // ? zero or one
| Sequence(nodes: Ptr<RegexNode>, count: i32)
| Alternation(left: Ptr<RegexNode>, right: Ptr<RegexNode>)  // |
| Group(child: Ptr<RegexNode>, capturing: bool)
    | Anchor(start: bool)           // ^ or $

// Compiled regex pattern
Regex: {
    pattern: RawPtr<i8>,
    root: Ptr<RegexNode>,
    group_count: i32,
}

// Match result
RegexMatch: {
    matched: bool,
    start: i32,
    end: i32,
    groups: Ptr<RegexGroup>,
    group_count: i32,
}

RegexGroup: {
    start: i32,
    end: i32,
    text: RawPtr<i8>,
}

// Regex parser state
RegexParser: {
    pattern: RawPtr<i8>,
    position: i32,
    length: i32,
    group_count: i32,
}

// Create a new regex parser
regex_parser_new = (pattern: RawPtr<i8>) RegexParser   {
    return RegexParser {
        pattern: pattern,
        position: 0,
        length: strlen(pattern) as i32,
        group_count: 0,
    }
}

// Parse a single character
regex_parse_char = (parser: Ptr<RegexParser>) Ptr<RegexNode> {
    ch := parser.pattern[parser.position]
    parser.position = parser.position + 1
    
    // Handle escape sequences
    ch == 92 ? | true { { // backslash }
        parser.position < parser.length ? | true {
            escaped := parser.pattern[parser.position]
            parser.position = parser.position + 1
            
            // Common escape sequences
            escaped == 110 ? | true { { // \n }
                node := RegexNode:Literal(10)
                result := allocate_raw(@sizeof(RegexNode)) as *RegexNode
                *result = node
                return result
            } | false {}
            
            escaped == 116 ? | true { { // \t }
                node := RegexNode:Literal(9)
                result := allocate_raw(@sizeof(RegexNode)) as *RegexNode
                *result = node
                return result
            } | false {}
            
            // Default: treat as literal
            node := RegexNode:Literal(escaped)
            result := allocate_raw(@sizeof(RegexNode)) as *RegexNode
            *result = node
            return result
        } | false {
            node := RegexNode:Literal(ch)
            result := allocate_raw(@sizeof(RegexNode)) as *RegexNode
            *result = node
            return result
        }
    } | false {}
    
    // Dot metacharacter
    ch == 46 ? | true { { // . }
        node := RegexNode:Dot
        result := allocate_raw(@sizeof(RegexNode)) as *RegexNode
        *result = node
        return result
    } | false {}
    
    // Start anchor
    ch == 94 ? | true { { // ^ }
        node := RegexNode:Anchor(true)
        result := allocate_raw(@sizeof(RegexNode)) as *RegexNode
        *result = node
        return result
    } | false {}
    
    // End anchor
    ch == 36 ? | true { { // $ }
        node := RegexNode:Anchor(false)
        result := allocate_raw(@sizeof(RegexNode)) as *RegexNode
        *result = node
        return result
    } | false {}
    
    // Character class
    ch == 91 ? | true { { // [ }
        return regex_parse_char_class(parser)
    } | false {}
    
    // Group
    ch == 40 ? | true { { // ( }
        parser.group_count = parser.group_count + 1
        child := regex_parse_sequence(parser)
        parser.position = parser.position + 1 // Skip )
        
        node := RegexNode:Group(child, true)
        result := allocate_raw(@sizeof(RegexNode)) as *RegexNode
        *result = node
        return result
    } | false {}
    
    // Literal character
    node := RegexNode:Literal(ch)
    result := allocate_raw(@sizeof(RegexNode)) as Ptr<RegexNode>
    result.write(node)
    return result
}

// Parse character class [abc] or [^abc]
regex_parse_char_class = (parser: *RegexParser) *RegexNode {
    chars := allocate_raw(256 as i64) as RawPtr<i8>
    char_count := 0
    negated := false
    
    // Check for negation
    parser.pattern[parser.position] == 94 ? | true { { // ^ }
        negated = true
        parser.position = parser.position + 1
    } | false {}
    
    // Collect characters
    loop {
        parser.position >= parser.length ? | true { { break  }} | false {}
        
        ch := parser.pattern[parser.position]
        ch == 93 ? | true { { // ] }
            parser.position = parser.position + 1
            break
        } | false {}
        
        // Handle range a-z
        parser.position + 2 < parser.length && 
        parser.pattern[parser.position + 1] == 45 ? | true { { // - }
            start := ch
            end := parser.pattern[parser.position + 2]
            
            range(start as i32, (end + 1) as i32).loop((i) {
                chars[char_count] = i as i8
                char_count = char_count + 1
            })
            
            parser.position = parser.position + 3
        } | false {
            chars[char_count] = ch
            char_count = char_count + 1
            parser.position = parser.position + 1
        }
    }
    
    chars[char_count] = 0
    
    node := RegexNode:CharClass(chars, negated)
    result := allocate_raw(@sizeof(RegexNode)) as Ptr<RegexNode>
    result.write(node)
    return result
}

// Parse sequence of nodes
regex_parse_sequence = (parser: *RegexParser) *RegexNode {
    nodes := allocate_raw(256 * @sizeof(RegexNode)) as *RegexNode
    node_count := 0
    
    loop {
        parser.position >= parser.length ? | true { { break  }} | false {}
        
        ch := parser.pattern[parser.position]
        
        // End of group or alternation
        ch == 41 || ch == 124 ? | true { { // ) or | }
            break
        } | false {}
        
        // Parse atom
        atom := regex_parse_char(parser)
        
        // Check for quantifiers
        parser.position < parser.length ? | true {
            quant := parser.pattern[parser.position]
            
            quant == 42 ? | true { { // * }
                node := RegexNode:Star(atom)
                atom = allocate_raw(@sizeof(RegexNode)) as *RegexNode
                *atom = node
                parser.position = parser.position + 1
            } | false {}
            
            quant == 43 ? | true { { // + }
                node := RegexNode:Plus(atom)
                atom = allocate_raw(@sizeof(RegexNode)) as *RegexNode
                *atom = node
                parser.position = parser.position + 1
            } | false {}
            
            quant == 63 ? | true { { // ? }
                node := RegexNode:Question(atom)
                atom = allocate_raw(@sizeof(RegexNode)) as *RegexNode
                *atom = node
                parser.position = parser.position + 1
            } | false {}
        } | false {}
        
        nodes[node_count] = *atom
        node_count = node_count + 1
    }
    
    node_count == 1 ? | true {
        return &nodes[0]
    } | false {
        node := RegexNode:Sequence(nodes, node_count)
        result := allocate_raw(@sizeof(RegexNode)) as *RegexNode
        *result = node
        return result
    }
}

// Compile regex pattern
regex_compile = (pattern: RawPtr<i8>) Regex   {
    parser := regex_parser_new(pattern)
    root := regex_parse_sequence(&parser)
    
    return Regex {
        pattern: pattern,
        root: root,
        group_count: parser.group_count,
    }
}

// Match a single node at position
regex_match_node = (node: *RegexNode, text: RawPtr<i8>, pos: i32, length: i32) (bool, i32) {
    pos >= length ? | true {
        // Check if node can match empty
        node ?
            | Star(_) { { return (true, pos)  }}
            | Question(_) { { return (true, pos)  }}
            | Anchor(false) { { return (true, pos)  }} // $ at end
            | _ { { return (false, pos)  }}
    } | false {}
    
    node ?
        | Literal(ch) {
            text[pos] == ch ? | true {
                return (true, pos + 1)
            } | false {
                return (false, pos)
            }
        }
        | Dot {
            text[pos] != 10 ? | true { { // Not newline }
                return (true, pos + 1)
            } | false {
                return (false, pos)
            }
        }
        | CharClass(chars, negated) {
            // Check if character is in class
            found := false
            i := 0
            loop {
                chars[i] == 0 ? | true { { break  }} | false {}
                chars[i] == text[pos] ? | true {
                    found = true
                    break
                } | false {}
                i = i + 1
            }
            
            := negated ? | true ?
            ? | true ?
                return (true, pos + 1)
            } | false {
                return (false, pos)
            }
        }
        | Star(child) {
            // Try to match zero or more
            new_pos := pos
            loop {
                result := regex_match_node(child, text, new_pos, length)
                result.0 ? | true {
                    new_pos = result.1
                } | false {
                    break
                }
            }
            return (true, new_pos)
        }
        | Plus(child) {
            // Must match at least once
            result := regex_match_node(child, text, pos, length)
            result.0 ? | false {
                return (false, pos)
            } | true {}
            
            // Match more if possible
            new_pos := result.1
            loop {
                result2 := regex_match_node(child, text, new_pos, length)
                result2.0 ? | true {
                    new_pos = result2.1
                } | false {
                    break
                }
            }
            return (true, new_pos)
        }
        | Question(child) {
            // Try to match, but ok if it doesn't
            result := regex_match_node(child, text, pos, length)
            result.0 ? | true {
                return (true, result.1)
            } | false {
                return (true, pos)
            }
        }
        | Sequence(nodes, count) {
            new_pos := pos
            range(0, count).loop((i) {
                result := regex_match_node(&nodes[i], text, new_pos, length)
                result.0 ? | true {
                    new_pos = result.1
                } | false {
                    return (false, pos)
                }
            })
            return (true, new_pos)
        }
        | Group(child, _) {
            return regex_match_node(child, text, pos, length)
        }
        | Anchor(start) {
            start ? | true {
                pos == 0 ? | true {
                    return (true, pos)
                } | false {
                    return (false, pos)
                }
            } | false {
                pos == length ? | true {
                    return (true, pos)
                } | false {
                    return (false, pos)
                }
            }
        }
        | Alternation(left, right) {
            // Try left first
            result := regex_match_node(left, text, pos, length)
            result.0 ? | true {
                return result
            } | false {
                // Try right
                return regex_match_node(right, text, pos, length)
            }
        }
}

// Match regex against text
regex_match = (regex: Regex, text: RawPtr<i8>) RegexMatch   {
    length := strlen(text) as i32
    
    // Try matching at each position
    range(0, length + 1).loop((start) {
        result := regex_match_node(regex.root, text, start, length)
        result.0 ? | true {
            return RegexMatch {
                matched: true,
                start: start,
                end: result.1,
                groups: 0 as *RegexGroup,
                group_count: 0,
            }
        } | false {}
    })
    
    return RegexMatch {
        matched: false,
        start: 0,
        end: 0,
        groups: 0 as *RegexGroup,
        group_count: 0,
    }
}

// Test if pattern matches text
regex_test = (pattern: RawPtr<i8>, text: RawPtr<i8>) bool   {
    regex := regex_compile(pattern)
    match := regex_match(regex, text)
    return match.matched
}

// Replace first match
regex_replace = (pattern: RawPtr<i8>, text: RawPtr<i8>, replacement: RawPtr<i8>) RawPtr<i8> {
    regex := regex_compile(pattern)
    match := regex_match(regex, text)
    
    match.matched ? | false {
        return text
    } | true {}
    
    text_len := strlen(text) as i32
    repl_len := strlen(replacement) as i32
    new_len := text_len - (match.end - match.start) + repl_len
    
    result := allocate_raw((new_len + 1) as i64) as RawPtr<i8>
    
    // Copy before match
    range(0, match.start).loop((i) {
        result[i] = text[i]
    })
    
    // Copy replacement
    range(0, repl_len).loop((i) {
        result[match.start + i] = replacement[i]
    })
    
    // Copy after match
    range(match.end, text_len).loop((i) {
        result[match.start + repl_len + (i - match.end)] = text[i]
    })
    
    result[new_len] = 0
    return result
}

// Free regex
regex_free = (regex: *Regex) void   {
    // Would need to recursively free nodes
    free(regex.root as RawPtr<void>)
}