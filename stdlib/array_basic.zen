// Basic array utilities module written in pure Zen
// Provides fundamental array manipulation functions

// Sum all elements in an integer array
sum_i32 = (arr: []i32, len: i32) i32 {
    sum := 0
    i := 0
    
    while (i < len) {
        sum = sum + arr[i]
        i = i + 1
    }
    
    return sum
}

// Find minimum element in array
min_element_i32 = (arr: []i32, len: i32) i32 {
    if (len <= 0) {
        return 0
    }
    
    min := arr[0]
    i := 1
    
    while (i < len) {
        if (arr[i] < min) {
            min = arr[i]
        }
        i = i + 1
    }
    
    return min
}

// Find maximum element in array
max_element_i32 = (arr: []i32, len: i32) i32 {
    if (len <= 0) {
        return 0
    }
    
    max := arr[0]
    i := 1
    
    while (i < len) {
        if (arr[i] > max) {
            max = arr[i]
        }
        i = i + 1
    }
    
    return max
}

// Linear search - returns index or -1
find_i32 = (arr: []i32, len: i32, value: i32) i32 {
    i := 0
    
    while (i < len) {
        if (arr[i] == value) {
            return i
        }
        i = i + 1
    }
    
    return -1
}

// Count occurrences of value
count_i32 = (arr: []i32, len: i32, value: i32) i32 {
    count := 0
    i := 0
    
    while (i < len) {
        if (arr[i] == value) {
            count = count + 1
        }
        i = i + 1
    }
    
    return count
}

// Check if array contains value
contains_i32 = (arr: []i32, len: i32, value: i32) bool {
    return find_i32(arr, len, value) != -1
}

// Reverse array in place
reverse_i32 = (arr: []i32, len: i32) void {
    left := 0
    right := len - 1
    
    while (left < right) {
        // Swap elements
        temp := arr[left]
        arr[left] = arr[right]
        arr[right] = temp
        
        left = left + 1
        right = right - 1
    }
}

// Copy array elements
copy_i32 = (dest: []i32, src: []i32, len: i32) void {
    i := 0
    
    while (i < len) {
        dest[i] = src[i]
        i = i + 1
    }
}

// Fill array with value
fill_i32 = (arr: []i32, len: i32, value: i32) void {
    i := 0
    
    while (i < len) {
        arr[i] = value
        i = i + 1
    }
}

// Check if arrays are equal
equal_i32 = (arr1: []i32, arr2: []i32, len: i32) bool {
    i := 0
    
    while (i < len) {
        if (arr1[i] != arr2[i]) {
            return false
        }
        i = i + 1
    }
    
    return true
}

// Bubble sort (simple but inefficient)
bubble_sort_i32 = (arr: []i32, len: i32) void {
    i := 0
    
    while (i < len - 1) {
        j := 0
        while (j < len - i - 1) {
            if (arr[j] > arr[j + 1]) {
                // Swap
                temp := arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            }
            j = j + 1
        }
        i = i + 1
    }
}

// Binary search (assumes sorted array)
binary_search_i32 = (arr: []i32, len: i32, value: i32) i32 {
    left := 0
    right := len - 1
    
    while (left <= right) {
        mid := left + (right - left) / 2
        
        if (arr[mid] == value) {
            return mid
        }
        
        if (arr[mid] < value) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1
}

// Partition for quicksort
partition_i32 = (arr: []i32, low: i32, high: i32) i32 {
    pivot := arr[high]
    i := low - 1
    j := low
    
    while (j < high) {
        if (arr[j] < pivot) {
            i = i + 1
            // Swap arr[i] and arr[j]
            temp := arr[i]
            arr[i] = arr[j]
            arr[j] = temp
        }
        j = j + 1
    }
    
    // Swap arr[i+1] and arr[high]
    temp := arr[i + 1]
    arr[i + 1] = arr[high]
    arr[high] = temp
    
    return i + 1
}

// Check if array is sorted
is_sorted_i32 = (arr: []i32, len: i32) bool {
    if (len <= 1) {
        return true
    }
    
    i := 0
    while (i < len - 1) {
        if (arr[i] > arr[i + 1]) {
            return false
        }
        i = i + 1
    }
    
    return true
}

// Rotate array left by n positions
rotate_left_i32 = (arr: []i32, len: i32, n: i32) void {
    if (len <= 1 || n <= 0) {
        return
    }
    
    // Normalize n
    n = n % len
    
    // Use reversal algorithm
    // Reverse first n elements
    reverse_range_i32(arr, 0, n - 1)
    // Reverse remaining elements
    reverse_range_i32(arr, n, len - 1)
    // Reverse entire array
    reverse_range_i32(arr, 0, len - 1)
}

// Helper function to reverse a range
reverse_range_i32 = (arr: []i32, start: i32, end: i32) void {
    while (start < end) {
        temp := arr[start]
        arr[start] = arr[end]
        arr[end] = temp
        start = start + 1
        end = end - 1
    }
}