// Zen Standard Library: Fixed-Size Vector Implementation
// A stack-allocated, fixed-size vector type

core := @std

// Fixed-size vector structure - stack allocated
Vec<T, N>: {
    data: [T; N]         // Fixed-size array on stack
    len: usize           // Current number of elements (â‰¤ N)
}

// Create a new empty fixed-size vector
Vec<T, N>.new = () Vec<T, N> {
    return Vec<T, N>{
        data: [core.default<T>(); N],
        len: 0
    }
}

// Create from an array
Vec<T, N>.from_array = (arr: [T; N]) Vec<T, N> {
    return Vec<T, N>{
        data: arr,
        len: N
    }
}

// Push element to the vector
Vec<T, N>.push = (self: *Vec<T, N>, value: T) core.Result<void, core.Error> {
    self.len >= N ? 
        | true => core.Result:Err(core.Error:CapacityExceeded(self.len, N))
        | false => {
            self.data[self.len] = value
            self.len = self.len + 1
            core.Result:Ok({})
        }
}

// Pop element from the vector
Vec<T, N>.pop = (self: *Vec<T, N>) core.Option<T> {
    self.len == 0 ? 
        | true => core.Option:None
        | false => {
            self.len = self.len - 1
            core.Option:Some(self.data[self.len])
        }
}

// Get element at index
Vec<T, N>.get = (self: *Vec<T, N>, index: usize) core.Result<T, core.Error> {
    index >= self.len ? 
        | true => core.Result:Err(core.Error:IndexOutOfBounds(index, self.len))
        | false => core.Result:Ok(self.data[index])
}

// Set element at index
Vec<T, N>.set = (self: *Vec<T, N>, index: usize, value: T) core.Result<void, core.Error> {
    index >= self.len ? 
        | true => core.Result:Err(core.Error:IndexOutOfBounds(index, self.len))
        | false => {
            self.data[index] = value
            core.Result:Ok({})
        }
}

// Get vector length
Vec<T, N>.len = (self: *Vec<T, N>) usize {
    return self.len
}

// Get vector capacity (always N)
Vec<T, N>.capacity = (self: *Vec<T, N>) usize {
    return N
}

// Check if vector is empty
Vec<T, N>.is_empty = (self: *Vec<T, N>) bool {
    return self.len == 0
}

// Check if vector is full
Vec<T, N>.is_full = (self: *Vec<T, N>) bool {
    return self.len == N
}

// Clear the vector (remove all elements)
Vec<T, N>.clear = (self: *Vec<T, N>) void {
    self.len = 0
}

// Insert element at position
Vec<T, N>.insert = (self: *Vec<T, N>, index: usize, value: T) core.Result<void, core.Error> {
    index > self.len ?
        | true => core.Result:Err(core.Error:IndexOutOfBounds(index, self.len))
        | false => {
            self.len >= N ?
                | true => core.Result:Err(core.Error:CapacityExceeded(self.len + 1, N))
                | false => {
                    // Shift elements to the right
                    i ::= self.len
                    loop {
                        i == index ? | true => break
                                    | false => {}
                        self.data[i] = self.data[i - 1]
                        i = i - 1
                    }
                    
                    self.data[index] = value
                    self.len = self.len + 1
                    core.Result:Ok({})
                }
        }
}

// Remove element at position
Vec<T, N>.remove = (self: *Vec<T, N>, index: usize) core.Result<T, core.Error> {
    index >= self.len ?
        | true => core.Result:Err(core.Error:IndexOutOfBounds(index, self.len))
        | false => {
            value := self.data[index]
            
            // Shift elements to the left
            i ::= index
            loop {
                i >= self.len - 1 ? | true => break
                                    | false => {}
                self.data[i] = self.data[i + 1]
                i = i + 1
            }
            
            self.len = self.len - 1
            core.Result:Ok(value)
        }
}

// Convert to dynamic vector
Vec<T, N>.to_dynamic = (self: *Vec<T, N>) DynVec<T> {
    dyn_vec := DynVec<T>.with_capacity(self.len).unwrap_or(DynVec<T>.new())
    
    i ::= 0
    loop {
        i >= self.len ? | true => break
                       | false => {}
        dyn_vec.push(self.data[i])
        i = i + 1
    }
    
    return dyn_vec
}

// Iterator support
Vec<T, N>.iter = (self: *Vec<T, N>) VecIterator<T, N> {
    return VecIterator<T, N>{
        vec: self,
        index: 0
    }
}

VecIterator<T, N>: {
    vec: *Vec<T, N>
    index: usize
}

VecIterator<T, N>.next = (self: *VecIterator<T, N>) core.Option<T> {
    self.index >= self.vec.len ?
        | true => core.Option:None
        | false => {
            value := self.vec.data[self.index]
            self.index = self.index + 1
            core.Option:Some(value)
        }
}

// Functional operations
Vec<T, N>.map<U> = (self: *Vec<T, N>, f: (T) U) Vec<U, N> {
    result := Vec<U, N>.new()
    
    i ::= 0
    loop {
        i >= self.len ? | true => break
                       | false => {}
        result.push(f(self.data[i]))
        i = i + 1
    }
    
    return result
}

Vec<T, N>.filter = (self: *Vec<T, N>, predicate: (T) bool) DynVec<T> {
    result := DynVec<T>.new()
    
    i ::= 0
    loop {
        i >= self.len ? | true => break
                       | false => {}
        predicate(self.data[i]) ?
            | true => result.push(self.data[i])
            | false => {}
        i = i + 1
    }
    
    return result
}

Vec<T, N>.fold<U> = (self: *Vec<T, N>, initial: U, f: (U, T) U) U {
    acc ::= initial
    
    i ::= 0
    loop {
        i >= self.len ? | true => break
                       | false => {}
        acc = f(acc, self.data[i])
        i = i + 1
    }
    
    return acc
}

// Export the type
export Vec