// Zen Memory Management Module - Unified Implementation
// Consolidates memory allocation, deallocation, and management utilities

{ core, io, inline } := @std

// External C function declarations for low-level operations
allocate_raw = (size: usize) RawPtr<void> {
    inline.c("""
        return malloc(${size});
    """)
}

deallocate_raw = (ptr: RawPtr<void>) void {
    inline.c("""
        free(${ptr.addr});
    """)
}

reallocate_raw = (ptr: RawPtr<void>, new_size: usize) RawPtr<void> {
    inline.c("""
        return realloc(${ptr.addr}, ${new_size});
    """)
}

allocate_zeroed_raw = (count: usize, size: usize) RawPtr<void> {
    inline.c("""
        return calloc(${count}, ${size});
    """)
}

copy_memory_raw = (dest: RawPtr<void>, src: RawPtr<void>, size: usize) RawPtr<void> {
    inline.c("""
        return memcpy(${dest.addr}, ${src.addr}, ${size});
    """)
}

move_memory_raw = (dest: RawPtr<void>, src: RawPtr<void>, size: usize) RawPtr<void> {
    inline.c("""
        return memmove(${dest.addr}, ${src.addr}, ${size});
    """)
}

set_memory_raw = (ptr: RawPtr<void>, value: i32, size: usize) RawPtr<void> {
    inline.c("""
        return memset(${ptr.addr}, ${value}, ${size});
    """)
}

compare_memory_raw = (ptr1: RawPtr<void>, ptr2: RawPtr<void>, size: usize) i32 {
    inline.c("""
        return memcmp(${ptr1.addr}, ${ptr2.addr}, ${size});
    """)
}

// Memory constants
DEFAULT_ALIGN := 8
CACHE_LINE_SIZE := 64

// Memory allocation tracking
AllocationInfo := {
    ptr: RawPtr<void>
    size: usize
    line: u32
    file: string
    next: Option<Ptr<AllocationInfo>>
}

// Memory statistics
MemoryStats := {
    total_allocated: usize
    total_freed: usize
    current_usage: usize
    peak_usage: usize
    allocation_count: u32
    deallocation_count: u32
}

// Global memory tracker
MemoryTracker := {
    head: Option<Ptr<AllocationInfo>>
    stats: MemoryStats
}

// Global tracker instance
memory_tracker: MemoryTracker = MemoryTracker{
    head: Option.None,
    stats: MemoryStats{
        total_allocated: 0,
        total_freed: 0,
        current_usage: 0,
        peak_usage: 0,
        allocation_count: 0,
        deallocation_count: 0
    }
}

// High-level allocation functions
allocate = <T>(count: usize) Result<Ptr<T>, core.Error> {
    size := count * @sizeof(T)
    ptr := allocate_raw(size)
    
    (ptr == null) ? {
        return Err(.OutOfMemory)
    }
    
    // Track allocation in debug mode
    @debug ? {
        track_allocation(ptr, size, @line, @file)
    }
    
    return Ok(@ptrcast(Ptr<T>, ptr))
}

// Allocate zeroed memory
allocate_zeroed = <T>(count: usize) Result<Ptr<T>, core.Error> {
    ptr := allocate_zeroed_raw(count, @sizeof(T))
    
    (ptr == null) ? {
        return Err(.OutOfMemory)
    }
    
    // Track allocation in debug mode
    @debug ? {
        track_allocation(ptr, count * @sizeof(T), @line, @file)
    }
    
    return Ok(@ptrcast(Ptr<T>, ptr))
}

// Reallocate memory
reallocate = <T>(ptr: Ptr<T>, new_count: usize) Result<Ptr<T>, core.Error> {
    new_size := new_count * @sizeof(T)
    new_ptr := reallocate_raw(@ptrcast(RawPtr<void>, ptr), new_size)
    
    (new_ptr == null) ? {
        return Err(.OutOfMemory)
    }
    
    // Update tracking in debug mode
    @debug ? {
        untrack_allocation(@ptrcast(RawPtr<void>, ptr))
        track_allocation(new_ptr, new_size, @line, @file)
    }
    
    return Ok(@ptrcast(Ptr<T>, new_ptr))
}

// Deallocate memory
deallocate = <T>(ptr: Ptr<T>) void {
    (ptr == null) ? { return }
    
    // Untrack allocation in debug mode
    @debug ? {
        untrack_allocation(@ptrcast(RawPtr<void>, ptr))
    }
    
    deallocate_raw(@ptrcast(RawPtr<void>, ptr))
}

// Memory utility functions
copy = <T>(dest: Ptr<T>, src: Ptr<T>, count: usize) void {
    size := count * @sizeof(T)
    copy_memory_raw(@ptrcast(RawPtr<void>, dest), @ptrcast(RawPtr<void>, src), size)
}

move = <T>(dest: Ptr<T>, src: Ptr<T>, count: usize) void {
    size := count * @sizeof(T)
    move_memory_raw(@ptrcast(RawPtr<void>, dest), @ptrcast(RawPtr<void>, src), size)
}

set = <T>(ptr: Ptr<T>, value: u8, count: usize) void {
    size := count * @sizeof(T)
    set_memory_raw(@ptrcast(RawPtr<void>, ptr), @intcast(i32, value), size)
}

compare = <T>(ptr1: Ptr<T>, ptr2: Ptr<T>, count: usize) i32 {
    size := count * @sizeof(T)
    return compare_memory_raw(@ptrcast(RawPtr<void>, ptr1), @ptrcast(RawPtr<void>, ptr2), size)
}

// Aligned allocation
alloc_aligned = (size: usize, alignment: usize) Result<RawPtr<void>, core.Error> {
    (size == 0) ? {
        return Err(.InvalidArgument("Size must be positive"))
    }
    
    (alignment == 0 || (alignment & (alignment - 1)) != 0) ? {
        return Err(.InvalidArgument("Alignment must be power of 2"))
    }
    
    // Allocate extra space for alignment
    total_size := size + alignment - 1
    ptr := allocate_raw(total_size)
    
    (ptr == null) ? {
        return Err(.OutOfMemory)
    }
    
    // Align the pointer
    aligned_addr := ((@intcast(usize, ptr) + alignment - 1) / alignment) * alignment
    aligned_ptr := @ptrcast(RawPtr<void>, aligned_addr)
    
    // Track allocation in debug mode
    @debug ? {
        track_allocation(aligned_ptr, size, @line, @file)
    }
    
    return Ok(aligned_ptr)
}

// Arena allocator for temporary allocations
Arena := {
    buffer: Ptr<u8>
    capacity: usize
    offset: usize
    previous: Option<Ptr<Arena>>
}

arena_new = (capacity: usize) Result<Ptr<Arena>, core.Error> {
    arena_result := allocate<Arena>(1)
    arena_result ? 
        | Err(e) { return Err(e) }
        | Ok(arena) {
            buffer_result := allocate<u8>(capacity)
            buffer_result ?
                | Err(e) {
                    deallocate(arena)
                    return Err(e)
                }
                | Ok(buffer) {
                    arena.buffer = buffer
                    arena.capacity = capacity
                    arena.offset = 0
                    arena.previous = Option.None
                    return Ok(arena)
                }
        }
}

arena_allocate = <T>(arena: Ptr<Arena>, count: usize) Result<Ptr<T>, core.Error> {
    size := count * @sizeof(T)
    alignment := @alignof(T)
    
    // Align offset
    aligned_offset := (arena.offset + alignment - 1) & ~(alignment - 1)
    
    (aligned_offset + size > arena.capacity) ? {
        return Err(.OutOfMemory)
    }
    
    ptr := @ptrcast(Ptr<T>, arena.buffer.addr + aligned_offset)
    arena.offset = aligned_offset + size
    
    return Ok(ptr)
}

arena_reset = (arena: Ptr<Arena>) void {
    arena.offset = 0
}

arena_destroy = (arena: Ptr<Arena>) void {
    deallocate(arena.buffer)
    deallocate(arena)
}

// Pool allocator for fixed-size objects
Pool<T> := {
    block_size: usize
    blocks_per_chunk: usize
    free_list: Option<Ptr<PoolNode<T>>>
    chunks: Option<Ptr<PoolChunk<T>>>
}

PoolNode<T> := {
    next: Option<Ptr<PoolNode<T>>>
}

PoolChunk<T> := {
    memory: Ptr<u8>
    next: Option<Ptr<PoolChunk<T>>>
}

pool_new = <T>(blocks_per_chunk: usize) Result<Ptr<Pool<T>>, core.Error> {
    pool_result := allocate<Pool<T>>(1)
    pool_result ?
        | Err(e) { return Err(e) }
        | Ok(pool) {
            pool.block_size = @sizeof(T)
            pool.blocks_per_chunk = blocks_per_chunk
            pool.free_list = Option.None
            pool.chunks = Option.None
            return Ok(pool)
        }
}

pool_allocate = <T>(pool: Ptr<Pool<T>>) Result<Ptr<T>, core.Error> {
    // Check free list first
    pool.free_list ? 
        | Option.Some(node) {
            pool.free_list = node.next
            return Ok(@ptrcast(Ptr<T>, node))
        }
        | Option.None {
            // Allocate new chunk
            allocate_pool_chunk<T>(pool) ?
                | Err(e) { return Err(e) }
                | Ok(_) { return pool_allocate<T>(pool) }
        }
}

allocate_pool_chunk = <T>(pool: Ptr<Pool<T>>) Result<void, core.Error> {
    chunk_result := allocate<PoolChunk<T>>(1)
    chunk_result ?
        | Err(e) { return Err(e) }
        | Ok(chunk) {
            memory_result := allocate<u8>(pool.block_size * pool.blocks_per_chunk)
            memory_result ?
                | Err(e) {
                    deallocate(chunk)
                    return Err(e)
                }
                | Ok(memory) {
                    chunk.memory = memory
                    chunk.next = pool.chunks
                    pool.chunks = Option.Some(chunk)
                    
                    // Add all blocks to free list
                    i := 0
                    loop (i < pool.blocks_per_chunk) {
                        node := @ptrcast(Ptr<PoolNode<T>>, chunk.memory.addr + i * pool.block_size)
                        node.next = pool.free_list
                        pool.free_list = Option.Some(node)
                        i += 1
                    }
                    
                    return Ok()
                }
        }
}

pool_deallocate = <T>(pool: Ptr<Pool<T>>, ptr: Ptr<T>) void {
    node := @ptrcast(Ptr<PoolNode<T>>, ptr)
    node.next = pool.free_list
    pool.free_list = Option.Some(node)
}

pool_destroy = <T>(pool: Ptr<Pool<T>>) void {
    current := pool.chunks
    loop (current) {
        current ? 
            | Option.Some(chunk) {
                next := chunk.next
                deallocate(chunk.memory)
                deallocate(chunk)
                current = next
            }
            | Option.None { break }
    }
    deallocate(pool)
}

// Allocation tracking functions (debug mode)
track_allocation = (ptr: RawPtr<void>, size: usize, line: u32, file: string) void {
    info_result := allocate<AllocationInfo>(1)
    info_result ? 
        | Ok(info) {
            info.ptr = ptr
            info.size = size
            info.line = line
            info.file = file
            info.next = memory_tracker.head
            
            memory_tracker.head = Option.Some(info)
            memory_tracker.stats.total_allocated += size
            memory_tracker.stats.allocation_count += 1
            
            current_usage := memory_tracker.stats.total_allocated - memory_tracker.stats.total_freed
            (current_usage > memory_tracker.stats.peak_usage) ? {
                memory_tracker.stats.peak_usage = current_usage
            }
        }
        | Err(_) {
            // Tracking allocation failed, but continue
        }
}

untrack_allocation = (ptr: RawPtr<void>) void {
    prev: Option<Ptr<AllocationInfo>> = Option.None
    current := memory_tracker.head
    
    loop (current) {
        current ? 
            | Option.Some(info) {
                (info.ptr == ptr) ? {
                    // Remove from list
                    prev ? 
                        | Option.Some(p) { p.next = info.next }
                        | Option.None { memory_tracker.head = info.next }
                    
                    memory_tracker.stats.total_freed += info.size
                    memory_tracker.stats.deallocation_count += 1
                    deallocate_raw(@ptrcast(RawPtr<void>, info))
                    return
                }
                prev = current
                current = info.next
            }
            | Option.None { break }
    }
}

// Memory statistics functions
get_memory_stats = () MemoryStats {
    current_usage := memory_tracker.stats.total_allocated - memory_tracker.stats.total_freed
    return MemoryStats{
        total_allocated: memory_tracker.stats.total_allocated,
        total_freed: memory_tracker.stats.total_freed,
        current_usage: current_usage,
        peak_usage: memory_tracker.stats.peak_usage,
        allocation_count: memory_tracker.stats.allocation_count,
        deallocation_count: memory_tracker.stats.deallocation_count
    }
}

print_memory_stats = () void {
    stats := get_memory_stats()
    
    io.println("=== Memory Statistics ===")
    io.printf("Total Allocated: {} bytes\n", stats.total_allocated)
    io.printf("Total Freed: {} bytes\n", stats.total_freed)
    io.printf("Current Usage: {} bytes\n", stats.current_usage)
    io.printf("Peak Usage: {} bytes\n", stats.peak_usage)
    io.printf("Allocations: {}\n", stats.allocation_count)
    io.printf("Deallocations: {}\n", stats.deallocation_count)
    
    // Check for leaks
    (stats.current_usage > 0) ? {
        io.println("WARNING: Potential memory leak detected!")
        print_allocations()
    }
}

print_allocations = () void {
    io.println("=== Active Allocations ===")
    
    current := memory_tracker.head
    index := 0
    
    loop (current) {
        current ? 
            | Option.Some(info) {
                io.printf("[{}] {} bytes at {}:{}\n", 
                         index, info.size, info.file, info.line)
                current = info.next
                index += 1
            }
            | Option.None { break }
    }
    
    (index == 0) ? {
        io.println("No active allocations")
    }
}

// Reset memory statistics
reset_stats = () void {
    memory_tracker.stats = MemoryStats{
        total_allocated: 0,
        total_freed: 0,
        current_usage: 0,
        peak_usage: 0,
        allocation_count: 0,
        deallocation_count: 0
    }
}
