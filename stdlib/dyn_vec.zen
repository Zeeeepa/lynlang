// DynVec - Dynamic Vector with Allocator support
// As per LANGUAGE_SPEC.zen, this supports mixed variant types!

{ Allocator } = @std

// DynVec can hold multiple variant types from an enum
// Example: DynVec<GameEntity.Player, GameEntity.Enemy>
DynVec<T>: {
    data: MutPtr<T>,
    len: usize,
    capacity: usize,
    allocator: Allocator,
}

// Initialize with allocator
init = <T>(alloc: Allocator) DynVec<T> {
    return DynVec<T> {
        data: alloc.null_ptr(),
        len: 0,
        capacity: 0,
        allocator: alloc,
    }
}

// Initialize with capacity
with_capacity = <T>(alloc: Allocator, cap: usize) DynVec<T> {
    data = alloc.allocate<T>(cap)
    return DynVec<T> {
        data: data,
        len: 0,
        capacity: cap,
        allocator: alloc,
    }
}

// Push element
push = <T>(vec: MutPtr<DynVec<T>>, value: T) void {
    vec.val.len >= vec.val.capacity ?
        | true { grow(vec) }
        | false {}
    
    vec.val.data[vec.val.len] = value
    vec.val.len = vec.val.len + 1
}

// Pop element
pop = <T>(vec: MutPtr<DynVec<T>>) Option<T> {
    vec.val.len > 0 ?
        | true {
            vec.val.len = vec.val.len - 1
            return Option.Some(vec.val.data[vec.val.len])
        }
        | false { return Option.None }
}

// Get element at index
get = <T>(vec: Ptr<DynVec<T>>, index: usize) Option<T> {
    index < vec.val.len ?
        | true { return Option.Some(vec.val.data[index]) }
        | false { return Option.None }
}

// Set element at index
set = <T>(vec: MutPtr<DynVec<T>>, index: usize, value: T) bool {
    index < vec.val.len ?
        | true { 
            vec.val.data[index] = value
            return true
        }
        | false { return false }
}

// Loop over elements - supports .loop() method from spec
loop = <T>(vec: Ptr<DynVec<T>>, f: (T) void) void {
    i ::= 0
    loop(() {
        i >= vec.val.len ?
            | true { break }
            | false {
                f(vec.val.data[i])
                i = i + 1
            }
    })
}

// Loop with index
loop_with_index = <T>(vec: Ptr<DynVec<T>>, f: (T, usize) void) void {
    i ::= 0
    loop(() {
        i >= vec.val.len ?
            | true { break }
            | false {
                f(vec.val.data[i], i)
                i = i + 1
            }
    })
}

// Grow capacity
grow = <T>(vec: MutPtr<DynVec<T>>) void {
    new_cap = vec.val.capacity == 0 ?
        | true { 4 }
        | false { vec.val.capacity * 2 }
    
    new_data = vec.val.allocator.allocate<T>(new_cap)
    
    // Copy old data
    i ::= 0
    loop(() {
        i >= vec.val.len ?
            | true { break }
            | false {
                new_data[i] = vec.val.data[i]
                i = i + 1
            }
    })
    
    // Free old data if it exists
    vec.val.capacity > 0 ?
        | true { vec.val.allocator.free(vec.val.data) }
        | false {}
    
    vec.val.data = new_data
    vec.val.capacity = new_cap
}

// Clean up
deinit = <T>(vec: MutPtr<DynVec<T>>) void {
    vec.val.capacity > 0 ?
        | true { vec.val.allocator.free(vec.val.data) }
        | false {}
    
    vec.val.data = vec.val.allocator.null_ptr()
    vec.val.len = 0
    vec.val.capacity = 0
}

// Length
len = <T>(vec: Ptr<DynVec<T>>) usize {
    return vec.val.len
}

// Is empty
is_empty = <T>(vec: Ptr<DynVec<T>>) bool {
    return vec.val.len == 0
}

// Clear all elements
clear = <T>(vec: MutPtr<DynVec<T>>) void {
    vec.val.len = 0
}