// Zen Standard Library - Collections Module
// Advanced data structures and collections

core := @std
build := @std
memory := build.import("memory")

// Import the new Vec and DynVec types
fixed_vec := build.import("fixed_vec")
dyn_vec := build.import("dyn_vec")

// Export the proper types
Vec := fixed_vec.Vec       // Fixed-size vector
DynVec := dyn_vec.DynVec   // Dynamic vector

// Vector is now an alias for DynVec for backwards compatibility
Vector<T>: DynVec<T>

// Create new vector - delegates to DynVec
Vector<T>.new = () Vector<T> {
    return DynVec<T>.new()
}

// Create vector with initial capacity - delegates to DynVec
Vector<T>.with_capacity = (cap: usize) Vector<T> {
    return DynVec<T>.with_capacity(cap).unwrap_or(DynVec<T>.new())
}

// Vector methods are inherited from Vec since Vector<T> is an alias

// Linked list node
ListNode<T>: {
    value: T
    next: Option<Ref<ListNode<T>>>
}

// Linked list implementation
LinkedList<T>: {
    head: Option<Ref<ListNode<T>>>
    tail: Option<Ref<ListNode<T>>>
    len: usize
}

// Create new linked list
LinkedList<T>.new = () LinkedList<T> {
    return LinkedList<T>{
        head: .None,
        tail: .None,
        len: 0
    }
}

// Push element to front
LinkedList<T>.push_front = (self: Ref<LinkedList<T>>, value: T) void {
    node ::= memory.alloc(ListNode<T>)
    node.val.value = value
    node.val.next = self.val.head
    
    self.val.head = .Some(node)
    self.val.tail ?
        | .None {
            self.val.tail = .Some(node)
        }
        | .Some(_) {}
    
    self.val.len = self.val.len + 1
}

// Push element to back
LinkedList<T>.push_back = (self: Ref<LinkedList<T>>, value: T) void {
    node ::= memory.alloc(ListNode<T>)
    node.val.value = value
    node.val.next = .None
    
    self.val.tail ?
        | .Some(tail_node) {
            tail_node.val.next = .Some(node)
        }
        | .None {
            self.val.head = .Some(node)
        }
    
    self.val.tail = .Some(node)
    self.val.len = self.val.len + 1
}

// Pop element from front
LinkedList<T>.pop_front = (self: Ref<LinkedList<T>>) Option<T> {
    self.val.head ?
        | .None {
            return .None
        }
        | .Some(node) {
            value ::= node.val.value
            
            self.val.head = node.val.next
            self.val.head ?
                | .None {
                    self.val.tail = .None
                }
                | .Some(_) {}
            
            memory.free(node)
            self.val.len = self.val.len - 1
            
            return .Some(value)
        }
}

// Stack implementation using Vec
Stack<T>: {
    data: Vec<T>
}

// Create new stack
Stack<T>.new = () Stack<T> {
    return Stack<T>{
        data: Vec<T>.new()
    }
}

// Push element onto stack
Stack<T>.push = (self: Ref<Stack<T>>, value: T) void {
    vec_module.vec_push(self.data, value)
}

// Pop element from stack  
Stack<T>.pop = (self: Ref<Stack<T>>) Option<T> {
    return vec_module.vec_pop(self.data)
}

// Peek at top element
Stack<T>.peek = (self: Ref<Stack<T>>) Option<T> {
    return vec_module.vec_last(self.data)
}

// Check if stack is empty
Stack<T>.is_empty = (self: Ref<Stack<T>>) bool {
    return vec_module.vec_is_empty(self.data)
}

// Queue implementation using linked list
Queue<T>: {
    list: LinkedList<T>
}

// Create new queue
Queue<T>.new = () Queue<T> {
    return Queue<T>{
        list: LinkedList<T>.new()
    }
}

// Enqueue element
Queue<T>.enqueue = (self: Ref<Queue<T>>, value: T) void {
    self.val.list.push_back(value)
}

// Dequeue element
Queue<T>.dequeue = (self: Ref<Queue<T>>) Option<T> {
    return self.val.list.pop_front()
}

// Peek at front element
Queue<T>.peek = (self: Ref<Queue<T>>) Option<T> {
    self.list.head ?
        | .Some(node) => .Some(node.value)
        | .None => .None
}

// Check if queue is empty
Queue<T>.is_empty = (self: Ref<Queue<T>>) bool {
    return self.list.len == 0
}

// Hash map bucket
HashBucket<K, V>: {
    key: K
    value: V
    next: Option<Ref<HashBucket<K, V>>>
}

// Hash map implementation
HashMap<K, V>: {
    buckets: Vec<Option<Ref<HashBucket<K, V>>>>
    len: usize
    capacity: usize
}

// Create new hash map
HashMap<K, V>.new = () HashMap<K, V> {
    buckets := Vec<Option<Ref<HashBucket<K, V>>>>.with_capacity(16).unwrap_or_default()
    return HashMap<K, V>{
        buckets: buckets,
        len: 0,
        capacity: 16
    }
}

// Hash function (simple for now)
hash<K> = (key: K, capacity: usize) usize {
    // Simple hash for numeric types - needs proper implementation
    return 0  // Placeholder - needs proper hash implementation
}

// Put key-value pair
HashMap<K, V>.put = (self: Ref<HashMap<K, V>>, key: K, value: V) void {
    index := hash(key, self.capacity)
    
    // Check if key exists
    current := self.buckets[index]
    while (current) {
        current.key == key ? {
            current.value = value
            return
        }
        current = current.next
    }
    
    // Add new bucket
    bucket := memory.alloc(HashBucket)
    bucket.key = key
    bucket.value = value
    bucket.next = self.buckets[index]
    
    self.buckets[index] = bucket
    self.len = self.len + 1
    
    // Resize if needed
    self.len > self.capacity * 3 / 4 ? {
        self.resize()
    }
}

// Get value by key
HashMap<K, V>.get = (self: Ref<HashMap<K, V>>, key: K) Option<V> {
    index := hash(key, self.capacity)
    
    current := self.buckets[index]
    while (current) {
        current.key == key ? {
            return current.value
        }
        current = current.next
    }
    
    return null
}

// Remove key-value pair
HashMap<K, V>.remove = (self: Ref<HashMap<K, V>>, key: K) bool {
    index := hash(key, self.capacity)
    
    prev := null
    current := self.buckets[index]
    
    while (current) {
        current.key == key ? {
            prev ? {
                prev.next = current.next
            } | false {
                self.buckets[index] = current.next
            }
            
            memory.free(current)
            self.len = self.len - 1
            return true
        }
        
        prev = current
        current = current.next
    }
    
    return false
}

// Check if key exists
HashMap<K, V>.contains = (self: Ref<HashMap<K, V>>, key: K) bool {
    return self.get(key) ?
        | .Some(_) => true
        | .None => false
}

// Resize hash map
HashMap<K, V>.resize = (self: Ref<HashMap<K, V>>) void {
    new_capacity := self.capacity * 2
    new_buckets := make([]?&HashBucket, new_capacity)
    
    // Rehash all entries
    i := 0
    while (i < self.capacity) {
        current := self.buckets[i]
        while (current) {
            next := current.next
            
            // Rehash and insert
            new_index := hash(current.key, new_capacity)
            current.next = new_buckets[new_index]
            new_buckets[new_index] = current
            
            current = next
        }
        i = i + 1
    }
    
    self.buckets = new_buckets
    self.capacity = new_capacity
}

// Set implementation using hash map
HashSet<T>: {
    map: HashMap<T, bool>
}

// Create new set
HashSet<T>.new = () HashSet<T> {
    return HashSet<T>{
        map: HashMap<T, bool>.new()
    }
}

// Add element to set
HashSet<T>.add = (self: Ref<HashSet<T>>, value: T) void {
    self.map.put(value, true)
}

// Remove element from set
HashSet<T>.remove = (self: Ref<HashSet<T>>, value: T) bool {
    return self.map.remove(value)
}

// Check if element exists
HashSet<T>.contains = (self: Ref<HashSet<T>>, value: T) bool {
    return self.map.contains(value)
}

// Get set size
HashSet<T>.size = (self: Ref<HashSet<T>>) usize {
    return self.map.len
}