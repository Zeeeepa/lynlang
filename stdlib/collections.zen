// Zen Standard Library - Collections Module
// Advanced data structures and collections

core := @std

// Import vector types from vec module
vec_module = import("vec")
Vec := vec_module.Vec       // Fixed-size vector Vec<T, N>
DynVec := vec_module.DynVec // Dynamic vector DynVec<T>

// Import collections from subdirectory
collections_module = import("collections/mod")

// Vector is an alias for DynVec for backwards compatibility  
Vector<T> = DynVec<T>

// Stack implementation using DynVec
Stack<T>: {
    data: DynVec<T>
}

// Create new stack
Stack<T>.new = () Stack<T> {
    return Stack<T>{
        data: DynVec<T>.init(@std.default_allocator())
    }
}

// Push element onto stack
Stack<T>.push = (self: Ptr<Stack<T>>, value: T) void {
    DynVec<T>.push(&self.data, value)
}

// Pop element from stack
Stack<T>.pop = (self: Ptr<Stack<T>>) core.Option<T> {
    return DynVec<T>.pop(&self.data)
}

// Peek at top element
Stack<T>.peek = (self: Ptr<Stack<T>>) core.Option<T> {
    self.data.len > 0 ?
        | true => DynVec<T>.get(&self.data, self.data.len - 1)
        | false => core.Option:None
}

// Check if stack is empty
Stack<T>.is_empty = (self: Ptr<Stack<T>>) bool {
    return DynVec<T>.is_empty(&self.data)
}

// Get stack size
Stack<T>.size = (self: Ptr<Stack<T>>) usize {
    return DynVec<T>.len(&self.data)
}

// Queue implementation using linked list from collections/list.zen
Queue<T>: {
    list: collections_module.List<T>
}

// Create new queue
Queue<T>.new = () Queue<T> {
    return Queue<T>{
        list: collections_module.new<T>()
    }
}

// Enqueue element
Queue<T>.enqueue = (self: Ptr<Queue<T>>, value: T) void {
    collections_module.push_back(&self.list, value)
}

// Dequeue element
Queue<T>.dequeue = (self: Ptr<Queue<T>>) core.Option<T> {
    return collections_module.pop_front(&self.list)
}

// Peek at front element
Queue<T>.peek = (self: Ptr<Queue<T>>) core.Option<T> {
    return collections_module.peek_front(&self.list)
}

// Check if queue is empty
Queue<T>.is_empty = (self: Ptr<Queue<T>>) bool {
    return collections_module.is_empty(&self.list)
}

// Get queue size
Queue<T>.size = (self: Ptr<Queue<T>>) usize {
    return collections_module.len(&self.list)
}

// Hash set implementation using HashMap from collections/hashmap.zen
Set<T>: {
    map: collections_module.HashMap<T, bool>
}

// Create new set
Set<T>.new = () Set<T> {
    return Set<T>{
        map: collections_module.hashmap_new<T, bool>()
    }
}

// Add element to set
Set<T>.add = (self: Ptr<Set<T>>, value: T, hash_func: (T) i64) core.Result<bool, core.Error> {
    contains := collections_module.hashmap_contains(&self.map, value, hash_func)
    contains ? | true {
        return core.Result:Ok(false)  // Already exists
    } | false {
        result := collections_module.hashmap_insert(&self.map, value, true, hash_func)
        return result ? | Ok(_) => core.Result:Ok(true) | Err(e) => core.Result:Err(e)
    }
}

// Remove element from set
Set<T>.remove = (self: Ptr<Set<T>>, value: T, hash_func: (T) i64) bool {
    result := collections_module.hashmap_remove(&self.map, value, hash_func)
    return result ? | Some(_) => true | None => false
}

// Check if element exists in set
Set<T>.contains = (self: Ptr<Set<T>>, value: T, hash_func: (T) i64) bool {
    return collections_module.hashmap_contains(&self.map, value, hash_func)
}

// Get set size
Set<T>.size = (self: Ptr<Set<T>>) i64 {
    return collections_module.hashmap_len(&self.map)
}

// Check if set is empty
Set<T>.is_empty = (self: Ptr<Set<T>>) bool {
    return collections_module.hashmap_is_empty(&self.map)
}

// Clear set
Set<T>.clear = (self: *Set<T>) void {
    collections_module.hashmap_clear(&self.map)
}

// Export all collections types and re-export the collections from subdirectory
module.exports = { 
    ...collections_module,
    Vec, DynVec, Vector,
    Stack, Queue, Set
}
