// Zen Standard Library - Collections Module
// Advanced data structures and collections

core := @std.core
memory := @std.memory

// Dynamic array (vector) implementation
Vector := {
    data: []T
    len: usize
    capacity: usize
}

// Create new vector
Vector.new = () Vector {
    return Vector{
        data: make([]T, 16),
        len: 0,
        capacity: 16
    }
}

// Create vector with initial capacity
Vector.with_capacity = (cap: usize) Vector {
    return Vector{
        data: make([]T, cap),
        len: 0,
        capacity: cap
    }
}

// Push element to vector
Vector.push = (self: &Vector, value: T) void {
    if (self.len >= self.capacity) {
        self.grow()
    }
    self.data[self.len] = value
    self.len = self.len + 1
}

// Pop element from vector
Vector.pop = (self: &Vector) ?T {
    if (self.len == 0) {
        return null
    }
    self.len = self.len - 1
    return self.data[self.len]
}

// Get element at index
Vector.get = (self: &Vector, index: usize) ?T {
    if (index >= self.len) {
        return null
    }
    return self.data[index]
}

// Set element at index
Vector.set = (self: &Vector, index: usize, value: T) bool {
    if (index >= self.len) {
        return false
    }
    self.data[index] = value
    return true
}

// Insert element at index
Vector.insert = (self: &Vector, index: usize, value: T) bool {
    if (index > self.len) {
        return false
    }
    
    if (self.len >= self.capacity) {
        self.grow()
    }
    
    // Shift elements right
    i := self.len
    while (i > index) {
        self.data[i] = self.data[i - 1]
        i = i - 1
    }
    
    self.data[index] = value
    self.len = self.len + 1
    return true
}

// Remove element at index
Vector.remove = (self: &Vector, index: usize) ?T {
    if (index >= self.len) {
        return null
    }
    
    value := self.data[index]
    
    // Shift elements left
    i := index
    while (i < self.len - 1) {
        self.data[i] = self.data[i + 1]
        i = i + 1
    }
    
    self.len = self.len - 1
    return value
}

// Clear vector
Vector.clear = (self: &Vector) void {
    self.len = 0
}

// Check if vector is empty
Vector.is_empty = (self: &Vector) bool {
    return self.len == 0
}

// Grow vector capacity
Vector.grow = (self: &Vector) void {
    new_capacity := self.capacity * 2
    new_data := make([]T, new_capacity)
    
    // Copy existing data
    i := 0
    while (i < self.len) {
        new_data[i] = self.data[i]
        i = i + 1
    }
    
    self.data = new_data
    self.capacity = new_capacity
}

// Linked list node
ListNode := {
    value: T
    next: ?&ListNode
}

// Linked list implementation
LinkedList := {
    head: ?&ListNode
    tail: ?&ListNode
    len: usize
}

// Create new linked list
LinkedList.new = () LinkedList {
    return LinkedList{
        head: null,
        tail: null,
        len: 0
    }
}

// Push element to front
LinkedList.push_front = (self: &LinkedList, value: T) void {
    node := memory.alloc(ListNode)
    node.value = value
    node.next = self.head
    
    self.head = node
    if (self.tail == null) {
        self.tail = node
    }
    
    self.len = self.len + 1
}

// Push element to back
LinkedList.push_back = (self: &LinkedList, value: T) void {
    node := memory.alloc(ListNode)
    node.value = value
    node.next = null
    
    if (self.tail) {
        self.tail.next = node
    } else {
        self.head = node
    }
    
    self.tail = node
    self.len = self.len + 1
}

// Pop element from front
LinkedList.pop_front = (self: &LinkedList) ?T {
    if (self.head == null) {
        return null
    }
    
    node := self.head
    value := node.value
    
    self.head = node.next
    if (self.head == null) {
        self.tail = null
    }
    
    memory.free(node)
    self.len = self.len - 1
    
    return value
}

// Stack implementation using vector
Stack := {
    data: Vector
}

// Create new stack
Stack.new = () Stack {
    return Stack{
        data: Vector.new()
    }
}

// Push element onto stack
Stack.push = (self: &Stack, value: T) void {
    self.data.push(value)
}

// Pop element from stack
Stack.pop = (self: &Stack) ?T {
    return self.data.pop()
}

// Peek at top element
Stack.peek = (self: &Stack) ?T {
    if (self.data.len == 0) {
        return null
    }
    return self.data.data[self.data.len - 1]
}

// Check if stack is empty
Stack.is_empty = (self: &Stack) bool {
    return self.data.is_empty()
}

// Queue implementation using linked list
Queue := {
    list: LinkedList
}

// Create new queue
Queue.new = () Queue {
    return Queue{
        list: LinkedList.new()
    }
}

// Enqueue element
Queue.enqueue = (self: &Queue, value: T) void {
    self.list.push_back(value)
}

// Dequeue element
Queue.dequeue = (self: &Queue) ?T {
    return self.list.pop_front()
}

// Peek at front element
Queue.peek = (self: &Queue) ?T {
    if (self.list.head) {
        return self.list.head.value
    }
    return null
}

// Check if queue is empty
Queue.is_empty = (self: &Queue) bool {
    return self.list.len == 0
}

// Hash map bucket
HashBucket := {
    key: K
    value: V
    next: ?&HashBucket
}

// Hash map implementation
HashMap := {
    buckets: []?&HashBucket
    len: usize
    capacity: usize
}

// Create new hash map
HashMap.new = () HashMap {
    return HashMap{
        buckets: make([]?&HashBucket, 16),
        len: 0,
        capacity: 16
    }
}

// Hash function (simple for now)
hash: (key: K, capacity: usize) usize  = {
    // Simple hash for numeric types
    return key % capacity
}

// Put key-value pair
HashMap.put = (self: &HashMap, key: K, value: V) void {
    index := hash(key, self.capacity)
    
    // Check if key exists
    current := self.buckets[index]
    while (current) {
        if (current.key == key) {
            current.value = value
            return
        }
        current = current.next
    }
    
    // Add new bucket
    bucket := memory.alloc(HashBucket)
    bucket.key = key
    bucket.value = value
    bucket.next = self.buckets[index]
    
    self.buckets[index] = bucket
    self.len = self.len + 1
    
    // Resize if needed
    if (self.len > self.capacity * 3 / 4) {
        self.resize()
    }
}

// Get value by key
HashMap.get = (self: &HashMap, key: K) ?V {
    index := hash(key, self.capacity)
    
    current := self.buckets[index]
    while (current) {
        if (current.key == key) {
            return current.value
        }
        current = current.next
    }
    
    return null
}

// Remove key-value pair
HashMap.remove = (self: &HashMap, key: K) bool {
    index := hash(key, self.capacity)
    
    prev := null
    current := self.buckets[index]
    
    while (current) {
        if (current.key == key) {
            if (prev) {
                prev.next = current.next
            } else {
                self.buckets[index] = current.next
            }
            
            memory.free(current)
            self.len = self.len - 1
            return true
        }
        
        prev = current
        current = current.next
    }
    
    return false
}

// Check if key exists
HashMap.contains = (self: &HashMap, key: K) bool {
    return self.get(key) != null
}

// Resize hash map
HashMap.resize = (self: &HashMap) void {
    new_capacity := self.capacity * 2
    new_buckets := make([]?&HashBucket, new_capacity)
    
    // Rehash all entries
    i := 0
    while (i < self.capacity) {
        current := self.buckets[i]
        while (current) {
            next := current.next
            
            // Rehash and insert
            new_index := hash(current.key, new_capacity)
            current.next = new_buckets[new_index]
            new_buckets[new_index] = current
            
            current = next
        }
        i = i + 1
    }
    
    self.buckets = new_buckets
    self.capacity = new_capacity
}

// Set implementation using hash map
HashSet := {
    map: HashMap
}

// Create new set
HashSet.new = () HashSet {
    return HashSet{
        map: HashMap.new()
    }
}

// Add element to set
HashSet.add = (self: &HashSet, value: T) void {
    self.map.put(value, true)
}

// Remove element from set
HashSet.remove = (self: &HashSet, value: T) bool {
    return self.map.remove(value)
}

// Check if element exists
HashSet.contains = (self: &HashSet, value: T) bool {
    return self.map.contains(value)
}

// Get set size
HashSet.size = (self: &HashSet) usize {
    return self.map.len
}