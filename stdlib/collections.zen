// Zen Standard Library - Collections Module
// Advanced data structures and collections

{ core } = @std.core
{ memory } = @std.memory

// Dynamic array (vector) implementation
Vector<T>: {
    data: DynVec<T>
    len: usize
    capacity: usize
}

// Create new vector
Vector.new = () Vector<T> {
    return Vector<T>{
        data: DynVec<T>.new(16),
        len: 0,
        capacity: 16
    }
}

// Create vector with initial capacity
Vector.with_capacity = (cap: usize) Vector<T> {
    return Vector<T>{
        data: DynVec<T>.new(cap),
        len: 0,
        capacity: cap
    }
}

// Push element to vector
Vector.push = (self: MutPtr<Vector<T>>, value: T) void {
    self.val.len >= self.val.capacity ?
        | true {
            self.grow()
        }
        | false {}
    self.val.data.set(self.val.len, value)
    self.val.len = self.val.len + 1
}

// Pop element from vector
Vector.pop = (self: MutPtr<Vector<T>>) Option<T> {
    self.val.len == 0 ?
        | true {
            return .None
        }
        | false {}
    self.val.len = self.val.len - 1
    return self.val.data.get(self.val.len)
}

// Get element at index
Vector.get = (self: Ptr<Vector<T>>, index: usize) Option<T> {
    index >= self.val.len ?
        | true {
            return .None
        }
        | false {}
    return self.val.data.get(index)
}

// Set element at index
Vector.set = (self: MutPtr<Vector<T>>, index: usize, value: T) bool {
    index >= self.val.len ?
        | true {
            return false
        }
        | false {}
    self.val.data.set(index, value)
    return true
}

// Insert element at index
Vector.insert = (self: MutPtr<Vector<T>>, index: usize, value: T) bool {
    index > self.val.len ?
        | true {
            return false
        }
        | false {}
    
    self.val.len >= self.val.capacity ?
        | true {
            self.grow()
        }
        | false {}
    
    // Shift elements right
    i ::= self.val.len
    loop(() {
        i <= index ?
            | true { break }
            | false {
                prev_val ::= self.val.data.get(i - 1)
                self.val.data.set(i, prev_val)
                i = i - 1
            }
    })
    
    self.val.data.set(index, value)
    self.val.len = self.val.len + 1
    return true
}

// Remove element at index
Vector.remove = (self: MutPtr<Vector<T>>, index: usize) Option<T> {
    index >= self.val.len ?
        | true {
            return .None
        }
        | false {}
    
    value ::= self.val.data.get(index)
    
    // Shift elements left
    i ::= index
    loop(() {
        i >= self.val.len - 1 ?
            | true { break }
            | false {
                next_val ::= self.val.data.get(i + 1)
                self.val.data.set(i, next_val)
                i = i + 1
            }
    })
    
    self.val.len = self.val.len - 1
    return value
}

// Clear vector
Vector.clear = (self: MutPtr<Vector<T>>) void {
    self.val.len = 0
}

// Check if vector is empty
Vector.is_empty = (self: Ptr<Vector<T>>) bool {
    return self.val.len == 0
}

// Grow vector capacity
Vector.grow = (self: MutPtr<Vector<T>>) void {
    new_capacity ::= self.val.capacity * 2
    new_data ::= DynVec<T>.new(new_capacity)
    
    // Copy existing data
    i ::= 0
    loop(() {
        i >= self.val.len ?
            | true { break }
            | false {
                val ::= self.val.data.get(i)
                new_data.set(i, val)
                i = i + 1
            }
    })
    
    self.val.data = new_data
    self.val.capacity = new_capacity
}

// Linked list node
ListNode<T>: {
    value: T
    next: Option<MutPtr<ListNode<T>>>
}

// Linked list implementation
LinkedList<T>: {
    head: Option<MutPtr<ListNode<T>>>
    tail: Option<MutPtr<ListNode<T>>>
    len: usize
}

// Create new linked list
LinkedList.new = () LinkedList<T> {
    return LinkedList<T>{
        head: .None,
        tail: .None,
        len: 0
    }
}

// Push element to front
LinkedList.push_front = (self: MutPtr<LinkedList<T>>, value: T) void {
    node ::= memory.alloc(ListNode<T>)
    node.val.value = value
    node.val.next = self.val.head
    
    self.val.head = .Some(node)
    self.val.tail ?
        | .None {
            self.val.tail = .Some(node)
        }
        | .Some(_) {}
    
    self.val.len = self.val.len + 1
}

// Push element to back
LinkedList.push_back = (self: MutPtr<LinkedList<T>>, value: T) void {
    node ::= memory.alloc(ListNode<T>)
    node.val.value = value
    node.val.next = .None
    
    self.val.tail ?
        | .Some(tail_node) {
            tail_node.val.next = .Some(node)
        }
        | .None {
            self.val.head = .Some(node)
        }
    
    self.val.tail = .Some(node)
    self.val.len = self.val.len + 1
}

// Pop element from front
LinkedList.pop_front = (self: MutPtr<LinkedList<T>>) Option<T> {
    self.val.head ?
        | .None {
            return .None
        }
        | .Some(node) {
            value ::= node.val.value
            
            self.val.head = node.val.next
            self.val.head ?
                | .None {
                    self.val.tail = .None
                }
                | .Some(_) {}
            
            memory.free(node)
            self.val.len = self.val.len - 1
            
            return .Some(value)
        }
}

// Stack implementation using vector
Stack<T>: {
    data: Vector<T>
}

// Create new stack
Stack.new = () Stack<T> {
    return Stack<T>{
        data: Vector<T>.new()
    }
}

// Push element onto stack
Stack.push = (self: MutPtr<Stack<T>>, value: T) void {
    self.val.data.push(value)
}

// Pop element from stack
Stack.pop = (self: MutPtr<Stack<T>>) Option<T> {
    return self.val.data.pop()
}

// Peek at top element
Stack.peek = (self: Ptr<Stack<T>>) Option<T> {
    self.val.data.len == 0 ?
        | true {
            return .None
        }
        | false {
            return self.val.data.get(self.val.data.len - 1)
        }
}

// Check if stack is empty
Stack.is_empty = (self: Ptr<Stack<T>>) bool {
    return self.val.data.is_empty()
}

// Queue implementation using linked list
Queue<T>: {
    list: LinkedList<T>
}

// Create new queue
Queue.new = () Queue<T> {
    return Queue<T>{
        list: LinkedList<T>.new()
    }
}

// Enqueue element
Queue.enqueue = (self: MutPtr<Queue<T>>, value: T) void {
    self.val.list.push_back(value)
}

// Dequeue element
Queue.dequeue = (self: MutPtr<Queue<T>>) Option<T> {
    return self.val.list.pop_front()
}

// Peek at front element
Queue.peek = (self: &Queue) ?T {
    if (self.list.head) {
        return self.list.head.value
    }
    return null
}

// Check if queue is empty
Queue.is_empty = (self: &Queue) bool {
    return self.list.len == 0
}

// Hash map bucket
HashBucket := {
    key: K
    value: V
    next: ?&HashBucket
}

// Hash map implementation
HashMap := {
    buckets: []?&HashBucket
    len: usize
    capacity: usize
}

// Create new hash map
HashMap.new = () HashMap {
    return HashMap{
        buckets: make([]?&HashBucket, 16),
        len: 0,
        capacity: 16
    }
}

// Hash function (simple for now)
hash = (key: K, capacity: usize) usize   {
    // Simple hash for numeric types
    return key % capacity
}

// Put key-value pair
HashMap.put = (self: &HashMap, key: K, value: V) void {
    index := hash(key, self.capacity)
    
    // Check if key exists
    current := self.buckets[index]
    while (current) {
        if (current.key == key) {
            current.value = value
            return
        }
        current = current.next
    }
    
    // Add new bucket
    bucket := memory.alloc(HashBucket)
    bucket.key = key
    bucket.value = value
    bucket.next = self.buckets[index]
    
    self.buckets[index] = bucket
    self.len = self.len + 1
    
    // Resize if needed
    if (self.len > self.capacity * 3 / 4) {
        self.resize()
    }
}

// Get value by key
HashMap.get = (self: &HashMap, key: K) ?V {
    index := hash(key, self.capacity)
    
    current := self.buckets[index]
    while (current) {
        if (current.key == key) {
            return current.value
        }
        current = current.next
    }
    
    return null
}

// Remove key-value pair
HashMap.remove = (self: &HashMap, key: K) bool {
    index := hash(key, self.capacity)
    
    prev := null
    current := self.buckets[index]
    
    while (current) {
        if (current.key == key) {
            if (prev) {
                prev.next = current.next
            } else {
                self.buckets[index] = current.next
            }
            
            memory.free(current)
            self.len = self.len - 1
            return true
        }
        
        prev = current
        current = current.next
    }
    
    return false
}

// Check if key exists
HashMap.contains = (self: &HashMap, key: K) bool {
    return self.get(key) != null
}

// Resize hash map
HashMap.resize = (self: &HashMap) void {
    new_capacity := self.capacity * 2
    new_buckets := make([]?&HashBucket, new_capacity)
    
    // Rehash all entries
    i := 0
    while (i < self.capacity) {
        current := self.buckets[i]
        while (current) {
            next := current.next
            
            // Rehash and insert
            new_index := hash(current.key, new_capacity)
            current.next = new_buckets[new_index]
            new_buckets[new_index] = current
            
            current = next
        }
        i = i + 1
    }
    
    self.buckets = new_buckets
    self.capacity = new_capacity
}

// Set implementation using hash map
HashSet := {
    map: HashMap
}

// Create new set
HashSet.new = () HashSet {
    return HashSet{
        map: HashMap.new()
    }
}

// Add element to set
HashSet.add = (self: &HashSet, value: T) void {
    self.map.put(value, true)
}

// Remove element from set
HashSet.remove = (self: &HashSet, value: T) bool {
    return self.map.remove(value)
}

// Check if element exists
HashSet.contains = (self: &HashSet, value: T) bool {
    return self.map.contains(value)
}

// Get set size
HashSet.size = (self: &HashSet) usize {
    return self.map.len
}