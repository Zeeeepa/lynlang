// DEPRECATED: Use memory_unified.zen instead
// This file kept for backward compatibility only

{ memory_unified } := @std

// Re-export all core functions from unified implementation
allocate_raw = memory_unified.allocate_raw
deallocate_raw = memory_unified.deallocate_raw  
reallocate_raw = memory_unified.reallocate_raw
allocate_zeroed_raw = memory_unified.allocate_zeroed_raw
copy_memory_raw = memory_unified.copy_memory_raw
set_memory_raw = memory_unified.set_memory_raw
compare_memory_raw = memory_unified.compare_memory_raw

// Re-export types and constants
DEFAULT_ALIGN := 8
CACHE_LINE_SIZE := 64
AllocationInfo = memory_unified.AllocationInfo
MemoryStats = memory_unified.MemoryStats

// Re-export high-level functions
allocate = memory_unified.allocate
deallocate = memory_unified.deallocate
copy = memory_unified.copy
set = memory_unified.set
compare = memory_unified.compare

// Re-export everything from unified memory
module.exports = memory_unified.exports

// Arena allocator for temporary allocations
Arena := {
    buffer: Ptr<u8>
    capacity: usize
    offset: usize
    previous: Option<Ptr<Arena>>
}

arena_new = (capacity: usize) Result<Ptr<Arena>, core.Error> {
    arena_result := allocate<Arena>(1)
    arena_result ? 
        | Err(e) { return Err(e) }
        | Ok(arena) {
            buffer_result := allocate<u8>(capacity)
            buffer_result ?
                | Err(e) {
                    deallocate(arena)
                    return Err(e)
                }
                | Ok(buffer) {
                    arena.buffer = buffer
                    arena.capacity = capacity
                    arena.offset = 0
                    arena.previous = Option.None
                    return Ok(arena)
                }
        }
}

arena_allocate = <T>(arena: Ptr<Arena>, count: usize) Result<Ptr<T>, core.Error> {
    size := count * @sizeof(T)
    alignment := @alignof(T)
    
    // Align offset
    aligned_offset := (arena.offset + alignment - 1) & ~(alignment - 1)
    
    (aligned_offset + size > arena.capacity) ? {
        return Err(.OutOfMemory)
    }
    
    ptr := @ptrcast(Ptr<T>, arena.buffer.addr + aligned_offset)
    arena.offset = aligned_offset + size
    
    return Ok(ptr)
}

arena_reset = (arena: Ptr<Arena>) void {
    arena.offset = 0
}

arena_destroy = (arena: Ptr<Arena>) void {
    deallocate(arena.buffer)
    deallocate(arena)
}

// Pool allocator for fixed-size objects
Pool<T> := {
    block_size: usize
    blocks_per_chunk: usize
    free_list: Option<Ptr<PoolNode<T>>>
    chunks: Option<Ptr<PoolChunk<T>>>
}

PoolNode<T> := {
    next: Option<Ptr<PoolNode<T>>>
}

PoolChunk<T> := {
    memory: Ptr<u8>
    next: Option<Ptr<PoolChunk<T>>>
}

pool_new = <T>(blocks_per_chunk: usize) Result<Ptr<Pool<T>>, core.Error> {
    pool_result := allocate<Pool<T>>(1)
    pool_result ?
        | Err(e) { return Err(e) }
        | Ok(pool) {
            pool.block_size = @sizeof(T)
            pool.blocks_per_chunk = blocks_per_chunk
            pool.free_list = Option.None
            pool.chunks = Option.None
            return Ok(pool)
        }
}

pool_allocate = <T>(pool: Ptr<Pool<T>>) Result<Ptr<T>, core.Error> {
    // Check free list first
    pool.free_list ? 
        | Option.Some(node) {
            pool.free_list = node.next
            return Ok(@ptrcast(Ptr<T>, node))
        }
        | Option.None {
            // Allocate new chunk
            allocate_pool_chunk<T>(pool) ?
                | Err(e) { return Err(e) }
                | Ok(_) { return pool_allocate<T>(pool) }
        }
}

allocate_pool_chunk = <T>(pool: Ptr<Pool<T>>) Result<void, core.Error> {
    chunk_result := allocate<PoolChunk<T>>(1)
    chunk_result ?
        | Err(e) { return Err(e) }
        | Ok(chunk) {
            memory_result := allocate<u8>(pool.block_size * pool.blocks_per_chunk)
            memory_result ?
                | Err(e) {
                    deallocate(chunk)
                    return Err(e)
                }
                | Ok(memory) {
                    chunk.memory = memory
                    chunk.next = pool.chunks
                    pool.chunks = Option.Some(chunk)
                    
                    // Add all blocks to free list
                    i := 0
                    loop (i < pool.blocks_per_chunk) {
                        node := @ptrcast(Ptr<PoolNode<T>>, chunk.memory.addr + i * pool.block_size)
                        node.next = pool.free_list
                        pool.free_list = Option.Some(node)
                        i += 1
                    }
                    
                    return Ok()
                }
        }
}

pool_deallocate = <T>(pool: Ptr<Pool<T>>, ptr: Ptr<T>) void {
    node := @ptrcast(Ptr<PoolNode<T>>, ptr)
    node.next = pool.free_list
    pool.free_list = Option.Some(node)
}

pool_destroy = <T>(pool: Ptr<Pool<T>>) void {
    current := pool.chunks
    loop (current) {
        current ? 
            | Option.Some(chunk) {
                next := chunk.next
                deallocate(chunk.memory)
                deallocate(chunk)
                current = next
            }
            | Option.None { break }
    }
    deallocate(pool)
}

// Allocation tracking functions (debug mode)
track_allocation = (ptr: RawPtr<void>, size: usize, line: u32, file: string) void {
    info_result := allocate<AllocationInfo>(1)
    info_result ? 
        | Ok(info) {
            info.ptr = ptr
            info.size = size
            info.line = line
            info.file = file
            info.next = memory_tracker.head
            
            memory_tracker.head = Option.Some(info)
            memory_tracker.stats.total_allocated += size
            memory_tracker.stats.allocation_count += 1
            
            current_usage := memory_tracker.stats.total_allocated - memory_tracker.stats.total_freed
            (current_usage > memory_tracker.stats.peak_usage) ? {
                memory_tracker.stats.peak_usage = current_usage
            }
        }
        | Err(_) {
            // Tracking allocation failed, but continue
        }
}

untrack_allocation = (ptr: RawPtr<void>) void {
    prev: Option<Ptr<AllocationInfo>> = Option.None
    current := memory_tracker.head
    
    loop (current) {
        current ? 
            | Option.Some(info) {
                (info.ptr == ptr) ? {
                    // Remove from list
                    prev ? 
                        | Option.Some(p) { p.next = info.next }
                        | Option.None { memory_tracker.head = info.next }
                    
                    memory_tracker.stats.total_freed += info.size
                    memory_tracker.stats.deallocation_count += 1
                    deallocate_raw(@ptrcast(RawPtr<void>, info))
                    return
                }
                prev = current
                current = info.next
            }
            | Option.None { break }
    }
}

// Memory statistics functions
get_memory_stats = () MemoryStats {
    current_usage := memory_tracker.stats.total_allocated - memory_tracker.stats.total_freed
    return MemoryStats{
        total_allocated: memory_tracker.stats.total_allocated,
        total_freed: memory_tracker.stats.total_freed,
        current_usage: current_usage,
        peak_usage: memory_tracker.stats.peak_usage,
        allocation_count: memory_tracker.stats.allocation_count,
        deallocation_count: memory_tracker.stats.deallocation_count
    }
}

print_memory_stats = () void {
    stats := get_memory_stats()
    
    io.println("=== Memory Statistics ===")
    io.printf("Total Allocated: {} bytes\n", stats.total_allocated)
    io.printf("Total Freed: {} bytes\n", stats.total_freed)
    io.printf("Current Usage: {} bytes\n", stats.current_usage)
    io.printf("Peak Usage: {} bytes\n", stats.peak_usage)
    io.printf("Allocations: {}\n", stats.allocation_count)
    io.printf("Deallocations: {}\n", stats.deallocation_count)
    
    // Check for leaks
    (stats.current_usage > 0) ? {
        io.println("WARNING: Potential memory leak detected!")
        print_allocations()
    }
}

print_allocations = () void {
    io.println("=== Active Allocations ===")
    
    current := memory_tracker.head
    index := 0
    
    loop (current) {
        current ? 
            | Option.Some(info) {
                io.printf("[{}] {} bytes at {}:{}\n", 
                         index, info.size, info.file, info.line)
                current = info.next
                index += 1
            }
            | Option.None { break }
    }
    
    (index == 0) ? {
        io.println("No active allocations")
    }
}

// Reset memory statistics
reset_stats = () void {
    memory_tracker.stats = MemoryStats{
        total_allocated: 0,
        total_freed: 0,
        current_usage: 0,
        peak_usage: 0,
        allocation_count: 0,
        deallocation_count: 0
    }
}

// Simple aliases for stdlib compatibility
malloc = allocate_raw
free = deallocate_raw  
memcpy = copy_memory_raw
memset = set_memory_raw
strlen = (str: RawPtr<i8>) i64 {
    inline.c("return strlen(${str.addr});")
}

// Allocator interface for backward compatibility  
Allocator = Arena

system_allocator = arena_new

// Export the memory management interface
module.exports = { 
    malloc, free, memcpy, memset, strlen, Allocator, system_allocator,
    allocate_raw, deallocate_raw, reallocate_raw, allocate_zeroed_raw,
    copy_memory_raw, move_memory_raw, set_memory_raw, compare_memory_raw,
    Arena, Pool, MemoryStats, AllocationInfo, MemoryTracker,
    allocate, allocate_zeroed, reallocate, deallocate, copy, move, set, compare,
    alloc_aligned, arena_new, arena_allocate, arena_reset, arena_destroy,
    pool_new, pool_allocate, pool_deallocate, pool_destroy,
    get_memory_stats, print_memory_stats, print_allocations, reset_stats
}
