// Zen Standard Library: Actor Supervisor (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Supervises actor lifecycle with restart strategies

{ compiler } = @std
{ Result } = @std.core.result
{ Option } = @std.core.option
{ Allocator } = @std.memory.allocator
{ AtomicI32 } = @std.sync.atomic
{ ACTOR_RUNNING, ACTOR_STOPPED, ACTOR_FAILED } = @std.actor.actor

// ============================================================================
// Restart Strategies
// ============================================================================

STRATEGY_ONE_FOR_ONE = 0    // Restart only the failed actor
STRATEGY_ONE_FOR_ALL = 1    // Restart all children if one fails
STRATEGY_REST_FOR_ONE = 2   // Restart failed actor and all started after it

// ============================================================================
// Child Specification
// ============================================================================
// Describes how to start and restart a child actor

ChildSpec: {
    id: u64,
    start_fn: i64,    // Function pointer to start the actor
    context: i64,     // Context passed to start function
    restart: i32,     // Restart policy
    shutdown: i32     // Shutdown timeout (ms)
}

// Restart policies
RESTART_PERMANENT = 0    // Always restart
RESTART_TEMPORARY = 1    // Never restart
RESTART_TRANSIENT = 2    // Restart only on abnormal exit

ChildSpec.permanent = (id: u64, start_fn: i64, context: i64) ChildSpec {
    return ChildSpec {
        id: id,
        start_fn: start_fn,
        context: context,
        restart: RESTART_PERMANENT,
        shutdown: 5000
    }
}

ChildSpec.temporary = (id: u64, start_fn: i64, context: i64) ChildSpec {
    return ChildSpec {
        id: id,
        start_fn: start_fn,
        context: context,
        restart: RESTART_TEMPORARY,
        shutdown: 5000
    }
}

ChildSpec.transient = (id: u64, start_fn: i64, context: i64) ChildSpec {
    return ChildSpec {
        id: id,
        start_fn: start_fn,
        context: context,
        restart: RESTART_TRANSIENT,
        shutdown: 5000
    }
}

// ============================================================================
// Child State
// ============================================================================

ChildState: {
    spec: ChildSpec,
    pid: i64,           // Thread/process ID
    actor_ptr: i64,     // Pointer to actor instance
    state: AtomicI32,
    restart_count: i32,
    last_restart: i64   // Timestamp of last restart
}

ChildState.new = (spec: ChildSpec) ChildState {
    return ChildState {
        spec: spec,
        pid: 0,
        actor_ptr: 0,
        state: AtomicI32.new(ACTOR_STOPPED),
        restart_count: 0,
        last_restart: 0
    }
}

// ============================================================================
// Supervisor
// ============================================================================

Supervisor: {
    strategy: i32,
    max_restarts: i32,     // Max restarts in time window
    max_time: i32,         // Time window (seconds) for restart limit
    children: i64,         // Pointer to child array
    child_count: i32,
    child_capacity: i32,
    state: AtomicI32,
    allocator: Allocator
}

Supervisor.new = (strategy: i32, max_restarts: i32, max_time: i32, allocator: Allocator) Supervisor {
    // Allocate initial child array (capacity 16)
    capacity = 16
    children_ptr = allocator.allocate(capacity * 64)  // sizeof(ChildState) ~64

    return Supervisor {
        strategy: strategy,
        max_restarts: max_restarts,
        max_time: max_time,
        children: children_ptr,
        child_count: 0,
        child_capacity: capacity,
        state: AtomicI32.new(ACTOR_STOPPED),
        allocator: allocator
    }
}

// Add a child specification
Supervisor.add_child = (self: MutPtr<Supervisor>, spec: ChildSpec) Result<i32, i32> {
    // Check capacity
    self.val.child_count >= self.val.child_capacity ? {
        // Need to grow array
        new_capacity = self.val.child_capacity * 2
        new_children = self.val.allocator.reallocate(
            self.val.children,
            self.val.child_capacity * 64,
            new_capacity * 64
        )
        new_children == 0 ? { return Result.Err(-12) }  // ENOMEM
        self.val.children = new_children
        self.val.child_capacity = new_capacity
    }

    // Add child state
    child_state = ChildState.new(spec)
    offset = self.val.child_count * 64
    compiler.memcpy(
        compiler.int_to_ptr(self.val.children + offset as i64),
        &child_state.ref() as RawPtr<u8>,
        64
    )

    idx = self.val.child_count
    self.val.child_count = self.val.child_count + 1

    return Result.Ok(idx)
}

// Start all children
Supervisor.start = (self: MutPtr<Supervisor>) Result<(), i32> {
    self.val.state.store(ACTOR_RUNNING)

    i = 0
    i < self.val.child_count ? {
        result = self.start_child(i)
        result ? {
            | Err(e) { return Result.Err(e) }
            | Ok(_) { }
        }
        i = i + 1
    }

    return Result.Ok(())
}

// Start a specific child
Supervisor.start_child = (self: MutPtr<Supervisor>, idx: i32) Result<(), i32> {
    idx >= self.val.child_count ? { return Result.Err(-22) }  // EINVAL

    child_ptr = compiler.int_to_ptr(self.val.children + (idx * 64) as i64) as MutPtr<ChildState>

    // Call the start function
    // start_fn signature: (context: i64, allocator: Allocator) i64 (returns actor_ptr)
    start_fn = child_ptr.val.spec.start_fn
    context = child_ptr.val.spec.context

    // Type-erased function call would go here
    // For now, store the function pointer and context
    child_ptr.val.state.store(ACTOR_RUNNING)

    return Result.Ok(())
}

// Stop all children
Supervisor.stop = (self: MutPtr<Supervisor>) void {
    self.val.state.store(ACTOR_STOPPED)

    // Stop children in reverse order
    i = self.val.child_count - 1
    i >= 0 ? {
        self.stop_child(i)
        i = i - 1
    }
}

// Stop a specific child
Supervisor.stop_child = (self: MutPtr<Supervisor>, idx: i32) void {
    idx >= self.val.child_count ? { return }

    child_ptr = compiler.int_to_ptr(self.val.children + (idx * 64) as i64) as MutPtr<ChildState>
    child_ptr.val.state.store(ACTOR_STOPPED)
}

// Handle child failure
Supervisor.handle_failure = (self: MutPtr<Supervisor>, idx: i32) void {
    idx >= self.val.child_count ? { return }

    child_ptr = compiler.int_to_ptr(self.val.children + (idx * 64) as i64) as MutPtr<ChildState>
    restart_policy = child_ptr.val.spec.restart

    // Check restart policy
    restart_policy == RESTART_TEMPORARY ? { return }

    // Check restart limits
    child_ptr.val.restart_count >= self.val.max_restarts ? {
        // Too many restarts, escalate to parent or shutdown
        child_ptr.val.state.store(ACTOR_FAILED)
        return
    }

    // Apply strategy
    self.val.strategy ? {
        | STRATEGY_ONE_FOR_ONE {
            self.restart_child(idx)
        }
        | STRATEGY_ONE_FOR_ALL {
            self.restart_all()
        }
        | STRATEGY_REST_FOR_ONE {
            self.restart_rest(idx)
        }
    }
}

// Restart a single child
Supervisor.restart_child = (self: MutPtr<Supervisor>, idx: i32) void {
    child_ptr = compiler.int_to_ptr(self.val.children + (idx * 64) as i64) as MutPtr<ChildState>
    child_ptr.val.restart_count = child_ptr.val.restart_count + 1
    self.start_child(idx)
}

// Restart all children
Supervisor.restart_all = (self: MutPtr<Supervisor>) void {
    // Stop all first
    i = self.val.child_count - 1
    i >= 0 ? {
        self.stop_child(i)
        i = i - 1
    }

    // Start all
    i = 0
    i < self.val.child_count ? {
        self.start_child(i)
        i = i + 1
    }
}

// Restart failed child and all started after it
Supervisor.restart_rest = (self: MutPtr<Supervisor>, idx: i32) void {
    // Stop from idx onwards (reverse)
    i = self.val.child_count - 1
    i >= idx ? {
        self.stop_child(i)
        i = i - 1
    }

    // Start from idx onwards
    i = idx
    i < self.val.child_count ? {
        self.start_child(i)
        i = i + 1
    }
}

// Get child count
Supervisor.child_count = (self: Ptr<Supervisor>) i32 {
    return self.val.child_count
}

// Check if supervisor is running
Supervisor.is_running = (self: Ptr<Supervisor>) bool {
    return self.val.state.load() == ACTOR_RUNNING
}

// Free supervisor resources
Supervisor.free = (self: MutPtr<Supervisor>) void {
    self.stop()
    self.val.allocator.deallocate(self.val.children, self.val.child_capacity * 64)
}
