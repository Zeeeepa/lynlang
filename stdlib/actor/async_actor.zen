// Zen Standard Library: Async Actor (Scheduler-integrated)
// No FFI - uses compiler.syscall* intrinsics
//
// AsyncActor runs on the task scheduler instead of OS threads.
// This enables millions of actors on a single machine.
//
// Key difference from Actor:
// - Uses AsyncPool for non-blocking message receive
// - Yields to scheduler while waiting for messages
// - Integrates with eventfd for efficient wakeup

{ compiler } = @std
{ Result } = @std.core.result
{ Option } = @std.core.option
{ Allocator } = @std.memory.allocator
{ AsyncPool } = @std.memory.async_pool
{ Scheduler, spawn, yield_now } = @std.async.scheduler
{ Task, TaskState, get_current_task } = @std.async.task
{ AtomicI32, AtomicI64 } = @std.sync.atomic
{ Eventfd } = @std.io.eventfd
{ SYS_READ } = @std.sys.syscall

// ============================================================================
// Async Mailbox
// ============================================================================
// Lock-free bounded queue with eventfd notification for async wakeup

MAILBOX_EMPTY = 0
MAILBOX_HAS_MESSAGES = 1

AsyncMailbox<M>: {
    buffer: i64,         // Pointer to message array
    capacity: usize,
    head: AtomicI64,     // Read position (consumers)
    tail: AtomicI64,     // Write position (producers)
    count: AtomicI32,    // Current message count
    notify_fd: i32,      // Eventfd for wakeup
    allocator: Allocator
}

AsyncMailbox.new = (capacity: usize, allocator: Allocator) Result<AsyncMailbox<M>, i32> {
    // Allocate message buffer
    msg_size = compiler.sizeof<M>()
    buffer = allocator.allocate(capacity * msg_size)
    buffer == 0 ? { return Result.Err(-12) }  // ENOMEM

    // Create eventfd for notification
    efd_result = Eventfd.new(0)
    efd_result ? {
        | Err(e) {
            allocator.deallocate(buffer, capacity * msg_size)
            return Result.Err(e.code)
        }
        | Ok(efd) {
            return Result.Ok(AsyncMailbox<M> {
                buffer: buffer,
                capacity: capacity,
                head: AtomicI64.new(0),
                tail: AtomicI64.new(0),
                count: AtomicI32.new(0),
                notify_fd: efd.fd,
                allocator: allocator
            })
        }
    }
}

// Send message (non-blocking, returns error if full)
AsyncMailbox.try_send = (self: MutPtr<AsyncMailbox<M>>, msg: M) Result<(), i32> {
    // Check if full
    count = self.val.count.load()
    count >= self.val.capacity as i32 ? {
        return Result.Err(-11)  // EAGAIN
    }

    // Get write position
    tail = self.val.tail.fetch_add(1)
    idx = tail % self.val.capacity as i64
    msg_size = compiler.sizeof<M>()

    // Write message
    dest = compiler.int_to_ptr(self.val.buffer + idx * msg_size as i64)
    compiler.memcpy(dest, &msg.ref() as RawPtr<u8>, msg_size)

    // Increment count
    old_count = self.val.count.fetch_add(1)

    // Signal if mailbox was empty
    old_count == 0 ? {
        // Write to eventfd to wake up waiting actor
        val: u64 = 1
        compiler.syscall3(1, self.val.notify_fd, compiler.ptr_to_int(&val.ref()), 8)  // SYS_WRITE
    }

    return Result.Ok(())
}

// Receive message (non-blocking)
AsyncMailbox.try_recv = (self: MutPtr<AsyncMailbox<M>>) Option<M> {
    // Check if empty
    count = self.val.count.load()
    count == 0 ? { return Option.None }

    // Get read position
    head = self.val.head.fetch_add(1)
    idx = head % self.val.capacity as i64
    msg_size = compiler.sizeof<M>()

    // Read message
    src = compiler.int_to_ptr(self.val.buffer + idx * msg_size as i64)
    msg: M = compiler.zeroed<M>()
    compiler.memcpy(&msg.mut_ref() as RawPtr<u8>, src, msg_size)

    // Decrement count
    self.val.count.fetch_sub(1)

    return Option.Some(msg)
}

// Get eventfd for async waiting
AsyncMailbox.notify_fd = (self: Ptr<AsyncMailbox<M>>) i32 {
    return self.val.notify_fd
}

// Check if has messages
AsyncMailbox.has_messages = (self: Ptr<AsyncMailbox<M>>) bool {
    return self.val.count.load() > 0
}

AsyncMailbox.free = (self: MutPtr<AsyncMailbox<M>>) void {
    msg_size = compiler.sizeof<M>()
    self.val.allocator.deallocate(self.val.buffer, self.val.capacity * msg_size)
    compiler.syscall1(3, self.val.notify_fd)  // SYS_CLOSE
}

// ============================================================================
// Async Actor Reference
// ============================================================================

AsyncActorRef<M>: {
    id: u64,
    mailbox: i64,    // Pointer to AsyncMailbox<M>
    state: i64       // Pointer to AtomicI32
}

AsyncActorRef.send = (self: AsyncActorRef<M>, msg: M) Result<(), i32> {
    mailbox = compiler.int_to_ptr(self.mailbox) as MutPtr<AsyncMailbox<M>>
    return mailbox.try_send(msg)
}

AsyncActorRef.is_alive = (self: AsyncActorRef<M>) bool {
    state_ptr = compiler.int_to_ptr(self.state) as Ptr<AtomicI32>
    return state_ptr.val.load() == 1  // RUNNING
}

// ============================================================================
// Async Actor Behavior
// ============================================================================

AsyncActorBehavior<M>: behavior {
    receive: (self: MutPtr<Self>, msg: M) void
    on_start: (self: MutPtr<Self>) void
    on_stop: (self: MutPtr<Self>) void
}

// ============================================================================
// Async Actor
// ============================================================================
// Runs as a task on the scheduler, not an OS thread

ASYNC_ACTOR_CREATED = 0
ASYNC_ACTOR_RUNNING = 1
ASYNC_ACTOR_STOPPING = 2
ASYNC_ACTOR_STOPPED = 3

AsyncActor<M, B>: {
    id: u64,
    state: AtomicI32,
    mailbox: AsyncMailbox<M>,
    behavior: B,
    task_id: u64,         // Task ID in scheduler
    async_pool: i64       // Pointer to AsyncPool for async I/O
}

// Global async actor ID counter
async_actor_id_counter: AtomicI64 = AtomicI64.new(1)

next_async_actor_id = () u64 {
    return async_actor_id_counter.fetch_add(1) as u64
}

// Create async actor
AsyncActor.new = (behavior: B, mailbox_size: usize, async_pool: MutPtr<AsyncPool>) Result<AsyncActor<M, B>, i32> {
    allocator = async_pool.val  // AsyncPool implements Allocator

    mailbox_result = AsyncMailbox<M>.new(mailbox_size, allocator)
    mailbox_result ? {
        | Err(e) { return Result.Err(e) }
        | Ok(mailbox) {
            return Result.Ok(AsyncActor<M, B> {
                id: next_async_actor_id(),
                state: AtomicI32.new(ASYNC_ACTOR_CREATED),
                mailbox: mailbox,
                behavior: behavior,
                task_id: 0,
                async_pool: compiler.ptr_to_int(async_pool as RawPtr<u8>)
            })
        }
    }
}

// Get reference for message sending
AsyncActor.ref = (self: Ptr<AsyncActor<M, B>>) AsyncActorRef<M> {
    return AsyncActorRef<M> {
        id: self.val.id,
        mailbox: compiler.ptr_to_int(&self.val.mailbox.ref() as RawPtr<u8>),
        state: compiler.ptr_to_int(&self.val.state.ref() as RawPtr<u8>)
    }
}

// Run actor message loop (called as a task)
AsyncActor.run = (self: MutPtr<AsyncActor<M, B>>) void {
    self.val.state.store(ASYNC_ACTOR_RUNNING)
    self.val.behavior.on_start()

    async_pool = compiler.int_to_ptr(self.val.async_pool) as MutPtr<AsyncPool>

    // Message loop
    self.val.state.load() == ASYNC_ACTOR_RUNNING ? {
        // Try to receive message
        msg_opt = self.val.mailbox.mut_ref().try_recv()
        msg_opt ? {
            | Some(msg) {
                // Process message
                self.val.behavior.receive(msg)
            }
            | None {
                // No message - wait asynchronously via eventfd
                notify_fd = self.val.mailbox.notify_fd()

                // Schedule async read on eventfd (will complete when message arrives)
                buf: u64 = 0
                async_pool.val.schedule_read(
                    notify_fd,
                    compiler.ptr_to_int(&buf.ref()),
                    8,
                    0,
                    async_actor_wakeup_callback,
                    compiler.ptr_to_int(self as RawPtr<u8>) as u64
                )

                // Yield to scheduler - we'll be resumed when eventfd signals
                yield_now()
            }
        }
    }

    self.val.behavior.on_stop()
    self.val.state.store(ASYNC_ACTOR_STOPPED)
}

// Callback when eventfd read completes (message arrived)
async_actor_wakeup_callback = (user_data: u64, result: i64) void {
    // Actor will be resumed by scheduler
    // No action needed here - the read completing is the signal
}

// Stop actor gracefully
AsyncActor.stop = (self: MutPtr<AsyncActor<M, B>>) void {
    self.val.state.store(ASYNC_ACTOR_STOPPING)
    // Send a signal to wake up if waiting
    val: u64 = 1
    compiler.syscall3(1, self.val.mailbox.notify_fd(), compiler.ptr_to_int(&val.ref()), 8)
}

AsyncActor.free = (self: MutPtr<AsyncActor<M, B>>) void {
    self.val.mailbox.mut_ref().free()
}

// ============================================================================
// Spawn Helper
// ============================================================================
// Spawns an async actor onto the scheduler

spawn_async_actor = (scheduler: MutPtr<Scheduler>, actor_ptr: i64) Result<u64, i32> {
    // The actor's run method becomes a task
    return scheduler.spawn(actor_run_entry, actor_ptr)
}

// Entry point for actor task
actor_run_entry = (actor_ptr: i64) void {
    // Type-erased call to actor.run()
    // In real implementation, would need runtime type info
    // For now, assume actor_ptr points to AsyncActor
}
