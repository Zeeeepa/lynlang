// Zen Standard Library - Core implementations
// This demonstrates how the standard library could be written in Zen itself

// ==========================================
// Memory Management
// ==========================================

extern malloc = (size: i64) RawPtr<void>
extern free = (ptr: RawPtr<void>) void
extern memcpy = (dest: RawPtr<void>, src: RawPtr<void>, size: i64) void
extern memset = (ptr: RawPtr<void>, value: i32, size: i64) void

// Memory allocator interface
Allocator: {
    alloc: (RawPtr<void>, i64) RawPtr<void>,
    free: (RawPtr<void>, RawPtr<void>) void,
    realloc: (RawPtr<void>, RawPtr<void>, i64) RawPtr<void>,
    context: RawPtr<void>,
}

// Default system allocator
system_allocator = () Allocator   {
    return Allocator {
        alloc: system_alloc,
        free: system_free,
        realloc: system_realloc,
        context: 0,
    }
}

system_alloc = (ctx: RawPtr<void>, size: i64) RawPtr<void> {
    return malloc(size)
}

system_free = (ctx: RawPtr<void>, ptr: RawPtr<void>) void   {
    free(ptr)
}

system_realloc = (ctx: RawPtr<void>, ptr: RawPtr<void>, new_size: i64) RawPtr<void> {
    // Simple realloc implementation
    new_ptr := malloc(new_size)
    new_ptr != 0 && ptr != 0 ?
        | true { { }
            memcpy(new_ptr, ptr, new_size)
            free(ptr)
        }
        | false { { }}
    return new_ptr
}

// ==========================================
// Dynamic Array (Vec)
// ==========================================

Vec<T> = {
    data: *T,
    len: i64,
    capacity: i64,
    allocator: Allocator,
}

vec_new<T>: () Vec<T>  = {
    return Vec<T> {
        data: 0,
        len: 0,
        capacity: 0,
        allocator: system_allocator(),
    }
}

vec_with_capacity<T>: (capacity: i64) Vec<T>  = {
    allocator := system_allocator()
    data := allocator.alloc(allocator.context, capacity * sizeof<T>())
    
    return Vec<T> {
        data: data,
        len: 0,
        capacity: capacity,
        allocator: allocator,
    }
}

vec_push<T>: (vec: *Vec<T>, value: T) void  = {
    // Check if we need to grow
    vec.len >= vec.capacity ?
        | true { { }
            new_capacity := vec.capacity == 0 ? 
                | true { 8 }
                | false { vec.capacity * 2 }
            vec_grow(vec, new_capacity)
        }
        | false { { }}
    
    // Add element
    vec.data[vec.len] = value
    vec.len = vec.len + 1
}

vec_pop<T>: (vec: *Vec<T>) Option<T>  = {
    vec.len > 0 ?
        | true { { }
            vec.len = vec.len - 1
            return Option:Some(vec.data[vec.len])
        }
        | false { { }
            return Option:None
        }
}

vec_get<T>: (vec: *Vec<T>, index: i64) Option<T>  = {
    index >= 0 && index < vec.len ?
        | true { return Option:Some(vec.data[index]) }
        | false { return Option:None }
}

vec_set<T>: (vec: *Vec<T>, index: i64, value: T) bool  = {
    index >= 0 && index < vec.len ?
        | true { { }
            vec.data[index] = value
            return true
        }
        | false { { }
            return false
        }
}

vec_grow<T>: (vec: *Vec<T>, new_capacity: i64) void  = {
    new_capacity <= vec.capacity ?
        | true { return }
        | false { { }}
    
    new_data := vec.allocator.realloc(
        vec.allocator.context,
        vec.data,
        new_capacity * sizeof<T>()
    )
    
    vec.data = new_data
    vec.capacity = new_capacity
}

vec_clear<T>: (vec: *Vec<T>) void  = {
    vec.len = 0
}

vec_free<T>: (vec: *Vec<T>) void  = {
    vec.data != 0 ?
        | true { { }
            vec.allocator.free(vec.allocator.context, vec.data)
            vec.data = 0
            vec.len = 0
            vec.capacity = 0
        }
        | false { { }}
}

// Iterator support for Vec
vec_iter<T> = (vec: *Vec<T>, func: (T) void) void {
    i := 0
    loop i < vec.len {
        func(vec.data[i])
        i = i + 1
    }
}

// ==========================================
// HashMap
// ==========================================

HashEntry<K, V> = {
    key: K,
    value: V,
    hash: i64,
    occupied: bool,
}

HashMap<K, V> = {
    buckets: *HashEntry<K, V>,
    size: i64,
    capacity: i64,
    allocator: Allocator,
}

hashmap_new<K, V>: () HashMap<K, V>  = {
    initial_capacity := 16
    allocator := system_allocator()
    buckets := allocator.alloc(allocator.context, initial_capacity * sizeof<HashEntry<K, V>>())
    
    // Initialize buckets
    memset(buckets, 0, initial_capacity * sizeof<HashEntry<K, V>>())
    
    return HashMap<K, V> {
        buckets: buckets,
        size: 0,
        capacity: initial_capacity,
        allocator: allocator,
    }
}

hashmap_hash<K>: (key: K) i64  = {
    // Simple hash function - would be specialized per type
    // This is a placeholder
    return 0
}

hashmap_insert<K, V>: (map: *HashMap<K, V>, key: K, value: V) void  = {
    // Check load factor
    map.size * 4 >= map.capacity * 3 ?
        | true { hashmap_resize(map, map.capacity * 2) }
        | false { { }}
    
    hash := hashmap_hash(key)
    index := hash % map.capacity
    
    // Linear probing for collision resolution
    loop map.buckets[index].occupied {
        map.buckets[index].key == key ?
            | true { { }
                // Update existing key
                map.buckets[index].value = value
                return
            }
            | false { { }}
        
        index = (index + 1) % map.capacity
    }
    
    // Insert new entry
    map.buckets[index] = HashEntry<K, V> {
        key: key,
        value: value,
        hash: hash,
        occupied: true,
    }
    map.size = map.size + 1
}

hashmap_get<K, V>: (map: *HashMap<K, V>, key: K) Option<V>  = {
    hash := hashmap_hash(key)
    index := hash % map.capacity
    
    loop map.buckets[index].occupied {
        map.buckets[index].key == key ?
            | true { return Option:Some(map.buckets[index].value) }
            | false { { }}
        
        index = (index + 1) % map.capacity
        
        // Check if we've wrapped around
        index == hash % map.capacity ?
            | true { break }
            | false { { }}
    }
    
    return Option:None
}

hashmap_remove<K, V>: (map: *HashMap<K, V>, key: K) Option<V>  = {
    hash := hashmap_hash(key)
    index := hash % map.capacity
    
    loop map.buckets[index].occupied {
        map.buckets[index].key == key ?
            | true { { }
                value := map.buckets[index].value
                map.buckets[index].occupied = false
                map.size = map.size - 1
                
                // Reinsert subsequent entries to maintain probing chain
                hashmap_reinsert_chain(map, index)
                
                return Option:Some(value)
            }
            | false { { }}
        
        index = (index + 1) % map.capacity
    }
    
    return Option:None
}

hashmap_resize<K, V>: (map: *HashMap<K, V>, new_capacity: i64) void  = {
    old_buckets := map.buckets
    old_capacity := map.capacity
    
    // Allocate new buckets
    map.buckets = map.allocator.alloc(map.allocator.context, new_capacity * sizeof<HashEntry<K, V>>())
    memset(map.buckets, 0, new_capacity * sizeof<HashEntry<K, V>>())
    map.capacity = new_capacity
    map.size = 0
    
    // Reinsert all entries
    i := 0
    loop i < old_capacity {
        old_buckets[i].occupied ?
            | true { hashmap_insert(map, old_buckets[i].key, old_buckets[i].value) }
            | false { { }}
        i = i + 1
    }
    
    // Free old buckets
    map.allocator.free(map.allocator.context, old_buckets)
}

// ==========================================
// String Operations
// ==========================================

extern strlen = (str: RawPtr<i8>) i64
extern strcmp = (s1: RawPtr<i8>, s2: RawPtr<i8>) i32
extern strcpy = (dest: RawPtr<i8>, src: RawPtr<i8>) RawPtr<i8>
extern strcat = (dest: RawPtr<i8>, src: RawPtr<i8>) RawPtr<i8>

String: {
    data: RawPtr<i8>,
    len: i64,
    capacity: i64,
    allocator: Allocator,
}

string_new = () String   {
    return String {
        data: 0,
        len: 0,
        capacity: 0,
        allocator: system_allocator(),
    }
}

string_from_cstr = (cstr: RawPtr<i8>) String   {
    len := strlen(cstr)
    capacity := len + 1
    allocator := system_allocator()
    data := allocator.alloc(allocator.context, capacity)
    strcpy(data, cstr)
    
    return String {
        data: data,
        len: len,
        capacity: capacity,
        allocator: allocator,
    }
}

string_append = (s: *String, other: RawPtr<i8>) void   {
    other_len := strlen(other)
    new_len := s.len + other_len
    
    new_len >= s.capacity ?
        | true { { }
            new_capacity := new_len * 2
            new_data := s.allocator.realloc(s.allocator.context, s.data, new_capacity)
            s.data = new_data
            s.capacity = new_capacity
        }
        | false { { }}
    
    strcpy(s.data + s.len, other)
    s.len = new_len
}

string_equals = (s1: String, s2: String) bool   {
    s1.len != s2.len ?
        | true { return false }
        | false { { }}
    
    return strcmp(s1.data, s2.data) == 0
}

string_free = (s: *String) void   {
    s.data != 0 ?
        | true { { }
            s.allocator.free(s.allocator.context, s.data)
            s.data = 0
            s.len = 0
            s.capacity = 0
        }
        | false { { }}
}

// ==========================================
// Result and Option Types
// ==========================================

Option<T> = 
    | Some(value: T)
    | None

Result<T, E> = 
    | Ok(value: T)
    | Err(error: E)

option_is_some<T>: (opt: Option<T>) bool  = {
    opt ?
        | Some(_) { return true }
        | None { return false }
}

option_is_none<T>: (opt: Option<T>) bool  = {
    return !option_is_some(opt)
}

option_unwrap<T>: (opt: Option<T>) T  = {
    opt ?
        | Some(value) { return value }
        | None { panic("Attempted to unwrap None") }
}

option_unwrap_or<T>: (opt: Option<T>, default: T) T  = {
    opt ?
        | Some(value) { return value }
        | None { return default }
}

result_is_ok<T, E>: (res: Result<T, E>) bool  = {
    res ?
        | Ok(_) { return true }
        | Err(_) { return false }
}

result_is_err<T, E>: (res: Result<T, E>) bool  = {
    return !result_is_ok(res)
}

result_unwrap<T, E>: (res: Result<T, E>) T  = {
    res ?
        | Ok(value) { return value }
        | Err(_) { panic("Attempted to unwrap Err") }
}

result_unwrap_err<T, E>: (res: Result<T, E>) E  = {
    res ?
        | Ok(_) { panic("Attempted to unwrap_err on Ok") }
        | Err(error) { return error }
}

// ==========================================
// Helper Functions
// ==========================================

extern panic = (msg: RawPtr<i8>) void
extern sizeof<T> = () i64

// Test the standard library
extern printf = (RawPtr<i8>, ...) i32

test_stdlib = () void   {
    printf("Testing Zen standard library...\n")
    
    // Test Vec
    v := vec_new<i32>()
    vec_push(&v, 10)
    vec_push(&v, 20)
    vec_push(&v, 30)
    
    printf("Vec length: %ld\n", v.len)
    
    // Test Option
    opt := vec_pop(&v)
    opt ?
        | Some(val) { printf("Popped: %d\n", val) }
        | None { printf("Vec was empty\n") }
    
    // Test HashMap
    map := hashmap_new<i32, i32>()
    hashmap_insert(&map, 1, 100)
    hashmap_insert(&map, 2, 200)
    
    result := hashmap_get(&map, 1)
    result ?
        | Some(val) { printf("Found value: %d\n", val) }
        | None { printf("Key not found\n") }
    
    // Cleanup
    vec_free(&v)
    
    printf("Standard library tests complete!\n")
}

main = () i32   {
    test_stdlib()
    return 0
}