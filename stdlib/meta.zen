// Zen Language Meta Module - Behaviors (Traits) System
// Provides compile-time trait definition and implementation
// No trait/interface keywords - using .implements() and .requires()

{ core } = @std

// ============================================================================
// CORE BEHAVIOR TYPES
// ============================================================================

// A behavior (trait) is a collection of method signatures
Behavior := {
    name: string
    methods: Vec<MethodSignature>
    required_behaviors: Vec<Behavior>  // Supertraits
}

// Method signature for behaviors
MethodSignature := {
    name: string
    params: Vec<ParamSignature>
    return_type: TypeInfo
    is_mut: bool  // Does it mutate self?
}

// Parameter signature
ParamSignature := {
    name: string
    type: TypeInfo
    is_mut: bool
}

// Runtime type information
TypeInfo := {
    name: string
    kind: TypeKind
    generic_params: Vec<TypeInfo>
}

TypeKind:
    Primitive   // i32, f64, bool, string, etc
    | Struct
    | Enum
    | Behavior  // Trait type
    | Generic   // T, U, etc
    | Pointer   // Ptr<T>, MutPtr<T>, RawPtr<T>
    | Function  // (args) -> ret

// ============================================================================
// BEHAVIOR REGISTRATION
// ============================================================================

// Global registry of behaviors and implementations
BehaviorRegistry := {
    behaviors: HashMap<string, Behavior>
    implementations: HashMap<string, Vec<Implementation>>
    requirements: HashMap<string, Vec<Behavior>>
}

// An implementation of a behavior for a type
Implementation := {
    type_name: string
    behavior_name: string
    methods: HashMap<string, Function>
    validated: bool
}

// Global registry instance (compile-time)
global_registry ::= BehaviorRegistry {
    behaviors: HashMap.new(),
    implementations: HashMap.new(),
    requirements: HashMap.new()
}

// ============================================================================
// PUBLIC API - COMPILE TIME FUNCTIONS
// ============================================================================

// Register a new behavior (trait)
// Called at compile time when parsing behavior definitions
register_behavior := (name: string, methods: Vec<MethodSignature>) void {
    behavior := Behavior {
        name: name,
        methods: methods,
        required_behaviors: Vec.new()
    }
    global_registry.behaviors.put(name, behavior)
}

// Type.implements(Behavior, impl) - Attach behavior to type
// This is the main API for implementing traits
implements := <T>(type_name: string, behavior: Behavior, implementation: {}) void {
    // Validate that all required methods are provided
    missing_methods := Vec<string>.new()
    
    behavior.methods.loop((method_sig) {
        has_method := @has_field(implementation, method_sig.name)
        (!has_method) ? {
            missing_methods.push(method_sig.name)
        }
    })
    
    (!missing_methods.is_empty()) ? {
        @compile_error("Type ${type_name} missing methods for ${behavior.name}: ${missing_methods}")
    }
    
    // Store implementation
    impl := Implementation {
        type_name: type_name,
        behavior_name: behavior.name,
        methods: extract_methods(implementation),
        validated: true
    }
    
    // Add to registry
    existing := global_registry.implementations.get(type_name).unwrap_or(Vec.new())
    existing.push(impl)
    global_registry.implementations.put(type_name, existing)
}

// Shape.requires(Behavior) - Enforce behavior on enum variants
// All enum variants must implement the specified behavior
requires := (enum_name: string, behavior: Behavior) void {
    existing := global_registry.requirements.get(enum_name).unwrap_or(Vec.new())
    existing.push(behavior)
    global_registry.requirements.put(enum_name, existing)
}

// Check if a type implements a behavior
has_behavior := <T>(type_name: string, behavior_name: string) bool {
    impls := global_registry.implementations.get(type_name)
    impls ?
        | Some(impl_list) {
            impl_list.loop((impl) {
                (impl.behavior_name == behavior_name) ? {
                    return true
                }
            })
            return false
        }
        | None { return false }
}

// Get implementation for a type and behavior
get_implementation := <T>(type_name: string, behavior_name: string) Option<Implementation> {
    impls := global_registry.implementations.get(type_name)
    impls ?
        | Some(impl_list) {
            impl_list.loop((impl) {
                (impl.behavior_name == behavior_name) ? {
                    return Option.Some(impl)
                }
            })
            return Option.None
        }
        | None { return Option.None }
}

// ============================================================================
// CONSTRAINT CHECKING
// ============================================================================

// Check generic constraint T: Behavior
check_constraint := <T>(type: TypeInfo, constraint: Behavior) bool {
    return has_behavior(type.name, constraint.name)
}

// Check multiple constraints T: Behavior1 + Behavior2
check_constraints := <T>(type: TypeInfo, constraints: Vec<Behavior>) bool {
    constraints.loop((constraint) {
        (!check_constraint(type, constraint)) ? {
            return false
        }
    })
    return true
}

// Validate enum requirements
validate_enum_requirements := (enum_name: string, variants: Vec<string>) void {
    requirements := global_registry.requirements.get(enum_name)
    requirements ?
        | Some(required_behaviors) {
            required_behaviors.loop((behavior) {
                variants.loop((variant) {
                    variant_type := "${enum_name}.${variant}"
                    (!has_behavior(variant_type, behavior.name)) ? {
                        @compile_error("Enum variant ${variant_type} must implement ${behavior.name}")
                    }
                })
            })
        }
        | None { /* No requirements */ }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Extract methods from implementation object
extract_methods := (impl: {}) HashMap<string, Function> {
    methods := HashMap<string, Function>.new()
    
    // Use compile-time reflection to extract methods
    fields := @reflect_fields(impl)
    fields.loop((field) {
        is_function := @is_function(field.value)
        is_function ? {
            methods.put(field.name, field.value)
        }
    })
    
    return methods
}

// Create a behavior from a struct definition (convenience)
behavior_from_struct := (struct_def: {}) Behavior {
    methods := Vec<MethodSignature>.new()
    
    fields := @reflect_fields(struct_def)
    fields.loop((field) {
        @is_function_type(field.type) ? {
            sig := extract_method_signature(field)
            methods.push(sig)
        }
    })
    
    return Behavior {
        name: @type_name(struct_def),
        methods: methods,
        required_behaviors: Vec.new()
    }
}

// Extract method signature from field
extract_method_signature := (field: Field) MethodSignature {
    // Parse function type to extract params and return
    func_type := field.type
    
    return MethodSignature {
        name: field.name,
        params: parse_params(func_type),
        return_type: parse_return_type(func_type),
        is_mut: check_if_mut(func_type)
    }
}

// ============================================================================
// COMPILE-TIME MACROS
// ============================================================================

// Macro to simplify behavior definition
@define_behavior := (name: string, body: {}) void {
    methods := extract_behavior_methods(body)
    register_behavior(name, methods)
}

// Macro to implement multiple behaviors at once
@implement_behaviors := <T>(type: T, behaviors: Vec<(Behavior, {})>) void {
    type_name := @type_name(T)
    behaviors.loop((pair) {
        behavior := pair.0
        impl := pair.1
        implements(type_name, behavior, impl)
    })
}

// ============================================================================
// STANDARD BEHAVIORS
// ============================================================================

// Common behaviors that many types might implement

// Equality comparison
Eq := {
    eq: (self, other: Self) bool
}

// Ordering
Ord := {
    cmp: (self, other: Self) i32  // -1, 0, 1
}

// Hashing
Hash := {
    hash: (self) u64
}

// String conversion
Display := {
    fmt: (self) string
}

// Debugging output
Debug := {
    debug: (self) string
}

// Cloning
Clone := {
    clone: (self) Self
}

// Default value
Default := {
    default: () Self
}

// Serialization
Serialize := {
    serialize: (self, writer: Writer) Result<void, string>
}

// Deserialization
Deserialize := {
    deserialize: (reader: Reader) Result<Self, string>
}

// ============================================================================
// EXPORTS
// ============================================================================

module.exports := {
    // Core types
    Behavior,
    MethodSignature,
    ParamSignature,
    TypeInfo,
    TypeKind,
    Implementation,
    
    // Main API
    implements,
    requires,
    has_behavior,
    get_implementation,
    check_constraint,
    check_constraints,
    
    // Standard behaviors
    Eq,
    Ord,
    Hash,
    Display,
    Debug,
    Clone,
    Default,
    Serialize,
    Deserialize,
    
    // Registry access (for tooling)
    global_registry
}