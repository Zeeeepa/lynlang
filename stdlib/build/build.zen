// Zen Standard Library: Build System
// Provides types and utilities for build configuration

{ io } = @std

// ============================================================================
// Enums - Build Configuration Options
// ============================================================================

// Optimization modes for compilation
OptimizeMode:
    Debug,
    ReleaseFast,
    ReleaseSmall,
    ReleaseSafe

// Target operating systems
OsTag:
    Linux,
    Macos,
    Windows,
    Freebsd,
    Native

// CPU architectures
CpuArch:
    X86_64,
    Aarch64,
    Arm,
    Wasm32,
    Native

// Installation directories
InstallDir:
    Bin,
    Lib,
    Include,
    Share

// ============================================================================
// Structs - Build Configuration Types
// ============================================================================

// Build target specification
Target: {
    os_tag: OsTag,
    cpu_arch: CpuArch
}

// Version information
Version: {
    major: i32,
    minor: i32,
    patch: i32
}

// Executable configuration
Executable: {
    name: StaticString,
    root_source_file: StaticString,
    optimize: OptimizeMode,
    strip: bool,
    enable_stack_traces: bool
}

// Static library configuration
StaticLibrary: {
    name: StaticString,
    root_source_file: StaticString,
    optimize: OptimizeMode,
    version: Version
}

// Test configuration
Test: {
    name: StaticString,
    root_source_file: StaticString
}

// Dependency specification
Dependency: {
    name: StaticString,
    url: StaticString
}

// Executable options for addExecutable
ExeOptions: {
    name: StaticString,
    root_source_file: StaticString,
    link_libc: bool
}

// Library options for addStaticLibrary
LibOptions: {
    name: StaticString,
    root_source_file: StaticString,
    version: Version
}

// Dependency options
DepOptions: {
    url: StaticString
}

// Main build configuration
Build: {
    optimize: OptimizeMode,
    strip: bool,
    enable_stack_traces: bool,
    target: Target,
    build_dir: StaticString,
    cache_dir: StaticString,
    install_prefix: StaticString
}

// ============================================================================
// Target Functions
// ============================================================================

// Create native target (current platform)
native_target = () Target {
    return Target {
        os_tag: OsTag.Native,
        cpu_arch: CpuArch.Native
    }
}

// Get OS tag name as string
os_name = (t: Target) StaticString {
    t.os_tag ?
        | Linux { "linux" }
        | Macos { "macos" }
        | Windows { "windows" }
        | Freebsd { "freebsd" }
        | Native { "native" }
}

// Get CPU arch name as string
cpu_name = (t: Target) StaticString {
    t.cpu_arch ?
        | X86_64 { "x86_64" }
        | Aarch64 { "aarch64" }
        | Arm { "arm" }
        | Wasm32 { "wasm32" }
        | Native { "native" }
}

// ============================================================================
// Build Functions
// ============================================================================

// Create new build configuration
new_build = () Build {
    return Build {
        optimize: OptimizeMode.Debug,
        strip: false,
        enable_stack_traces: true,
        target: native_target(),
        build_dir: "build/",
        cache_dir: "build/cache/",
        install_prefix: "/usr/local"
    }
}

// Get standard target options (returns native target)
standard_target = (b: Build) Target {
    return b.target
}

// Get standard optimize option
standard_optimize = (b: Build) OptimizeMode {
    return b.optimize
}

// Add an executable target
add_executable = (b: Build, opts: ExeOptions) Executable {
    io.println("  Adding executable: ${opts.name}")
    return Executable {
        name: opts.name,
        root_source_file: opts.root_source_file,
        optimize: b.optimize,
        strip: b.strip,
        enable_stack_traces: b.enable_stack_traces
    }
}

// Add a test target
add_test = (b: Build, root_file: StaticString) Test {
    io.println("  Adding test: ${root_file}")
    return Test {
        name: root_file,
        root_source_file: root_file
    }
}

// Add a static library target
add_static_library = (b: Build, opts: LibOptions) StaticLibrary {
    io.println("  Adding static library: ${opts.name}")
    return StaticLibrary {
        name: opts.name,
        root_source_file: opts.root_source_file,
        optimize: b.optimize,
        version: opts.version
    }
}

// Add a dependency
add_dependency = (b: Build, name: StaticString, opts: DepOptions) Dependency {
    io.println("  Adding dependency: ${name} from ${opts.url}")
    return Dependency {
        name: name,
        url: opts.url
    }
}

// Install an artifact
install_artifact = (b: Build, exe: Executable) void {
    io.println("  Installing artifact: ${exe.name}")
}

// Install a library artifact
install_library = (b: Build, lib: StaticLibrary) void {
    io.println("  Installing library: ${lib.name}")
}

// Install a file
install_file = (b: Build, src: StaticString, dest: StaticString) void {
    io.println("  Installing file: ${src} -> ${dest}")
}

// Get install path for a directory type
get_install_path = (b: Build, dir: InstallDir, path: StaticString) StaticString {
    dir ?
        | Bin { "${b.install_prefix}/bin/${path}" }
        | Lib { "${b.install_prefix}/lib/${path}" }
        | Include { "${b.install_prefix}/include/${path}" }
        | Share { "${b.install_prefix}/share/${path}" }
}

// ============================================================================
// Executable Functions
// ============================================================================

// Link a system library
link_system_library = (exe: Executable, lib: StaticString) void {
    io.println("    Linking system library: ${lib}")
}

// Link a framework (macOS)
link_framework = (exe: Executable, framework: StaticString) void {
    io.println("    Linking framework: ${framework}")
}

// Add a library search path
add_library_path = (exe: Executable, path: StaticString) void {
    io.println("    Adding library path: ${path}")
}

// Define a compile-time symbol
define_symbol = (exe: Executable, name: StaticString, value: StaticString) void {
    io.println("    Defining symbol: ${name}=${value}")
}

// ============================================================================
// Utility Functions
// ============================================================================

// Get optimization mode name
optimize_name = (mode: OptimizeMode) StaticString {
    mode ?
        | Debug { "Debug" }
        | ReleaseFast { "ReleaseFast" }
        | ReleaseSmall { "ReleaseSmall" }
        | ReleaseSafe { "ReleaseSafe" }
}
