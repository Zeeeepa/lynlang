// Zen Standard Library: Iterator Types
// Core iteration abstractions for collections

{ Option } = @std.core.option

// ============================================================================
// Range Iterator
// ============================================================================

// Range iterator for numeric sequences
Range: {
    current: i64,
    end: i64,
    step: i64
}

// Create a range from start to end (exclusive)
Range.new = (start: i64, end: i64) Range {
    return Range { current: start, end: end, step: 1 }
}

// Create a range with custom step
Range.with_step = (start: i64, end: i64, step: i64) Range {
    return Range { current: start, end: end, step: step }
}

// Get next value from range
Range.next = (self: MutPtr<Range>) Option<i64> {
    self.val.current < self.val.end ?
        | true {
            value = self.val.current
            self.val.current = self.val.current + self.val.step
            return Option.Some(value)
        }
        | false { return Option.None }
}

// Check if range has more elements
Range.has_next = (self: Range) bool {
    return self.current < self.end
}

// Count remaining elements in range
Range.count = (self: Range) i64 {
    self.end > self.current ?
        | true { return (self.end - self.current) / self.step }
        | false { return 0 }
}

// Convenience function: create a range from 0 to n
range = (n: i64) Range {
    return Range.new(0, n)
}

// Convenience function: create a range with step
range_step = (start: i64, end: i64, step: i64) Range {
    return Range.with_step(start, end, step)
}
