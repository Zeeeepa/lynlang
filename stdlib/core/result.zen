// Result type for error handling in Zen
// Provides a type-safe way to handle operations that can fail

core = @std
{ Option } = @std.import("core/option")

// Result type - represents success (Ok) or failure (Err)
// As per LANGUAGE_SPEC.zen: Result<T, E>: Ok(T) | Err(E)
Result<T, E>: Ok(T) | Err(E)

// Result methods implementation
Result<T, E>.impl = {
    // Check if Result is Ok
    is_ok = (self: Result<T, E>) bool   {
        self ?
            | Ok(_) { true }
            | Err(_) { false }
    }
    
    // Check if Result is Err
    is_err = (self: Result<T, E>) bool   {
        self ?
            | Ok(_) { false }
            | Err(_) { true }
    }
    
    // Extract Ok value or panic with message
    unwrap = (self: Result<T, E>) T   {
        self ?
            | Ok(value) { value }
            | Err(_) { core.panic("called Result.unwrap() on an Err value") }
    }
    
    // Extract Ok value or return default
    unwrap_or = (self: Result<T, E>, default: T) T   {
        self ?
            | Ok(value) { value }
            | Err(_) { default }
    }
    
    // Extract Ok value or compute default from closure
    unwrap_or_else = (self: Result<T, E>, f: (E) { T }) T {
        self ?
            | Ok(value) { value }
            | Err(error) { f(error) }
    }
    
    // Extract Err value or panic
    unwrap_err = (self: Result<T, E>) E   {
        self ?
            | Ok(_) { core.panic("called Result.unwrap_err() on an Ok value") }
            | Err(error) { error }
    }
    
    // Map Ok value through a function
    map = (self: Result<T, E>, f: (T) { U }) Result<U, E> {
        self ?
            | Ok(value) { Ok(f(value)) }
            | Err(error) { Err(error) }
    }
    
    // Map Err value through a function
    map_err = (self: Result<T, E>, f: (E) { F }) Result<T, F> {
        self ?
            | Ok(ok_val) { Ok(ok_val.value) }
            | Err(err_val) { Err(f(err_val.error)) }
    }
    
    // Chain Result operations
    and_then = (self: Result<T, E>, f: (T) { Result<U, E> }) Result<U, E> {
        self ?
            | Ok(ok_val) { f(ok_val.value) }
            | Err(err_val) { Err(err_val.error) }
    }
    
    // Chain error handling
    or_else = (self: Result<T, E>, f: (E) { Result<T, F> }) Result<T, F> {
        self ?
            | Ok(value) { Ok(value) }
            | Err(error) { f(error) }
    }
    
    // Combine two Results
    and = (self: Result<T, E>, other: Result<U, E>) Result<U, E>   {
        self ?
            | Ok(_) { other }
            | Err(error) { Err(error) }
    }
    
    // Return self if Ok, otherwise return other
    or = (self: Result<T, E>, other: Result<T, F>) Result<T, F>   {
        self ?
            | Ok(value) { Ok(value) }
            | Err(_) { other }
    }
}

// Option methods implementation
Option<T>.impl = {
    // Check if Option has a value
    is_some = (self: Option<T>) bool   {
        self ?
            | Some(_) { true }
            | None { false }
    }
    
    // Check if Option is None
    is_none = (self: Option<T>) bool   {
        self ?
            | Some(_) { false }
            | None { true }
    }
    
    // Extract value or panic
    unwrap = (self: Option<T>) T   {
        self ?
            | Some(value) { value }
            | None { core.panic("called Option.unwrap() on a None value") }
    }
    
    // Extract value or return default
    unwrap_or = (self: Option<T>, default: T) T   {
        self ?
            | Some(value) { value }
            | None { default }
    }
    
    // Extract value or compute default
    unwrap_or_else = (self: Option<T>, f: () { T }) T {
        self ?
            | Some(value) { value }
            | None { f() }
    }
    
    // Map value through function
    map = (self: Option<T>, f: (T) { U }) Option<U> {
        self ?
            | Some(some_val) { Some(f(some_val.value)) }
            | None { None }
    }
    
    // Chain Option operations
    and_then = (self: Option<T>, f: (T) { Option<U> }) Option<U> {
        self ?
            | Some(some_val) { f(some_val.value) }
            | None { None }
    }
    
    // Filter value based on predicate
    filter = (self: Option<T>, predicate: (T) { bool }) Option<T> {
        self ?
            | Some(value) {
                predicate(value) ?
                    | true { Some(value) }
                    | false { None }
            }
            | None { None }
    }
    
    // Convert to Result
    ok_or = (self: Option<T>, err: E) Result<T, E>   {
        self ?
            | Some(value) { Ok(value) }
            | None { Err(err) }
    }
    
    // Convert to Result with error from closure
    ok_or_else = (self: Option<T>, f: () { E }) Result<T, E> {
        self ?
            | Some(value) { Ok(value) }
            | None { Err(f()) }
    }
}

// Utility functions for Result creation
ok = (value: T) Result<T, E>   {
    return Ok(value)
}

err = (error: E) Result<T, E>   {
    return Err(error)
}

// Utility functions for Option creation
some = (value: T) Option<T>   {
    return Some(value)
}

none = () Option<T>   {
    return None
}

// Error propagation using ? operator and pattern matching
// Example: value := some_result?;  // Propagates error up
// Or use explicit pattern matching:
// some_result ? | Ok(value) { process(value) }
//              | Err(e) { return Err(e) }

// Collect Results into a Result of collection
collect_results = (results: Vec<Result<T, E>>) Result<DynVec<T>, E>   {
    values := DynVec<T>{}
    
    (0..results.length).loop((i) {
        results[i] ?
            | Ok(value) { values.append(value) }
            | Err(error) { return Err(error) }
    })
    
    return Ok(values)
}

// Convert Option to Result with custom error message
option_to_result = (opt: Option<T>, error_msg: string) Result<T, string>   {
    opt ?
        | Some(value) { Ok(value) }
        | None { Err(error_msg) }
}