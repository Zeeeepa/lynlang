// Option type for nullable values
// As per LANGUAGE_SPEC.zen: No null! Only Option types

{ Option, Some, None, Result, Ok, Err } = @std

// Option type - represents a value that may or may not exist
// Enums are sum types: a value is ONE of the variants, not all of them
Option<T>: Some: T, None

// Option methods implementation
Option<T>.impl = {
    // Check if option has value
    is_some = (self: Option<T>) bool {
        self ?
        | Some(_) { true }
        | None { false }
    }

    // Check if option is none
    is_none = (self: Option<T>) bool {
        self ?
        | Some(_) { false }
        | None { true }
    }

    // Extract value or panic
    unwrap = (self: Option<T>) T {
        self ?
        | Some(v) { v }
        | None { core.panic("called unwrap on None value") }
    }

    // Extract value or return default
    unwrap_or = (self: Option<T>, default: T) T {
        self ?
        | Some(v) { v }
        | None { default }
    }

    // Extract value or compute default
    unwrap_or_else = (self: Option<T>, f: () { T }) T {
        self ?
        | Some(v) { v }
        | None { f() }
    }

    // Extract value or panic with message
    expect = (self: Option<T>, msg: string) T {
        self ?
        | Some(v) { v }
        | None { core.panic(msg) }
    }

    // Map value through function
    map = <U>(self: Option<T>, f: (T) { U }) Option<U> {
        self ?
        | Some(v) { Option.Some(f(v)) }
        | None { Option.None }
    }

    // Chain operations
    and_then = <U>(self: Option<T>, f: (T) { Option<U> }) Option<U> {
        self ?
        | Some(v) { f(v) }
        | None { Option.None }
    }
}

// Create Some variant
some = (value: T) Option<T> {
    return Option.Some(value)
}

// Create None variant
none = () Option<T> {
    return Option.None
}

// Check if option has value
is_some = (opt: Option<T>) bool {
    opt ?
    | Some(_) { true }
    | None { false }
}

// Check if option is none
is_none = (opt: Option<T>) bool {
    opt ?
    | Some(_) { false }
    | None { true }
}

// Get value or panic
unwrap = (opt: Option<T>) T {
    opt ?
    | Some(v) { v }
    | None { core.panic("called unwrap on None value") }
}

// Get value or default
unwrap_or = (opt: Option<T>, default: T) T {
    opt ?
    | Some(v) { v }
    | None { default }
}

// Get value or compute default
unwrap_or_else = (opt: Option<T>, f: () { T }) T {
    opt ?
    | Some(v) { v }
    | None { f() }
}

// Expect with custom message
expect = (opt: Option<T>, msg: string) T {
    opt ?
    | Some(v) { v }
    | None { core.panic(msg) }
}

// Map value through function
map = (opt: Option<T>, f: (T) { U }) Option<U> {
    opt ?
    | Some(v) { Option.Some(f(v)) }
    | None { Option.None }
}

// Map or return default
map_or = <T, U>(opt: Option<T>, default: U, f: (T) U) U {
    opt ?
    | Some(v) { f(v) }
    | None { default }
}

// Map or compute default
map_or_else = <T, U>(opt: Option<T>, default_fn: () U, f: (T) U) U {
    opt ?
    | Some(v) { f(v) }
    | None { default_fn() }
}

// Chain operations
and_then = <T, U>(opt: Option<T>, f: (T) Option<U>) Option<U> {
    opt ?
    | Some(v) { f(v) }
    | None { Option.None }
}

// Filter based on predicate
filter = <T>(opt: Option<T>, predicate: (T) bool) Option<T> {
    opt ?
    | Some(v) {
        predicate(v) ? {
            Option.Some(v)
        } : {
            Option.None
        }
    }
    | None { Option.None }
}

// Combine with another option
and = <T, U>(opt: Option<T>, other: Option<U>) Option<U> {
    opt ?
    | Some(_) { other }
    | None { Option.None }
}

// Alternative option
or = <T>(opt: Option<T>, other: Option<T>) Option<T> {
    opt ?
    | Some(v) { Option.Some(v) }
    | None { other }
}

// Alternative with function
or_else = <T>(opt: Option<T>, f: () Option<T>) Option<T> {
    opt ?
    | Some(v) { Option.Some(v) }
    | None { f() }
}

// XOR - one or the other but not both
xor = <T>(opt: Option<T>, other: Option<T>) Option<T> {
    (opt.is_some(), other.is_some()) ?
    | (true, false) { opt }
    | (false, true) { other }
    | _ { Option.None }
}

// Get contained value by reference
as_ref = <T>(opt: Ptr<Option<T>>) Option<Ptr<T>> {
    opt ?
    | Some(ref v) { Option.Some(v) }
    | None { Option.None }
}

// Get contained value by mutable reference
as_mut = <T>(opt: MutPtr<Option<T>>) Option<MutPtr<T>> {
    opt ?
    | Some(ref mut v) { Option.Some(v) }
    | None { Option.None }
}

// Take value out, leaving None
take = <T>(opt: MutPtr<Option<T>>) Option<T> {
    let old = *opt
    *opt = Option.None
    return old
}

// Replace value, returning old value
replace = <T>(opt: MutPtr<Option<T>>, value: T) Option<T> {
    let old = *opt
    *opt = Option.Some(value)
    return old
}

// Zip two options
zip = <T, U>(opt1: Option<T>, opt2: Option<U>) Option<(T, U)> {
    (opt1, opt2) ?
    | (Some(v1), Some(v2)) { Option.Some((v1, v2)) }
    | _ { Option.None }
}

// Unzip option of tuple
unzip = <T, U>(opt: Option<(T, U)>) (Option<T>, Option<U>) {
    opt ?
    | Some((v1, v2)) { (Option.Some(v1), Option.Some(v2)) }
    | None { (Option.None, Option.None) }
}

// Flatten nested option
flatten = <T>(opt: Option<Option<T>>) Option<T> {
    opt ?
    | Some(inner) { inner }
    | None { Option.None }
}

