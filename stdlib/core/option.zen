// Option type for nullable values
// As per LANGUAGE_SPEC.zen: No null! Only Option types

{ Option, Some, None, Result, Ok, Err } = @std

// Option type - represents a value that may or may not exist  
Option<T>: {
    Some: T,
    None
}

// Create Some variant
some = (value: T) Option<T> {
    return Option.Some(value)
}

// Create None variant
none = () Option<T> {
    return Option.None
}

// Check if option has value
is_some = (opt: Option<T>) bool {
    opt ?
        | Some(_) { true }
        | None { false }
}

// Check if option is none
is_none = (opt: Option<T>) bool {
    opt ?
        | Some(_) { false }
        | None { true }
}

// Get value or panic
unwrap = (opt: Option<T>) T {
    opt ?
        | Some(v) { v }
        | None { core.panic("called unwrap on None value") }
}

// Get value or default
unwrap_or = (opt: Option<T>, default: T) T {
    opt ?
        | Some(v) { v }
        | None { default }
}

// Get value or compute default
unwrap_or_else = (opt: Option<T>, f: () { T }) T {
    opt ?
        | Some(v) { v }
        | None { f() }
}

// Expect with custom message
expect = (opt: Option<T>, msg: string) T {
    opt ?
        | Some(v) { v }
        | None { core.panic(msg) }
}

// Map value through function
map = (opt: Option<T>, f: (T) { U }) Option<U> {
    opt ?
        | Some(v) { Option.Some(f(v)) }
        | None { Option.None }
}

// Map or return default
map_or = <T, U>(opt: Option<T>, default: U, f: (T) U) U {
    opt ?
        | Some(v) { f(v) }
        | None { default }
}

// Map or compute default
map_or_else = <T, U>(opt: Option<T>, default_fn: () U, f: (T) U) U {
    opt ?
        | Some(v) { f(v) }
        | None { default_fn() }
}

// Chain operations
and_then = <T, U>(opt: Option<T>, f: (T) Option<U>) Option<U> {
    opt ?
        | Some(v) { f(v) }
        | None { Option.None }
}

// Filter based on predicate
filter = <T>(opt: Option<T>, predicate: (T) bool) Option<T> {
    opt ?
        | Some(v) {
            predicate(v) ? {
                Option.Some(v)
            } : {
                Option.None
            }
        }
        | None { Option.None }
}

// Combine with another option
and = <T, U>(opt: Option<T>, other: Option<U>) Option<U> {
    opt ?
        | Some(_) { other }
        | None { Option.None }
}

// Alternative option
or = <T>(opt: Option<T>, other: Option<T>) Option<T> {
    opt ?
        | Some(v) { Option.Some(v) }
        | None { other }
}

// Alternative with function
or_else = <T>(opt: Option<T>, f: () Option<T>) Option<T> {
    opt ?
        | Some(v) { Option.Some(v) }
        | None { f() }
}

// XOR - one or the other but not both
xor = <T>(opt: Option<T>, other: Option<T>) Option<T> {
    (opt.is_some(), other.is_some()) ?
        | (true, false) { opt }
        | (false, true) { other }
        | _ { Option.None }
}

// Get contained value by reference
as_ref = <T>(opt: Ptr<Option<T>>) Option<Ptr<T>> {
    opt ?
        | Some(ref v) { Option.Some(v) }
        | None { Option.None }
}

// Get contained value by mutable reference
as_mut = <T>(opt: MutPtr<Option<T>>) Option<MutPtr<T>> {
    opt ?
        | Some(ref mut v) { Option.Some(v) }
        | None { Option.None }
}

// Take value out, leaving None
take = <T>(opt: MutPtr<Option<T>>) Option<T> {
    let old = *opt
    *opt = Option.None
    return old
}

// Replace value, returning old value
replace = <T>(opt: MutPtr<Option<T>>, value: T) Option<T> {
    let old = *opt
    *opt = Option.Some(value)
    return old
}

// Zip two options
zip = <T, U>(opt1: Option<T>, opt2: Option<U>) Option<(T, U)> {
    (opt1, opt2) ?
        | (Some(v1), Some(v2)) { Option.Some((v1, v2)) }
        | _ { Option.None }
}

// Unzip option of tuple
unzip = <T, U>(opt: Option<(T, U)>) (Option<T>, Option<U>) {
    opt ?
        | Some((v1, v2)) { (Option.Some(v1), Option.Some(v2)) }
        | None { (Option.None, Option.None) }
}

// Flatten nested option
flatten = <T>(opt: Option<Option<T>>) Option<T> {
    opt ?
        | Some(inner) { inner }
        | None { Option.None }
}

