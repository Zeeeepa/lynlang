// Zen Standard Library: Safe Pointer Type
// Wraps raw pointers with type safety and ownership tracking

{ compiler } = @std

// ============================================================================
// Ptr<T> - Owned Pointer (Heap Allocation, Must Be Freed)
// ============================================================================

Ptr<T>: 
    Some: i64,
    None

// Allocate memory and wrap in Ptr<T>
Ptr<T>.allocate = (size: usize) Ptr<T> {
    addr = compiler.raw_allocate(size)
    null_ptr = compiler.int_to_ptr(0)
    addr == null_ptr ?
        | true { return Ptr.None }
        | false { 
            addr_int = compiler.ptr_to_int(addr)
            return Ptr.Some(addr_int)
        }
}

// Create a Ptr from an address (caller must ensure validity)
Ptr<T>.from_addr = (addr: RawPtr<u8>) Ptr<T> {
    null_ptr = compiler.int_to_ptr(0)
    addr == null_ptr ?
        | true { return Ptr.None }
        | false {
            addr_int = compiler.ptr_to_int(addr)
            return Ptr.Some(addr_int)
        }
}

// Create a None pointer
Ptr<T>.none = () Ptr<T> {
    return Ptr.None
}

// Check if pointer is valid
Ptr<T>.is_some = (self: Ptr<T>) bool {
    self ?
        | Some(_) { true }
        | None { false }
}

// Check if pointer is null
Ptr<T>.is_none = (self: Ptr<T>) bool {
    self ?
        | Some(_) { false }
        | None { true }
}

// Get element at index (no dereferencing yet - just calculate offset)
Ptr<T>.at = (self: Ptr<T>, index: usize) Ptr<T> {
    self ?
        | Some(addr_i64) {
            addr = compiler.int_to_ptr(addr_i64)
            item_size = compiler.sizeof<T>()
            offset = index * item_size
            new_addr = compiler.gep(addr, offset)
            new_addr_int = compiler.ptr_to_int(new_addr)
            return Ptr.Some(new_addr_int)
        }
        | None { return Ptr.None }
}

// Pointer arithmetic - advance by N items
Ptr<T>.offset = (self: Ptr<T>, count: i64) Ptr<T> {
    self ?
        | Some(addr_i64) {
            addr = compiler.int_to_ptr(addr_i64)
            item_size = compiler.sizeof<T>()
            byte_offset = count * item_size
            new_addr = compiler.gep(addr, byte_offset)
            new_addr_int = compiler.ptr_to_int(new_addr)
            return Ptr.Some(new_addr_int)
        }
        | None { return Ptr.None }
}

// Get raw address
Ptr<T>.addr = (self: Ptr<T>) RawPtr<u8> {
    self ?
        | Some(addr_i64) { compiler.int_to_ptr(addr_i64) }
        | None { compiler.int_to_ptr(0) }
}

// Unsafe unwrap - gets address or null
Ptr<T>.unwrap = (self: Ptr<T>) RawPtr<u8> {
    self ?
        | Some(addr_i64) { compiler.int_to_ptr(addr_i64) }
        | None { compiler.int_to_ptr(0) }
}

// Deallocate memory
Ptr<T>.free = (self: Ptr<T>, size: usize) void {
    self ?
        | Some(addr_i64) {
            addr = compiler.int_to_ptr(addr_i64)
            compiler.raw_deallocate(addr, size)
        }
        | None { }
}

// Compare two pointers for equality
Ptr<T>.eq = (self: Ptr<T>, other: Ptr<T>) bool {
    addr1 = self.addr()
    addr2 = other.addr()
    return addr1 == addr2
}
