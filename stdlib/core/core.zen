// Zen Standard Library: Core Module
// Essential types and utilities for the Zen language

// Import core types from their respective modules
{ Option } = @std.import("core/option")
{ Result } = @std.import("core/result")

// Type aliases for clarity
size: i64
index: i64
byte: i8

// Basic error types
Error: OutOfMemory
    InvalidArgument: { message: string },
    IndexOutOfBounds: { start: i64, end: i64 },
    NullPointer,
    SystemError: { code: i32 }

// Memory operations (will be implemented with comptime/intrinsics)
malloc = (size: i64) RawPtr<void> {
    inline.c("""
        return malloc(${size});
    """)
}

free = (ptr: RawPtr<void>) void {
    inline.c("""
        free(${ptr.addr});
    """)
}

memcpy = (dest: RawPtr<void>, src: RawPtr<void>, n: i64) RawPtr<void> {
    inline.c("""
        return memcpy(${dest.addr}, ${src.addr}, ${n});
    """)
}

memset = (ptr: RawPtr<void>, value: i32, n: i64) RawPtr<void> {
    inline.c("""
        return memset(${ptr.addr}, ${value}, ${n});
    """)
}

// Assertion for debugging
assert = (condition: bool, message: string) void {
    condition ?
        | false {
            // In the future, this would panic with the message
            // For now, we'll use a placeholder
            exit = (code: i32) void {
                inline.c("""
                    exit(${code});
                """)
            }
            exit(1)
        }
        | true {}
}

// Min/max functions
min = (a: i64, b: i64) i64 {
    a < b ?
        | true { return a }
        | false { return b }
}

max = (a: i64, b: i64) i64 {
    a > b ?
        | true { return a }
        | false { return b }
}

// Absolute value
abs = (n: i64) i64 {
    n < 0 ?
        | true { return -n }
        | false { return n }
}

// Swap two values (when we have references)
swap = (a: MutPtr<i64>, b: MutPtr<i64>) void {
    temp ::= a.val
    a.val = b.val
    b.val = temp
}

// Range type for iteration
Range: {
    start: i64,
    end: i64,
    step: i64,
}

// Create a range
range = (start: i64, end: i64) Range   {
    return Range { start: start, end: end, step: 1 }
}

// Create a range with custom step
range_step = (start: i64, end: i64, step: i64) Range   {
    return Range { start: start, end: end, step: step }
}

// Functional loop method for Range
Range.loop = (self: Range, callback: (i64) void) void {
    i ::= self.start
    loop(() {
        i >= self.end ?
            | true { break }
            | false {
                callback(i)
                i = i + self.step
            }
    })
}

// Inclusive range
range_inclusive = (start: i64, end: i64) Range   {
    return Range { start: start, end: end + 1, step: 1 }
}

// ===== Additional Core Operations =====

// Clamp a value between min and max
clamp = (value: i64, min_val: i64, max_val: i64) i64 {
    value < min_val ?
        | true { return min_val }
        | false {
            value > max_val ?
                | true { return max_val }
                | false { return value }
        }
}

// Sign function
sign = (n: i64) i64 {
    n < 0 ?
        | true { return -1 }
        | false {
            n > 0 ?
                | true { return 1 }
                | false { return 0 }
        }
}

// Power of 2 check
is_power_of_two = (n: i64) bool {
    (n > 0 && (n & (n - 1)) == 0) ?
        | true { return true }
        | false { return false }
}

// Next power of 2
next_power_of_two = (n: i64) i64 {
    n <= 1 ? { return 1 }
    
    result ::= 1
    loop(() {
        result >= n ?
            | true { break }
            | false { result = result << 1 }
    })
    return result
}

// Bit counting operations
count_ones = (n: i64) i64 {
    count ::= 0
    val ::= n
    loop(() {
        val == 0 ?
            | true { break }
            | false {
                count = count + (val & 1)
                val = val >> 1
            }
    })
    return count
}

count_zeros = (n: i64) i64   {
    return 64 - count_ones(n)
}

// Array/slice utilities
reverse_array = (arr: MutPtr<i64>, len: i64) void {
    i ::= 0
    j ::= len - 1
    loop(() {
        i >= j ?
            | true { break }
            | false {
                // Would need array indexing syntax for MutPtr
                temp ::= (arr.addr + i * 8).val  // Assuming i64 is 8 bytes
                (arr.addr + i * 8).val = (arr.addr + j * 8).val
                (arr.addr + j * 8).val = temp
                i = i + 1
                j = j - 1
            }
    })
}

// Find minimum in array
array_min = (arr: Ptr<i64>, len: i64) i64 {
    len == 0 ? { return 0 }
    
    min_val ::= (arr.addr).val  // First element
    i ::= 1
    loop(() {
        i >= len ?
            | true { break }
            | false {
                current ::= (arr.addr + i * 8).val
                current < min_val ? { min_val = current }
                i = i + 1
            }
    })
    return min_val
}

// Find maximum in array  
array_max = (arr: Ptr<i64>, len: i64) i64 {
    len == 0 ? { return 0 }
    
    max_val ::= (arr.addr).val  // First element
    i ::= 1
    loop(() {
        i >= len ?
            | true { break }
            | false {
                current ::= (arr.addr + i * 8).val
                current > max_val ? { max_val = current }
                i = i + 1
            }
    })
    return max_val
}

// Sum of array elements
array_sum = (arr: Ptr<i64>, len: i64) i64 {
    sum ::= 0
    i ::= 0
    loop(() {
        i >= len ?
            | true { break }
            | false {
                sum = sum + (arr.addr + i * 8).val
                i = i + 1
            }
    })
    return sum
}

// Equality check for arrays
arrays_equal = (a: Ptr<i64>, b: Ptr<i64>, len: i64) bool {
    i ::= 0
    loop(() {
        i >= len ?
            | true { break }
            | false {
                val_a ::= (a.addr + i * 8).val
                val_b ::= (b.addr + i * 8).val
                val_a != val_b ? { return false }
                i = i + 1
            }
    })
    return true
}

// Copy array
array_copy = (dest: MutPtr<i64>, src: Ptr<i64>, len: i64) void {
    i ::= 0
    loop(() {
        i >= len ?
            | true { break }
            | false {
                (dest.addr + i * 8).val = (src.addr + i * 8).val
                i = i + 1
            }
    })
}

// Fill array with value
array_fill = (arr: MutPtr<i64>, len: i64, value: i64) void {
    i ::= 0
    loop(() {
        i >= len ?
            | true { break }
            | false {
                (arr.addr + i * 8).val = value
                i = i + 1
            }
    })
}

// Linear search
array_find = (arr: Ptr<i64>, len: i64, value: i64) i64 {
    i ::= 0
    loop(() {
        i >= len ?
            | true { break }
            | false {
                (arr.addr + i * 8).val == value ? { return i }
                i = i + 1
            }
    })
    return -1  // Not found
}

// Contains check
array_contains = (arr: Ptr<i64>, len: i64, value: i64) bool {
    return array_find(arr, len, value) != -1
}

// GCD and LCM
gcd = (a: i64, b: i64) i64 {
    a_val ::= abs(a)
    b_val ::= abs(b)
    
    loop(() {
        b_val == 0 ?
            | true { break }
            | false {
                temp := b_val
                b_val = a_val % b_val
                a_val = temp
            }
    })
    return a_val
}

lcm = (a: i64, b: i64) i64 {
    (a == 0 || b == 0) ? { return 0 }
    return abs(a * b) / gcd(a, b)
}

// Factorial
factorial = (n: i64) i64 {
    n < 0 ? { return 0 }
    n <= 1 ? { return 1 }
    
    result ::= 1
    i ::= 2
    loop(() {
        i > n ?
            | true { break }
            | false {
                result = result * i
                i = i + 1
            }
    })
    return result
}

// Fibonacci
fibonacci = (n: i64) i64 {
    n <= 0 ? { return 0 } 
    n == 1 ? { return 1 }
    
    a ::= 0
    b ::= 1
    i ::= 2
    loop(() {
        i > n ?
            | true { break }
            | false {
                temp := a + b
                a = b
                b = temp
                i = i + 1
            }
    })
    return b
}

// Is prime
is_prime = (n: i64) bool {
    n <= 1 ? { return false }
    n <= 3 ? { return true }
    (n % 2 == 0 || n % 3 == 0) ? { return false }
    
    i ::= 5
    loop(() {
        i * i > n ?
            | true { break }
            | false {
                (n % i == 0 || n % (i + 2) == 0) ? { return false }
                i = i + 6
            }
    })
    return true
}

// Panic function for unrecoverable errors
abort = () void {
    inline.c("""
        abort();
    """)
}
panic = (message: string) void   {
    // Would print the message in a real implementation
    abort()
}

// Unreachable marker
unreachable = () void   {
    panic("unreachable code executed")
}

// Type size information (platform-dependent, assuming 64-bit)
size_of_i8 = () i64   { return 1 }
size_of_i16 = () i64   { return 2 }
size_of_i32 = () i64   { return 4 }
size_of_i64 = () i64   { return 8 }
size_of_ptr = () i64   { return 8 }  // 64-bit platform
size_of_bool = () i64   { return 1 }

// Alignment helpers
align_up = (value: i64, alignment: i64) i64   {
    return (value + alignment - 1) & ~(alignment - 1)
}

align_down = (value: i64, alignment: i64) i64   {
    return value & ~(alignment - 1)
}

is_aligned = (value: i64, alignment: i64) bool   {
    return (value & (alignment - 1)) == 0
}