// Zen Standard Library - Command Line Arguments Module
// Provides argument parsing and handling utilities

core := @std.core
io := @std.io
string := @std.string
vec := @std.vec

// Argument parser configuration
ArgParser: {
    program_name: string,
    description: string,
    version: string,
    flags: Vec<Flag>,
    positional: Vec<Positional>,
    subcommands: Vec<Subcommand>,
}

// Flag definition
Flag: {
    short: Option<u8>,        // -h
    long: string,             // --help
    description: string,
    value_name: Option<string>,
    default_value: Option<string>,
    required: bool,
    takes_value: bool,
    multiple: bool,           // Can be specified multiple times
}

// Positional argument
Positional: {
    name: string,
    description: string,
    required: bool,
    multiple: bool,           // Accepts multiple values
}

// Subcommand definition
Subcommand: {
    name: string,
    description: string,
    parser: ArgParser,
}

// Parsed arguments result
ParsedArgs: {
    flags: HashMap<string, FlagValue>,
    positional: Vec<string>,
    subcommand: Option<(string, ParsedArgs)>,
}

// Flag value types
FlagValue: 
    Present,                  // Flag was present (no value)
    Single(string),          // Single value
    Multiple(Vec<string>),   // Multiple values

// Create new argument parser
new_parser: (name: string, desc: string) ArgParser  = {
    return ArgParser{
        program_name: name,
        description: desc,
        version: "1.0.0",
        flags: vec_new<Flag>(),
        positional: vec_new<Positional>(),
        subcommands: vec_new<Subcommand>(),
    }
}

// Add flag to parser
add_flag: (parser: &mut ArgParser, flag: Flag)   = {
    vec_push(parser.flags, flag)
}

// Add short flag (e.g., -h)
flag_short: (short: u8, long: string, desc: string) Flag  = {
    return Flag{
        short: Option<u8>.Some(short),
        long: long,
        description: desc,
        value_name: Option<string>.None,
        default_value: Option<string>.None,
        required: false,
        takes_value: false,
        multiple: false,
    }
}

// Add long flag (e.g., --help)
flag_long: (long: string, desc: string) Flag  = {
    return Flag{
        short: Option<u8>.None,
        long: long,
        description: desc,
        value_name: Option<string>.None,
        default_value: Option<string>.None,
        required: false,
        takes_value: false,
        multiple: false,
    }
}

// Add flag with value
flag_value: (short: u8, long: string, value_name: string, desc: string) Flag  = {
    return Flag{
        short: Option<u8>.Some(short),
        long: long,
        description: desc,
        value_name: Option<string>.Some(value_name),
        default_value: Option<string>.None,
        required: false,
        takes_value: true,
        multiple: false,
    }
}

// Add required flag
flag_required: (long: string, value_name: string, desc: string) Flag  = {
    return Flag{
        short: Option<u8>.None,
        long: long,
        description: desc,
        value_name: Option<string>.Some(value_name),
        default_value: Option<string>.None,
        required: true,
        takes_value: true,
        multiple: false,
    }
}

// Add positional argument
add_positional: (parser: &mut ArgParser, name: string, desc: string, required: bool)   = {
    pos := Positional{
        name: name,
        description: desc,
        required: required,
        multiple: false,
    }
    vec_push(parser.positional, pos)
}

// Add subcommand
add_subcommand: (parser: &mut ArgParser, name: string, desc: string, sub_parser: ArgParser)   = {
    sub := Subcommand{
        name: name,
        description: desc,
        parser: sub_parser,
    }
    vec_push(parser.subcommands, sub)
}

// Parse command line arguments
parse: (parser: &ArgParser, args: Vec<string>) Result<ParsedArgs, string>  = {
    result := ParsedArgs{
        flags: hashmap_new<string, FlagValue>(),
        positional: vec_new<string>(),
        subcommand: Option<(string, ParsedArgs)>.None,
    }
    
    i := 1  // Skip program name (args[0])
    positional_index := 0
    
    loop i < vec_len(args) {
        arg := vec_get(args, i)
        
        // Check for flags
        string.starts_with(arg, "--") ? {
            // Long flag
            flag_name := string.substring(arg, 2, string.len(arg))
            
            // Check for = syntax (--flag=value)
            eq_pos := string.index_of(flag_name, "=")
            eq_pos >= 0 ? {
                actual_flag := string.substring(flag_name, 0, eq_pos)
                value := string.substring(flag_name, eq_pos + 1, string.len(flag_name))
                
                flag := find_flag_by_long(parser, actual_flag)
                match flag {
                    | Option<Flag>.Some(f) => {
                        f.takes_value ? {
                            hashmap_put(result.flags, f.long, FlagValue.Single(value))
                        } : {
                            return Result<ParsedArgs, string>.Err("Flag --" + actual_flag + " does not take a value")
                        }
                    }
                    | Option<Flag>.None => {
                        return Result<ParsedArgs, string>.Err("Unknown flag: --" + actual_flag)
                    }
                }
            } : {
                // Regular long flag
                flag := find_flag_by_long(parser, flag_name)
                match flag {
                    | Option<Flag>.Some(f) => {
                        f.takes_value ? {
                            i = i + 1
                            i < vec_len(args) ? {
                                value := vec_get(args, i)
                                hashmap_put(result.flags, f.long, FlagValue.Single(value))
                            } : {
                                return Result<ParsedArgs, string>.Err("Flag --" + f.long + " requires a value")
                            }
                        } : {
                            hashmap_put(result.flags, f.long, FlagValue.Present)
                        }
                    }
                    | Option<Flag>.None => {
                        return Result<ParsedArgs, string>.Err("Unknown flag: --" + flag_name)
                    }
                }
            }
        } :
        string.starts_with(arg, "-") && string.len(arg) > 1 ? {
            // Short flag(s)
            j := 1
            loop j < string.len(arg) {
                short_char := arg[j]
                flag := find_flag_by_short(parser, short_char)
                
                match flag {
                    | Option<Flag>.Some(f) => {
                        f.takes_value ? {
                            // If it takes a value, rest of string or next arg is the value
                            j + 1 < string.len(arg) ? {
                                // Rest of string is the value
                                value := string.substring(arg, j + 1, string.len(arg))
                                hashmap_put(result.flags, f.long, FlagValue.Single(value))
                                j = string.len(arg)  // Exit loop
                            } : {
                                // Next arg is the value
                                i = i + 1
                                i < vec_len(args) ? {
                                    value := vec_get(args, i)
                                    hashmap_put(result.flags, f.long, FlagValue.Single(value))
                                } : {
                                    return Result<ParsedArgs, string>.Err("Flag -" + short_char + " requires a value")
                                }
                            }
                        } : {
                            hashmap_put(result.flags, f.long, FlagValue.Present)
                        }
                    }
                    | Option<Flag>.None => {
                        return Result<ParsedArgs, string>.Err("Unknown flag: -" + short_char)
                    }
                }
                j = j + 1
            }
        } : {
            // Check for subcommand
            vec_len(parser.subcommands) > 0 && positional_index == 0 ? {
                sub := find_subcommand(parser, arg)
                match sub {
                    | Option<Subcommand>.Some(s) => {
                        // Parse remaining args with subcommand parser
                        sub_args := vec_slice(args, i + 1, vec_len(args))
                        sub_result := parse(&s.parser, sub_args)
                        match sub_result {
                            | Result<ParsedArgs, string>.Ok(parsed) => {
                                result.subcommand = Option<(string, ParsedArgs)>.Some((s.name, parsed))
                                return Result<ParsedArgs, string>.Ok(result)
                            }
                            | Result<ParsedArgs, string>.Err(e) => {
                                return Result<ParsedArgs, string>.Err("Subcommand " + s.name + ": " + e)
                            }
                        }
                    }
                    | Option<Subcommand>.None => {
                        // Not a subcommand, treat as positional
                        vec_push(result.positional, arg)
                        positional_index = positional_index + 1
                    }
                }
            } : {
                // Positional argument
                vec_push(result.positional, arg)
                positional_index = positional_index + 1
            }
        }
        
        i = i + 1
    }
    
    // Check required flags
    i = 0
    loop i < vec_len(parser.flags) {
        flag := vec_get(parser.flags, i)
        flag.required && !hashmap_has(result.flags, flag.long) ? {
            return Result<ParsedArgs, string>.Err("Required flag --" + flag.long + " not provided")
        } : {}
        i = i + 1
    }
    
    // Check required positional
    i = 0
    loop i < vec_len(parser.positional) {
        pos := vec_get(parser.positional, i)
        pos.required && i >= vec_len(result.positional) ? {
            return Result<ParsedArgs, string>.Err("Required argument '" + pos.name + "' not provided")
        } : {}
        i = i + 1
    }
    
    return Result<ParsedArgs, string>.Ok(result)
}

// Find flag by short name
find_flag_by_short: (parser: &ArgParser, short: u8) Option<Flag>  = {
    i := 0
    loop i < vec_len(parser.flags) {
        flag := vec_get(parser.flags, i)
        match flag.short {
            | Option<u8>.Some(s) => {
                s == short ? {
                    return Option<Flag>.Some(flag)
                } : {}
            }
            | Option<u8>.None => {}
        }
        i = i + 1
    }
    return Option<Flag>.None
}

// Find flag by long name
find_flag_by_long: (parser: &ArgParser, long: string) Option<Flag>  = {
    i := 0
    loop i < vec_len(parser.flags) {
        flag := vec_get(parser.flags, i)
        flag.long == long ? {
            return Option<Flag>.Some(flag)
        } : {}
        i = i + 1
    }
    return Option<Flag>.None
}

// Find subcommand by name
find_subcommand: (parser: &ArgParser, name: string) Option<Subcommand>  = {
    i := 0
    loop i < vec_len(parser.subcommands) {
        sub := vec_get(parser.subcommands, i)
        sub.name == name ? {
            return Option<Subcommand>.Some(sub)
        } : {}
        i = i + 1
    }
    return Option<Subcommand>.None
}

// Check if flag is present
has_flag: (args: &ParsedArgs, name: string) bool  = {
    return hashmap_has(args.flags, name)
}

// Get flag value
get_flag: (args: &ParsedArgs, name: string) Option<string>  = {
    value := hashmap_get(args.flags, name)
    match value {
        | Option<FlagValue>.Some(v) => {
            match v {
                | FlagValue.Present => return Option<string>.None
                | FlagValue.Single(s) => return Option<string>.Some(s)
                | FlagValue.Multiple(m) => {
                    vec_len(m) > 0 ? {
                        return Option<string>.Some(vec_get(m, 0))
                    } : {
                        return Option<string>.None
                    }
                }
            }
        }
        | Option<FlagValue>.None => return Option<string>.None
    }
}

// Get all values for multi-value flag
get_flag_multi: (args: &ParsedArgs, name: string) Vec<string>  = {
    value := hashmap_get(args.flags, name)
    match value {
        | Option<FlagValue>.Some(v) => {
            match v {
                | FlagValue.Multiple(m) => return m
                | FlagValue.Single(s) => return vec_of([s])
                | FlagValue.Present => return vec_new<string>()
            }
        }
        | Option<FlagValue>.None => return vec_new<string>()
    }
}

// Generate help text
help_text: (parser: &ArgParser) string  = {
    help := parser.description + "\n\n"
    help = help + "USAGE:\n"
    help = help + "    " + parser.program_name
    
    // Add flags to usage
    vec_len(parser.flags) > 0 ? {
        help = help + " [OPTIONS]"
    } : {}
    
    // Add positional to usage
    i := 0
    loop i < vec_len(parser.positional) {
        pos := vec_get(parser.positional, i)
        pos.required ? {
            help = help + " <" + pos.name + ">"
        } : {
            help = help + " [" + pos.name + "]"
        }
        i = i + 1
    }
    
    // Add subcommands to usage
    vec_len(parser.subcommands) > 0 ? {
        help = help + " [SUBCOMMAND]"
    } : {}
    
    help = help + "\n\n"
    
    // List positional arguments
    vec_len(parser.positional) > 0 ? {
        help = help + "ARGUMENTS:\n"
        i = 0
        loop i < vec_len(parser.positional) {
            pos := vec_get(parser.positional, i)
            help = help + "    " + pos.name
            help = help + string.repeat(" ", 20 - string.len(pos.name))
            help = help + pos.description + "\n"
            i = i + 1
        }
        help = help + "\n"
    } : {}
    
    // List options
    vec_len(parser.flags) > 0 ? {
        help = help + "OPTIONS:\n"
        i = 0
        loop i < vec_len(parser.flags) {
            flag := vec_get(parser.flags, i)
            help = help + "    "
            
            // Short flag
            match flag.short {
                | Option<u8>.Some(s) => {
                    help = help + "-" + s + ", "
                }
                | Option<u8>.None => {
                    help = help + "    "
                }
            }
            
            // Long flag
            help = help + "--" + flag.long
            
            // Value name
            match flag.value_name {
                | Option<string>.Some(v) => {
                    help = help + " <" + v + ">"
                }
                | Option<string>.None => {}
            }
            
            // Padding and description
            current_len := string.len(flag.long) + 6
            flag.takes_value ? {
                current_len = current_len + string.len(flag.value_name.unwrap()) + 3
            } : {}
            
            padding := 30 - current_len
            padding > 0 ? {
                help = help + string.repeat(" ", padding)
            } : {
                help = help + "  "
            }
            
            help = help + flag.description
            
            // Show if required
            flag.required ? {
                help = help + " [required]"
            } : {}
            
            // Show default value
            match flag.default_value {
                | Option<string>.Some(d) => {
                    help = help + " [default: " + d + "]"
                }
                | Option<string>.None => {}
            }
            
            help = help + "\n"
            i = i + 1
        }
        help = help + "\n"
    } : {}
    
    // List subcommands
    vec_len(parser.subcommands) > 0 ? {
        help = help + "SUBCOMMANDS:\n"
        i = 0
        loop i < vec_len(parser.subcommands) {
            sub := vec_get(parser.subcommands, i)
            help = help + "    " + sub.name
            help = help + string.repeat(" ", 20 - string.len(sub.name))
            help = help + sub.description + "\n"
            i = i + 1
        }
        help = help + "\n"
    } : {}
    
    return help
}