// Zen Standard Library: Actor Framework (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Hollywood-style actors: "Don't call us, we'll call you"
//
// Design Principles:
// - Message passing only (no shared mutable state)
// - Sequential processing (one message at a time per actor)
// - Let it crash (supervisors handle failures)
// - Location transparency (ActorRef works anywhere)
//
// Simplicity: An actor is just a mailbox + behavior + thread. Nothing more.

{ compiler } = @std
{ Result } = @std.core.result
{ Option } = @std.core.option
{ Allocator } = @std.memory.allocator
{ Channel, ChannelError } = @std.concurrency.sync.channel
{ AtomicI32, AtomicI64 } = @std.concurrency.primitives.atomic

// ============================================================================
// Actor State
// ============================================================================

ACTOR_CREATED = 0
ACTOR_RUNNING = 1
ACTOR_STOPPING = 2
ACTOR_STOPPED = 3
ACTOR_FAILED = 4

// ============================================================================
// ActorRef - Handle to send messages to an actor
// ============================================================================
// This is the only way to interact with an actor.
// Provides location transparency - caller doesn't know where actor runs.

ActorRef<M>: {
    id: u64,
    mailbox: i64,    // Pointer to Channel<M>
    state: i64       // Pointer to AtomicI32 (actor state)
}

// Send a message (blocking if mailbox is full)
ActorRef.send = (self: ActorRef<M>, msg: M) Result<(), ChannelError> {
    mailbox = compiler.int_to_ptr(self.mailbox) as MutPtr<Channel<M>>
    return mailbox.send(msg)
}

// Non-blocking send
ActorRef.try_send = (self: ActorRef<M>, msg: M) Result<(), ChannelError> {
    mailbox = compiler.int_to_ptr(self.mailbox) as MutPtr<Channel<M>>
    return mailbox.try_send(msg)
}

// Check if actor is alive
ActorRef.is_alive = (self: ActorRef<M>) bool {
    state_ptr = compiler.int_to_ptr(self.state) as Ptr<AtomicI32>
    state = state_ptr.load()
    return state == ACTOR_RUNNING
}

// Get actor ID
ActorRef.id = (self: ActorRef<M>) u64 {
    return self.id
}

// ============================================================================
// ActorContext - Passed to actor during message processing
// ============================================================================
// Provides access to self reference, spawning, and lifecycle control

ActorContext<M>: {
    self_ref: ActorRef<M>,
    allocator: Allocator,
    should_stop: bool
}

ActorContext.self = (self: Ptr<ActorContext<M>>) ActorRef<M> {
    return self.val.self_ref
}

ActorContext.stop = (self: MutPtr<ActorContext<M>>) void {
    self.val.should_stop = true
}

// ============================================================================
// Actor Behavior
// ============================================================================
// Defines how an actor processes messages.
// Users implement this behavior for their actor types.

ActorBehavior<M>: behavior {
    // Called for each message
    receive: (self: MutPtr<Self>, ctx: MutPtr<ActorContext<M>>, msg: M) void

    // Called when actor starts (optional override)
    on_start: (self: MutPtr<Self>, ctx: MutPtr<ActorContext<M>>) void

    // Called when actor stops (optional override)
    on_stop: (self: MutPtr<Self>, ctx: MutPtr<ActorContext<M>>) void
}

// ============================================================================
// Actor - The runtime instance
// ============================================================================
// An actor is: A mailbox (Channel), A behavior, An allocator. That's it.

Actor<M, B>: {
    id: u64,
    state: AtomicI32,
    mailbox: Channel<M>,
    behavior: B,
    allocator: Allocator
}

// Global actor ID counter
actor_id_counter: AtomicI64 = AtomicI64.new(1)

next_actor_id = () u64 {
    return actor_id_counter.fetch_add(1) as u64
}

// Create a new actor (does not start it)
Actor.new = (behavior: B, mailbox_size: usize, allocator: Allocator) Actor<M, B> {
    return Actor<M, B> {
        id: next_actor_id(),
        state: AtomicI32.new(ACTOR_CREATED),
        mailbox: Channel.new(mailbox_size, allocator),
        behavior: behavior,
        allocator: allocator
    }
}

// Get a reference to this actor for message sending
Actor.ref = (self: Ptr<Actor<M, B>>) ActorRef<M> {
    return ActorRef<M> {
        id: self.val.id,
        mailbox: compiler.ptr_to_int(&self.val.mailbox.ref() as RawPtr<u8>),
        state: compiler.ptr_to_int(&self.val.state.ref() as RawPtr<u8>)
    }
}

// Run the actor's message loop (blocking)
// This should be called in a dedicated thread
Actor.run = (self: MutPtr<Actor<M, B>>) void {
    // Transition to running
    self.val.state.store(ACTOR_RUNNING)

    // Create context
    ctx = ActorContext<M> {
        self_ref: self.ref(),
        allocator: self.val.allocator,
        should_stop: false
    }

    // Call on_start
    self.val.behavior.on_start(&ctx)

    // Message loop
    ctx.should_stop == false ? {
        // Check if we should stop
        state = self.val.state.load()
        state == ACTOR_STOPPING ? { ctx.should_stop = true }

        ctx.should_stop == false ? {
            // Wait for message (direct - no envelope overhead)
            msg_opt = self.val.mailbox.recv()
            msg_opt ? {
                | Some(msg) {
                    self.val.behavior.receive(&ctx, msg)
                }
                | None {
                    // Channel closed
                    ctx.should_stop = true
                }
            }
        }
    }

    // Call on_stop
    self.val.behavior.on_stop(&ctx)

    // Transition to stopped
    self.val.state.store(ACTOR_STOPPED)
}

// Request actor to stop gracefully
Actor.stop = (self: MutPtr<Actor<M, B>>) void {
    self.val.state.store(ACTOR_STOPPING)
    self.val.mailbox.close()
}

// Check if actor is running
Actor.is_running = (self: Ptr<Actor<M, B>>) bool {
    return self.val.state.load() == ACTOR_RUNNING
}

// Free actor resources
Actor.free = (self: MutPtr<Actor<M, B>>) void {
    self.val.mailbox.free()
}

// ============================================================================
// Default Behavior Implementations
// ============================================================================

// Default on_start does nothing
default_on_start<M, B> = (self: MutPtr<B>, ctx: MutPtr<ActorContext<M>>) void {
    // No-op
}

// Default on_stop does nothing
default_on_stop<M, B> = (self: MutPtr<B>, ctx: MutPtr<ActorContext<M>>) void {
    // No-op
}
