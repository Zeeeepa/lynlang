// Zen Standard Library: Once (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// One-time initialization primitive

{ compiler } = @std
{ futex_wait, futex_wake_all } = @std.concurrency.primitives.futex

// ============================================================================
// Once States
// ============================================================================

ONCE_INCOMPLETE = 0
ONCE_RUNNING = 1
ONCE_COMPLETE = 2

// ============================================================================
// Once - One-time Initialization
// ============================================================================
// Ensures a piece of initialization code runs exactly once,
// even when called concurrently from multiple threads.

Once: {
    state: i32
}

Once.new = () Once {
    return Once { state: ONCE_INCOMPLETE }
}

// Check if initialization has completed
Once.is_completed = (self: Ptr<Once>) bool {
    state = compiler.atomic_load(&self.val.state.ref() as Ptr<u64>) as i32
    return state == ONCE_COMPLETE
}

// Call the initialization function exactly once
// Note: Without closures, the caller must check is_completed
// and perform initialization manually:
//
//   once.call_once() ? {
//       | true { /* we are the initializer, do init */ }
//       | false { /* already initialized or another thread is doing it */ }
//   }
//
// Returns true if this call should perform initialization
Once.call_once = (self: MutPtr<Once>) bool {
    // Fast path: already complete
    state = compiler.atomic_load(&self.val.state.ref() as Ptr<u64>) as i32
    state == ONCE_COMPLETE ? { return false }

    // Try to become the initializer
    old = compiler.atomic_cas(&self.val.state.ref() as Ptr<u64>, ONCE_INCOMPLETE, ONCE_RUNNING)

    // We won the race - we are the initializer
    old == ONCE_INCOMPLETE ? { return true }

    // Another thread is initializing - wait for completion
    old == ONCE_RUNNING ? {
        self.wait_for_completion()
    }

    return false
}

// Mark initialization as complete (must be called by initializer)
Once.complete = (self: MutPtr<Once>) void {
    compiler.atomic_store(&self.val.state.ref() as Ptr<u64>, ONCE_COMPLETE)
    futex_wake_all(&self.val.state.ref())
}

// Wait for another thread to complete initialization
Once.wait_for_completion = (self: MutPtr<Once>) void {
    state = compiler.atomic_load(&self.val.state.ref() as Ptr<u64>) as i32
    state == ONCE_RUNNING ? {
        futex_wait(&self.val.state.ref(), ONCE_RUNNING)
    }
}

// ============================================================================
// OnceCell - Lazy initialization container
// ============================================================================
// Holds a value that is initialized once on first access.
// Note: Without generics at runtime and closures, this is limited.

OnceCell: {
    once: Once,
    value: i64  // Store value or pointer
}

OnceCell.new = () OnceCell {
    return OnceCell { once: Once.new(), value: 0 }
}

// Get or initialize the value
// Returns the stored value
// Caller must initialize if call_once returns true
OnceCell.get_or_init = (self: MutPtr<OnceCell>) i64 {
    self.val.once.is_completed() ? {
        return self.val.value
    }

    // Try to initialize
    self.val.once.call_once() ? {
        | true {
            // We are the initializer - caller must set value and complete
            return 0  // Signal that initialization is needed
        }
        | false {
            // Another thread initialized
            return self.val.value
        }
    }
    return self.val.value
}

// Set the value (must only be called during initialization)
OnceCell.set = (self: MutPtr<OnceCell>, value: i64) void {
    self.val.value = value
    self.val.once.complete()
}

// Check if initialized
OnceCell.is_initialized = (self: Ptr<OnceCell>) bool {
    return self.val.once.is_completed()
}

// Get value without initialization (returns 0 if not initialized)
OnceCell.get = (self: Ptr<OnceCell>) i64 {
    self.val.once.is_completed() ? { return self.val.value }
    return 0
}
