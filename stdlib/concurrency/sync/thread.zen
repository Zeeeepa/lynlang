// Zen Standard Library: Thread (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Lightweight threads using Linux clone syscall

{ compiler } = @std
{ Result } = @std.core.result
{ Allocator } = @std.memory.allocator
{ futex_wait } = @std.concurrency.primitives.futex
{ SYS_CLONE, SYS_EXIT, SYS_TGKILL, SYS_FUTEX, SYS_GETTID } = @std.sys.syscall

// ============================================================================
// Clone Flags
// ============================================================================

CLONE_VM = 256            // Share memory space
CLONE_FS = 512            // Share filesystem info
CLONE_FILES = 1024        // Share file descriptors
CLONE_SIGHAND = 2048      // Share signal handlers
CLONE_THREAD = 65536      // Same thread group
CLONE_SYSVSEM = 262144    // Share SysV semaphores
CLONE_SETTLS = 524288     // Set TLS
CLONE_PARENT_SETTID = 1048576   // Store TID in parent
CLONE_CHILD_CLEARTID = 2097152  // Clear TID on exit
CLONE_CHILD_SETTID = 16777216   // Store TID in child

// Standard flags for spawning a thread
CLONE_THREAD_FLAGS = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID

// ============================================================================
// Thread State
// ============================================================================

THREAD_CREATED = 0
THREAD_RUNNING = 1
THREAD_FINISHED = 2
THREAD_JOINED = 3

// Default stack size: 2MB
DEFAULT_STACK_SIZE = 2097152

// ============================================================================
// ThreadHandle - Handle to a spawned thread
// ============================================================================

ThreadHandle: {
    tid: i32,           // Thread ID
    state: i32,         // Thread state (for join synchronization)
    stack_base: i64,    // Base of allocated stack (for deallocation)
    stack_size: usize,  // Stack size
    allocator: Allocator
}

// Get current thread ID
get_tid = () i32 {
    result = compiler.syscall0(SYS_GETTID)
    return result as i32
}

// ============================================================================
// Thread Spawning
// ============================================================================

// Spawn a new thread running the given function
// The function receives a context pointer
// Returns ThreadHandle on success
//
// Note: This is a low-level primitive. The thread function must:
// 1. Not return (call thread_exit instead)
// 2. Handle its own cleanup
//
// Usage:
//   thread_fn = (ctx: i64) void { ... thread_exit(0) }
//   handle = Thread.spawn(thread_fn, ctx_ptr, allocator)
//
Thread.spawn = (entry_fn: i64, context: i64, allocator: Allocator) Result<ThreadHandle, i32> {
    // Allocate stack (grows down, so we need the top)
    stack_size = DEFAULT_STACK_SIZE
    stack_base = allocator.allocate(stack_size)
    stack_base == 0 ? {
        return Result.Err(-12)  // ENOMEM
    }

    // Stack top (stack grows down on x86-64)
    stack_top = stack_base + stack_size - 64  // Leave some space

    // Set up initial stack frame with context and entry point
    // The child will start at the entry function with context as argument
    compiler.store<i64>(compiler.int_to_ptr(stack_top), context)
    compiler.store<i64>(compiler.int_to_ptr(stack_top - 8), entry_fn)

    // Allocate space for TID storage (child_tid for CLEARTID)
    tid_ptr = allocator.allocate(8)
    compiler.store<i64>(compiler.int_to_ptr(tid_ptr), 0)

    // Clone with thread flags
    // clone(flags, stack, parent_tid, child_tid, tls)
    // For threads: flags, stack_top, &parent_tid, &child_tid
    result = compiler.syscall4(
        SYS_CLONE,
        CLONE_THREAD_FLAGS,
        stack_top - 16,  // Point to the setup stack frame
        tid_ptr,         // parent_tid (we'll read from here)
        tid_ptr          // child_tid (kernel writes here, clears on exit)
    )

    result < 0 ? {
        allocator.deallocate(stack_base, stack_size)
        allocator.deallocate(tid_ptr, 8)
        return Result.Err(result as i32)
    }

    // Parent: result is child TID
    tid = result as i32

    handle = ThreadHandle {
        tid: tid,
        state: THREAD_RUNNING,
        stack_base: stack_base,
        stack_size: stack_size,
        allocator: allocator
    }

    return Result.Ok(handle)
}

// ============================================================================
// Thread Control
// ============================================================================

// Exit current thread with given status
thread_exit = (status: i32) void {
    compiler.syscall1(SYS_EXIT, status)
}

// Wait for thread to finish
// Note: Uses futex on TID (CLONE_CHILD_CLEARTID sets up kernel to wake on exit)
ThreadHandle.join = (self: MutPtr<ThreadHandle>) Result<(), i32> {
    self.val.state == THREAD_JOINED ? {
        return Result.Err(-22)  // EINVAL - already joined
    }

    // Wait for thread to exit using futex on TID
    // The kernel clears the TID and wakes futex when thread exits
    tid_ptr = &self.val.tid.ref()
    tid = compiler.atomic_load(&self.val.tid.ref() as Ptr<u64>) as i32

    tid != 0 ? {
        futex_wait(tid_ptr, tid)
    }

    // Clean up
    self.val.allocator.deallocate(self.val.stack_base, self.val.stack_size)
    self.val.state = THREAD_JOINED

    return Result.Ok(())
}

// Check if thread has finished (non-blocking)
ThreadHandle.is_finished = (self: Ptr<ThreadHandle>) bool {
    tid = compiler.atomic_load(&self.val.tid.ref() as Ptr<u64>) as i32
    return tid == 0
}

// Get the thread ID
ThreadHandle.id = (self: Ptr<ThreadHandle>) i32 {
    return self.val.tid
}

// ============================================================================
// Thread Yield
// ============================================================================

SYS_SCHED_YIELD = 24

// Yield execution to other threads
thread_yield = () void {
    compiler.syscall0(SYS_SCHED_YIELD)
}

// ============================================================================
// Thread-Local Key (TLS-like mechanism)
// ============================================================================
// Note: Full TLS requires CLONE_SETTLS and arch-specific setup.
// This provides a simpler key-value store per thread.

// For now, use a simple global approach with thread ID as key
// A proper implementation would use the FS segment register on x86-64
