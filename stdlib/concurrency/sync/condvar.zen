// Zen Standard Library: CondVar (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Condition variable for thread synchronization

{ compiler } = @std
{ Mutex } = @std.concurrency.sync.mutex
{ futex_wait, futex_wake_one, futex_wake_all } = @std.concurrency.primitives.futex

// ============================================================================
// Syscall for timeout support
// ============================================================================

SYS_FUTEX = 202
FUTEX_WAIT = 0
FUTEX_WAKE = 1
FUTEX_WAIT_PRIVATE = 128
FUTEX_WAKE_PRIVATE = 129

// ============================================================================
// CondVar - Condition Variable
// ============================================================================
// Allows threads to wait for a condition to become true.
// Must be used with a Mutex to protect the condition.

CondVar: {
    seq: i32  // Sequence number for spurious wakeup detection
}

CondVar.new = () CondVar {
    return CondVar { seq: 0 }
}

// Wait for the condition to be signaled
// The mutex must be held when calling wait.
// The mutex is released while waiting and reacquired before returning.
//
// Usage:
//   mutex.lock()
//   condition == false ? { condvar.wait(&mutex) }
//   // condition is now true (or spurious wakeup - recheck condition)
//   mutex.unlock()
//
CondVar.wait = (self: MutPtr<CondVar>, mutex: MutPtr<Mutex>) void {
    // Capture current sequence number
    seq = compiler.atomic_load(&self.val.seq.ref() as Ptr<u64>) as i32

    // Release the mutex before sleeping
    mutex.unlock()

    // Wait for signal (seq to change)
    futex_wait(&self.val.seq.ref(), seq)

    // Reacquire the mutex before returning
    mutex.lock()
}

// Wait with timeout (nanoseconds)
// Returns true if signaled, false if timed out
CondVar.wait_timeout = (self: MutPtr<CondVar>, mutex: MutPtr<Mutex>, timeout_ns: i64) bool {
    seq = compiler.atomic_load(&self.val.seq.ref() as Ptr<u64>) as i32

    mutex.unlock()

    // Build timespec on stack
    sec = timeout_ns / 1000000000
    nsec = timeout_ns % 1000000000

    // Create timespec struct: {tv_sec: i64, tv_nsec: i64}
    timespec_ptr = compiler.raw_allocate(16)
    compiler.store<i64>(timespec_ptr, sec)
    compiler.store<i64>(compiler.gep(timespec_ptr, 8), nsec)

    // futex_wait with timeout
    result = compiler.syscall4(
        SYS_FUTEX,
        compiler.ptr_to_int(&self.val.seq.ref()),
        FUTEX_WAIT_PRIVATE,
        seq,
        compiler.ptr_to_int(timespec_ptr)
    )

    compiler.raw_deallocate(timespec_ptr, 16)

    mutex.lock()

    // ETIMEDOUT = -110
    return result != -110
}

// Signal one waiting thread
CondVar.signal = (self: MutPtr<CondVar>) void {
    // Increment sequence number (atomic)
    done = false
    done == false ? {
        old_seq = compiler.atomic_load(&self.val.seq.ref() as Ptr<u64>) as i32
        new_seq = old_seq + 1
        result = compiler.atomic_cas(&self.val.seq.ref() as Ptr<u64>, old_seq, new_seq)
        result == old_seq ? { done = true }
    }

    // Wake one waiter
    futex_wake_one(&self.val.seq.ref())
}

// Signal all waiting threads
CondVar.broadcast = (self: MutPtr<CondVar>) void {
    // Increment sequence number
    done = false
    done == false ? {
        old_seq = compiler.atomic_load(&self.val.seq.ref() as Ptr<u64>) as i32
        new_seq = old_seq + 1
        result = compiler.atomic_cas(&self.val.seq.ref() as Ptr<u64>, old_seq, new_seq)
        result == old_seq ? { done = true }
    }

    // Wake all waiters
    futex_wake_all(&self.val.seq.ref())
}

// ============================================================================
// Convenience: Wait with predicate loop
// ============================================================================
// Note: Without closures, users must manually loop:
//
//   mutex.lock()
//   !ready ? { condvar.wait(&mutex) }  // Loop until ready
//   mutex.unlock()
//
// A proper wait_while would require closures:
//   condvar.wait_while(&mutex, || !ready)
