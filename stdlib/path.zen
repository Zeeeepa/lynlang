// Path manipulation utilities for Zen
// Provides cross-platform path handling and manipulation

core := @std
build := @std
string := build.import("string")
{ Vec, DynVec } = @std
result := build.import("result")
fs := build.import("fs")

// Path separator for the current platform
PATH_SEPARATOR := "/" // Unix-like systems
PATH_LIST_SEPARATOR := ":" // Unix-like systems

// Common path operations result type
PathResult<T> := result.Result<T, string>

// Check if a path is absolute
is_absolute = (path: string) bool   {
    string.is_empty(path) ? {
        false
    } : {
        string.starts_with(path, "/")
    }
}

// Check if a path is relative
is_relative = (path: string) bool   {
    return !is_absolute(path)
}

// Join multiple path components
join = (components: ...string) string   {
    components.len() == 0 ? {
        return ""
    }
    
    result := ""
    i := 0
    loop (i < components.len()) {
        component := components[i]
        string.is_empty(component) ? {
            i += 1
            continue
        }
        
        i == 0 ? {
            result = component
        } : {
            // Handle trailing separator in result
            string.ends_with(result, PATH_SEPARATOR) ? {
                result = result
            } : {
                result = string.concat(result, PATH_SEPARATOR)
            }
            
            // Handle leading separator in component
            string.starts_with(component, PATH_SEPARATOR) ? {
                result = string.concat(result, string.substring(component, 1, component.len()))
            } : {
                result = string.concat(result, component)
            }
        }
        i += 1
    }
    
    return result
}

// Get the directory name from a path
dirname = (path: string) string   {
    string.is_empty(path) ? {
        return "."
    }
    
    // Find the last separator
    last_sep := string.last_index_of(path, PATH_SEPARATOR)
    last_sep == -1 ? {
        return "."
    }
    
    last_sep == 0 ? {
        return PATH_SEPARATOR
    }
    
    return string.substring(path, 0, last_sep)
}

// Get the base name from a path
basename = (path: string) string   {
    string.is_empty(path) ? {
        return ""
    }
    
    // Remove trailing separators
    clean_path := path
    loop (string.ends_with(clean_path, PATH_SEPARATOR) && clean_path.len() > 1) {
        clean_path = string.substring(clean_path, 0, clean_path.len() - 1)
    }
    
    // Find the last separator
    last_sep := string.last_index_of(clean_path, PATH_SEPARATOR)
    last_sep == -1 ? {
        return clean_path
    }
    
    return string.substring(clean_path, last_sep + 1, clean_path.len())
}

// Get the file extension
extension = (path: string) string   {
    base := basename(path)
    string.is_empty(base) ? {
        return ""
    }
    
    // Find the last dot in the basename
    last_dot := string.last_index_of(base, ".")
    (last_dot == -1 || last_dot == 0) ? {
        return ""
    }
    
    return string.substring(base, last_dot, base.len())
}

// Get the file name without extension
stem = (path: string) string   {
    base := basename(path)
    string.is_empty(base) ? {
        return ""
    }
    
    ext := extension(path)
    string.is_empty(ext) ? {
        return base
    }
    
    return string.substring(base, 0, base.len() - ext.len())
}

// Split a path into its components
split = (path: string) DynVec<string>   {
    string.is_empty(path) ? {
        return DynVec.new<string>()
    }
    
    components := DynVec.new<string>()
    
    // Handle absolute paths
    is_absolute(path) ? {
        components.push(PATH_SEPARATOR)
        path = string.substring(path, 1, path.len())
    }
    
    // Split by separator
    parts := string.split(path, PATH_SEPARATOR)
    i := 0
    loop (i < parts.len()) {
        part := parts[i]
        !string.is_empty(part) ? {
            components.push(part)
        }
        i += 1
    }
    
    return components
}

// Normalize a path (remove . and .. components)
normalize = (path: string) string   {
    string.is_empty(path) ? {
        return "."
    }
    
    components := split(path)
    normalized := DynVec.new<string>()
    
    i := 0
    loop (i < components.len()) {
        component := components[i]
        component == "." ? {
            // Skip current directory references
            i += 1
            continue
        } : component == ".." ? {
            // Go up one directory if possible
            (normalized.len() > 0 && normalized[normalized.len() - 1] != "..") ? {
                normalized.pop()
            } : !is_absolute(path) ? {
                normalized.push("..")
            }
        } : {
            normalized.push(component)
        }
        i += 1
    }
    
    normalized.len() == 0 ? {
        return is_absolute(path) ? PATH_SEPARATOR : "."
    }
    
    result := ""
    i := 0
    loop (i < normalized.len()) {
        component := normalized[i]
        i == 0 ? {
            result = component
        } : component == PATH_SEPARATOR ? {
            // Don't double up separators
            i += 1
            continue
        } : {
            result = join(result, component)
        }
        i += 1
    }
    
    return result
}

// Make a path relative to a base path
relative = (base: string, target: string) PathResult<string>   {
    // Both paths must be absolute or both relative
    is_absolute(base) != is_absolute(target) ? {
        return result.err("Cannot compute relative path between absolute and relative paths")
    }
    
    base_parts := split(normalize(base))
    target_parts := split(normalize(target))
    
    // Find common prefix
    common_len := 0
    min_len := base_parts.len() < target_parts.len() ? base_parts.len() : target_parts.len()
    
    i := 0
    loop (i < min_len) {
        base_parts[i] == target_parts[i] ? {
            common_len = i + 1
        } : {
            break
        }
        i += 1
    }
    
    // Build relative path
    relative_parts := DynVec.new<string>()
    
    // Add .. for each remaining base component
    i := common_len
    loop (i < base_parts.len()) {
        relative_parts.push("..")
        i += 1
    }
    
    // Add remaining target components
    i := common_len
    loop (i < target_parts.len()) {
        relative_parts.push(target_parts[i])
        i += 1
    }
    
    relative_parts.len() == 0 ? {
        return result.ok(".")
    }
    
    result_path := ""
    i := 0
    loop (i < relative_parts.len()) {
        part := relative_parts[i]
        i == 0 ? {
            result_path = part
        } : {
            result_path = join(result_path, part)
        }
        i += 1
    }
    
    return result.ok(result_path)
}

// Resolve a path to an absolute path
resolve = (path: string) PathResult<string>   {
    is_absolute(path) ? {
        return result.ok(normalize(path))
    }
    
    // Get current working directory
    cwd := fs.get_cwd()?
    resolved := join(cwd, path)
    return result.ok(normalize(resolved))
}

// Check if a path exists
exists = (path: string) bool   {
    return fs.exists(path)
}

// Check if a path is a directory
is_dir = (path: string) bool   {
    stats := fs.stat(path)
    return stats.is_ok() && stats.unwrap().is_directory
}

// Check if a path is a file
is_file = (path: string) bool   {
    stats := fs.stat(path)
    return stats.is_ok() && stats.unwrap().is_file
}

// Get the parent directory
parent = (path: string) string   {
    return dirname(path)
}

// Create all parent directories if they don't exist
ensure_parent = (path: string) PathResult<void>   {
    parent_dir := dirname(path)
    (parent_dir != "." && !exists(parent_dir)) ? {
        fs.mkdir_all(parent_dir)?
    }
    return result.ok(void)
}

// Walk a directory tree
walk = (root: string, callback: fn(path: string, is_dir: bool) bool) PathResult<void> {
    !exists(root) ? {
        return result.err("Path does not exist: " + root)
    }
    
    !is_dir(root) ? {
        callback(root, false)
        return result.ok(void)
    }
    
    walk_recursive(root, callback)?
    return result.ok(void)
}

// Internal recursive walker
walk_recursive = (dir: string, callback: fn(path: string, is_dir: bool) bool) PathResult<void> {
    entries := fs.readdir(dir)?
    
    i := 0
    loop (i < entries.len()) {
        entry := entries[i]
        full_path := join(dir, entry.name)
        should_continue := callback(full_path, entry.is_directory)
        
        !should_continue ? {
            return result.ok(void)
        }
        
        entry.is_directory ? {
            walk_recursive(full_path, callback)?
        }
        i += 1
    }
    
    return result.ok(void)
}

// Common file path patterns
is_hidden = (path: string) bool   {
    base := basename(path)
    return string.starts_with(base, ".")
}

// Check if path matches a glob pattern (simple implementation)
matches = (path: string, pattern: string) bool   {
    // Convert glob pattern to simple regex-like matching
    // * matches any characters except /
    // ** matches any characters including /
    // ? matches single character
    
    pattern == "*" ? {
        return true
    }
    
    pattern == path ? {
        return true
    }
    
    // Simple glob matching (can be enhanced)
    string.contains(pattern, "*") ? {
        parts := string.split(pattern, "*")
        current_pos := 0
        
        i := 0
        loop (i < parts.len()) {
            part := parts[i]
            string.is_empty(part) ? {
                i += 1
                continue
            }
            
            index := string.index_of_from(path, part, current_pos)
            index == -1 ? {
                return false
            }
            
            (i == 0 && index != 0) ? {
                return false
            }
            
            current_pos = index + part.len()
            i += 1
        }
        
        return true
    } : {
        false
    }
}

// Path builder for fluent API
PathBuilder := {
    components: DynVec<string>
}

// Create a new path builder
builder = () PathBuilder   {
    return PathBuilder{
        components: DynVec.new<string>()
    }
}

// Add a component to the path
PathBuilder.add = (self: MutPtr<PathBuilder>, component: string) MutPtr<PathBuilder> {
    self.components.push(component)
    return self
}

// Build the final path
PathBuilder.build = (self: &PathBuilder) string {
    self.components.len() == 0 ? {
        return ""
    }
    
    result := ""
    i := 0
    loop (i < self.components.len()) {
        component := self.components[i]
        i == 0 ? {
            result = component
        } : {
            result = join(result, component)
        }
        i += 1
    }
    
    return result
}