// Zen Standard Library: String Type
// Dynamic growable UTF-8 string with allocator support

{ compiler } = @std
{ Ptr } = @std.core
{ Allocator } = @std.memory.allocator

// String - dynamic growable text buffer
String: {
    data: Ptr<u8>,
    len: usize,
    capacity: usize,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create a new empty string with allocator
String.new = (allocator: Allocator) String {
    initial_capacity = 16
    raw_ptr = allocator.allocate(initial_capacity)
    data = Ptr<u8>.from_addr(raw_ptr)

    return String {
        data: data,
        len: 0,
        capacity: initial_capacity,
        allocator: allocator
    }
}

// ============================================================================
// Properties
// ============================================================================

// Get string length
String.len = (self: String) usize {
    return self.len
}

// Get string capacity
String.capacity = (self: String) usize {
    return self.capacity
}

// Check if empty
String.is_empty = (self: String) bool {
    return self.len == 0
}

// ============================================================================
// Operations
// ============================================================================

// Push a single byte (auto-grow)
String.push = (self: MutPtr<String>, byte: u8) void {
    // Grow if needed
    self.val.len >= self.val.capacity ?
    | true {
        new_capacity = self.val.capacity * 2
        old_addr = self.val.data.addr()
        old_size = self.val.capacity
        new_addr = self.val.allocator.reallocate(old_addr, old_size, new_capacity)
        self.val.data = Ptr<u8>.from_addr(new_addr)
        self.val.capacity = new_capacity
    }
    | false { }

    // Write byte at end
    raw_addr = self.val.data.addr()
    offset_i64 = self.val.len
    target = compiler.gep(raw_addr, offset_i64)
    compiler.store<u8>(target, byte)

    self.val.len = self.val.len + 1
}

// Get byte at index
String.at = (self: String, index: usize) u8 {
    index >= self.len ?
    | true { return 0 }
    | false {
        raw_addr = self.data.addr()
        offset_i64 = index
        addr = compiler.gep(raw_addr, offset_i64)
        return compiler.load<u8>(addr)
    }
}

// Clear string (keep capacity)
String.clear = (self: MutPtr<String>) void {
    self.val.len = 0
}

// Reserve additional capacity
String.reserve = (self: MutPtr<String>, additional: usize) void {
    needed = self.val.len + additional
    needed > self.val.capacity ?
    | true {
        new_capacity = needed * 2
        old_addr = self.val.data.addr()
        old_size = self.val.capacity
        new_addr = self.val.allocator.reallocate(old_addr, old_size, new_capacity)
        self.val.data = Ptr<u8>.from_addr(new_addr)
        self.val.capacity = new_capacity
    }
    | false { }
}

// ============================================================================
// Memory Management
// ============================================================================

// Deallocate string
String.free = (self: MutPtr<String>) void {
    raw_addr = self.val.data.addr()
    self.val.allocator.deallocate(raw_addr, self.val.capacity)
    self.val.data = Ptr<u8>.none()
    self.val.len = 0
    self.val.capacity = 0
}

// Clone string (requires allocator for new allocation)
String.clone = (self: String, allocator: Allocator) String {
    new_capacity = self.capacity
    raw_ptr = allocator.allocate(new_capacity)
    new_data = Ptr<u8>.from_addr(raw_ptr)

    result = String {
        data: new_data,
        len: self.len,
        capacity: new_capacity,
        allocator: allocator
    }

    // Copy bytes directly
    i = 0
    loop(() {
        i >= self.len ?
        | true { break }
        | false {
            // Read from source
            src_addr = self.data.addr()
            src_offset_i64 = i
            src_ptr = compiler.gep(src_addr, src_offset_i64)
            byte = compiler.load<u8>(src_ptr)

            // Write to destination
            dst_addr = result.data.addr()
            dst_offset_i64 = i
            dst_ptr = compiler.gep(dst_addr, dst_offset_i64)
            compiler.store<u8>(dst_ptr, byte)

            i = i + 1
        }
    })

    return result
}
