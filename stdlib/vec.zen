// Zen Standard Library: Vector Type
// Generic growable array with allocator support

{ compiler } = @std
{ Ptr, Option } = @std.core
{ Allocator } = @std.memory.allocator

// Vec<T> - Growable Array (Owned, Must Be Freed)
Vec<T>: {
    data: Ptr<T>,
    len: usize,
    capacity: usize,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create new empty vector
Vec<T>.new = (allocator: Allocator) Vec<T> {
    return Vec<T> {
        data: Ptr<T>.none(),
        len: 0,
        capacity: 0,
        allocator: allocator
    }
}

// Create vector with initial capacity
Vec<T>.with_capacity = (allocator: Allocator, initial_capacity: usize) Vec<T> {
    initial_capacity == 0 ?
        | true { return Vec<T>.new(allocator) }
        | false {
            item_size = compiler.sizeof(T)
            total_size = initial_capacity * item_size
            raw_ptr = allocator.allocate(total_size)
            data = Ptr<T>.from_addr(raw_ptr)
            
            return Vec<T> {
                data: data,
                len: 0,
                capacity: initial_capacity,
                allocator: allocator
            }
        }
}

// ============================================================================
// Properties
// ============================================================================

// Get current length
Vec<T>.len = (self: Vec<T>) usize {
    return self.len
}

// Get allocated capacity
Vec<T>.capacity = (self: Vec<T>) usize {
    return self.capacity
}

// Check if empty
Vec<T>.is_empty = (self: Vec<T>) bool {
    return self.len == 0
}

// ============================================================================
// Read Operations
// ============================================================================

// Get element at index (returns Option<T>)
Vec<T>.get = (self: Vec<T>, index: usize) Option<T> {
    index >= self.len ?
        | true { return Option.None }
        | false {
            // Get pointer to element (at handles offset calculation)
            elem_ptr = self.data.at(index)
            elem_ptr ?
                | Some(_) {
                    // addr is already at the correct offset, load directly
                    addr = elem_ptr.addr()
                    value = compiler.load<T>(addr)
                    return Option.Some(value)
                }
                | None { return Option.None }
        }
}

// Check if index is valid
Vec<T>.is_valid_index = (self: Vec<T>, index: usize) bool {
    return index < self.len
}

// ============================================================================
// Write Operations (Mutable)
// ============================================================================

// Push element to end (auto-grows)
Vec<T>.push = (self: *Vec<T>, elem: T) void {
    // Initial allocation if empty
    self.len == 0 && self.capacity == 0 ?
        | true {
            self.capacity = 1
            item_size = compiler.sizeof(T)
            raw_ptr = self.allocator.allocate(item_size)
            self.data = Ptr<T>.from_addr(raw_ptr)
        }
        | false { }
    
    // Grow capacity if full
    self.len >= self.capacity ?
        | true {
            new_capacity = self.capacity * 2
            item_size = compiler.sizeof(T)
            old_size = self.capacity * item_size
            new_size = new_capacity * item_size
            old_addr = self.data.addr()
            new_addr = self.allocator.reallocate(old_addr, old_size, new_size)
            self.data = Ptr<T>.from_addr(new_addr)
            self.capacity = new_capacity
        }
        | false { }
    
    // Write element at end
    elem_ptr = self.data.at(self.len)
    elem_ptr ?
        | Some(_) {
            // addr is already at the correct offset, store directly
            addr = elem_ptr.addr()
            compiler.store<T>(addr, elem)
        }
        | None { }
    
    self.len = self.len + 1
}

// Pop element from end
Vec<T>.pop = (self: *Vec<T>) void {
    self.len > 0 ?
        | true { self.len = self.len - 1 }
        | false { }
}

// Clear without deallocating
Vec<T>.clear = (self: *Vec<T>) void {
    self.len = 0
}

// ============================================================================
// Memory Management
// ============================================================================

// Reserve additional capacity
Vec<T>.reserve = (self: *Vec<T>, additional: usize) void {
    needed = self.len + additional
    needed > self.capacity ?
        | true {
            new_capacity = needed * 2
            item_size = compiler.sizeof(T)
            old_size = self.capacity * item_size
            new_size = new_capacity * item_size
            old_addr = self.data.addr()
            new_addr = self.allocator.reallocate(old_addr, old_size, new_size)
            self.data = Ptr<T>.from_addr(new_addr)
            self.capacity = new_capacity
        }
        | false { }
}

// Deallocate vector
Vec<T>.free = (self: *Vec<T>) void {
    raw_addr = self.data.addr()
    item_size = compiler.sizeof(T)
    total_size = self.capacity * item_size
    self.allocator.deallocate(raw_addr, total_size)
    
    self.len = 0
    self.capacity = 0
    self.data = Ptr<T>.none()
}
