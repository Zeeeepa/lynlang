// Zen Standard Library: Vector Type
// Generic growable array with allocator support

{ compiler } = @std
{ Ptr } = @std.core.ptr
{ Option } = @std.core.option
{ Allocator } = @std.memory.allocator

// Vec<T> - Growable Array (Owned, Must Be Freed)
Vec<T>: {
    data: Ptr<T>,
    len: usize,
    capacity: usize,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create new empty vector
Vec<T>.new = (allocator: Allocator) Vec<T> {
    return Vec<T> {
        data: Ptr<T>.none(),
        len: 0,
        capacity: 0,
        allocator: allocator
    }
}

// Create vector with initial capacity
Vec<T>.with_capacity = (allocator: Allocator, initial_capacity: usize) Vec<T> {
    initial_capacity == 0 ?
        | true { return Vec<T>.new(allocator) }
        | false {
            item_size = compiler.sizeof<T>()
            total_size = initial_capacity * item_size
            raw_ptr = allocator.allocate(total_size)
            data = Ptr<T>.from_addr(raw_ptr)
            
            return Vec<T> {
                data: data,
                len: 0,
                capacity: initial_capacity,
                allocator: allocator
            }
        }
}

// ============================================================================
// Properties
// ============================================================================

// Get current length
Vec<T>.len = (self: Vec<T>) usize {
    return self.len
}

// Get allocated capacity
Vec<T>.capacity = (self: Vec<T>) usize {
    return self.capacity
}

// Check if empty
Vec<T>.is_empty = (self: Vec<T>) bool {
    return self.len == 0
}

// ============================================================================
// Read Operations
// ============================================================================

// Get element at index (returns Option<T>)
Vec<T>.get = (self: Vec<T>, index: usize) Option<T> {
    index >= self.len ?
        | true { return Option.None }
        | false {
            // Get pointer to element (at handles offset calculation)
            elem_ptr = self.data.at(index)
            elem_ptr ?
                | Some(addr_i64) {
                    // Convert i64 address to raw pointer and load
                    addr = compiler.int_to_ptr(addr_i64)
                    value = compiler.load<T>(addr)
                    return Option.Some(value)
                }
                | None { return Option.None }
        }
}

// Check if index is valid
Vec<T>.is_valid_index = (self: Vec<T>, index: usize) bool {
    return index < self.len
}

// ============================================================================
// Write Operations (Mutable)
// ============================================================================

// Push element to end (auto-grows)
Vec<T>.push = (self: MutPtr<Vec<T>>, elem: T) void {
    item_size = compiler.sizeof<T>()

    // Initial allocation if empty
    self.val.len == 0 && self.val.capacity == 0 ?
        | true {
            self.val.capacity = 1
            raw_ptr = self.val.allocator.allocate(item_size)
            self.val.data = Ptr<T>.from_addr(raw_ptr)
        }
        | false { }

    // Grow capacity if full
    self.val.len >= self.val.capacity ?
        | true {
            new_capacity = self.val.capacity * 2
            old_size = self.val.capacity * item_size
            new_size = new_capacity * item_size
            old_addr = self.val.data.addr()
            new_addr = self.val.allocator.reallocate(old_addr, old_size, new_size)
            self.val.data = Ptr<T>.from_addr(new_addr)
            self.val.capacity = new_capacity
        }
        | false { }

    // Write element at end
    elem_ptr = self.val.data.at(self.val.len)
    elem_ptr ?
        | Some(addr_i64) {
            elem_addr = compiler.int_to_ptr(addr_i64)
            compiler.store<T>(elem_addr, elem)
        }
        | None { }

    self.val.len = self.val.len + 1
}

// Pop element from end
Vec<T>.pop = (self: MutPtr<Vec<T>>) void {
    self.val.len > 0 ?
        | true { self.val.len = self.val.len - 1 }
        | false { }
}

// Clear without deallocating
Vec<T>.clear = (self: MutPtr<Vec<T>>) void {
    self.val.len = 0
}

// ============================================================================
// Memory Management
// ============================================================================

// Reserve additional capacity
Vec<T>.reserve = (self: MutPtr<Vec<T>>, additional: usize) void {
    needed = self.val.len + additional
    needed > self.val.capacity ?
        | true {
            new_capacity = needed * 2
            item_size = compiler.sizeof<T>()
            old_size = self.val.capacity * item_size
            new_size = new_capacity * item_size
            old_addr = self.val.data.addr()
            new_addr = self.val.allocator.reallocate(old_addr, old_size, new_size)
            self.val.data = Ptr<T>.from_addr(new_addr)
            self.val.capacity = new_capacity
        }
        | false { }
}

// Deallocate vector
Vec<T>.free = (self: MutPtr<Vec<T>>) void {
    raw_addr = self.val.data.addr()
    item_size = compiler.sizeof<T>()
    total_size = self.val.capacity * item_size
    self.val.allocator.deallocate(raw_addr, total_size)

    self.val.len = 0
    self.val.capacity = 0
    self.val.data = Ptr<T>.none()
}

// ============================================================================
// Iterator Support
// ============================================================================

// VecIterator - Iterates over Vec elements
VecIterator<T>: {
    data: Ptr<T>,
    index: usize,
    len: usize
}

// Create an iterator over the vector
Vec<T>.iter = (self: Vec<T>) VecIterator<T> {
    return VecIterator<T> {
        data: self.data,
        index: 0,
        len: self.len
    }
}

// Get next element from iterator
VecIterator<T>.next = (self: MutPtr<VecIterator<T>>) Option<T> {
    self.val.index < self.val.len ?
        | true {
            // Get element at current index
            elem_ptr = self.val.data.at(self.val.index)
            self.val.index = self.val.index + 1
            elem_ptr ?
                | Some(addr_i64) {
                    addr = compiler.int_to_ptr(addr_i64)
                    value = compiler.load<T>(addr)
                    return Option.Some(value)
                }
                | None { return Option.None }
        }
        | false { return Option.None }
}

// Check if iterator has more elements
VecIterator<T>.has_next = (self: VecIterator<T>) bool {
    return self.index < self.len
}
