// Zen Standard Library: Vector Types
// - Vec<T, N>: Fixed-size stack-allocated vector
// - DynVec<T>: Dynamic heap-allocated vector with allocator

core := @std
{ Allocator } = @std

// Fixed-size vector structure - stack allocated
Vec<T, N>: {
    data: [T; N]         // Fixed-size array on stack
    len: usize           // Current number of elements (â‰¤ N)
}

// Create a new empty fixed-size vector
Vec<T, N>.new = () Vec<T, N> {
    return Vec<T, N>{
        data: [core.default<T>(); N],
        len: 0
    }
}

// Create from an array
Vec<T, N>.from_array = (arr: [T; N]) Vec<T, N> {
    return Vec<T, N>{
        data: arr,
        len: N
    }
}

// Push element to the vector
Vec<T, N>.push = (self: Ptr<Vec<T, N>>, value: T) core.Result<void, core.Error> {
    self.len >= N ? 
        | true => core.Result:Err(core.Error:CapacityExceeded(self.len, N))
        | false => {
            self.data[self.len] = value
            self.len = self.len + 1
            core.Result:Ok({})
        }
}

// Pop element from the vector
Vec<T, N>.pop = (self: Ptr<Vec<T, N>>) core.Option<T> {
    self.len == 0 ? 
        | true => core.Option:None
        | false => {
            self.len = self.len - 1
            core.Option:Some(self.data[self.len])
        }
}

// Get element at index (safe)
Vec<T, N>.get = (self: Ptr<Vec<T, N>>, index: usize) core.Option<T> {
    index >= self.len ? 
        | true => core.Option:None
        | false => core.Option:Some(self.data[index])
}

// Get element at index (unchecked, returns Result for errors)
Vec<T, N>.get_unchecked = (self: Ptr<Vec<T, N>>, index: usize) core.Result<T, core.Error> {
    index >= self.len ? 
        | true => core.Result:Err(core.Error:IndexOutOfBounds(index, self.len))
        | false => core.Result:Ok(self.data[index])
}

// Set element at index (safe)
Vec<T, N>.set = (self: Ptr<Vec<T, N>>, index: usize, value: T) bool {
    index >= self.len ? 
        | true => false
        | false => {
            self.data[index] = value
            true
        }
}

// Set element at index (unchecked, returns Result for errors)
Vec<T, N>.set_unchecked = (self: Ptr<Vec<T, N>>, index: usize, value: T) core.Result<void, core.Error> {
    index >= self.len ? 
        | true => core.Result:Err(core.Error:IndexOutOfBounds(index, self.len))
        | false => {
            self.data[index] = value
            core.Result:Ok({})
        }
}

// Get vector length
Vec<T, N>.len = (self: Ptr<Vec<T, N>>) usize {
    return self.len
}

// Get vector capacity (always N)
Vec<T, N>.capacity = (self: Ptr<Vec<T, N>>) usize {
    return N
}

// Check if vector is empty
Vec<T, N>.is_empty = (self: Ptr<Vec<T, N>>) bool {
    return self.len == 0
}

// Check if vector is full
Vec<T, N>.is_full = (self: Ptr<Vec<T, N>>) bool {
    return self.len == N
}

// Clear the vector (remove all elements)
Vec<T, N>.clear = (self: Ptr<Vec<T, N>>) void {
    self.len = 0
}

// Insert element at position
Vec<T, N>.insert = (self: Ptr<Vec<T, N>>, index: usize, value: T) core.Result<void, core.Error> {
    index > self.len ?
        | true => core.Result:Err(core.Error:IndexOutOfBounds(index, self.len))
        | false => {
            self.len >= N ?
                | true => core.Result:Err(core.Error:CapacityExceeded(self.len + 1, N))
                | false => {
                    // Shift elements to the right
                    i ::= self.len
                    loop {
                        i == index ? { break }
                        self.data[i] = self.data[i - 1]
                        i = i - 1
                    }
                    
                    self.data[index] = value
                    self.len = self.len + 1
                    core.Result:Ok({})
                }
        }
}

// Remove element at position
Vec<T, N>.remove = (self: Ptr<Vec<T, N>>, index: usize) core.Result<T, core.Error> {
    index >= self.len ?
        | true => core.Result:Err(core.Error:IndexOutOfBounds(index, self.len))
        | false => {
            value := self.data[index]
            
            // Shift elements to the left
            i ::= index
            loop {
                i >= self.len - 1 ? { break }
                self.data[i] = self.data[i + 1]
                i = i + 1
            }
            
            self.len = self.len - 1
            core.Result:Ok(value)
        }
}

// Convert to dynamic vector
Vec<T, N>.to_dynamic = (self: Ptr<Vec<T, N>>) DynVec<T> {
    dyn_vec := DynVec<T>.with_capacity(self.len).unwrap_or(DynVec<T>.new())
    
    i ::= 0
    loop {
        i >= self.len ? { break }
        dyn_vec.push(self.data[i])
        i = i + 1
    }
    
    return dyn_vec
}

// Iterator support
Vec<T, N>.iter = (self: Ptr<Vec<T, N>>) VecIterator<T, N> {
    return VecIterator<T, N>{
        vec: self,
        index: 0
    }
}

VecIterator<T, N>: {
    vec: Ptr<Vec<T, N>>
    index: usize
}

VecIterator<T, N>.next = (self: Ptr<VecIterator<T, N>>) core.Option<T> {
    self.index >= self.vec.len ?
        | true => core.Option:None
        | false => {
            value := self.vec.data[self.index]
            self.index = self.index + 1
            core.Option:Some(value)
        }
}

// Functional operations
Vec<T, N>.map<U> = (self: Ptr<Vec<T, N>>, f: (T) U) Vec<U, N> {
    result := Vec<U, N>.new()
    
    i ::= 0
    loop {
        i >= self.len ? { break }
        result.push(f(self.data[i]))
        i = i + 1
    }
    
    return result
}

Vec<T, N>.filter = (self: Ptr<Vec<T, N>>, predicate: (T) bool) DynVec<T> {
    result := DynVec<T>.new()
    
    i ::= 0
    loop {
        i >= self.len ? { break }
        predicate(self.data[i]) ?
            | true => result.push(self.data[i])
        i = i + 1
    }
    
    return result
}

Vec<T, N>.fold<U> = (self: Ptr<Vec<T, N>>, initial: U, f: (U, T) U) U {
    acc ::= initial
    
    i ::= 0
    loop {
        i >= self.len ? { break }
        acc = f(acc, self.data[i])
        i = i + 1
    }
    
    return acc
}

// Dynamic vector structure - heap allocated with allocator support
DynVec<T>: {
    data: MutPtr<T>
    len: usize
    capacity: usize
    allocator: Allocator
}

// Initialize with allocator
DynVec<T>.init = (alloc: Allocator) DynVec<T> {
    return DynVec<T> {
        data: alloc.null_ptr(),
        len: 0,
        capacity: 0,
        allocator: alloc,
    }
}

// Initialize with capacity
DynVec<T>.with_capacity = (alloc: Allocator, cap: usize) DynVec<T> {
    data = alloc.allocate<T>(cap)
    return DynVec<T> {
        data: data,
        len: 0,
        capacity: cap,
        allocator: alloc,
    }
}

// Push element
DynVec<T>.push = (vec: MutPtr<DynVec<T>>, value: T) void {
    vec.val.len >= vec.val.capacity ?
        | true { DynVec<T>.grow(vec) }
        | false {}
    
    vec.val.data[vec.val.len] = value
    vec.val.len = vec.val.len + 1
}

// Pop element
DynVec<T>.pop = (vec: MutPtr<DynVec<T>>) core.Option<T> {
    vec.val.len > 0 ?
        | true {
            vec.val.len = vec.val.len - 1
            return core.Option:Some(vec.val.data[vec.val.len])
        }
        | false { return core.Option:None }
}

// Get element at index (safe)
DynVec<T>.get = (vec: Ptr<DynVec<T>>, index: usize) core.Option<T> {
    index < vec.val.len ?
        | true { return core.Option:Some(vec.val.data[index]) }
        | false { return core.Option:None }
}

// Get element at index (unchecked, returns Result for errors)
DynVec<T>.get_unchecked = (vec: Ptr<DynVec<T>>, index: usize) core.Result<T, core.Error> {
    index >= vec.val.len ?
        | true { return core.Result:Err(core.Error:IndexOutOfBounds(index, vec.val.len)) }
        | false { return core.Result:Ok(vec.val.data[index]) }
}

// Set element at index (safe)
DynVec<T>.set = (vec: MutPtr<DynVec<T>>, index: usize, value: T) bool {
    index < vec.val.len ?
        | true { 
            vec.val.data[index] = value
            return true
        }
        | false { return false }
}

// Set element at index (unchecked, returns Result for errors)
DynVec<T>.set_unchecked = (vec: MutPtr<DynVec<T>>, index: usize, value: T) core.Result<void, core.Error> {
    index >= vec.val.len ?
        | true { return core.Result:Err(core.Error:IndexOutOfBounds(index, vec.val.len)) }
        | false { 
            vec.val.data[index] = value
            return core.Result:Ok({})
        }
}

// Loop over elements
DynVec<T>.loop = (vec: Ptr<DynVec<T>>, f: (T) void) void {
    i ::= 0
    loop {
        i >= vec.val.len ?
            | true { break }
            | false {
                f(vec.val.data[i])
                i = i + 1
            }
    }
}

// Loop with index
DynVec<T>.loop_with_index = (vec: Ptr<DynVec<T>>, f: (T, usize) void) void {
    i ::= 0
    loop {
        i >= vec.val.len ?
            | true { break }
            | false {
                f(vec.val.data[i], i)
                i = i + 1
            }
    }
}

// Grow capacity
DynVec<T>.grow = (vec: MutPtr<DynVec<T>>) void {
    new_cap = vec.val.capacity == 0 ?
        | true { 4 }
        | false { vec.val.capacity * 2 }
    
    new_data = vec.val.allocator.allocate<T>(new_cap)
    
    // Copy old data
    i ::= 0
    loop {
        i >= vec.val.len ?
            | true { break }
            | false {
                new_data[i] = vec.val.data[i]
                i = i + 1
            }
    }
    
    // Free old data if it exists
    vec.val.capacity > 0 ?
        | true { vec.val.allocator.free(vec.val.data) }
        | false {}
    
    vec.val.data = new_data
    vec.val.capacity = new_cap
}

// Clean up
DynVec<T>.deinit = (vec: MutPtr<DynVec<T>>) void {
    vec.val.capacity > 0 ?
        | true { vec.val.allocator.free(vec.val.data) }
        | false {}
    
    vec.val.data = vec.val.allocator.null_ptr()
    vec.val.len = 0
    vec.val.capacity = 0
}

// Length
DynVec<T>.len = (vec: Ptr<DynVec<T>>) usize {
    return vec.val.len
}

// Is empty
DynVec<T>.is_empty = (vec: Ptr<DynVec<T>>) bool {
    return vec.val.len == 0
}

// Clear all elements
DynVec<T>.clear = (vec: MutPtr<DynVec<T>>) void {
    vec.val.len = 0
}

// Export both types
module.exports = { Vec, DynVec, VecIterator }
