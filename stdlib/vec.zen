// Zen Standard Library: Vector Type
// Generic growable array

{ compiler } = @std

// Vec<T> - Growable Array (Owned, Must Be Freed)
Vec<T>: {
    data: *u8,
    len: usize,
    capacity: usize
}

// ============================================================================
// Constructors
// ============================================================================

// Create new empty vector
vec_new<T> = () Vec<T> {
    return Vec<T> {
        data: (0 as *u8),
        len: 0,
        capacity: 0
    }
}

// Create vector with initial capacity
vec_with_capacity<T> = (initial_capacity: usize) Vec<T> {
    if initial_capacity == 0 {
        return vec_new()
    }
    
    item_size = compiler.sizeof(T)
    total_size = initial_capacity * item_size
    data = compiler.raw_allocate(total_size)
    
    return Vec<T> {
        data: data,
        len: 0,
        capacity: initial_capacity
    }
}

// ============================================================================
// Properties
// ============================================================================

// Get current length
vec_len<T> = (v: Vec<T>) usize {
    return v.len
}

// Get allocated capacity
vec_capacity<T> = (v: Vec<T>) usize {
    return v.capacity
}

// Check if empty
vec_is_empty<T> = (v: Vec<T>) bool {
    return v.len == 0
}

// ============================================================================
// Read Operations
// ============================================================================

// Get element address at index (unsafe)
vec_get_addr<T> = (v: Vec<T>, index: usize) *u8 {
    if index >= v.len {
        return (0 as *u8)
    }
    
    item_size = compiler.sizeof(T)
    offset = (index * item_size) as i64
    return compiler.gep(v.data, offset)
}

// Check if index is valid
vec_is_valid_index<T> = (v: Vec<T>, index: usize) bool {
    return index < v.len
}

// Get first valid index
vec_first_index = () usize {
    return 0
}

// Get last valid index for non-empty vec
vec_last_index<T> = (v: Vec<T>) usize {
    if v.len == 0 {
        return 0
    }
    return v.len - 1
}

// ============================================================================
// Write Operations (Mutable)
// ============================================================================

// Push element to end (auto-grows)
vec_push<T> = (v: *Vec<T>, elem_size: usize, elem_addr: *u8) void {
    // Initial allocation if empty
    if v.len == 0 && v.capacity == 0 {
        v.capacity = 1
        v.data = compiler.raw_allocate(elem_size)
    }
    
    // Grow capacity if full
    if v.len >= v.capacity {
        new_capacity = v.capacity * 2
        new_size = new_capacity * elem_size
        new_data = compiler.raw_allocate(new_size)
        
        // Copy old data (simple byte copy)
        if v.len > 0 {
            old_size = v.len * elem_size
            i = 0
            loop(() {
                if i >= old_size { break }
                
                offset = i as i64
                src = compiler.gep(v.data, offset)
                dst = compiler.gep(new_data, offset)
                
                // TODO: Copy byte when load/store available
                
                i = i + 1
            })
        }
        
        // Free old data
        if v.data != (0 as *u8) {
            compiler.raw_deallocate(v.data, v.capacity * elem_size)
        }
        
        v.data = new_data
        v.capacity = new_capacity
    }
    
    // Write element at end
    offset = ((v.len) * elem_size) as i64
    target = compiler.gep(v.data, offset)
    
    // Copy element data (simple byte copy)
    i = 0
    loop(() {
        if i >= elem_size { break }
        
        src_offset = i as i64
        dst_offset = i as i64
        src = compiler.gep(elem_addr, src_offset)
        dst = compiler.gep(target, dst_offset)
        
        // TODO: Copy byte when load/store available
        
        i = i + 1
    })
    
    v.len = v.len + 1
}

// Pop element from end
vec_pop<T> = (v: *Vec<T>) void {
    if v.len > 0 {
        v.len = v.len - 1
    }
}

// Clear without deallocating
vec_clear<T> = (v: *Vec<T>) void {
    v.len = 0
}

// ============================================================================
// Memory Management
// ============================================================================

// Reserve additional capacity
vec_reserve<T> = (v: *Vec<T>, additional: usize, elem_size: usize) void {
    needed = v.len + additional
    if needed > v.capacity {
        new_capacity = needed * 2
        new_size = new_capacity * elem_size
        new_data = compiler.raw_allocate(new_size)
        
        // Copy old data
        if v.len > 0 {
            old_size = v.len * elem_size
            i = 0
            loop(() {
                if i >= old_size { break }
                
                offset = i as i64
                src = compiler.gep(v.data, offset)
                dst = compiler.gep(new_data, offset)
                
                // TODO: Copy byte
                
                i = i + 1
            })
        }
        
        // Free old data
        if v.data != (0 as *u8) {
            compiler.raw_deallocate(v.data, v.capacity * elem_size)
        }
        
        v.data = new_data
        v.capacity = new_capacity
    }
}

// Shrink to fit
vec_shrink_to_fit<T> = (v: *Vec<T>, elem_size: usize) void {
    if v.len < v.capacity && v.len > 0 {
        new_size = v.len * elem_size
        new_data = compiler.raw_allocate(new_size)
        
        // Copy data
        i = 0
        loop(() {
            if i >= new_size { break }
            
            offset = i as i64
            src = compiler.gep(v.data, offset)
            dst = compiler.gep(new_data, offset)
            
            // TODO: Copy byte
            
            i = i + 1
        })
        
        // Free old data
        compiler.raw_deallocate(v.data, v.capacity * elem_size)
        
        v.data = new_data
        v.capacity = v.len
    }
}

// Deallocate vector
vec_free<T> = (v: *Vec<T>, elem_size: usize) void {
    if v.data != (0 as *u8) {
        compiler.raw_deallocate(v.data, v.capacity * elem_size)
    }
    
    v.len = 0
    v.capacity = 0
    v.data = (0 as *u8)
}

// ============================================================================
// Deprecated: Static arrays
// ============================================================================

// Array - fixed size (backward compatibility)
Array: {
    data: *u8,
    len: usize
}

// DynVec - old name for growable vector
DynVec: {
    data: *u8,
    len: usize,
    capacity: usize
}
