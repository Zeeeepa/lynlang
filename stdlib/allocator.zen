// Core allocator trait for colorless concurrent/sync execution
// Based on the design in agent/zen-allocator-concurrent.md

{ build } = @std.build
std := build.import("std")

// Continuation type for concurrent execution
Continuation: {
    state: RawPtr<void>
    resume_fn: (RawPtr<void>) void
}

// Base allocator trait - memory + execution context
Allocator: {
    // Memory operations
    alloc: (size: usize) RawPtr<void>
    free: (ptr: RawPtr<void>) void
    realloc: (ptr: RawPtr<void>, old_size: usize, new_size: usize) RawPtr<void>
    
    // Execution mode
    is_concurrent: bool
    
    // Control flow operations (only for concurrent execution)
    suspend: () ?Continuation
    resume: (cont: Continuation) void
    
    // Utility functions
    create: (comptime T: type) *T {
        ptr := self.alloc(@std.sizeOf(T))
        return @std.ptrCast(*T, ptr)
    }
    
    destroy: (ptr: anytype) void {
        self.free(@std.ptrCast(RawPtr<void>, ptr))
    }
    
    alloc_slice: (comptime T: type, n: usize) []T {
        bytes := self.alloc(@std.sizeOf(T) * n)
        return @std.ptrCast([*]T, bytes)[0..n]
    }
    
    free_slice: (slice: anytype) void {
        self.free(@std.ptrCast(RawPtr<void>, slice.ptr))
    }
}

// Sync allocator - traditional blocking execution
SyncAllocator: {
    heap: std.heap.GeneralPurposeAllocator
    
    init: () SyncAllocator {
        return SyncAllocator{
            heap: std.heap.GeneralPurposeAllocator.init()
        }
    }
    
    deinit: (self: *SyncAllocator) void {
        self.heap.deinit()
    }
    
    allocator: () Allocator {
        return Allocator{
            alloc: (size) { self.heap.alloc(size) },
            free: (ptr) { self.heap.free(ptr) },
            realloc: (ptr, old_size, new_size) { self.heap.realloc(ptr, old_size, new_size) },
            is_concurrent: false,
            suspend: () { .None },
            resume: (cont) { @panic("Cannot resume in sync context") }
        }
    }
}

// Runtime for concurrent execution
Runtime: {
    ready_queue: []Continuation
    current_continuation: ?Continuation
    heap: std.heap.GeneralPurposeAllocator
    
    init: () Runtime {
        return Runtime{
            ready_queue: []Continuation{},
            current_continuation: null,
            heap: std.heap.GeneralPurposeAllocator.init()
        }
    }
    
    save_continuation: () ?Continuation {
        // Save current execution state
        // This would be implemented with platform-specific assembly
        return self.current_continuation
    }
    
    schedule: (cont: Continuation) void {
        self.ready_queue.append(cont)
    }
    
    run: () void {
        loop(() {
            (self.ready_queue.len == 0) ?
                | true { break }
                | false { }
            
            cont := self.ready_queue[0]
            self.ready_queue = self.ready_queue[1..]
            self.current_continuation = cont
            cont.resume_fn(cont.state)
        })
    }
    
    wait: () void {
        // Wait for I/O or timer events
        // Platform-specific implementation
    }
}

// Concurrent allocator - non-blocking with continuations
ConcurrentAllocator: {
    runtime: *Runtime
    
    init: (runtime: *Runtime) ConcurrentAllocator {
        return ConcurrentAllocator{
            runtime: runtime
        }
    }
    
    allocator: () Allocator {
        return Allocator{
            alloc: (size) { self.runtime.heap.alloc(size) },
            free: (ptr) { self.runtime.heap.free(ptr) },
            realloc: (ptr, old_size, new_size) { self.runtime.heap.realloc(ptr, old_size, new_size) },
            is_concurrent: true,
            suspend: () { self.runtime.save_continuation() },
            resume: (cont) { self.runtime.schedule(cont) }
        }
    }
}

// Auto allocator - chooses based on context
AutoAllocator: {
    sync_alloc: SyncAllocator
    concurrent_alloc: ?ConcurrentAllocator
    runtime: ?Runtime
    
    init: () AutoAllocator {
        return AutoAllocator{
            sync_alloc: SyncAllocator.init(),
            concurrent_alloc: null,
            runtime: null
        }
    }
    
    init_with_runtime: (runtime: *Runtime) AutoAllocator {
        return AutoAllocator{
            sync_alloc: SyncAllocator.init(),
            concurrent_alloc: ConcurrentAllocator.init(runtime),
            runtime: runtime
        }
    }
    
    allocator: () Allocator {
        // Choose based on whether we have a runtime
        self.runtime ? 
            | null { self.sync_alloc.allocator() }
            | runtime { self.concurrent_alloc.?.allocator() }
    }
}

// Test allocator for debugging
TestAllocator: {
    underlying: SyncAllocator
    allocations: []AllocationInfo
    total_allocated: usize
    total_freed: usize
    
    AllocationInfo: {
        ptr: RawPtr<void>
        size: usize
        freed: bool
    }
    
    init: () TestAllocator {
        return TestAllocator{
            underlying: SyncAllocator.init(),
            allocations: []AllocationInfo{},
            total_allocated: 0,
            total_freed: 0
        }
    }
    
    deinit: (self: *TestAllocator) void {
        self.underlying.deinit()
    }
    
    allocator: () Allocator {
        return Allocator{
            alloc: (size) => {
                ptr := self.underlying.heap.alloc(size)
                self.allocations.append(AllocationInfo{
                    ptr: ptr,
                    size: size,
                    freed: false
                })
                self.total_allocated += size
                return ptr
            },
            free: (ptr) => {
                loop i := 0; i < self.allocations.len; i += 1 {
                    self.allocations[i].ptr == ptr ? {
                        self.allocations[i].freed = true
                        self.total_freed += self.allocations[i].size
                        break
                    } : {}
                }
                self.underlying.heap.free(ptr)
            },
            realloc: (ptr, old_size, new_size) => self.underlying.heap.realloc(ptr, old_size, new_size),
            is_concurrent: false,
            suspend: () => null,
            resume: (cont) => @panic("Cannot resume in test allocator")
        }
    }
    
    bytes_leaked: () usize {
        return self.total_allocated - self.total_freed
    }
    
    check_leaks: () bool {
        loop i := 0; i < self.allocations.len; i += 1 {
            !self.allocations[i].freed ? {
                return true
            } : {}
        }
        return false
    }
}