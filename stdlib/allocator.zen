// Core allocator interface for Zen
// Provides standardized memory allocation interface

{ memory } := @std

// Basic allocator interface
Allocator := {
    // Memory operations
    alloc: (size: usize) Result<RawPtr<void>, core.Error>
    free: (ptr: RawPtr<void>) void
    realloc: (ptr: RawPtr<void>, old_size: usize, new_size: usize) Result<RawPtr<void>, core.Error>
    
    // Utility functions
    create: <T>() Result<Ptr<T>, core.Error> {
        result := self.alloc(@sizeof(T))
        result ?
            | Err(e) { return Err(e) }
            | Ok(ptr) { return Ok(@ptrcast(Ptr<T>, ptr)) }
    }
    
    destroy: <T>(ptr: Ptr<T>) void {
        self.free(@ptrcast(RawPtr<void>, ptr))
    }
    
    alloc_slice: <T>(n: usize) Result<Vec<T>, core.Error> {
        result := self.alloc(@sizeof(T) * n)
        result ?
            | Err(e) { return Err(e) }
            | Ok(ptr) {
                return Ok(Vec<T>{
                    data: @ptrcast(Ptr<T>, ptr),
                    len: n,
                    capacity: n
                })
            }
    }
    
    free_slice: <T>(slice: Vec<T>) void {
        self.free(@ptrcast(RawPtr<void>, slice.data))
    }
}

// Default allocator using system malloc/free
DefaultAllocator := {
    alloc: (size: usize) Result<RawPtr<void>, core.Error> {
        ptr := memory.allocate_raw(size)
        (ptr == null) ? {
            return Err(.OutOfMemory)
        }
        return Ok(ptr)
    }
    
    free: (ptr: RawPtr<void>) void {
        memory.deallocate_raw(ptr)
    }
    
    realloc: (ptr: RawPtr<void>, old_size: usize, new_size: usize) Result<RawPtr<void>, core.Error> {
        new_ptr := memory.reallocate_raw(ptr, new_size)
        (new_ptr == null) ? {
            return Err(.OutOfMemory)
        }
        return Ok(new_ptr)
    }
}

// Tracking allocator for debugging
TrackingAllocator := {
    underlying: DefaultAllocator
    allocations: Vec<AllocationInfo>
    total_allocated: usize
    total_freed: usize
    
    AllocationInfo := {
        ptr: RawPtr<void>
        size: usize
        freed: bool
    }
    
    init: () TrackingAllocator {
        return TrackingAllocator{
            underlying: DefaultAllocator{},
            allocations: Vec<AllocationInfo>{},
            total_allocated: 0,
            total_freed: 0
        }
    }
    
    alloc: (size: usize) Result<RawPtr<void>, core.Error> {
        result := self.underlying.alloc(size)
        result ?
            | Err(e) { return Err(e) }
            | Ok(ptr) {
                self.allocations.push(AllocationInfo{
                    ptr: ptr,
                    size: size,
                    freed: false
                })
                self.total_allocated += size
                return Ok(ptr)
            }
    }
    
    free: (ptr: RawPtr<void>) void {
        i := 0
        loop (i < self.allocations.len) {
            (self.allocations[i].ptr == ptr) ? {
                self.allocations[i].freed = true
                self.total_freed += self.allocations[i].size
                break
            }
            i += 1
        }
        self.underlying.free(ptr)
    }
    
    realloc: (ptr: RawPtr<void>, old_size: usize, new_size: usize) Result<RawPtr<void>, core.Error> {
        return self.underlying.realloc(ptr, old_size, new_size)
    }
    
    bytes_leaked: () usize {
        return self.total_allocated - self.total_freed
    }
    
    check_leaks: () bool {
        i := 0
        loop (i < self.allocations.len) {
            (!self.allocations[i].freed) ? {
                return true
            }
            i += 1
        }
        return false
    }
}

// Global default allocator instance
default_allocator: DefaultAllocator = DefaultAllocator{}

// Get the default allocator
get_default_allocator = () Ptr<Allocator> {
    return Ptr<Allocator>.from(default_allocator)
}
