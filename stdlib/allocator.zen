// Core allocator trait for colorless async/sync execution
// Based on the design in agent/zen-allocator-async.md

std := @import("std")

// Continuation type for async execution
Continuation = {
    state: *void
    resume_fn: (*void) void
}

// Base allocator trait - memory + execution context
Allocator = {
    // Memory operations
    alloc: (size: usize) *void
    free: (ptr: *void) void
    realloc: (ptr: *void, old_size: usize, new_size: usize) *void
    
    // Execution mode
    is_async: bool
    
    // Control flow operations (only for async)
    suspend: () ?Continuation
    resume: (cont: Continuation) void
    
    // Utility functions
    create: (comptime T: type) *T {
        ptr := self.alloc(@sizeOf(T))
        return @ptrCast(*T, ptr)
    }
    
    destroy: (ptr: anytype) void {
        self.free(@ptrCast(*void, ptr))
    }
    
    alloc_slice: (comptime T: type, n: usize) []T {
        bytes := self.alloc(@sizeOf(T) * n)
        return @ptrCast([*]T, bytes)[0..n]
    }
    
    free_slice: (slice: anytype) void {
        self.free(@ptrCast(*void, slice.ptr))
    }
}

// Sync allocator - traditional blocking execution
SyncAllocator = {
    heap: std.heap.GeneralPurposeAllocator
    
    init: () SyncAllocator {
        return SyncAllocator{
            heap: std.heap.GeneralPurposeAllocator.init()
        }
    }
    
    deinit: (self: *SyncAllocator) void {
        self.heap.deinit()
    }
    
    allocator: () Allocator {
        return Allocator{
            alloc: (size) => self.heap.alloc(size),
            free: (ptr) => self.heap.free(ptr),
            realloc: (ptr, old_size, new_size) => self.heap.realloc(ptr, old_size, new_size),
            is_async: false,
            suspend: () => null,
            resume: (cont) => @panic("Cannot resume in sync context")
        }
    }
}

// Runtime for async execution
Runtime = {
    ready_queue: []Continuation
    current_continuation: ?Continuation
    heap: std.heap.GeneralPurposeAllocator
    
    init: () Runtime {
        return Runtime{
            ready_queue: []Continuation{},
            current_continuation: null,
            heap: std.heap.GeneralPurposeAllocator.init()
        }
    }
    
    save_continuation: () ?Continuation {
        // Save current execution state
        // This would be implemented with platform-specific assembly
        return self.current_continuation
    }
    
    schedule: (cont: Continuation) void {
        self.ready_queue.append(cont)
    }
    
    run: () void {
        loop {
            self.ready_queue.len == 0 ? break : {}
            
            cont := self.ready_queue[0]
            self.ready_queue = self.ready_queue[1..]
            self.current_continuation = cont
            cont.resume_fn(cont.state)
        }
    }
    
    wait: () void {
        // Wait for I/O or timer events
        // Platform-specific implementation
    }
}

// Async allocator - non-blocking with continuations
AsyncAllocator = {
    runtime: *Runtime
    
    init: (runtime: *Runtime) AsyncAllocator {
        return AsyncAllocator{
            runtime: runtime
        }
    }
    
    allocator: () Allocator {
        return Allocator{
            alloc: (size) => self.runtime.heap.alloc(size),
            free: (ptr) => self.runtime.heap.free(ptr),
            realloc: (ptr, old_size, new_size) => self.runtime.heap.realloc(ptr, old_size, new_size),
            is_async: true,
            suspend: () => self.runtime.save_continuation(),
            resume: (cont) => self.runtime.schedule(cont)
        }
    }
}

// Auto allocator - chooses based on context
AutoAllocator = {
    sync_alloc: SyncAllocator
    async_alloc: ?AsyncAllocator
    runtime: ?Runtime
    
    init: () AutoAllocator {
        return AutoAllocator{
            sync_alloc: SyncAllocator.init(),
            async_alloc: null,
            runtime: null
        }
    }
    
    init_with_runtime: (runtime: *Runtime) AutoAllocator {
        return AutoAllocator{
            sync_alloc: SyncAllocator.init(),
            async_alloc: AsyncAllocator.init(runtime),
            runtime: runtime
        }
    }
    
    allocator: () Allocator {
        // Choose based on whether we have a runtime
        self.runtime ? 
            | null => self.sync_alloc.allocator()
            | runtime => self.async_alloc.?.allocator()
    }
}

// Test allocator for debugging
TestAllocator = {
    underlying: SyncAllocator
    allocations: []AllocationInfo
    total_allocated: usize
    total_freed: usize
    
    AllocationInfo = {
        ptr: *void
        size: usize
        freed: bool
    }
    
    init: () TestAllocator {
        return TestAllocator{
            underlying: SyncAllocator.init(),
            allocations: []AllocationInfo{},
            total_allocated: 0,
            total_freed: 0
        }
    }
    
    deinit: (self: *TestAllocator) void {
        self.underlying.deinit()
    }
    
    allocator: () Allocator {
        return Allocator{
            alloc: (size) => {
                ptr := self.underlying.heap.alloc(size)
                self.allocations.append(AllocationInfo{
                    ptr: ptr,
                    size: size,
                    freed: false
                })
                self.total_allocated += size
                return ptr
            },
            free: (ptr) => {
                loop i := 0; i < self.allocations.len; i += 1 {
                    self.allocations[i].ptr == ptr ? {
                        self.allocations[i].freed = true
                        self.total_freed += self.allocations[i].size
                        break
                    } : {}
                }
                self.underlying.heap.free(ptr)
            },
            realloc: (ptr, old_size, new_size) => self.underlying.heap.realloc(ptr, old_size, new_size),
            is_async: false,
            suspend: () => null,
            resume: (cont) => @panic("Cannot resume in test allocator")
        }
    }
    
    bytes_leaked: () usize {
        return self.total_allocated - self.total_freed
    }
    
    check_leaks: () bool {
        loop i := 0; i < self.allocations.len; i += 1 {
            !self.allocations[i].freed ? {
                return true
            } : {}
        }
        return false
    }
}