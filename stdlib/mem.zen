// Zen Standard Library: Memory Management
// Safe memory management utilities and allocators

core = @std.core

// Memory alignment constants
DEFAULT_ALIGN = 8
CACHE_LINE_SIZE = 64

// Allocation statistics
AllocStats: {
    total_allocated: i64,
    total_freed: i64,
    current_usage: i64,
    peak_usage: i64,
    allocation_count: i64,
    free_count: i64,
}

// Global allocation statistics (would be thread-local in real implementation)
global_stats := AllocStats {
    total_allocated: 0,
    total_freed: 0,
    current_usage: 0,
    peak_usage: 0,
    allocation_count: 0,
    free_count: 0,
}

// Aligned allocation
alloc_aligned = (size: i64, alignment: i64) core.Result<RawPtr<void>, core.Error> {
    size <= 0 ?
        | true {
            return .Err(.InvalidArgument("Size must be positive"))
        }
        | false {}
    
    (alignment <= 0 || (alignment & (alignment - 1)) != 0) ?
        | true {
            return .Err(.InvalidArgument("Alignment must be power of 2"))
        }
        | false {}
    
    // Allocate extra space for alignment
    total_size := size + alignment - 1
    ptr := core.malloc(total_size)
    
    ptr == 0 ?
        | true {
            return .Err(.OutOfMemory)
        }
        | false {}
    
    // Align the pointer
    aligned_ptr := ((ptr as i64 + alignment - 1) / alignment) * alignment as RawPtr<void>
    
    // Update statistics
    global_stats.total_allocated = global_stats.total_allocated + size
    global_stats.current_usage = global_stats.current_usage + size
    global_stats.allocation_count = global_stats.allocation_count + 1
    
    global_stats.current_usage > global_stats.peak_usage ?
        | true {
            global_stats.peak_usage = global_stats.current_usage
        }
        | false {}
    
    return .Ok(aligned_ptr)
}

// Standard allocation with default alignment
alloc = (size: i64) core.Result<RawPtr<void>, core.Error> {
    return alloc_aligned(size, DEFAULT_ALIGN)
}

// Zero-initialized allocation
calloc = (count: i64, size: i64) core.Result<RawPtr<void>, core.Error> {
    total_size := count * size
    result := alloc(total_size)
    
    result ?
        | .Ok(ptr) {
            core.memset(ptr, 0, total_size)
            return .Ok(ptr)
        }
        | .Err(e) {
            return .Err(e)
        }
}

// Reallocate memory
realloc = (ptr: RawPtr<void>, old_size: i64, new_size: i64) core.Result<RawPtr<void>, core.Error> {
    new_size <= 0 ?
        | true {
            ptr != 0 ?
                | true { dealloc(ptr, old_size) }
                | false {}
            return .Ok(0)
        }
        | false {}
    
    // Allocate new block
    new_ptr := alloc(new_size)
    new_ptr ?
        | .Err(e) { return .Err(e) }
        | .Ok(p) {
            // Copy old data if exists
            (ptr != 0 && old_size > 0) ?
                | true {
                    copy_size := core.min(old_size, new_size)
                    core.memcpy(p, ptr, copy_size)
                    dealloc(ptr, old_size)
                }
                | false {}
            
            return .Ok(p)
        }
}

// Deallocate memory
dealloc = (ptr: RawPtr<void>, size: i64) void {
    ptr == 0 ?
        | true { return }
        | false {}
    
    core.free(ptr)
    
    // Update statistics
    global_stats.total_freed = global_stats.total_freed + size
    global_stats.current_usage = global_stats.current_usage - size
    global_stats.free_count = global_stats.free_count + 1
}

// Get allocation statistics
get_stats = () AllocStats   {
    return global_stats
}

// Reset allocation statistics
reset_stats = () void   {
    global_stats = AllocStats {
        total_allocated: 0,
        total_freed: 0,
        current_usage: 0,
        peak_usage: 0,
        allocation_count: 0,
        free_count: 0,
    }
}

// Memory pool for fixed-size allocations
Pool<T>: {
    block_size: i64,
    block_count: i64,
    memory: MutPtr<T>,
    free_list: MutPtr<i64>,      // Indices of free blocks
    free_count: i64,
    initialized: bool,
}

// Create a memory pool
pool_new<T> = (block_count: i64) core.Result<Pool<T>, core.Error> {
    block_count <= 0 ?
        | true {
            return .Err(.InvalidArgument("Block count must be positive"))
        }
        | false {}
    
    block_size := sizeof(T)
    total_size := block_size * block_count
    
    // Allocate memory for blocks
    memory := alloc(total_size)
    memory ?
        | .Err(e) { return .Err(e) }
        | .Ok(mem) {
            // Allocate free list
            free_list_size := block_count * sizeof(i64)
            free_list := alloc(free_list_size)
            free_list ?
                | .Err(e) {
                    dealloc(mem, total_size)
                    return .Err(e)
                }
                | .Ok(list) {
                    // Initialize free list
                    i ::= 0
                    loop(() {
                        i >= block_count ?
                            | true { break }
                            | false {
                                (list.addr + i * 8).val = i  // Assuming i64 is 8 bytes
                                i = i + 1
                            }
                    })
                    
                    return .Ok(Pool<T> {
                        block_size: block_size,
                        block_count: block_count,
                        memory: mem,
                        free_list: list,
                        free_count: block_count,
                        initialized: true,
                    })
                }
        }
}

// Allocate from pool
pool_alloc<T> = (pool: MutPtr<Pool<T>>) core.Result<MutPtr<T>, core.Error> {
    !pool.val.initialized ?
        | true {
            return .Err(.InvalidArgument("Pool not initialized"))
        }
        | false {}
    
    pool.val.free_count == 0 ?
        | true {
            return .Err(.OutOfMemory)
        }
        | false {}
    
    // Get next free block
    pool.val.free_count = pool.val.free_count - 1
    block_index ::= (pool.val.free_list.addr + pool.val.free_count * 8).val
    
    return .Ok(pool.val.memory.addr + block_index * pool.val.block_size)
}

// Return block to pool
pool_free<T> = (pool: MutPtr<Pool<T>>, ptr: MutPtr<T>) core.Result<void, core.Error> {
    !pool.val.initialized ?
        | true {
            return .Err(.InvalidArgument("Pool not initialized"))
        }
        | false {}
    
    // Calculate block index
    offset := (ptr.addr - pool.val.memory.addr) / pool.val.block_size
    (offset < 0 || offset >= pool.val.block_count) ?
        | true {
            return .Err(.InvalidArgument("Pointer not from this pool"))
        }
        | false {}
    
    // Add to free list
    (pool.val.free_list.addr + pool.val.free_count * 8).val = offset
    pool.val.free_count = pool.val.free_count + 1
    
    return .Ok()
}

// Destroy pool
pool_destroy<T>: (pool: MutPtr<Pool<T>>) void = {
    !pool.val.initialized ?
        | true { return }
        | false {}
    
    pool.val.memory.addr != 0 ?
        | true {
            dealloc(pool.val.memory.addr, pool.val.block_size * pool.val.block_count)
        }
        | false {}
    
    pool.val.free_list.addr != 0 ?
        | true {
            dealloc(pool.val.free_list.addr, pool.val.block_count * sizeof(i64))
        }
        | false {}
    
    pool.val.initialized = false
}

// Copy memory
copy = (dest: RawPtr<void>, src: RawPtr<void>, size: i64) void   {
    core.memcpy(dest, src, size)
}

// Set memory
set = (ptr: RawPtr<void>, value: i32, size: i64) void   {
    core.memset(ptr, value, size)
}

// Compare memory
compare = (a: RawPtr<void>, b: RawPtr<void>, size: i64) i32 {
    i ::= 0
    loop(() {
        i >= size ?
            | true { break }
            | false {
                byte_a ::= (a.addr + i).val
                byte_b ::= (b.addr + i).val
                
                byte_a != byte_b ?
                    | true {
                        byte_a < byte_b ?
                            | true { return -1 }
                            | false { return 1 }
                    }
                    | false {}
                
                i = i + 1
            }
    })
    return 0
}