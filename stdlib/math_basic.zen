// Basic math module written in pure Zen
// Provides fundamental mathematical functions

// Constants
PI := 3.14159265358979323846
E := 2.71828182845904523536
TAU := 6.28318530717958647693

// Absolute value for integers
abs_i32 = (x: i32) i32 {
    if (x < 0) {
        return -x
    }
    return x
}

abs_i64 = (x: i64) i64 {
    if (x < 0) {
        return -x
    }
    return x
}

// Absolute value for floats
abs_f32 = (x: f32) f32 {
    if (x < 0.0) {
        return -x
    }
    return x
}

abs_f64 = (x: f64) f64 {
    if (x < 0.0) {
        return -x
    }
    return x
}

// Min and max functions
min_i32 = (a: i32, b: i32) i32 {
    if (a < b) {
        return a
    }
    return b
}

max_i32 = (a: i32, b: i32) i32 {
    if (a > b) {
        return a
    }
    return b
}

min_f64 = (a: f64, b: f64) f64 {
    if (a < b) {
        return a
    }
    return b
}

max_f64 = (a: f64, b: f64) f64 {
    if (a > b) {
        return a
    }
    return b
}

// Clamp value between min and max
clamp_i32 = (value: i32, min: i32, max: i32) i32 {
    if (value < min) {
        return min
    }
    if (value > max) {
        return max
    }
    return value
}

clamp_f64 = (value: f64, min: f64, max: f64) f64 {
    if (value < min) {
        return min
    }
    if (value > max) {
        return max
    }
    return value
}

// Power function for integers (iterative)
pow_i32 = (base: i32, exp: i32) i32 {
    if (exp < 0) {
        return 0  // Integer division would give 0 for negative exponents
    }
    
    result := 1
    i := 0
    while (i < exp) {
        result = result * base
        i = i + 1
    }
    return result
}

// Factorial
factorial = (n: i32) i64 {
    if (n < 0) {
        return 0  // Undefined for negative numbers
    }
    if (n == 0 || n == 1) {
        return 1
    }
    
    result: i64 = 1
    i := 2
    while (i <= n) {
        result = result * i
        i = i + 1
    }
    return result
}

// Greatest common divisor (Euclidean algorithm)
gcd = (a: i32, b: i32) i32 {
    a_val := abs_i32(a)
    b_val := abs_i32(b)
    
    while (b_val != 0) {
        temp := b_val
        b_val = a_val % b_val
        a_val = temp
    }
    return a_val
}

// Least common multiple
lcm = (a: i32, b: i32) i32 {
    if (a == 0 || b == 0) {
        return 0
    }
    return abs_i32(a * b) / gcd(a, b)
}

// Check if number is prime
is_prime = (n: i32) bool {
    if (n <= 1) {
        return false
    }
    if (n <= 3) {
        return true
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false
    }
    
    i := 5
    while (i * i <= n) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false
        }
        i = i + 6
    }
    return true
}

// Simple square root approximation using Newton's method
sqrt_f64 = (x: f64) f64 {
    if (x < 0.0) {
        return 0.0  // Return 0 for negative numbers (should be NaN)
    }
    if (x == 0.0) {
        return 0.0
    }
    
    // Initial guess
    guess := x / 2.0
    epsilon := 0.000001
    
    // Newton's method iterations
    i := 0
    while (i < 100) {  // Maximum iterations to prevent infinite loop
        next_guess := (guess + x / guess) / 2.0
        diff := abs_f64(next_guess - guess)
        
        if (diff < epsilon) {
            return next_guess
        }
        
        guess = next_guess
        i = i + 1
    }
    
    return guess
}

// Modulo that handles negative numbers correctly
mod = (a: i32, b: i32) i32 {
    result := a % b
    if (result < 0) {
        result = result + abs_i32(b)
    }
    return result
}

// Sign function
sign_i32 = (x: i32) i32 {
    if (x > 0) {
        return 1
    }
    if (x < 0) {
        return -1
    }
    return 0
}

sign_f64 = (x: f64) f64 {
    if (x > 0.0) {
        return 1.0
    }
    if (x < 0.0) {
        return -1.0
    }
    return 0.0
}