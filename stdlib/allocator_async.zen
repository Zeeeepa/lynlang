// Zen Language Allocator-Based Async System
// No async/await keywords - allocator determines sync/async behavior
// As per LANGUAGE_SPEC.zen: "Allocators determine sync/async behavior (no function coloring)"

{ memory_unified, concurrent_unified } := @std
{ Result } := @std.core

// ============================================================================
// GPA (General Purpose Allocator) - SYNCHRONOUS
// ============================================================================
// Simple synchronous allocator that blocks on all operations

GPA := {
    underlying: memory_unified.DefaultAllocator
    is_async: false
    
    init := () GPA {
        return GPA {
            underlying: memory_unified.DefaultAllocator{},
            is_async: false
        }
    }
    
    deinit := () void {
        // Nothing to cleanup for default allocator
    }
    
    allocator := () memory_unified.Allocator {
        return memory_unified.Allocator {
            alloc: self.underlying.alloc,
            realloc: self.underlying.realloc,
            free: self.underlying.free
        }
    }
    
    // Blocking allocation
    alloc := (size: usize, align: usize) Result<RawPtr<void>, memory_unified.AllocatorError> {
        return self.underlying.alloc(size, align)
    }
    
    // Blocking free
    free := (ptr: RawPtr<void>, size: usize, align: usize) void {
        self.underlying.free(ptr, size, align)
    }
}

// ============================================================================
// AsyncPool - ASYNCHRONOUS ALLOCATOR
// ============================================================================
// Async allocator that manages memory operations without blocking
// Uses thread pool for background operations

AsyncPool := {
    underlying: memory_unified.Pool
    thread_pool: concurrent_unified.ThreadPool
    is_async: true
    pending_ops: concurrent_unified.Queue<AsyncOp>
    
    init := () AsyncPool {
        return AsyncPool {
            underlying: memory_unified.pool_new<u8>(1024, memory_unified.get_default_allocator()),
            thread_pool: concurrent_unified.ThreadPool.new(4),
            is_async: true,
            pending_ops: concurrent_unified.Queue.new()
        }
    }
    
    deinit := () void {
        // Wait for all pending operations
        self.flush()
        self.thread_pool.shutdown()
        self.underlying.destroy()
    }
    
    allocator := () memory_unified.Allocator {
        return memory_unified.Allocator {
            alloc: (size: usize, align: usize) Result<RawPtr<void>, memory_unified.AllocatorError> {
                // Non-blocking allocation via thread pool
                return self.alloc_async(size, align)
            },
            realloc: (ptr: RawPtr<void>, old_size: usize, new_size: usize, align: usize) Result<RawPtr<void>, memory_unified.AllocatorError> {
                return self.realloc_async(ptr, old_size, new_size, align)
            },
            free: (ptr: RawPtr<void>, size: usize, align: usize) void {
                self.free_async(ptr, size, align)
            }
        }
    }
    
    // Non-blocking allocation
    alloc_async := (size: usize, align: usize) Result<RawPtr<void>, memory_unified.AllocatorError> {
        // Submit allocation request to thread pool
        future := self.thread_pool.submit(() {
            return self.underlying.alloc(size, align)
        })
        
        // Return immediately with a future result
        // The caller can check if ready or wait
        return future.get_or_default(memory_unified.allocate_raw(size))
    }
    
    // Non-blocking reallocation
    realloc_async := (ptr: RawPtr<void>, old_size: usize, new_size: usize, align: usize) Result<RawPtr<void>, memory_unified.AllocatorError> {
        future := self.thread_pool.submit(() {
            return self.underlying.realloc(ptr, old_size, new_size, align)
        })
        
        // For safety, perform synchronous realloc if async not ready
        return future.try_get().unwrap_or(self.underlying.realloc(ptr, old_size, new_size, align))
    }
    
    // Non-blocking free
    free_async := (ptr: RawPtr<void>, size: usize, align: usize) void {
        // Queue free operation to be done asynchronously
        self.pending_ops.push(AsyncOp.Free{
            ptr: ptr,
            size: size,
            align: align
        })
        
        // Submit to thread pool
        self.thread_pool.submit(() {
            op := self.pending_ops.pop()
            op ?
                | Free(f) { self.underlying.free(f.ptr, f.size, f.align) }
                | _ { /* ignore */ }
        })
    }
    
    // Wait for all pending operations to complete
    flush := () void {
        self.thread_pool.wait_all()
        // Process any remaining operations
        loop(self.pending_ops.is_empty() == false) {
            op := self.pending_ops.pop()
            op ?
                | Free(f) { self.underlying.free(f.ptr, f.size, f.align) }
                | _ { /* ignore */ }
        }
    }
}

// Async operation types
AsyncOp:
    Free: {
        ptr: RawPtr<void>,
        size: usize,
        align: usize
    }
    | Alloc: {
        size: usize,
        align: usize,
        callback: (Result<RawPtr<void>, memory_unified.AllocatorError>) void
    }
    | Realloc: {
        ptr: RawPtr<void>,
        old_size: usize,
        new_size: usize,
        align: usize,
        callback: (Result<RawPtr<void>, memory_unified.AllocatorError>) void
    }

// ============================================================================
// MULTISYNC SUPPORT
// ============================================================================
// Helper to determine if an allocator is async

is_async_allocator := (alloc: memory_unified.Allocator) bool {
    // Check if allocator has async flag
    // This is a runtime check
    return @has_field(alloc, "is_async") && alloc.is_async
}

// Example multisync function from LANGUAGE_SPEC.zen
// This blocks or doesn't based on allocator!
execute_with_allocator := <T>(task: () T, alloc: memory_unified.Allocator) T {
    is_async_allocator(alloc) ?
        | true {
            // Non-blocking execution
            return task()  // Returns immediately
        }
        | false {
            // Blocking execution
            return task()  // Blocks until complete
        }
}

// ============================================================================
// EXPORTS
// ============================================================================

module.exports := {
    GPA,
    AsyncPool,
    AsyncOp,
    is_async_allocator,
    execute_with_allocator
}