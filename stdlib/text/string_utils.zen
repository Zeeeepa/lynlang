// Zen Standard Library - String Utilities
// Comprehensive string manipulation and processing functions

core = @std
mem = @std
{ Vec, DynVec } = @std
io = @std

// Note: StringBuilder moved to text/string_builder.zen to avoid duplication

// String length
string_len = (s: string) u32   {
    s .== None ? | true { return 0 | false => { }}
    
    len := 0
    loop s[len] != 0 {
        len = len + 1
    }
    return len
}

// String comparison
string_eq = (a: string, b: string) bool   {
    a .== None && b .== None ? | true { return true | false => { }}
    a .== None || b .== None ? | true { return false | false => { }}
    
    i := 0
    loop {
        a[i] != b[i] ? | true { return false | false => { }}
        a[i] == 0 ? | true { return true | false => { }}
        i = i + 1
    }
}

// Lexicographic comparison
string_compare = (a: string, b: string) i32   {
    a .== None && b .== None ? | true { return 0 | false => { }}
    a .== None ? | true { return -1 | false => { }}
    b .== None ? | true { return 1 | false => { }}
    
    i := 0
    loop {
        a[i] < b[i] ? | true { return -1 | false => { }}
        a[i] > b[i] ? | true { return 1 | false => { }}
        a[i] == 0 ? | true { return 0 | false => { }}
        i = i + 1
    }
}

// Check if string starts with prefix
string_starts_with = (s: string, prefix: string) bool   {
    s .== None || prefix .== None ? | true { return false | false => { }}
    
    prefix_len := string_len(prefix)
    s_len := string_len(s)
    
    prefix_len > s_len ? | true { return false | false => { }}
    
    i := 0
    loop i < prefix_len {
        s[i] != prefix[i] ? | true { return false | false => { }}
        i = i + 1
    }
    return true
}

// Check if string ends with suffix
string_ends_with = (s: string, suffix: string) bool   {
    s .== None || suffix .== None ? | true { return false | false => { }}
    
    suffix_len := string_len(suffix)
    s_len := string_len(s)
    
    suffix_len > s_len ? | true { return false | false => { }}
    
    offset := s_len - suffix_len
    i := 0
    loop i < suffix_len {
        s[offset + i] != suffix[i] ? | true { return false | false => { }}
        i = i + 1
    }
    return true
}

// Find substring
string_find = (haystack: string, needle: string) i32   {
    haystack .== None || needle .== None ? | true { return -1 | false => { }}
    
    needle_len := string_len(needle)
    haystack_len := string_len(haystack)
    
    needle_len == 0 ? | true { return 0 | false => { }}
    needle_len > haystack_len ? | true { return -1 | false => { }}
    
    i := 0
    loop i <= haystack_len - needle_len {
        // Check if needle matches at position i
        match := true
        j := 0
        loop j < needle_len {
            haystack[i + j] != needle[j] ? | true {
                match = false
                break
            } | false {}
            j = j + 1
        }
        
        match ? | true { return i } | false {}
        i = i + 1
    }
    
    return -1
}

// Find last occurrence of substring
string_rfind = (haystack: string, needle: string) i32   {
    haystack .== None || needle .== None ? | true { return -1 | false => { }}
    
    needle_len := string_len(needle)
    haystack_len := string_len(haystack)
    
    needle_len == 0 ? | true { return haystack_len | false => { }}
    needle_len > haystack_len ? | true { return -1 | false => { }}
    
    i := haystack_len - needle_len
    loop i >= 0 {
        // Check if needle matches at position i
        match := true
        j := 0
        loop j < needle_len {
            haystack[i + j] != needle[j] ? | true {
                match = false
                break
            } | false {}
            j = j + 1
        }
        
        match ? | true { return i } | false {}
        i = i - 1
    }
    
    return -1
}

// Count occurrences of substring
string_count = (haystack: string, needle: string) u32   {
    haystack .== None || needle .== None ? | true { return 0 | false => { }}
    
    needle_len := string_len(needle)
    needle_len == 0 ? | true { return 0 | false => { }}
    
    count := 0
    pos := 0
    loop {
        found := string_find(haystack + pos, needle)
        found < 0 ? | true { break | false => { }}
        
        count = count + 1
        pos = pos + found + needle_len
    }
    
    return count
}

// Substring extraction
string_substring = (s: string, start: u32, length: u32) string   {
    s .== None ? | true { return null | false => { }}
    
    s_len := string_len(s)
    start >= s_len ? | true { return "" | false => { }}
    
    actual_len := start + length > s_len ?
        | true { s_len - start }
        | false { length }
    
    result := mem.alloc(actual_len + 1)
    result ?
        | Ok(ptr) {
            bytes := ptr as Ptr<i8>
            i := 0
            loop i < actual_len {
                bytes[i] = s[start + i]
                i = i + 1
            }
            bytes[actual_len] = 0
            return bytes as string
        }
        | Err(_) {
            return ""
        }
}

// Convert to uppercase
string_to_upper = (s: string) string   {
    s .== None ? | true { return null | false => { }}
    
    len := string_len(s)
    result := mem.alloc(len + 1)
    result ?
        | Ok(ptr) {
            bytes := ptr as Ptr<i8>
            i := 0
            loop i < len {
                c := s[i]
                c >= 'a' && c <= 'z' ?
                    | true { bytes[i] = c - ('a' - 'A') }
                    | false { bytes[i] = c }
                i = i + 1
            }
            bytes[len] = 0
            return bytes as string
        }
        | Err(_) {
            return s
        }
}

// Convert to lowercase
string_to_lower = (s: string) string   {
    s .== None ? | true { return null | false => { }}
    
    len := string_len(s)
    result := mem.alloc(len + 1)
    result ?
        | Ok(ptr) {
            bytes := ptr as Ptr<i8>
            i := 0
            loop i < len {
                c := s[i]
                c >= 'A' && c <= 'Z' ?
                    | true { bytes[i] = c + ('a' - 'A') }
                    | false { bytes[i] = c }
                i = i + 1
            }
            bytes[len] = 0
            return bytes as string
        }
        | Err(_) {
            return s
        }
}

// Trim whitespace from both ends
string_trim = (s: string) string   {
    s .== None ? | true { return null | false => { }}
    
    len := string_len(s)
    len == 0 ? | true { return s | false => { }}
    
    // Find start of non-whitespace
    start := 0
    loop start < len {
        c := s[start]
        c != ' ' && c != '\t' && c != '\n' && c != '\r' ?
            | true { break }
            | false {}
        start = start + 1
    }
    
    // All whitespace?
    start >= len ? | true { return "" | false => { }}
    
    // Find end of non-whitespace
    end := len - 1
    loop end > start {
        c := s[end]
        c != ' ' && c != '\t' && c != '\n' && c != '\r' ?
            | true { break }
            | false {}
        end = end - 1
    }
    
    return string_substring(s, start, end - start + 1)
}

// Trim whitespace from left
string_ltrim = (s: string) string   {
    s .== None ? | true { return null | false => { }}
    
    len := string_len(s)
    len == 0 ? | true { return s | false => { }}
    
    start := 0
    loop start < len {
        c := s[start]
        c != ' ' && c != '\t' && c != '\n' && c != '\r' ?
            | true { break }
            | false {}
        start = start + 1
    }
    
    start >= len ? | true { return "" | false => { }}
    return string_substring(s, start, len - start)
}

// Trim whitespace from right
string_rtrim = (s: string) string   {
    s .== None ? | true { return null | false => { }}
    
    len := string_len(s)
    len == 0 ? | true { return s | false => { }}
    
    end := len - 1
    loop end >= 0 {
        c := s[end]
        c != ' ' && c != '\t' && c != '\n' && c != '\r' ?
            | true { break }
            | false {}
        end = end - 1
    }
    
    end < 0 ? | true { return "" | false => { }}
    return string_substring(s, 0, end + 1)
}

// Replace all occurrences of a substring
string_replace = (s: string, old: string, new: string) string   {
    s .== None || old .== None || new .== None ? | true { return s | false => { }}
    
    old_len := string_len(old)
    old_len == 0 ? | true { return s | false => { }}
    
    // Count occurrences
    count := string_count(s, old)
    count == 0 ? | true { return s | false => { }}
    
    s_len := string_len(s)
    new_len := string_len(new)
    result_len := s_len + count * (new_len - old_len)
    
    // Allocate result
    result := mem.alloc(result_len + 1)
    result ?
        | Ok(ptr) {
            bytes := ptr as Ptr<i8>
            src_pos := 0
            dst_pos := 0
            
            loop src_pos < s_len {
                // Check if old string matches at current position
                match := true
                i := 0
                loop i < old_len && src_pos + i < s_len {
                    s[src_pos + i] != old[i] ? | true {
                        match = false
                        break
                    } | false {}
                    i = i + 1
                }
                
                match && i == old_len ? | true {
                    // Copy replacement
                    j := 0
                    loop j < new_len {
                        bytes[dst_pos] = new[j]
                        dst_pos = dst_pos + 1
                        j = j + 1
                    }
                    src_pos = src_pos + old_len
                } | false {
                    // Copy original character
                    bytes[dst_pos] = s[src_pos]
                    dst_pos = dst_pos + 1
                    src_pos = src_pos + 1
                }
            }
            
            bytes[dst_pos] = 0
            return bytes as string
        }
        | Err(_) {
            return s
        }
}

// Split string by delimiter
string_split = (s: string, delimiter: string) DynVec<string>   {
    result := DynVec.new<string>()
    
    s .== None || delimiter .== None ? | true { return result | false => { }}
    
    s_len := string_len(s)
    del_len := string_len(delimiter)
    
    del_len == 0 ? | true {
        result.push(s)
        return result
    } | false {}
    
    start := 0
    loop {
        // Find next delimiter
        pos := string_find(s + start, delimiter)
        
        pos < 0 ? | true {
            // No more delimiters, add remaining string
            remaining := string_substring(s, start, s_len - start)
            result.push(remaining)
            break
        } | false {
            // Add substring before delimiter
            part := string_substring(s, start, pos)
            result.push(part)
            start = start + pos + del_len
        }
    }
    
    return result
}

// Join strings with separator
string_join = (strings: DynVec<string>, separator: string) string   {
    strings.len() == 0 ? | true { return "" | false => { }}
    strings.len() == 1 ? | true { return strings.at(0) | false => { }}
    
    sep_len := string_len(separator)
    
    // Calculate total length
    total_len := 0
    i := 0
    loop i < strings.len() {
        total_len = total_len + string_len(strings.at(i))
        i < strings.len() - 1 ? | true {
            total_len = total_len + sep_len
        } | false {}
        i = i + 1
    }
    
    // Build result
    result := mem.alloc(total_len + 1)
    result ?
        | Ok(ptr) {
            bytes := ptr as Ptr<i8>
            pos := 0
            
            i = 0
            loop i < strings.len() {
                s := strings.at(i)
                len := string_len(s)
                
                // Copy string
                j := 0
                loop j < len {
                    bytes[pos] = s[j]
                    pos = pos + 1
                    j = j + 1
                }
                
                // Add separator if not last
                i < strings.len() - 1 ? | true {
                    j = 0
                    loop j < sep_len {
                        bytes[pos] = separator[j]
                        pos = pos + 1
                        j = j + 1
                    }
                } | false {}
                
                i = i + 1
            }
            
            bytes[pos] = 0
            return bytes as string
        }
        | Err(_) {
            return ""
        }
}

// Check if character is digit
char_is_digit = (c: i8) bool   {
    return c >= '0' && c <= '9'
}

// Check if character is letter
char_is_alpha = (c: i8) bool   {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
}

// Check if character is alphanumeric
char_is_alnum = (c: i8) bool   {
    return char_is_alpha(c) || char_is_digit(c)
}

// Check if character is whitespace
char_is_space = (c: i8) bool   {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

// Parse integer from string
string_to_i32 = (s: string) core.Result<i32, string> {
    s .== None || string_len(s) == 0 ? | true {
        return core.Result.Err("Empty string")
    } | false {}
    
    negative := false
    start := 0
    
    s[0] == '-' ? | true {
        negative = true
        start = 1
    } | false {}
    
    s[0] == '+' ? | true {
        start = 1
    } | false {}
    
    result := 0
    i := start
    len := string_len(s)
    
    loop i < len {
        c := s[i]
        !char_is_digit(c) ? | true {
            return core.Result.Err("Invalid character in number")
        } | false {}
        
        digit := c - '0'
        result = result * 10 + digit
        i = i + 1
    }
    
    negative ? | true { result = -result | false => { }}
    
    return core.Result.Ok(result)
}

// Convert integer to string
i32_to_string = (n: i32) string   {
    n == 0 ? | true { return "0" | false => { }}
    
    // Handle negative
    negative := n < 0
    negative ? | true { n = -n | false => { }}
    
    // Count digits
    temp := n
    digits := 0
    loop temp > 0 {
        digits = digits + 1
        temp = temp / 10
    }
    
    // Allocate string
    len := digits + (negative ? 1 : 0)
    result := mem.alloc(len + 1)
    result ?
        | Ok(ptr) {
            bytes := ptr as Ptr<i8>
            
            // Fill from right to left
            pos := len - 1
            loop n > 0 {
                bytes[pos] = '0' + (n % 10)
                pos = pos - 1
                n = n / 10
            }
            
            negative ? | true { bytes[0] = '-' | false => { }}
            bytes[len] = 0
            
            return bytes as string
        }
        | Err(_) {
            return ""
        }
}

// Module exports
module.exports = {
    string_len, string_eq, string_compare,
    string_starts_with, string_ends_with,
    string_find, string_rfind, string_count,
    string_substring, string_to_upper, string_to_lower,
    string_trim, string_ltrim, string_rtrim,
    string_replace, string_split, string_join,
    char_is_digit, char_is_alpha, char_is_alnum, char_is_space,
    string_to_i32, i32_to_string
}