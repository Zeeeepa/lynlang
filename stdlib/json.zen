// JSON Parser and Serializer for Zen
// Provides JSON parsing and serialization capabilities

{ allocate_raw, deallocate_raw, copy_memory_raw, strlen } = import("memory.zen")

// JSON Value types
JsonValue: Null
    Boolean: {value: bool},
    Number: {value: f64},
    String: {value: RawPtr<i8>},
    Array: {elements: Ptr<JsonValue>, count: i32},
    Object: {pairs: Ptr<JsonPair>, count: i32},

JsonPair: {
    key: RawPtr<i8>,
    value: Ptr<JsonValue>,
}

// JSON Parser state
JsonParser: {
    input: RawPtr<i8>,
    position: i32,
    length: i32,
}

// Create a new JSON parser
json_parser_new = (input: RawPtr<i8>) JsonParser   {
    return JsonParser {
        input: input,
        position: 0,
        length: strlen(input) as i32,
    }
}

// Skip whitespace in parser
json_skip_whitespace = (parser: Ptr<JsonParser>) void   {
    loop {
        parser.position >= parser.length ? | true { { break  }} | false {}
        
        ch := parser.input[parser.position]
        is_ws := ch == 32 || ch == 9 || ch == 10 || ch == 13
        is_ws ? | false { { break  }} | true {}
        
        parser.position = parser.position + 1
    }
}

// Parse a JSON string
json_parse_string = (parser: Ptr<JsonParser>) RawPtr<i8> {
    // Skip opening quote
    parser.position = parser.position + 1
    
    start := parser.position
    length := 0
    
    loop {
        parser.position >= parser.length ? | true { { break  }} | false {}
        
        ch := parser.input[parser.position]
        ch == 34 ? | true { { break  }} | false {} // Found closing quote
        
        ch == 92 ? | true { { // Escape character }
            parser.position = parser.position + 2
            length = length + 1
        } | false {
            parser.position = parser.position + 1
            length = length + 1
        }
    }
    
    // Allocate and copy string
    result := allocate_raw((length + 1) as usize) as RawPtr<i8>
    copy_memory_raw(result as RawPtr<void>, (parser.input + start) as RawPtr<void>, length as i64)
    result[length] = 0
    
    // Skip closing quote
    parser.position = parser.position + 1
    
    return result
}

// Parse a JSON number
json_parse_number = (parser: Ptr<JsonParser>) f64   {
    start := parser.position
    has_decimal := false
    
    // Handle negative sign
    parser.input[parser.position] == 45 ? | true { { // '-' }
        parser.position = parser.position + 1
    } | false {}
    
    // Parse digits
    loop {
        parser.position >= parser.length ? | true { { break  }} | false {}
        
        ch := parser.input[parser.position]
        
        ch >= 48 && ch <= 57 ? | true { { // '0' to '9' }
            parser.position = parser.position + 1
        } | false {
            ch == 46 ? | true { { // '.' }
                has_decimal ? | true { { break  }} | false {}
                has_decimal = true
                parser.position = parser.position + 1
            } | false { { break  }}
        }
    }
    
    // Convert string to number (simplified)
    // In a real implementation, we'd use proper string-to-float conversion
    return 0.0
}

// Parse a JSON value
json_parse_value = (parser: Ptr<JsonParser>) Ptr<JsonValue> {
    json_skip_whitespace(parser)
    
    parser.position >= parser.length ? | true {
        return Ptr<JsonValue>(JsonValue.Null)
    } | false {}
    
    ch := parser.input[parser.position]
    
    // Null
    ch == 110 ? | true { { // 'n' }
        parser.position = parser.position + 4 // Skip "null"
        return Ptr<JsonValue>(JsonValue.Null)
    } | false {}
    
    // Boolean true
    ch == 116 ? | true { { // 't' }
        parser.position = parser.position + 4 // Skip "true"
        value := JsonValue:Boolean(true)
        result := allocate_raw(@sizeof(JsonValue) as usize) as Ptr<JsonValue>
        result.write(value)
        return result
    } | false {}
    
    // Boolean false
    ch == 102 ? | true { { // 'f' }
        parser.position = parser.position + 5 // Skip "false"
        value := JsonValue:Boolean(false)
        result := allocate_raw(@sizeof(JsonValue) as usize) as Ptr<JsonValue>
        result.write(value)
        return result
    } | false {}
    
    // String
    ch == 34 ? | true { { // '"' }
        str := json_parse_string(parser)
        value := JsonValue:String(str)
        result := allocate_raw(@sizeof(JsonValue) as usize) as Ptr<JsonValue>
        result.write(value)
        return result
    } | false {}
    
    // Number
    ch == 45 || (ch >= 48 && ch <= 57) ? | true { { // '-' or digit }
        num := json_parse_number(parser)
        value := JsonValue:Number(num)
        result := allocate_raw(@sizeof(JsonValue) as usize) as Ptr<JsonValue>
        result.write(value)
        return result
    } | false {}
    
    // Array
    ch == 91 ? | true { { // '[' }
        parser.position = parser.position + 1
        return json_parse_array(parser)
    } | false {}
    
    // Object
    ch == 123 ? | true { { // '{' }
        parser.position = parser.position + 1
        return json_parse_object(parser)
    } | false {}
    
    return Ptr<JsonValue>(JsonValue.Null)
}

// Parse JSON array
json_parse_array = (parser: Ptr<JsonParser>) Ptr<JsonValue> {
    elements := allocate_raw(1024 as usize) as Ptr<JsonValue>
    count := 0
    
    loop {
        json_skip_whitespace(parser)
        
        parser.position >= parser.length ? | true { { break  }} | false {}
        parser.input[parser.position] == 93 ? | true { { // ']' }
            parser.position = parser.position + 1
            break
        } | false {}
        
        count > 0 ? | true {
            parser.input[parser.position] == 44 ? | true { { // ',' }
                parser.position = parser.position + 1
            } | false {}
        } | false {}
        
        element := json_parse_value(parser)
        elements[count] = element.read()
        count = count + 1
    }
    
    value := JsonValue:Array(elements, count)
    result := allocate_raw(@sizeof(JsonValue) as usize) as Ptr<JsonValue>
    result.write(value)
    return result
}

// Parse JSON object
json_parse_object = (parser: Ptr<JsonParser>) Ptr<JsonValue> {
    pairs := allocate_raw(1024 as usize) as Ptr<JsonPair>
    count := 0
    
    loop {
        json_skip_whitespace(parser)
        
        parser.position >= parser.length ? | true { { break  }} | false {}
        parser.input[parser.position] == 125 ? | true { { // ' }}'
            parser.position = parser.position + 1
            break
        } | false {}
        
        count > 0 ? | true {
            parser.input[parser.position] == 44 ? | true { { // ',' }
                parser.position = parser.position + 1
                json_skip_whitespace(parser)
            } | false {}
        } | false {}
        
        // Parse key
        key := json_parse_string(parser)
        
        json_skip_whitespace(parser)
        
        // Skip colon
        parser.input[parser.position] == 58 ? | true { { // ':' }
            parser.position = parser.position + 1
        } | false {}
        
        // Parse value
        value := json_parse_value(parser)
        
        pairs[count] = JsonPair { key: key, value: value }
        count = count + 1
    }
    
    value := JsonValue:Object(pairs, count)
    result := allocate_raw(@sizeof(JsonValue) as usize) as Ptr<JsonValue>
    result.write(value)
    return result
}

// Main parse function
json_parse = (input: RawPtr<i8>) Ptr<JsonValue> {
    parser := json_parser_new(input)
    return json_parse_value(Ptr<JsonParser>(parser))
}

// Stringify a JSON value (simplified)
json_stringify = (value: Ptr<JsonValue>) RawPtr<i8> {
    value ? 
        | Null { { return "null" as RawPtr<i8>  }}
        | Boolean(b) { { return b ? | true => "true" as RawPtr<i8> | false => "false" as RawPtr<i8>  }}
        | Number(n) { { return "0" as RawPtr<i8>  }} // Would need proper number-to-string
        | String(s) { { return s  }}
        | Array(elements, count) { { return "[]" as RawPtr<i8>  }} // Simplified
        | Object(pairs, count) { { return "{ }}" as RawPtr<i8> } // Simplified
}

// Free JSON value memory
json_free = (value: Ptr<JsonValue>) void   {
    value ? 
        | String(s) { { deallocate_raw(s as RawPtr<void>)  }}
        | Array(elements, count) {
            range(0, count).loop((i) {
                json_free(Ptr<JsonValue>(elements[i]))
            })
            deallocate_raw(elements as RawPtr<void>)
        }
        | Object(pairs, count) {
            range(0, count).loop((i) {
                deallocate_raw(pairs[i].key as RawPtr<void>)
                json_free(pairs[i].value)
            })
            deallocate_raw(pairs as RawPtr<void>)
        }
        | _ {}
    deallocate_raw(value as RawPtr<void>)
}