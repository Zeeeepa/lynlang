// Code generator for Zen compiler
// Generates intermediate representation (IR) or target code

core := @std.core
mem := @std.mem
array := @std.array
string := @std.string
ast := @std.ast
type_system := @std.compiler.type_system
symbol_table := @std.compiler.symbol_table

// IR instruction types
IROpcode = enum {
    // Arithmetic
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Neg,
    
    // Bitwise
    And,
    Or,
    Xor,
    Not,
    Shl,
    Shr,
    
    // Comparison
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
    
    // Memory
    Load,
    Store,
    Alloca,
    GetElementPtr,
    
    // Control flow
    Br,
    BrCond,
    Switch,
    Call,
    Ret,
    Phi,
    
    // Type conversion
    Cast,
    Bitcast,
    Trunc,
    Zext,
    Sext,
    
    // Constants
    ConstInt,
    ConstFloat,
    ConstString,
    ConstNull,
    
    // Other
    Select,
    Nop,
}

// IR value
IRValue = struct {
    id: u32,
    type: *type_system.Type,
    kind: IRValueKind,
    data: IRValueData,
}

IRValueKind = enum {
    Constant,
    Variable,
    Temporary,
    Function,
    BasicBlock,
    Global,
}

IRValueData = union {
    const_int: i64,
    const_float: f64,
    const_string: String,
    variable: String,
    temp_id: u32,
    func_ref: *IRFunction,
    block_ref: *IRBasicBlock,
}

// IR instruction
IRInstruction = struct {
    opcode: IROpcode,
    result: ?*IRValue,
    operands: Array(*IRValue),
    metadata: IRMetadata,
}

IRMetadata = struct {
    debug_location: ?SourceLocation,
    flags: u32,
}

// IR basic block
IRBasicBlock = struct {
    id: u32,
    name: String,
    instructions: Array(*IRInstruction),
    predecessors: Array(*IRBasicBlock),
    successors: Array(*IRBasicBlock),
    is_entry: bool,
}

// IR function
IRFunction = struct {
    name: String,
    params: Array(*IRValue),
    return_type: *type_system.Type,
    blocks: Array(*IRBasicBlock),
    entry_block: *IRBasicBlock,
    locals: Array(*IRValue),
    attributes: FunctionAttributes,
}

FunctionAttributes = struct {
    is_inline: bool,
    is_no_return: bool,
    is_pure: bool,
    is_const: bool,
    calling_convention: CallingConvention,
}

CallingConvention = enum {
    Default,
    C,
    FastCall,
    StdCall,
}

// IR module
IRModule = struct {
    name: String,
    functions: Array(*IRFunction),
    globals: Array(*IRValue),
    types: Array(*type_system.Type),
    string_literals: Array(String),
    target_info: TargetInfo,
}

TargetInfo = struct {
    arch: Architecture,
    os: OperatingSystem,
    pointer_size: u8,
    endianness: Endianness,
}

Architecture = enum {
    X86_64,
    ARM64,
    WASM32,
    RISCV64,
}

OperatingSystem = enum {
    Linux,
    Windows,
    MacOS,
    FreeBSD,
    Bare,
}

Endianness = enum {
    Little,
    Big,
}

// Code generator context
CodeGenerator = struct {
    module: *IRModule,
    current_function: ?*IRFunction,
    current_block: ?*IRBasicBlock,
    value_counter: u32,
    block_counter: u32,
    symbols: *symbol_table.SymbolTable,
    types: *type_system.TypeContext,
    string_pool: Array(String),
    errors: Array(CodeGenError),
}

CodeGenError = struct {
    message: String,
    location: ?SourceLocation,
}

SourceLocation = struct {
    file: String,
    line: u32,
    column: u32,
}

// Create new code generator
new = () CodeGenerator {
    module := alloc_module()
    return CodeGenerator{
        module: module,
        current_function: null,
        current_block: null,
        value_counter: 0,
        block_counter: 0,
        symbols: symbol_table.new(),
        types: type_system.new(),
        string_pool: array.new(String, 256),
        errors: array.new(CodeGenError, 32),
    }
}

// Generate code for AST
generate = (gen: *CodeGenerator, program: *ast.Program) *IRModule {
    // Process all declarations
    for (i := 0; i < program.declarations.len; i += 1) {
        generate_declaration(gen, program.declarations.data[i])
    }
    
    // Finalize module
    finalize_module(gen.module)
    
    return gen.module
}

// Generate declaration
generate_declaration = (gen: *CodeGenerator, decl: *ast.Declaration) void {
    switch (decl.kind) {
        ast.DeclKind.Function => generate_function(gen, decl.function)
        ast.DeclKind.Variable => generate_global_variable(gen, decl.variable)
        ast.DeclKind.Type => process_type_declaration(gen, decl.type_decl)
        ast.DeclKind.Struct => process_struct_declaration(gen, decl.struct_decl)
        ast.DeclKind.Enum => process_enum_declaration(gen, decl.enum_decl)
        ast.DeclKind.Import => process_import(gen, decl.import)
        default => {}
    }
}

// Generate function
generate_function = (gen: *CodeGenerator, func: *ast.FunctionDecl) void {
    // Create IR function
    ir_func := create_ir_function(gen, func)
    array.push(*IRFunction, &gen.module.functions, ir_func)
    
    // Set as current function
    gen.current_function = ir_func
    
    // Create entry block
    entry_block := create_basic_block(gen, "entry")
    ir_func.entry_block = entry_block
    array.push(*IRBasicBlock, &ir_func.blocks, entry_block)
    gen.current_block = entry_block
    
    // Generate parameters
    for (i := 0; i < func.params.len; i += 1) {
        param := func.params.data[i]
        ir_param := create_parameter(gen, param, i)
        array.push(*IRValue, &ir_func.params, ir_param)
        
        // Store parameter in local variable
        local := create_alloca(gen, ir_param.type, param.name)
        emit_store(gen, local, ir_param)
    }
    
    // Generate function body
    if (func.body != null) {
        generate_block(gen, func.body)
    }
    
    // Add implicit return if needed
    if (!block_has_terminator(gen.current_block)) {
        if (is_void_type(ir_func.return_type)) {
            emit_ret_void(gen)
        } else {
            // Error: missing return
            add_error(gen, "Missing return statement", func.location)
        }
    }
    
    // Clear current function
    gen.current_function = null
    gen.current_block = null
}

// Generate block
generate_block = (gen: *CodeGenerator, block: *ast.Block) void {
    for (i := 0; i < block.statements.len; i += 1) {
        generate_statement(gen, block.statements.data[i])
    }
}

// Generate statement
generate_statement = (gen: *CodeGenerator, stmt: *ast.Statement) void {
    switch (stmt.kind) {
        ast.StmtKind.Expression => {
            generate_expression(gen, stmt.expression)
        }
        ast.StmtKind.Return => {
            generate_return(gen, stmt.return_stmt)
        }
        ast.StmtKind.If => {
            generate_if(gen, stmt.if_stmt)
        }
        ast.StmtKind.While => {
            generate_while(gen, stmt.while_stmt)
        }
        ast.StmtKind.For => {
            generate_for(gen, stmt.for_stmt)
        }
        ast.StmtKind.Assignment => {
            generate_assignment(gen, stmt.assignment)
        }
        ast.StmtKind.VariableDecl => {
            generate_local_variable(gen, stmt.var_decl)
        }
        ast.StmtKind.Break => {
            generate_break(gen, stmt.break_stmt)
        }
        ast.StmtKind.Continue => {
            generate_continue(gen, stmt.continue_stmt)
        }
        default => {}
    }
}

// Generate expression
generate_expression = (gen: *CodeGenerator, expr: *ast.Expression) *IRValue {
    switch (expr.kind) {
        ast.ExprKind.Literal => return generate_literal(gen, expr.literal)
        ast.ExprKind.Identifier => return generate_identifier(gen, expr.identifier)
        ast.ExprKind.Binary => return generate_binary(gen, expr.binary)
        ast.ExprKind.Unary => return generate_unary(gen, expr.unary)
        ast.ExprKind.Call => return generate_call(gen, expr.call)
        ast.ExprKind.Index => return generate_index(gen, expr.index)
        ast.ExprKind.Field => return generate_field(gen, expr.field)
        ast.ExprKind.Cast => return generate_cast(gen, expr.cast)
        default => {
            add_error(gen, "Unknown expression type", expr.location)
            return create_null_value(gen)
        }
    }
}

// Generate literal
generate_literal = (gen: *CodeGenerator, lit: *ast.Literal) *IRValue {
    switch (lit.kind) {
        ast.LiteralKind.Integer => {
            return create_const_int(gen, lit.int_value, 32)
        }
        ast.LiteralKind.Float => {
            return create_const_float(gen, lit.float_value, 64)
        }
        ast.LiteralKind.String => {
            return create_const_string(gen, lit.string_value)
        }
        ast.LiteralKind.Bool => {
            value := if (lit.bool_value) 1 else 0
            return create_const_int(gen, value, 1)
        }
        ast.LiteralKind.Null => {
            return create_null_value(gen)
        }
        default => {
            return create_null_value(gen)
        }
    }
}

// Generate identifier
generate_identifier = (gen: *CodeGenerator, id: *ast.Identifier) *IRValue {
    // Look up symbol
    sym := symbol_table.lookup_symbol(gen.symbols, id.name)
    if (sym == null) {
        add_error(gen, "Undefined identifier", id.location)
        return create_null_value(gen)
    }
    
    // Load value if it's a variable
    if (sym.kind == symbol_table.SymbolKind.Variable) {
        return emit_load(gen, sym.ir_value, id.name)
    }
    
    return sym.ir_value
}

// Generate binary expression
generate_binary = (gen: *CodeGenerator, bin: *ast.BinaryExpr) *IRValue {
    left := generate_expression(gen, bin.left)
    right := generate_expression(gen, bin.right)
    
    switch (bin.op) {
        ast.BinaryOp.Add => return emit_binary(gen, IROpcode.Add, left, right)
        ast.BinaryOp.Sub => return emit_binary(gen, IROpcode.Sub, left, right)
        ast.BinaryOp.Mul => return emit_binary(gen, IROpcode.Mul, left, right)
        ast.BinaryOp.Div => return emit_binary(gen, IROpcode.Div, left, right)
        ast.BinaryOp.Mod => return emit_binary(gen, IROpcode.Mod, left, right)
        ast.BinaryOp.And => return emit_binary(gen, IROpcode.And, left, right)
        ast.BinaryOp.Or => return emit_binary(gen, IROpcode.Or, left, right)
        ast.BinaryOp.Xor => return emit_binary(gen, IROpcode.Xor, left, right)
        ast.BinaryOp.Shl => return emit_binary(gen, IROpcode.Shl, left, right)
        ast.BinaryOp.Shr => return emit_binary(gen, IROpcode.Shr, left, right)
        ast.BinaryOp.Eq => return emit_binary(gen, IROpcode.Eq, left, right)
        ast.BinaryOp.Ne => return emit_binary(gen, IROpcode.Ne, left, right)
        ast.BinaryOp.Lt => return emit_binary(gen, IROpcode.Lt, left, right)
        ast.BinaryOp.Le => return emit_binary(gen, IROpcode.Le, left, right)
        ast.BinaryOp.Gt => return emit_binary(gen, IROpcode.Gt, left, right)
        ast.BinaryOp.Ge => return emit_binary(gen, IROpcode.Ge, left, right)
        default => {
            add_error(gen, "Unknown binary operator", bin.location)
            return create_null_value(gen)
        }
    }
}

// Generate unary expression
generate_unary = (gen: *CodeGenerator, un: *ast.UnaryExpr) *IRValue {
    operand := generate_expression(gen, un.operand)
    
    switch (un.op) {
        ast.UnaryOp.Neg => return emit_unary(gen, IROpcode.Neg, operand)
        ast.UnaryOp.Not => return emit_unary(gen, IROpcode.Not, operand)
        ast.UnaryOp.Ref => return operand  // Already an address
        ast.UnaryOp.Deref => return emit_load(gen, operand, "deref")
        default => {
            add_error(gen, "Unknown unary operator", un.location)
            return create_null_value(gen)
        }
    }
}

// Generate call expression
generate_call = (gen: *CodeGenerator, call: *ast.CallExpr) *IRValue {
    // Generate function value
    func := generate_expression(gen, call.function)
    
    // Generate arguments
    args := array.new(*IRValue, call.arguments.len)
    for (i := 0; i < call.arguments.len; i += 1) {
        arg := generate_expression(gen, call.arguments.data[i])
        array.push(*IRValue, &args, arg)
    }
    
    // Emit call instruction
    return emit_call(gen, func, args)
}

// Generate index expression
generate_index = (gen: *CodeGenerator, idx: *ast.IndexExpr) *IRValue {
    base := generate_expression(gen, idx.base)
    index := generate_expression(gen, idx.index)
    
    // Calculate element pointer
    ptr := emit_get_element_ptr(gen, base, index)
    
    // Load value
    return emit_load(gen, ptr, "index")
}

// Generate field expression
generate_field = (gen: *CodeGenerator, field: *ast.FieldExpr) *IRValue {
    base := generate_expression(gen, field.base)
    
    // Get field index
    field_idx := get_field_index(gen, base.type, field.name)
    if (field_idx < 0) {
        add_error(gen, "Unknown field", field.location)
        return create_null_value(gen)
    }
    
    // Calculate field pointer
    idx_val := create_const_int(gen, field_idx, 32)
    ptr := emit_get_element_ptr(gen, base, idx_val)
    
    // Load value
    return emit_load(gen, ptr, field.name)
}

// Generate cast expression
generate_cast = (gen: *CodeGenerator, cast: *ast.CastExpr) *IRValue {
    value := generate_expression(gen, cast.value)
    target_type := resolve_type(gen, cast.target_type)
    
    return emit_cast(gen, value, target_type)
}

// Generate return statement
generate_return = (gen: *CodeGenerator, ret: *ast.ReturnStmt) void {
    if (ret.value != null) {
        value := generate_expression(gen, ret.value)
        emit_ret(gen, value)
    } else {
        emit_ret_void(gen)
    }
}

// Generate if statement
generate_if = (gen: *CodeGenerator, if_stmt: *ast.IfStmt) void {
    // Generate condition
    cond := generate_expression(gen, if_stmt.condition)
    
    // Create blocks
    then_block := create_basic_block(gen, "then")
    else_block := create_basic_block(gen, "else")
    merge_block := create_basic_block(gen, "merge")
    
    // Emit conditional branch
    emit_br_cond(gen, cond, then_block, else_block)
    
    // Generate then block
    gen.current_block = then_block
    generate_block(gen, if_stmt.then_block)
    if (!block_has_terminator(gen.current_block)) {
        emit_br(gen, merge_block)
    }
    
    // Generate else block
    gen.current_block = else_block
    if (if_stmt.else_block != null) {
        generate_block(gen, if_stmt.else_block)
    }
    if (!block_has_terminator(gen.current_block)) {
        emit_br(gen, merge_block)
    }
    
    // Continue in merge block
    gen.current_block = merge_block
}

// Generate while loop
generate_while = (gen: *CodeGenerator, while_stmt: *ast.WhileStmt) void {
    // Create blocks
    cond_block := create_basic_block(gen, "while.cond")
    body_block := create_basic_block(gen, "while.body")
    exit_block := create_basic_block(gen, "while.exit")
    
    // Jump to condition
    emit_br(gen, cond_block)
    
    // Generate condition block
    gen.current_block = cond_block
    cond := generate_expression(gen, while_stmt.condition)
    emit_br_cond(gen, cond, body_block, exit_block)
    
    // Generate body block
    gen.current_block = body_block
    generate_block(gen, while_stmt.body)
    if (!block_has_terminator(gen.current_block)) {
        emit_br(gen, cond_block)
    }
    
    // Continue after loop
    gen.current_block = exit_block
}

// Generate for loop
generate_for = (gen: *CodeGenerator, for_stmt: *ast.ForStmt) void {
    // Generate init
    if (for_stmt.init != null) {
        generate_statement(gen, for_stmt.init)
    }
    
    // Create blocks
    cond_block := create_basic_block(gen, "for.cond")
    body_block := create_basic_block(gen, "for.body")
    update_block := create_basic_block(gen, "for.update")
    exit_block := create_basic_block(gen, "for.exit")
    
    // Jump to condition
    emit_br(gen, cond_block)
    
    // Generate condition block
    gen.current_block = cond_block
    if (for_stmt.condition != null) {
        cond := generate_expression(gen, for_stmt.condition)
        emit_br_cond(gen, cond, body_block, exit_block)
    } else {
        emit_br(gen, body_block)
    }
    
    // Generate body block
    gen.current_block = body_block
    generate_block(gen, for_stmt.body)
    if (!block_has_terminator(gen.current_block)) {
        emit_br(gen, update_block)
    }
    
    // Generate update block
    gen.current_block = update_block
    if (for_stmt.update != null) {
        generate_statement(gen, for_stmt.update)
    }
    emit_br(gen, cond_block)
    
    // Continue after loop
    gen.current_block = exit_block
}

// Generate assignment
generate_assignment = (gen: *CodeGenerator, assign: *ast.Assignment) void {
    // Generate lvalue address
    lvalue := generate_lvalue(gen, assign.left)
    
    // Generate rvalue
    rvalue := generate_expression(gen, assign.right)
    
    // Store value
    emit_store(gen, lvalue, rvalue)
}

// Generate local variable
generate_local_variable = (gen: *CodeGenerator, var_decl: *ast.VariableDecl) void {
    // Get variable type
    var_type := resolve_type(gen, var_decl.type)
    
    // Allocate local variable
    local := create_alloca(gen, var_type, var_decl.name)
    
    // Initialize if provided
    if (var_decl.initializer != null) {
        init_value := generate_expression(gen, var_decl.initializer)
        emit_store(gen, local, init_value)
    }
    
    // Register in symbol table
    symbol_table.define_variable(gen.symbols, var_decl.name, local)
}

// Generate global variable
generate_global_variable = (gen: *CodeGenerator, var_decl: *ast.VariableDecl) void {
    // Get variable type
    var_type := resolve_type(gen, var_decl.type)
    
    // Create global variable
    global := create_global(gen, var_type, var_decl.name)
    
    // Initialize if provided
    if (var_decl.initializer != null) {
        // Global initializers must be constant
        init_value := evaluate_constant(gen, var_decl.initializer)
        set_global_initializer(global, init_value)
    }
    
    array.push(*IRValue, &gen.module.globals, global)
}

// Helper functions
create_ir_function = (gen: *CodeGenerator, func: *ast.FunctionDecl) *IRFunction {
    ir_func := mem.alloc(IRFunction)
    ir_func.name = func.name
    ir_func.params = array.new(*IRValue, func.params.len)
    ir_func.return_type = resolve_type(gen, func.return_type)
    ir_func.blocks = array.new(*IRBasicBlock, 8)
    ir_func.locals = array.new(*IRValue, 16)
    ir_func.attributes = FunctionAttributes{
        is_inline: false,
        is_no_return: false,
        is_pure: false,
        is_const: false,
        calling_convention: CallingConvention.Default,
    }
    return ir_func
}

create_basic_block = (gen: *CodeGenerator, name: String) *IRBasicBlock {
    block := mem.alloc(IRBasicBlock)
    block.id = gen.block_counter
    gen.block_counter += 1
    block.name = name
    block.instructions = array.new(*IRInstruction, 32)
    block.predecessors = array.new(*IRBasicBlock, 4)
    block.successors = array.new(*IRBasicBlock, 4)
    block.is_entry = false
    
    if (gen.current_function != null) {
        array.push(*IRBasicBlock, &gen.current_function.blocks, block)
    }
    
    return block
}

create_value = (gen: *CodeGenerator) *IRValue {
    value := mem.alloc(IRValue)
    value.id = gen.value_counter
    gen.value_counter += 1
    return value
}

create_const_int = (gen: *CodeGenerator, value: i64, bits: u32) *IRValue {
    val := create_value(gen)
    val.kind = IRValueKind.Constant
    val.data.const_int = value
    val.type = type_system.make_integer_type(bits, true)
    return val
}

create_const_float = (gen: *CodeGenerator, value: f64, bits: u32) *IRValue {
    val := create_value(gen)
    val.kind = IRValueKind.Constant
    val.data.const_float = value
    val.type = type_system.make_float_type(bits)
    return val
}

create_const_string = (gen: *CodeGenerator, value: String) *IRValue {
    val := create_value(gen)
    val.kind = IRValueKind.Constant
    val.data.const_string = value
    val.type = type_system.make_string_type()
    
    // Add to string pool
    array.push(String, &gen.string_pool, value)
    
    return val
}

create_null_value = (gen: *CodeGenerator) *IRValue {
    val := create_value(gen)
    val.kind = IRValueKind.Constant
    val.type = type_system.make_pointer_type(type_system.make_void_type())
    return val
}

emit_instruction = (gen: *CodeGenerator, inst: *IRInstruction) void {
    if (gen.current_block != null) {
        array.push(*IRInstruction, &gen.current_block.instructions, inst)
    }
}

emit_binary = (gen: *CodeGenerator, op: IROpcode, left: *IRValue, right: *IRValue) *IRValue {
    result := create_value(gen)
    result.type = left.type  // Simplified type resolution
    
    inst := mem.alloc(IRInstruction)
    inst.opcode = op
    inst.result = result
    inst.operands = array.new(*IRValue, 2)
    array.push(*IRValue, &inst.operands, left)
    array.push(*IRValue, &inst.operands, right)
    
    emit_instruction(gen, inst)
    return result
}

emit_unary = (gen: *CodeGenerator, op: IROpcode, operand: *IRValue) *IRValue {
    result := create_value(gen)
    result.type = operand.type
    
    inst := mem.alloc(IRInstruction)
    inst.opcode = op
    inst.result = result
    inst.operands = array.new(*IRValue, 1)
    array.push(*IRValue, &inst.operands, operand)
    
    emit_instruction(gen, inst)
    return result
}

emit_load = (gen: *CodeGenerator, ptr: *IRValue, name: String) *IRValue {
    result := create_value(gen)
    result.type = get_pointee_type(ptr.type)
    
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.Load
    inst.result = result
    inst.operands = array.new(*IRValue, 1)
    array.push(*IRValue, &inst.operands, ptr)
    
    emit_instruction(gen, inst)
    return result
}

emit_store = (gen: *CodeGenerator, ptr: *IRValue, value: *IRValue) void {
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.Store
    inst.operands = array.new(*IRValue, 2)
    array.push(*IRValue, &inst.operands, ptr)
    array.push(*IRValue, &inst.operands, value)
    
    emit_instruction(gen, inst)
}

emit_call = (gen: *CodeGenerator, func: *IRValue, args: Array(*IRValue)) *IRValue {
    func_type := get_function_type(func.type)
    result := create_value(gen)
    result.type = func_type.return_type
    
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.Call
    inst.result = result
    inst.operands = array.new(*IRValue, args.len + 1)
    array.push(*IRValue, &inst.operands, func)
    
    for (i := 0; i < args.len; i += 1) {
        array.push(*IRValue, &inst.operands, args.data[i])
    }
    
    emit_instruction(gen, inst)
    return result
}

emit_br = (gen: *CodeGenerator, target: *IRBasicBlock) void {
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.Br
    inst.operands = array.new(*IRValue, 1)
    
    target_val := create_value(gen)
    target_val.kind = IRValueKind.BasicBlock
    target_val.data.block_ref = target
    array.push(*IRValue, &inst.operands, target_val)
    
    emit_instruction(gen, inst)
    
    // Update CFG
    array.push(*IRBasicBlock, &gen.current_block.successors, target)
    array.push(*IRBasicBlock, &target.predecessors, gen.current_block)
}

emit_br_cond = (gen: *CodeGenerator, cond: *IRValue, true_block: *IRBasicBlock, false_block: *IRBasicBlock) void {
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.BrCond
    inst.operands = array.new(*IRValue, 3)
    
    array.push(*IRValue, &inst.operands, cond)
    
    true_val := create_value(gen)
    true_val.kind = IRValueKind.BasicBlock
    true_val.data.block_ref = true_block
    array.push(*IRValue, &inst.operands, true_val)
    
    false_val := create_value(gen)
    false_val.kind = IRValueKind.BasicBlock
    false_val.data.block_ref = false_block
    array.push(*IRValue, &inst.operands, false_val)
    
    emit_instruction(gen, inst)
    
    // Update CFG
    array.push(*IRBasicBlock, &gen.current_block.successors, true_block)
    array.push(*IRBasicBlock, &gen.current_block.successors, false_block)
    array.push(*IRBasicBlock, &true_block.predecessors, gen.current_block)
    array.push(*IRBasicBlock, &false_block.predecessors, gen.current_block)
}

emit_ret = (gen: *CodeGenerator, value: *IRValue) void {
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.Ret
    inst.operands = array.new(*IRValue, 1)
    array.push(*IRValue, &inst.operands, value)
    
    emit_instruction(gen, inst)
}

emit_ret_void = (gen: *CodeGenerator) void {
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.Ret
    inst.operands = array.new(*IRValue, 0)
    
    emit_instruction(gen, inst)
}

// Stub implementations
alloc_module = () *IRModule {
    module := mem.alloc(IRModule)
    module.name = string.from_literal("main")
    module.functions = array.new(*IRFunction, 64)
    module.globals = array.new(*IRValue, 128)
    module.types = array.new(*type_system.Type, 256)
    module.string_literals = array.new(String, 512)
    module.target_info = TargetInfo{
        arch: Architecture.X86_64,
        os: OperatingSystem.Linux,
        pointer_size: 8,
        endianness: Endianness.Little,
    }
    return module
}

finalize_module = (module: *IRModule) void {
    // Perform module-level optimizations and finalization
}

resolve_type = (gen: *CodeGenerator, type_expr: *ast.TypeExpr) *type_system.Type {
    return type_system.lookup_type(gen.types, type_expr.name)
}

block_has_terminator = (block: *IRBasicBlock) bool {
    if (block.instructions.len == 0) {
        return false
    }
    
    last := block.instructions.data[block.instructions.len - 1]
    return last.opcode == IROpcode.Ret or
           last.opcode == IROpcode.Br or
           last.opcode == IROpcode.BrCond or
           last.opcode == IROpcode.Switch
}

add_error = (gen: *CodeGenerator, message: String, location: ?SourceLocation) void {
    error := CodeGenError{
        message: message,
        location: location,
    }
    array.push(CodeGenError, &gen.errors, error)
}

// Additional stubs
create_parameter = (gen: *CodeGenerator, param: *ast.Parameter, index: u32) *IRValue {
    val := create_value(gen)
    val.kind = IRValueKind.Variable
    val.type = resolve_type(gen, param.type)
    return val
}

create_alloca = (gen: *CodeGenerator, type: *type_system.Type, name: String) *IRValue {
    ptr := create_value(gen)
    ptr.type = type_system.make_pointer_type(type)
    ptr.kind = IRValueKind.Variable
    
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.Alloca
    inst.result = ptr
    inst.operands = array.new(*IRValue, 0)
    
    emit_instruction(gen, inst)
    return ptr
}

create_global = (gen: *CodeGenerator, type: *type_system.Type, name: String) *IRValue {
    global := create_value(gen)
    global.type = type_system.make_pointer_type(type)
    global.kind = IRValueKind.Global
    global.data.variable = name
    return global
}

emit_get_element_ptr = (gen: *CodeGenerator, base: *IRValue, index: *IRValue) *IRValue {
    result := create_value(gen)
    result.type = base.type  // Simplified
    
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.GetElementPtr
    inst.result = result
    inst.operands = array.new(*IRValue, 2)
    array.push(*IRValue, &inst.operands, base)
    array.push(*IRValue, &inst.operands, index)
    
    emit_instruction(gen, inst)
    return result
}

emit_cast = (gen: *CodeGenerator, value: *IRValue, target_type: *type_system.Type) *IRValue {
    result := create_value(gen)
    result.type = target_type
    
    inst := mem.alloc(IRInstruction)
    inst.opcode = IROpcode.Cast
    inst.result = result
    inst.operands = array.new(*IRValue, 1)
    array.push(*IRValue, &inst.operands, value)
    
    emit_instruction(gen, inst)
    return result
}

generate_lvalue = (gen: *CodeGenerator, expr: *ast.Expression) *IRValue {
    // Generate address of lvalue
    switch (expr.kind) {
        ast.ExprKind.Identifier => {
            sym := symbol_table.lookup_symbol(gen.symbols, expr.identifier.name)
            return sym.ir_value
        }
        default => {
            add_error(gen, "Invalid lvalue", expr.location)
            return create_null_value(gen)
        }
    }
}

generate_break = (gen: *CodeGenerator, break_stmt: *ast.BreakStmt) void {
    // Would need loop context to generate proper break
}

generate_continue = (gen: *CodeGenerator, continue_stmt: *ast.ContinueStmt) void {
    // Would need loop context to generate proper continue
}

evaluate_constant = (gen: *CodeGenerator, expr: *ast.Expression) *IRValue {
    // Evaluate constant expression
    return generate_expression(gen, expr)
}

set_global_initializer = (global: *IRValue, init: *IRValue) void {
    // Set initializer for global variable
}

get_field_index = (gen: *CodeGenerator, type: *type_system.Type, field_name: String) i32 {
    // Look up field index in struct type
    return -1
}

get_pointee_type = (type: *type_system.Type) *type_system.Type {
    // Get type pointed to by pointer type
    return type
}

get_function_type = (type: *type_system.Type) *type_system.FunctionType {
    // Extract function type
    return type.metadata.function
}

is_void_type = (type: *type_system.Type) bool {
    return type.kind == type_system.TypeKind.Void
}

process_type_declaration = (gen: *CodeGenerator, type_decl: *ast.TypeDecl) void {
    // Process type alias
}

process_struct_declaration = (gen: *CodeGenerator, struct_decl: *ast.StructDecl) void {
    // Process struct type
}

process_enum_declaration = (gen: *CodeGenerator, enum_decl: *ast.EnumDecl) void {
    // Process enum type
}

process_import = (gen: *CodeGenerator, import: *ast.ImportDecl) void {
    // Process import
}

// Free code generator
free = (gen: *CodeGenerator) void {
    array.free(String, &gen.string_pool)
    array.free(CodeGenError, &gen.errors)
}