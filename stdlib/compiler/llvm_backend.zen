// LLVM Backend Integration for Zen Compiler
// Provides direct LLVM IR generation and optimization

core := @std.core
io := @std.io
string := @std.string
vec := @std.vec
parser := @compiler.parser
type_checker := @compiler.type_checker
symbol_table := @compiler.symbol_table
codegen := @compiler.codegen

// LLVM Context wrapper
LLVMContext = {
    module_name: String,
    target_triple: String,
    data_layout: String,
    functions: vec.Vec<LLVMFunction>,
    globals: vec.Vec<LLVMGlobal>,
    string_constants: vec.Vec<LLVMStringConstant>,
    metadata: vec.Vec<LLVMMetadata>,
}

// LLVM Function representation
LLVMFunction = {
    name: String,
    return_type: String,
    params: vec.Vec<LLVMParam>,
    body: vec.Vec<LLVMInstruction>,
    is_declaration: bool,
    linkage: String,
    attributes: vec.Vec<String>,
}

// LLVM Parameter
LLVMParam = {
    type_str: String,
    name: String,
    attributes: vec.Vec<String>,
}

// LLVM Global variable
LLVMGlobal = {
    name: String,
    type_str: String,
    initializer: String,
    is_constant: bool,
    linkage: String,
}

// LLVM String constant
LLVMStringConstant = {
    name: String,
    value: String,
    length: i32,
}

// LLVM Instruction
LLVMInstruction = {
    opcode: LLVMOpcode,
    result: String,
    operands: vec.Vec<String>,
    type_str: String,
    metadata: vec.Vec<String>,
}

// LLVM Opcodes
LLVMOpcode = enum {
    // Terminator instructions
    Ret,
    Br,
    Switch,
    IndirectBr,
    Unreachable,
    
    // Binary operations
    Add,
    FAdd,
    Sub,
    FSub,
    Mul,
    FMul,
    UDiv,
    SDiv,
    FDiv,
    URem,
    SRem,
    FRem,
    
    // Bitwise binary operations
    Shl,
    LShr,
    AShr,
    And,
    Or,
    Xor,
    
    // Memory operations
    Alloca,
    Load,
    Store,
    GetElementPtr,
    
    // Conversion operations
    Trunc,
    ZExt,
    SExt,
    FPToUI,
    FPToSI,
    UIToFP,
    SIToFP,
    FPTrunc,
    FPExt,
    PtrToInt,
    IntToPtr,
    BitCast,
    
    // Other operations
    ICmp,
    FCmp,
    Phi,
    Call,
    Select,
    ExtractElement,
    InsertElement,
    ShuffleVector,
    ExtractValue,
    InsertValue,
}

// LLVM Metadata
LLVMMetadata = {
    id: i32,
    kind: String,
    values: vec.Vec<String>,
}

// Create new LLVM context
llvm_context_new = (module_name: String) LLVMContext {
    return LLVMContext {
        module_name: module_name,
        target_triple: "x86_64-unknown-linux-gnu",
        data_layout: "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
        functions: vec.new<LLVMFunction>(),
        globals: vec.new<LLVMGlobal>(),
        string_constants: vec.new<LLVMStringConstant>(),
        metadata: vec.new<LLVMMetadata>(),
    }
}

// Add function to context
add_function = (ctx: *LLVMContext, func: LLVMFunction) void {
    vec.push<LLVMFunction>(&ctx.functions, func)
}

// Add global to context
add_global = (ctx: *LLVMContext, global: LLVMGlobal) void {
    vec.push<LLVMGlobal>(&ctx.globals, global)
}

// Add string constant and return its name
add_string_constant = (ctx: *LLVMContext, value: String) String {
    idx := vec.len<LLVMStringConstant>(ctx.string_constants)
    name := "@.str." + string.from_int(idx)
    
    constant := LLVMStringConstant {
        name: name,
        value: value,
        length: string.len(value) + 1, // Include null terminator
    }
    
    vec.push<LLVMStringConstant>(&ctx.string_constants, constant)
    return name
}

// Convert Zen type to LLVM type string
zen_type_to_llvm = (t: *type_checker.Type) String {
    t.kind == type_checker.TypeKind.Void ? | true => { return "void" } | false => {}
    t.kind == type_checker.TypeKind.Bool ? | true => { return "i1" } | false => {}
    t.kind == type_checker.TypeKind.I8 ? | true => { return "i8" } | false => {}
    t.kind == type_checker.TypeKind.I16 ? | true => { return "i16" } | false => {}
    t.kind == type_checker.TypeKind.I32 ? | true => { return "i32" } | false => {}
    t.kind == type_checker.TypeKind.I64 ? | true => { return "i64" } | false => {}
    t.kind == type_checker.TypeKind.U8 ? | true => { return "i8" } | false => {}
    t.kind == type_checker.TypeKind.U16 ? | true => { return "i16" } | false => {}
    t.kind == type_checker.TypeKind.U32 ? | true => { return "i32" } | false => {}
    t.kind == type_checker.TypeKind.U64 ? | true => { return "i64" } | false => {}
    t.kind == type_checker.TypeKind.F32 ? | true => { return "float" } | false => {}
    t.kind == type_checker.TypeKind.F64 ? | true => { return "double" } | false => {}
    t.kind == type_checker.TypeKind.String ? | true => { return "i8*" } | false => {}
    t.kind == type_checker.TypeKind.Pointer ? | true => {
        return zen_type_to_llvm(t.pointee_type) + "*"
    } | false => {}
    t.kind == type_checker.TypeKind.Array ? | true => {
        return "[" + string.from_int(t.array_size) + " x " + zen_type_to_llvm(t.element_type) + "]"
    } | false => {}
    
    return "unknown_type"
}

// Generate LLVM instruction string
generate_instruction = (inst: *LLVMInstruction) String {
    result := ""
    
    // Add result if present
    string.len(inst.result) > 0 ? | true => {
        result = "  " + inst.result + " = "
    } | false => {
        result = "  "
    }
    
    // Generate instruction based on opcode
    inst.opcode == LLVMOpcode.Ret ? | true => {
        vec.len<String>(inst.operands) > 0 ? | true => {
            result = result + "ret " + inst.type_str + " " + vec.get<String>(inst.operands, 0)
        } | false => {
            result = result + "ret void"
        }
    } | false => {}
    
    inst.opcode == LLVMOpcode.Br ? | true => {
        vec.len<String>(inst.operands) == 1 ? | true => {
            // Unconditional branch
            result = result + "br label %" + vec.get<String>(inst.operands, 0)
        } | false => {
            // Conditional branch
            result = result + "br i1 " + vec.get<String>(inst.operands, 0)
            result = result + ", label %" + vec.get<String>(inst.operands, 1)
            result = result + ", label %" + vec.get<String>(inst.operands, 2)
        }
    } | false => {}
    
    inst.opcode == LLVMOpcode.Add ? | true => {
        result = result + "add " + inst.type_str + " "
        result = result + vec.get<String>(inst.operands, 0) + ", "
        result = result + vec.get<String>(inst.operands, 1)
    } | false => {}
    
    inst.opcode == LLVMOpcode.Sub ? | true => {
        result = result + "sub " + inst.type_str + " "
        result = result + vec.get<String>(inst.operands, 0) + ", "
        result = result + vec.get<String>(inst.operands, 1)
    } | false => {}
    
    inst.opcode == LLVMOpcode.Mul ? | true => {
        result = result + "mul " + inst.type_str + " "
        result = result + vec.get<String>(inst.operands, 0) + ", "
        result = result + vec.get<String>(inst.operands, 1)
    } | false => {}
    
    inst.opcode == LLVMOpcode.SDiv ? | true => {
        result = result + "sdiv " + inst.type_str + " "
        result = result + vec.get<String>(inst.operands, 0) + ", "
        result = result + vec.get<String>(inst.operands, 1)
    } | false => {}
    
    inst.opcode == LLVMOpcode.Alloca ? | true => {
        result = result + "alloca " + inst.type_str
    } | false => {}
    
    inst.opcode == LLVMOpcode.Load ? | true => {
        result = result + "load " + inst.type_str + ", "
        result = result + inst.type_str + "* " + vec.get<String>(inst.operands, 0)
    } | false => {}
    
    inst.opcode == LLVMOpcode.Store ? | true => {
        result = result + "store " + inst.type_str + " "
        result = result + vec.get<String>(inst.operands, 0) + ", "
        result = result + inst.type_str + "* " + vec.get<String>(inst.operands, 1)
    } | false => {}
    
    inst.opcode == LLVMOpcode.Call ? | true => {
        result = result + "call " + inst.type_str + " "
        result = result + vec.get<String>(inst.operands, 0) + "("
        
        i := 1
        loop (i < vec.len<String>(inst.operands)) {
            i > 1 ? | true => { result = result + ", " } | false => {}
            result = result + vec.get<String>(inst.operands, i)
            i = i + 1
        }
        result = result + ")"
    } | false => {}
    
    inst.opcode == LLVMOpcode.ICmp ? | true => {
        result = result + "icmp " + vec.get<String>(inst.operands, 0) + " "
        result = result + inst.type_str + " "
        result = result + vec.get<String>(inst.operands, 1) + ", "
        result = result + vec.get<String>(inst.operands, 2)
    } | false => {}
    
    inst.opcode == LLVMOpcode.GetElementPtr ? | true => {
        result = result + "getelementptr inbounds " + inst.type_str + ", "
        result = result + inst.type_str + "* " + vec.get<String>(inst.operands, 0)
        
        i := 1
        loop (i < vec.len<String>(inst.operands)) {
            result = result + ", i32 " + vec.get<String>(inst.operands, i)
            i = i + 1
        }
    } | false => {}
    
    return result
}

// Generate complete LLVM IR module
generate_llvm_ir = (ctx: *LLVMContext) String {
    output := ""
    
    // Module header
    output = output + "; ModuleID = '" + ctx.module_name + "'\n"
    output = output + "source_filename = \"" + ctx.module_name + "\"\n"
    output = output + "target datalayout = \"" + ctx.data_layout + "\"\n"
    output = output + "target triple = \"" + ctx.target_triple + "\"\n\n"
    
    // String constants
    vec.len<LLVMStringConstant>(ctx.string_constants) > 0 ? | true => {
        output = output + "; String constants\n"
        i := 0
        loop (i < vec.len<LLVMStringConstant>(ctx.string_constants)) {
            sc := vec.get<LLVMStringConstant>(ctx.string_constants, i)
            output = output + sc.name + " = private unnamed_addr constant ["
            output = output + string.from_int(sc.length) + " x i8] c\""
            output = output + escape_string(sc.value) + "\\00\", align 1\n"
            i = i + 1
        }
        output = output + "\n"
    } | false => {}
    
    // Global variables
    vec.len<LLVMGlobal>(ctx.globals) > 0 ? | true => {
        output = output + "; Global variables\n"
        i := 0
        loop (i < vec.len<LLVMGlobal>(ctx.globals)) {
            g := vec.get<LLVMGlobal>(ctx.globals, i)
            output = output + "@" + g.name + " = "
            output = output + g.linkage + " "
            g.is_constant ? | true => { output = output + "constant " } | false => { output = output + "global " }
            output = output + g.type_str + " " + g.initializer + "\n"
            i = i + 1
        }
        output = output + "\n"
    } | false => {}
    
    // External function declarations
    output = output + "; External functions\n"
    output = output + "declare i32 @printf(i8*, ...)\n"
    output = output + "declare i8* @malloc(i64)\n"
    output = output + "declare void @free(i8*)\n"
    output = output + "declare void @exit(i32)\n\n"
    
    // Functions
    i := 0
    loop (i < vec.len<LLVMFunction>(ctx.functions)) {
        func := vec.get<LLVMFunction>(ctx.functions, i)
        
        // Function signature
        func.is_declaration ? | true => {
            output = output + "declare "
        } | false => {
            output = output + "define "
        }
        
        output = output + func.linkage + " "
        output = output + func.return_type + " @" + func.name + "("
        
        // Parameters
        j := 0
        loop (j < vec.len<LLVMParam>(func.params)) {
            j > 0 ? | true => { output = output + ", " } | false => {}
            param := vec.get<LLVMParam>(func.params, j)
            output = output + param.type_str + " %" + param.name
            j = j + 1
        }
        
        output = output + ")"
        
        // Attributes
        vec.len<String>(func.attributes) > 0 ? | true => {
            k := 0
            loop (k < vec.len<String>(func.attributes)) {
                output = output + " " + vec.get<String>(func.attributes, k)
                k = k + 1
            }
        } | false => {}
        
        func.is_declaration ? | true => {
            output = output + "\n"
        } | false => {
            output = output + " {\n"
            
            // Function body
            k := 0
            loop (k < vec.len<LLVMInstruction>(func.body)) {
                inst := vec.get<LLVMInstruction>(func.body, k)
                output = output + generate_instruction(&inst) + "\n"
                k = k + 1
            }
            
            output = output + "}\n"
        }
        
        output = output + "\n"
        i = i + 1
    }
    
    return output
}

// Escape string for LLVM IR
escape_string = (s: String) String {
    result := ""
    i := 0
    loop (i < string.len(s)) {
        c := string.char_at(s, i)
        c == '\n' ? | true => { result = result + "\\0A" } | false => {}
        c == '\t' ? | true => { result = result + "\\09" } | false => {}
        c == '\r' ? | true => { result = result + "\\0D" } | false => {}
        c == '\\' ? | true => { result = result + "\\\\" } | false => {}
        c == '"' ? | true => { result = result + "\\\"" } | false => {}
        c >= ' ' && c <= '~' ? | true => { 
            result = result + string.from_char(c)
        } | false => {
            // Non-printable character
            result = result + "\\x"
            result = result + to_hex(c)
        }
        i = i + 1
    }
    return result
}

// Convert byte to hex string
to_hex = (b: u8) String {
    hex_chars := "0123456789ABCDEF"
    high := (b >> 4) & 0x0F
    low := b & 0x0F
    return string.from_char(string.char_at(hex_chars, high)) + string.from_char(string.char_at(hex_chars, low))
}

// Create a simple LLVM function
create_simple_function = () LLVMFunction {
    func := LLVMFunction {
        name: "main",
        return_type: "i32",
        params: vec.new<LLVMParam>(),
        body: vec.new<LLVMInstruction>(),
        is_declaration: false,
        linkage: "",
        attributes: vec.new<String>(),
    }
    
    // Add some instructions
    inst1 := LLVMInstruction {
        opcode: LLVMOpcode.Alloca,
        result: "%1",
        operands: vec.new<String>(),
        type_str: "i32",
        metadata: vec.new<String>(),
    }
    vec.push<LLVMInstruction>(&func.body, inst1)
    
    // Store value
    inst2 := LLVMInstruction {
        opcode: LLVMOpcode.Store,
        result: "",
        operands: vec.new<String>(),
        type_str: "i32",
        metadata: vec.new<String>(),
    }
    vec.push<String>(&inst2.operands, "42")
    vec.push<String>(&inst2.operands, "%1")
    vec.push<LLVMInstruction>(&func.body, inst2)
    
    // Load value
    inst3 := LLVMInstruction {
        opcode: LLVMOpcode.Load,
        result: "%2",
        operands: vec.new<String>(),
        type_str: "i32",
        metadata: vec.new<String>(),
    }
    vec.push<String>(&inst3.operands, "%1")
    vec.push<LLVMInstruction>(&func.body, inst3)
    
    // Return
    inst4 := LLVMInstruction {
        opcode: LLVMOpcode.Ret,
        result: "",
        operands: vec.new<String>(),
        type_str: "i32",
        metadata: vec.new<String>(),
    }
    vec.push<String>(&inst4.operands, "%2")
    vec.push<LLVMInstruction>(&func.body, inst4)
    
    return func
}

// Main test function
main = () i32 {
    io.print("LLVM Backend Integration Test\n")
    io.print("=============================\n\n")
    
    // Create LLVM context
    ctx := llvm_context_new("test_module")
    
    // Add a string constant
    hello_str := add_string_constant(&ctx, "Hello, LLVM!\n")
    io.print("Added string constant: ")
    io.print(hello_str)
    io.print("\n")
    
    // Create and add a simple function
    main_func := create_simple_function()
    add_function(&ctx, main_func)
    
    // Generate LLVM IR
    ir := generate_llvm_ir(&ctx)
    
    io.print("\nGenerated LLVM IR:\n")
    io.print("------------------\n")
    io.print(ir)
    
    // Write to file
    io.write_file("test_output.ll", ir)
    io.print("\nLLVM IR written to test_output.ll\n")
    
    return 0
}