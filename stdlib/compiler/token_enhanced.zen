// Enhanced Token types for the Zen lexer
// Part of the self-hosting compiler

core := @std.core

// Token types enumeration
TokenType = enum {
    // Literals
    Integer,
    Float,
    String,
    Boolean,
    Character,
    
    // Identifiers and keywords
    Identifier,
    Keyword,
    
    // Arithmetic operators
    Plus,           // +
    Minus,          // -
    Star,           // *
    Slash,          // /
    Percent,        // %
    
    // Comparison operators
    Equals,         // ==
    NotEquals,      // !=
    LessThan,       // <
    LessThanEquals, // <=
    GreaterThan,    // >
    GreaterThanEquals, // >=
    
    // Logical operators
    And,            // &&
    Or,             // ||
    Not,            // !
    
    // Bitwise operators
    Ampersand,      // &
    Pipe,           // |
    Caret,          // ^
    Tilde,          // ~
    LeftShift,      // <<
    RightShift,     // >>
    
    // Assignment operators
    Assign,         // =
    AssignConst,    // :=
    AssignMut,      // ::=
    PlusEquals,     // +=
    MinusEquals,    // -=
    StarEquals,     // *=
    SlashEquals,    // /=
    
    // Delimiters
    LeftParen,      // (
    RightParen,     // )
    LeftBrace,      // {
    RightBrace,     // }
    LeftBracket,    // [
    RightBracket,   // ]
    
    // Punctuation
    Comma,          // ,
    Semicolon,      // ;
    Colon,          // :
    DoubleColon,    // ::
    Dot,            // .
    Range,          // ..
    Ellipsis,       // ...
    Arrow,          // ->
    FatArrow,       // =>
    Question,       // ?
    At,             // @
    
    // Special
    EOF,
    Newline,
    Comment,
    Unknown,        // For error handling
}

// Token structure
Token = {
    type: TokenType,
    value: String,
    line: i32,
    column: i32,
}

// Helper functions for token creation
create_token = (type: TokenType, value: String, line: i32, column: i32) Token {
    return Token {
        type: type,
        value: value,
        line: line,
        column: column,
    }
}

// Check if a string is a keyword
is_keyword = (s: String) bool {
    // Keywords in Zen
    keywords := [
        // Control flow
        "if", "else", "loop", "break", "continue", "return",
        // Declarations
        "fn", "struct", "enum", "impl", "behavior", "type",
        // Modifiers
        "extern", "comptime", "const", "mut", "pub",
        // Types
        "bool", "void", "String",
        "i8", "i16", "i32", "i64",
        "u8", "u16", "u32", "u64",
        "f32", "f64",
        "isize", "usize",
        // Special
        "self", "Self", "import", "export", "module"
    ]
    
    // Simple linear search for now
    i := 0
    loop (i < keywords.len()) {
        keywords[i] == s ? | true => { return true } | false => {}
        i = i + 1
    }
    
    return false
}

// Token type to string conversion
token_type_to_string = (t: TokenType) String {
    t ?
        | Integer => { return "Integer" }
        | Float => { return "Float" }
        | String => { return "String" }
        | Boolean => { return "Boolean" }
        | Character => { return "Character" }
        | Identifier => { return "Identifier" }
        | Keyword => { return "Keyword" }
        | Plus => { return "Plus" }
        | Minus => { return "Minus" }
        | Star => { return "Star" }
        | Slash => { return "Slash" }
        | Percent => { return "Percent" }
        | Equals => { return "Equals" }
        | NotEquals => { return "NotEquals" }
        | LessThan => { return "LessThan" }
        | LessThanEquals => { return "LessThanEquals" }
        | GreaterThan => { return "GreaterThan" }
        | GreaterThanEquals => { return "GreaterThanEquals" }
        | And => { return "And" }
        | Or => { return "Or" }
        | Not => { return "Not" }
        | Ampersand => { return "Ampersand" }
        | Pipe => { return "Pipe" }
        | Caret => { return "Caret" }
        | Tilde => { return "Tilde" }
        | LeftShift => { return "LeftShift" }
        | RightShift => { return "RightShift" }
        | Assign => { return "Assign" }
        | AssignConst => { return "AssignConst" }
        | AssignMut => { return "AssignMut" }
        | PlusEquals => { return "PlusEquals" }
        | MinusEquals => { return "MinusEquals" }
        | StarEquals => { return "StarEquals" }
        | SlashEquals => { return "SlashEquals" }
        | LeftParen => { return "LeftParen" }
        | RightParen => { return "RightParen" }
        | LeftBrace => { return "LeftBrace" }
        | RightBrace => { return "RightBrace" }
        | LeftBracket => { return "LeftBracket" }
        | RightBracket => { return "RightBracket" }
        | Comma => { return "Comma" }
        | Semicolon => { return "Semicolon" }
        | Colon => { return "Colon" }
        | DoubleColon => { return "DoubleColon" }
        | Dot => { return "Dot" }
        | Range => { return "Range" }
        | Ellipsis => { return "Ellipsis" }
        | Arrow => { return "Arrow" }
        | FatArrow => { return "FatArrow" }
        | Question => { return "Question" }
        | At => { return "At" }
        | EOF => { return "EOF" }
        | Newline => { return "Newline" }
        | Comment => { return "Comment" }
        | Unknown => { return "Unknown" }
}

// Token debugging
token_debug = (t: Token) String {
    return "[" + token_type_to_string(t.type) + ":" + t.value + " @" + 
           t.line.to_string() + ":" + t.column.to_string() + "]"
}