// Zen Type Checker - Self-hosted type checking implementation
// Performs semantic analysis and type validation

core := @std.core
io := @std.io
parser := @compiler.parser
token := @compiler.token

// Type kinds
TypeKind = enum {
    // Primitive types
    Void,
    Bool,
    I8, I16, I32, I64,
    U8, U16, U32, U64,
    F32, F64,
    String,
    
    // Composite types
    Array,
    Pointer,
    Function,
    Struct,
    Enum,
    
    // Special types
    Unknown,
    Error,
}

// Type representation
Type = {
    kind: TypeKind,
    name: String,
    
    // For arrays
    element_type: *Type,
    array_size: i32,
    
    // For pointers
    pointee_type: *Type,
    
    // For functions
    param_types: [*Type],
    return_type: *Type,
    
    // For structs
    fields: [*StructField],
    
    // For enums
    variants: [String],
}

// Struct field
StructField = {
    name: String,
    field_type: *Type,
    is_mutable: bool,
}

// Symbol information
Symbol = {
    name: String,
    symbol_type: *Type,
    is_mutable: bool,
    is_function: bool,
    is_type: bool,
}

// Scope for symbol management
Scope = {
    symbols: [*Symbol],
    parent: *Scope,
}

// Type checker context
TypeChecker = {
    current_scope: *Scope,
    errors: [String],
    current_function_return_type: *Type,
    in_loop: bool,
}

// Built-in types
VOID_TYPE := Type { kind: TypeKind.Void, name: "void" }
BOOL_TYPE := Type { kind: TypeKind.Bool, name: "bool" }
I32_TYPE := Type { kind: TypeKind.I32, name: "i32" }
I64_TYPE := Type { kind: TypeKind.I64, name: "i64" }
F32_TYPE := Type { kind: TypeKind.F32, name: "f32" }
F64_TYPE := Type { kind: TypeKind.F64, name: "f64" }
STRING_TYPE := Type { kind: TypeKind.String, name: "String" }

// Create a new type checker
type_checker_new = () TypeChecker {
    global_scope := Scope {
        symbols: [],
        parent: nullptr,
    }
    
    // Add built-in types to global scope
    add_builtin_types(&global_scope)
    
    return TypeChecker {
        current_scope: &global_scope,
        errors: [],
        current_function_return_type: &VOID_TYPE,
        in_loop: false,
    }
}

// Add built-in types to scope
add_builtin_types = (scope: *Scope) void {
    // Add primitive types
    scope.symbols.append(&Symbol {
        name: "void",
        symbol_type: &VOID_TYPE,
        is_type: true,
    })
    
    scope.symbols.append(&Symbol {
        name: "bool",
        symbol_type: &BOOL_TYPE,
        is_type: true,
    })
    
    scope.symbols.append(&Symbol {
        name: "i32",
        symbol_type: &I32_TYPE,
        is_type: true,
    })
    
    scope.symbols.append(&Symbol {
        name: "i64",
        symbol_type: &I64_TYPE,
        is_type: true,
    })
    
    scope.symbols.append(&Symbol {
        name: "f32",
        symbol_type: &F32_TYPE,
        is_type: true,
    })
    
    scope.symbols.append(&Symbol {
        name: "f64",
        symbol_type: &F64_TYPE,
        is_type: true,
    })
    
    scope.symbols.append(&Symbol {
        name: "String",
        symbol_type: &STRING_TYPE,
        is_type: true,
    })
}

// Enter a new scope
enter_scope = (tc: *TypeChecker) void {
    new_scope := Scope {
        symbols: [],
        parent: tc.current_scope,
    }
    tc.current_scope = &new_scope
}

// Exit current scope
exit_scope = (tc: *TypeChecker) void {
    tc.current_scope.parent != nullptr ? | true => {
        tc.current_scope = tc.current_scope.parent
    } | false => {
        tc.errors.append("Cannot exit global scope")
    }
}

// Look up a symbol
lookup_symbol = (tc: *TypeChecker, name: String) *Symbol {
    mut scope := tc.current_scope
    
    loop (scope != nullptr) {
        i := 0
        loop (i < scope.symbols.len()) {
            scope.symbols[i].name == name ? | true => {
                return scope.symbols[i]
            } | false => {}
            i = i + 1
        }
        scope = scope.parent
    }
    
    return nullptr
}

// Add a symbol to current scope
add_symbol = (tc: *TypeChecker, symbol: *Symbol) bool {
    // Check for duplicates in current scope
    i := 0
    loop (i < tc.current_scope.symbols.len()) {
        tc.current_scope.symbols[i].name == symbol.name ? | true => {
            tc.errors.append("Duplicate symbol: " + symbol.name)
            return false
        } | false => {}
        i = i + 1
    }
    
    tc.current_scope.symbols.append(symbol)
    return true
}

// Resolve type from name
resolve_type = (tc: *TypeChecker, type_name: String) *Type {
    sym := lookup_symbol(tc, type_name)
    
    sym != nullptr && sym.is_type ? | true => {
        return sym.symbol_type
    } | false => {
        tc.errors.append("Unknown type: " + type_name)
        return &Type { kind: TypeKind.Error }
    }
}

// Check if types are compatible
types_compatible = (t1: *Type, t2: *Type) bool {
    // Same type
    t1.kind == t2.kind ? | true => {
        // For arrays, check element type and size
        t1.kind == TypeKind.Array ? | true => {
            return types_compatible(t1.element_type, t2.element_type) &&
                   t1.array_size == t2.array_size
        } | false => {}
        
        // For pointers, check pointee type
        t1.kind == TypeKind.Pointer ? | true => {
            return types_compatible(t1.pointee_type, t2.pointee_type)
        } | false => {}
        
        return true
    } | false => {}
    
    // Numeric promotions
    is_numeric(t1) && is_numeric(t2) ? | true => {
        return can_promote(t1, t2)
    } | false => {}
    
    return false
}

// Check if type is numeric
is_numeric = (t: *Type) bool {
    return t.kind == TypeKind.I8 || t.kind == TypeKind.I16 || 
           t.kind == TypeKind.I32 || t.kind == TypeKind.I64 ||
           t.kind == TypeKind.U8 || t.kind == TypeKind.U16 || 
           t.kind == TypeKind.U32 || t.kind == TypeKind.U64 ||
           t.kind == TypeKind.F32 || t.kind == TypeKind.F64
}

// Check if t1 can be promoted to t2
can_promote = (t1: *Type, t2: *Type) bool {
    // Simplified promotion rules
    // Integer to larger integer
    (t1.kind == TypeKind.I32 && t2.kind == TypeKind.I64) ? | true => { return true } | false => {}
    
    // Integer to float
    (is_integer(t1) && is_float(t2)) ? | true => { return true } | false => {}
    
    return false
}

// Check if type is integer
is_integer = (t: *Type) bool {
    return t.kind == TypeKind.I8 || t.kind == TypeKind.I16 || 
           t.kind == TypeKind.I32 || t.kind == TypeKind.I64 ||
           t.kind == TypeKind.U8 || t.kind == TypeKind.U16 || 
           t.kind == TypeKind.U32 || t.kind == TypeKind.U64
}

// Check if type is float
is_float = (t: *Type) bool {
    return t.kind == TypeKind.F32 || t.kind == TypeKind.F64
}

// Type check an AST node
type_check_node = (tc: *TypeChecker, node: *parser.AstNode) *Type {
    node.type == parser.NodeType.Literal ? | true => {
        // Determine literal type
        node.int_value != 0 ? | true => { return &I32_TYPE } | false => {}
        node.float_value != 0.0 ? | true => { return &F64_TYPE } | false => {}
        node.string_value.len() > 0 ? | true => { return &STRING_TYPE } | false => {}
        return &BOOL_TYPE  // for bool_value
    } | false => {}
    
    node.type == parser.NodeType.Identifier ? | true => {
        sym := lookup_symbol(tc, node.name)
        sym != nullptr ? | true => {
            return sym.symbol_type
        } | false => {
            tc.errors.append("Undefined identifier: " + node.name)
            return &Type { kind: TypeKind.Error }
        }
    } | false => {}
    
    node.type == parser.NodeType.Binary ? | true => {
        left_type := type_check_node(tc, node.left)
        right_type := type_check_node(tc, node.right)
        
        // Check operator compatibility
        return type_check_binary_op(tc, node.operator, left_type, right_type)
    } | false => {}
    
    node.type == parser.NodeType.FunctionCall ? | true => {
        callee_type := type_check_node(tc, node.callee)
        
        callee_type.kind == TypeKind.Function ? | true => {
            // Check argument count
            node.arguments.len() != callee_type.param_types.len() ? | true => {
                tc.errors.append("Argument count mismatch")
                return &Type { kind: TypeKind.Error }
            } | false => {}
            
            // Check argument types
            i := 0
            loop (i < node.arguments.len()) {
                arg_type := type_check_node(tc, node.arguments[i])
                !types_compatible(arg_type, callee_type.param_types[i]) ? | true => {
                    tc.errors.append("Argument type mismatch")
                } | false => {}
                i = i + 1
            }
            
            return callee_type.return_type
        } | false => {
            tc.errors.append("Cannot call non-function")
            return &Type { kind: TypeKind.Error }
        }
    } | false => {}
    
    node.type == parser.NodeType.Return ? | true => {
        node.operand != nullptr ? | true => {
            ret_type := type_check_node(tc, node.operand)
            !types_compatible(ret_type, tc.current_function_return_type) ? | true => {
                tc.errors.append("Return type mismatch")
            } | false => {}
        } | false => {
            tc.current_function_return_type.kind != TypeKind.Void ? | true => {
                tc.errors.append("Missing return value")
            } | false => {}
        }
        return &VOID_TYPE
    } | false => {}
    
    // Add more node type checking...
    
    return &Type { kind: TypeKind.Unknown }
}

// Type check binary operator
type_check_binary_op = (tc: *TypeChecker, op: String, left: *Type, right: *Type) *Type {
    // Arithmetic operators
    (op == "+" || op == "-" || op == "*" || op == "/" || op == "%") ? | true => {
        is_numeric(left) && is_numeric(right) ? | true => {
            // Return the larger type
            return left  // Simplified - should determine larger type
        } | false => {
            tc.errors.append("Arithmetic operator requires numeric types")
            return &Type { kind: TypeKind.Error }
        }
    } | false => {}
    
    // Comparison operators
    (op == "<" || op == ">" || op == "<=" || op == ">=" || op == "==" || op == "!=") ? | true => {
        types_compatible(left, right) ? | true => {
            return &BOOL_TYPE
        } | false => {
            tc.errors.append("Cannot compare incompatible types")
            return &Type { kind: TypeKind.Error }
        }
    } | false => {}
    
    // Logical operators
    (op == "&&" || op == "||") ? | true => {
        left.kind == TypeKind.Bool && right.kind == TypeKind.Bool ? | true => {
            return &BOOL_TYPE
        } | false => {
            tc.errors.append("Logical operator requires boolean types")
            return &Type { kind: TypeKind.Error }
        }
    } | false => {}
    
    tc.errors.append("Unknown operator: " + op)
    return &Type { kind: TypeKind.Error }
}

// Type check a statement
type_check_statement = (tc: *TypeChecker, stmt: *parser.AstNode) void {
    stmt.type == parser.NodeType.VariableDecl ? | true => {
        // Check initializer type
        stmt.initializer != nullptr ? | true => {
            init_type := type_check_node(tc, stmt.initializer)
            
            // If type is specified, check compatibility
            stmt.var_type != nullptr ? | true => {
                var_type := resolve_type(tc, stmt.var_type.name)
                !types_compatible(init_type, var_type) ? | true => {
                    tc.errors.append("Type mismatch in variable declaration")
                } | false => {}
            } | false => {
                // Infer type from initializer
                stmt.var_type = init_type
            }
            
            // Add to symbol table
            sym := Symbol {
                name: stmt.name,
                symbol_type: stmt.var_type,
                is_mutable: stmt.is_mutable,
            }
            add_symbol(tc, &sym)
        } | false => {
            tc.errors.append("Variable must be initialized")
        }
    } | false => {}
    
    stmt.type == parser.NodeType.FunctionDecl ? | true => {
        // Create function type
        func_type := Type {
            kind: TypeKind.Function,
            param_types: [],
            return_type: resolve_type(tc, stmt.return_type.name),
        }
        
        // Add function to symbol table
        func_sym := Symbol {
            name: stmt.name,
            symbol_type: &func_type,
            is_function: true,
        }
        add_symbol(tc, &func_sym)
        
        // Enter function scope
        enter_scope(tc)
        tc.current_function_return_type = func_type.return_type
        
        // Add parameters to scope
        i := 0
        loop (i < stmt.params.len()) {
            param := stmt.params[i]
            param_type := resolve_type(tc, param.var_type.name)
            func_type.param_types.append(param_type)
            
            param_sym := Symbol {
                name: param.name,
                symbol_type: param_type,
                is_mutable: false,
            }
            add_symbol(tc, &param_sym)
            i = i + 1
        }
        
        // Type check function body
        type_check_statement(tc, stmt.body)
        
        // Exit function scope
        exit_scope(tc)
        tc.current_function_return_type = &VOID_TYPE
    } | false => {}
    
    stmt.type == parser.NodeType.Block ? | true => {
        enter_scope(tc)
        i := 0
        loop (i < stmt.statements.len()) {
            type_check_statement(tc, stmt.statements[i])
            i = i + 1
        }
        exit_scope(tc)
    } | false => {}
    
    stmt.type == parser.NodeType.If ? | true => {
        condition_type := type_check_node(tc, stmt.condition)
        condition_type.kind != TypeKind.Bool ? | true => {
            tc.errors.append("If condition must be boolean")
        } | false => {}
        
        type_check_statement(tc, stmt.then_branch)
        stmt.else_branch != nullptr ? | true => {
            type_check_statement(tc, stmt.else_branch)
        } | false => {}
    } | false => {}
    
    stmt.type == parser.NodeType.Loop ? | true => {
        stmt.condition != nullptr ? | true => {
            condition_type := type_check_node(tc, stmt.condition)
            condition_type.kind != TypeKind.Bool ? | true => {
                tc.errors.append("Loop condition must be boolean")
            } | false => {}
        } | false => {}
        
        tc.in_loop = true
        type_check_statement(tc, stmt.body)
        tc.in_loop = false
    } | false => {}
    
    stmt.type == parser.NodeType.Break || stmt.type == parser.NodeType.Continue ? | true => {
        !tc.in_loop ? | true => {
            tc.errors.append("Break/continue must be inside a loop")
        } | false => {}
    } | false => {}
    
    stmt.type == parser.NodeType.ExpressionStmt ? | true => {
        type_check_node(tc, stmt.operand)
    } | false => {}
    
    // Add more statement type checking...
}

// Type check a program
type_check_program = (tc: *TypeChecker, program: *parser.AstNode) bool {
    program.type != parser.NodeType.Program ? | true => {
        tc.errors.append("Expected program node")
        return false
    } | false => {}
    
    i := 0
    loop (i < program.statements.len()) {
        type_check_statement(tc, program.statements[i])
        i = i + 1
    }
    
    return tc.errors.len() == 0
}

// Main test function
main = () i32 {
    io.print("Zen Type Checker - Self-hosting component\n")
    io.print("=========================================\n\n")
    
    // Create type checker
    tc := type_checker_new()
    
    io.print("Type checker initialized with built-in types\n")
    io.print("Ready for type checking!\n")
    
    return 0
}