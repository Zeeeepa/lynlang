// Zen Code Generator - Self-hosted code generation implementation
// Generates LLVM IR or C code from typed AST

core := @std.core
io := @std.io
string := @std.string
vec := @std.vec
parser := @compiler.parser
type_checker := @compiler.type_checker
symbol_table := @compiler.symbol_table

// Code generation target
Target = enum {
    LLVM_IR,
    C,
    Assembly,
}

// Code generator context
CodeGen = {
    target: Target,
    output: String,
    indent_level: i32,
    temp_counter: i32,
    label_counter: i32,
    register_counter: i32,
    errors: vec.Vec<String>,
    current_function: String,
    in_main: bool,
    symbols: *symbol_table.SymbolTable,
    string_literals: vec.Vec<String>,
    global_vars: vec.Vec<String>,
}

// Create new code generator
codegen_new = (target: Target, symbols: *symbol_table.SymbolTable) CodeGen {
    return CodeGen {
        target: target,
        output: "",
        indent_level: 0,
        temp_counter: 0,
        label_counter: 0,
        register_counter: 0,
        errors: vec.new<String>(),
        current_function: "",
        in_main: false,
        symbols: symbols,
        string_literals: vec.new<String>(),
        global_vars: vec.new<String>(),
    }
}

// Generate a temporary variable name
gen_temp = (cg: *CodeGen) String {
    name := "t" + string.from_int(cg.temp_counter)
    cg.temp_counter = cg.temp_counter + 1
    return name
}

// Generate an LLVM register name
gen_register = (cg: *CodeGen) String {
    name := "%" + string.from_int(cg.register_counter)
    cg.register_counter = cg.register_counter + 1
    return name
}

// Generate a label name
gen_label = (cg: *CodeGen) String {
    name := "L" + string.from_int(cg.label_counter)
    cg.label_counter = cg.label_counter + 1
    return name
}

// Add string literal and return its index
add_string_literal = (cg: *CodeGen, str: String) i32 {
    vec.push<String>(&cg.string_literals, str)
    return vec.len<String>(cg.string_literals) - 1
}

// Emit code with proper indentation
emit = (cg: *CodeGen, code: String) void {
    i := 0
    loop (i < cg.indent_level) {
        cg.output = cg.output + "  "
        i = i + 1
    }
    cg.output = cg.output + code + "\n"
}

// Emit raw code without indentation
emit_raw = (cg: *CodeGen, code: String) void {
    cg.output = cg.output + code
}

// Convert Zen type to C type
zen_type_to_c = (t: *type_checker.Type) String {
    t.kind == type_checker.TypeKind.Void ? | true => { return "void" } | false => {}
    t.kind == type_checker.TypeKind.Bool ? | true => { return "bool" } | false => {}
    t.kind == type_checker.TypeKind.I8 ? | true => { return "int8_t" } | false => {}
    t.kind == type_checker.TypeKind.I16 ? | true => { return "int16_t" } | false => {}
    t.kind == type_checker.TypeKind.I32 ? | true => { return "int32_t" } | false => {}
    t.kind == type_checker.TypeKind.I64 ? | true => { return "int64_t" } | false => {}
    t.kind == type_checker.TypeKind.U8 ? | true => { return "uint8_t" } | false => {}
    t.kind == type_checker.TypeKind.U16 ? | true => { return "uint16_t" } | false => {}
    t.kind == type_checker.TypeKind.U32 ? | true => { return "uint32_t" } | false => {}
    t.kind == type_checker.TypeKind.U64 ? | true => { return "uint64_t" } | false => {}
    t.kind == type_checker.TypeKind.F32 ? | true => { return "float" } | false => {}
    t.kind == type_checker.TypeKind.F64 ? | true => { return "double" } | false => {}
    t.kind == type_checker.TypeKind.String ? | true => { return "char*" } | false => {}
    t.kind == type_checker.TypeKind.Pointer ? | true => {
        return zen_type_to_c(t.pointee_type) + "*"
    } | false => {}
    
    return "unknown_type"
}

// Convert Zen type to LLVM type
zen_type_to_llvm = (t: *type_checker.Type) String {
    t.kind == type_checker.TypeKind.Void ? | true => { return "void" } | false => {}
    t.kind == type_checker.TypeKind.Bool ? | true => { return "i1" } | false => {}
    t.kind == type_checker.TypeKind.I8 ? | true => { return "i8" } | false => {}
    t.kind == type_checker.TypeKind.I16 ? | true => { return "i16" } | false => {}
    t.kind == type_checker.TypeKind.I32 ? | true => { return "i32" } | false => {}
    t.kind == type_checker.TypeKind.I64 ? | true => { return "i64" } | false => {}
    t.kind == type_checker.TypeKind.U8 ? | true => { return "i8" } | false => {}
    t.kind == type_checker.TypeKind.U16 ? | true => { return "i16" } | false => {}
    t.kind == type_checker.TypeKind.U32 ? | true => { return "i32" } | false => {}
    t.kind == type_checker.TypeKind.U64 ? | true => { return "i64" } | false => {}
    t.kind == type_checker.TypeKind.F32 ? | true => { return "float" } | false => {}
    t.kind == type_checker.TypeKind.F64 ? | true => { return "double" } | false => {}
    t.kind == type_checker.TypeKind.String ? | true => { return "i8*" } | false => {}
    t.kind == type_checker.TypeKind.Pointer ? | true => {
        return zen_type_to_llvm(t.pointee_type) + "*"
    } | false => {}
    
    return "unknown_type"
}

// Generate code for expression (C target)
gen_expr_c = (cg: *CodeGen, node: *parser.AstNode) String {
    node.type == parser.NodeType.Literal ? | true => {
        node.int_value != 0 ? | true => { return node.int_value.to_string() } | false => {}
        node.float_value != 0.0 ? | true => { return node.float_value.to_string() } | false => {}
        node.string_value.len() > 0 ? | true => { 
            return "\"" + node.string_value + "\""
        } | false => {}
        node.bool_value ? | true => { return "true" } | false => { return "false" }
    } | false => {}
    
    node.type == parser.NodeType.Identifier ? | true => {
        return node.name
    } | false => {}
    
    node.type == parser.NodeType.Binary ? | true => {
        left := gen_expr_c(cg, node.left)
        right := gen_expr_c(cg, node.right)
        return "(" + left + " " + node.operator + " " + right + ")"
    } | false => {}
    
    node.type == parser.NodeType.Unary ? | true => {
        operand := gen_expr_c(cg, node.operand)
        return "(" + node.operator + operand + ")"
    } | false => {}
    
    node.type == parser.NodeType.FunctionCall ? | true => {
        call := gen_expr_c(cg, node.callee) + "("
        i := 0
        loop (i < node.arguments.len()) {
            i > 0 ? | true => { call = call + ", " } | false => {}
            call = call + gen_expr_c(cg, node.arguments[i])
            i = i + 1
        }
        call = call + ")"
        return call
    } | false => {}
    
    node.type == parser.NodeType.MemberAccess ? | true => {
        obj := gen_expr_c(cg, node.left)
        return obj + "." + node.name
    } | false => {}
    
    node.type == parser.NodeType.ArrayAccess ? | true => {
        arr := gen_expr_c(cg, node.left)
        index := gen_expr_c(cg, node.right)
        return arr + "[" + index + "]"
    } | false => {}
    
    return "/* unknown expression */"
}

// Generate code for statement (C target)
gen_stmt_c = (cg: *CodeGen, node: *parser.AstNode) void {
    node.type == parser.NodeType.VariableDecl ? | true => {
        type_str := node.var_type != nullptr ? 
            | true => { zen_type_to_c(node.var_type) } 
            | false => { "auto" }
        
        emit(cg, type_str + " " + node.name)
        
        node.initializer != nullptr ? | true => {
            emit_raw(cg, " = " + gen_expr_c(cg, node.initializer))
        } | false => {}
        
        emit_raw(cg, ";")
    } | false => {}
    
    node.type == parser.NodeType.Assignment ? | true => {
        emit(cg, node.name + " = " + gen_expr_c(cg, node.operand) + ";")
    } | false => {}
    
    node.type == parser.NodeType.FunctionDecl ? | true => {
        // Generate function signature
        ret_type := zen_type_to_c(node.return_type)
        emit(cg, ret_type + " " + node.name + "(")
        
        // Parameters
        i := 0
        loop (i < node.params.len()) {
            i > 0 ? | true => { emit_raw(cg, ", ") } | false => {}
            param := node.params[i]
            param_type := zen_type_to_c(param.var_type)
            emit_raw(cg, param_type + " " + param.name)
            i = i + 1
        }
        
        emit_raw(cg, ") {")
        cg.indent_level = cg.indent_level + 1
        
        // Function body
        cg.current_function = node.name
        gen_stmt_c(cg, node.body)
        cg.current_function = ""
        
        cg.indent_level = cg.indent_level - 1
        emit(cg, "}")
        emit(cg, "")
    } | false => {}
    
    node.type == parser.NodeType.Block ? | true => {
        i := 0
        loop (i < node.statements.len()) {
            gen_stmt_c(cg, node.statements[i])
            i = i + 1
        }
    } | false => {}
    
    node.type == parser.NodeType.If ? | true => {
        condition := gen_expr_c(cg, node.condition)
        emit(cg, "if (" + condition + ") {")
        cg.indent_level = cg.indent_level + 1
        gen_stmt_c(cg, node.then_branch)
        cg.indent_level = cg.indent_level - 1
        
        node.else_branch != nullptr ? | true => {
            emit(cg, "} else {")
            cg.indent_level = cg.indent_level + 1
            gen_stmt_c(cg, node.else_branch)
            cg.indent_level = cg.indent_level - 1
        } | false => {}
        
        emit(cg, "}")
    } | false => {}
    
    node.type == parser.NodeType.Loop ? | true => {
        node.condition != nullptr ? | true => {
            condition := gen_expr_c(cg, node.condition)
            emit(cg, "while (" + condition + ") {")
        } | false => {
            emit(cg, "while (1) {")
        }
        
        cg.indent_level = cg.indent_level + 1
        gen_stmt_c(cg, node.body)
        cg.indent_level = cg.indent_level - 1
        emit(cg, "}")
    } | false => {}
    
    node.type == parser.NodeType.Return ? | true => {
        node.operand != nullptr ? | true => {
            emit(cg, "return " + gen_expr_c(cg, node.operand) + ";")
        } | false => {
            emit(cg, "return;")
        }
    } | false => {}
    
    node.type == parser.NodeType.Break ? | true => {
        emit(cg, "break;")
    } | false => {}
    
    node.type == parser.NodeType.Continue ? | true => {
        emit(cg, "continue;")
    } | false => {}
    
    node.type == parser.NodeType.ExpressionStmt ? | true => {
        emit(cg, gen_expr_c(cg, node.operand) + ";")
    } | false => {}
    
    node.type == parser.NodeType.PatternMatch ? | true => {
        // Generate pattern match as if-else chain
        scrutinee := gen_expr_c(cg, node.scrutinee)
        
        i := 0
        loop (i < node.arms.len()) {
            arm := node.arms[i]
            
            i == 0 ? | true => {
                emit(cg, "if (" + scrutinee + " == " + arm.pattern.identifier_name + ") {")
            } | false => {
                emit(cg, "} else if (" + scrutinee + " == " + arm.pattern.identifier_name + ") {")
            }
            
            cg.indent_level = cg.indent_level + 1
            gen_stmt_c(cg, arm.body)
            cg.indent_level = cg.indent_level - 1
            
            i = i + 1
        }
        
        emit(cg, "}")
    } | false => {}
}

// Generate C code for program
gen_program_c = (cg: *CodeGen, program: *parser.AstNode) void {
    // Generate includes
    emit(cg, "#include <stdio.h>")
    emit(cg, "#include <stdlib.h>")
    emit(cg, "#include <stdbool.h>")
    emit(cg, "#include <stdint.h>")
    emit(cg, "#include <string.h>")
    emit(cg, "")
    
    // Generate forward declarations
    emit(cg, "// Forward declarations")
    i := 0
    loop (i < program.statements.len()) {
        stmt := program.statements[i]
        stmt.type == parser.NodeType.FunctionDecl ? | true => {
            ret_type := zen_type_to_c(stmt.return_type)
            emit_raw(cg, ret_type + " " + stmt.name + "(")
            
            j := 0
            loop (j < stmt.params.len()) {
                j > 0 ? | true => { emit_raw(cg, ", ") } | false => {}
                param := stmt.params[j]
                param_type := zen_type_to_c(param.var_type)
                emit_raw(cg, param_type + " " + param.name)
                j = j + 1
            }
            
            emit_raw(cg, ");")
            emit(cg, "")
        } | false => {}
        i = i + 1
    }
    emit(cg, "")
    
    // Generate functions and global variables
    emit(cg, "// Functions and globals")
    i = 0
    loop (i < program.statements.len()) {
        gen_stmt_c(cg, program.statements[i])
        i = i + 1
    }
}

// Generate LLVM IR for expression
gen_expr_llvm = (cg: *CodeGen, node: *parser.AstNode, result: String) void {
    node.type == parser.NodeType.Literal ? | true => {
        node.int_value != 0 ? | true => {
            emit(cg, "  " + result + " = add i32 0, " + node.int_value.to_string())
        } | false => {}
        // Add more literal types...
    } | false => {}
    
    node.type == parser.NodeType.Binary ? | true => {
        left_temp := gen_temp(cg)
        right_temp := gen_temp(cg)
        
        gen_expr_llvm(cg, node.left, left_temp)
        gen_expr_llvm(cg, node.right, right_temp)
        
        op := node.operator
        op == "+" ? | true => {
            emit(cg, "  " + result + " = add i32 " + left_temp + ", " + right_temp)
        } | false => {}
        op == "-" ? | true => {
            emit(cg, "  " + result + " = sub i32 " + left_temp + ", " + right_temp)
        } | false => {}
        op == "*" ? | true => {
            emit(cg, "  " + result + " = mul i32 " + left_temp + ", " + right_temp)
        } | false => {}
        op == "/" ? | true => {
            emit(cg, "  " + result + " = sdiv i32 " + left_temp + ", " + right_temp)
        } | false => {}
    } | false => {}
    
    node.type == parser.NodeType.Identifier ? | true => {
        // Load variable from memory
        ptr_temp := gen_temp(cg)
        emit(cg, "  " + ptr_temp + " = alloca i32")
        emit(cg, "  " + result + " = load i32, i32* " + ptr_temp)
    } | false => {}
    
    node.type == parser.NodeType.FunctionCall ? | true => {
        // Generate function call
        args_temps := vec.new<String>()
        i := 0
        loop (i < node.arguments.len()) {
            arg_temp := gen_temp(cg)
            gen_expr_llvm(cg, node.arguments[i], arg_temp)
            vec.push<String>(&args_temps, arg_temp)
            i = i + 1
        }
        
        emit_raw(cg, "  " + result + " = call i32 @" + node.name + "(")
        i = 0
        loop (i < vec.len<String>(args_temps)) {
            i > 0 ? | true => { emit_raw(cg, ", ") } | false => {}
            emit_raw(cg, "i32 " + vec.get<String>(args_temps, i))
            i = i + 1
        }
        emit_raw(cg, ")\n")
    } | false => {}
}

// Generate LLVM IR for statement
gen_stmt_llvm = (cg: *CodeGen, node: *parser.AstNode) void {
    node.type == parser.NodeType.FunctionDecl ? | true => {
        ret_type := zen_type_to_llvm(node.return_type)
        emit_raw(cg, "define " + ret_type + " @" + node.name + "(")
        
        // Parameters
        i := 0
        loop (i < node.params.len()) {
            i > 0 ? | true => { emit_raw(cg, ", ") } | false => {}
            param := node.params[i]
            param_type := zen_type_to_llvm(param.var_type)
            emit_raw(cg, param_type + " %" + param.name)
            i = i + 1
        }
        
        emit_raw(cg, ") {")
        emit(cg, "entry:")
        
        // Function body
        cg.current_function = node.name
        gen_stmt_llvm(cg, node.body)
        cg.current_function = ""
        
        emit(cg, "}")
        emit(cg, "")
    } | false => {}
    
    node.type == parser.NodeType.Return ? | true => {
        node.operand != nullptr ? | true => {
            temp := gen_temp(cg)
            gen_expr_llvm(cg, node.operand, temp)
            emit(cg, "  ret i32 " + temp)
        } | false => {
            emit(cg, "  ret void")
        }
    } | false => {}
    
    node.type == parser.NodeType.VariableDecl ? | true => {
        // Allocate local variable
        type_str := zen_type_to_llvm(node.var_type)
        emit(cg, "  %" + node.name + " = alloca " + type_str)
        
        node.initializer != nullptr ? | true => {
            temp := gen_temp(cg)
            gen_expr_llvm(cg, node.initializer, temp)
            emit(cg, "  store " + type_str + " " + temp + ", " + type_str + "* %" + node.name)
        } | false => {}
    } | false => {}
    
    node.type == parser.NodeType.Assignment ? | true => {
        temp := gen_temp(cg)
        gen_expr_llvm(cg, node.operand, temp)
        type_str := zen_type_to_llvm(node.var_type)
        emit(cg, "  store " + type_str + " " + temp + ", " + type_str + "* %" + node.name)
    } | false => {}
    
    node.type == parser.NodeType.Block ? | true => {
        i := 0
        loop (i < node.statements.len()) {
            gen_stmt_llvm(cg, node.statements[i])
            i = i + 1
        }
    } | false => {}
    
    node.type == parser.NodeType.If ? | true => {
        cond_temp := gen_temp(cg)
        gen_expr_llvm(cg, node.condition, cond_temp)
        
        then_label := gen_label(cg)
        else_label := gen_label(cg)
        end_label := gen_label(cg)
        
        emit(cg, "  br i1 " + cond_temp + ", label %" + then_label + ", label %" + else_label)
        
        emit(cg, then_label + ":")
        gen_stmt_llvm(cg, node.then_branch)
        emit(cg, "  br label %" + end_label)
        
        emit(cg, else_label + ":")
        node.else_branch != nullptr ? | true => {
            gen_stmt_llvm(cg, node.else_branch)
        } | false => {}
        emit(cg, "  br label %" + end_label)
        
        emit(cg, end_label + ":")
    } | false => {}
    
    node.type == parser.NodeType.Loop ? | true => {
        loop_label := gen_label(cg)
        body_label := gen_label(cg)
        end_label := gen_label(cg)
        
        emit(cg, "  br label %" + loop_label)
        emit(cg, loop_label + ":")
        
        node.condition != nullptr ? | true => {
            cond_temp := gen_temp(cg)
            gen_expr_llvm(cg, node.condition, cond_temp)
            emit(cg, "  br i1 " + cond_temp + ", label %" + body_label + ", label %" + end_label)
        } | false => {
            emit(cg, "  br label %" + body_label)
        }
        
        emit(cg, body_label + ":")
        gen_stmt_llvm(cg, node.body)
        emit(cg, "  br label %" + loop_label)
        
        emit(cg, end_label + ":")
    } | false => {}
}

// Generate code for program
generate_program = (cg: *CodeGen, program: *parser.AstNode) bool {
    program.type != parser.NodeType.Program ? | true => {
        cg.errors.append("Expected program node")
        return false
    } | false => {}
    
    cg.target == Target.C ? | true => {
        gen_program_c(cg, program)
    } | false => {}
    
    cg.target == Target.LLVM_IR ? | true => {
        // Generate LLVM IR header
        emit(cg, "; ModuleID = 'zen_program'")
        emit(cg, "source_filename = \"zen_program\"")
        emit(cg, "")
        
        // Generate declarations
        emit(cg, "; External declarations")
        emit(cg, "declare i32 @printf(i8*, ...)")
        emit(cg, "")
        
        // Generate functions
        i := 0
        loop (i < program.statements.len()) {
            gen_stmt_llvm(cg, program.statements[i])
            i = i + 1
        }
    } | false => {}
    
    return cg.errors.len() == 0
}

// Compile a Zen source file to target code
compile_file = (source_file: String, target: Target, output_file: String) bool {
    // Read source file
    source := io.read_file(source_file)
    string.is_empty(source) ? | true => {
        io.print("Error: Could not read source file\n")
        return false
    } | false => {}
    
    // Create lexer and tokenize
    lexer := @compiler.lexer
    lex := lexer.lexer_new(source)
    tokens := lexer.tokenize(&lex)
    
    vec.len<lexer.Token>(tokens) == 0 ? | true => {
        io.print("Error: No tokens generated\n")
        return false
    } | false => {}
    
    // Parse tokens to AST
    parse := parser.parser_new(tokens)
    ast := parser.parse(&parse)
    
    vec.len<String>(parse.errors) > 0 ? | true => {
        io.print("Parser errors:\n")
        i := 0
        loop (i < vec.len<String>(parse.errors)) {
            io.print("  - ")
            io.print(vec.get<String>(parse.errors, i))
            io.print("\n")
            i = i + 1
        }
        return false
    } | false => {}
    
    // Type check the AST
    symbols := symbol_table.symbol_table_new()
    checker := type_checker.type_checker_new(&symbols)
    type_checker.check_program(&checker, ast)
    
    vec.len<String>(checker.errors) > 0 ? | true => {
        io.print("Type checker errors:\n")
        i := 0
        loop (i < vec.len<String>(checker.errors)) {
            io.print("  - ")
            io.print(vec.get<String>(checker.errors, i))
            io.print("\n")
            i = i + 1
        }
        return false
    } | false => {}
    
    // Generate code
    cg := codegen_new(target, &symbols)
    success := generate_program(&cg, ast)
    
    success ? | false => {
        io.print("Code generation errors:\n")
        i := 0
        loop (i < vec.len<String>(cg.errors)) {
            io.print("  - ")
            io.print(vec.get<String>(cg.errors, i))
            io.print("\n")
            i = i + 1
        }
        return false
    } | true => {}
    
    // Write output file
    io.write_file(output_file, cg.output)
    
    io.print("Successfully compiled ")
    io.print(source_file)
    io.print(" to ")
    io.print(output_file)
    io.print("\n")
    
    return true
}

// Main test function
main = () i32 {
    io.print("Zen Code Generator - Self-hosting component\n")
    io.print("===========================================\n\n")
    
    // Test compilation
    test_source := "
fn add(a: i32, b: i32) i32 {
    return a + b
}

fn main() i32 {
    x := 10
    y := 20
    result := add(x, y)
    return result
}"
    
    // Write test source to file
    io.write_file("test.zen", test_source)
    
    // Test C generation
    io.print("Testing C code generation...\n")
    compile_file("test.zen", Target.C, "test.c") ? | true => {
        io.print("C generation successful!\n")
    } | false => {
        io.print("C generation failed!\n")
    }
    
    io.print("\n")
    
    // Test LLVM IR generation
    io.print("Testing LLVM IR generation...\n")
    compile_file("test.zen", Target.LLVM_IR, "test.ll") ? | true => {
        io.print("LLVM IR generation successful!\n")
    } | false => {
        io.print("LLVM IR generation failed!\n")
    }
    
    return 0
}