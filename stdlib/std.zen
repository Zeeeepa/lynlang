// Zen Standard Library - Main entry point
// Clean aggregator that imports from specialized modules

// ==========================================
// Core Types & Memory Management  
// ==========================================

// Import core types
{ Option } = import("core/option")
{ Result } = import("core/result")

// Memory management functions
memory = import("memory")
{ malloc, free, memcpy, memset, Allocator, system_allocator } = memory

// ==========================================
// Collections
// ==========================================

// Import vector types from vec module
vec_module = import("vec")
{ Vec, DynVec, VecIterator } = vec_module

// Import other collections from collections/
collections = import("collections")
{ HashMap, HashEntry, List, ListNode } = collections

// Import Stack and Queue (they have their own modules)
stack_module = import("stack")
{ Stack } = stack_module
queue_module = import("queue")
{ Queue } = queue_module

// For backward compatibility, re-export collection functions
// with original names from stdlib.zen
vec_new = Vec.new
vec_push = Vec.push
vec_pop = Vec.pop
vec_get = Vec.get
vec_set = Vec.set
vec_clear = Vec.clear

hashmap_new = HashMap.new
hashmap_insert = HashMap.insert
hashmap_get = HashMap.get
hashmap_remove = HashMap.remove

// ==========================================
// String Operations & Other Utilities
// ==========================================

// Import string functionality
string_module = import("string/string")
{ String, strlen, strcmp, strcpy, strcat, string_new, string_from_cstr, 
  string_append, string_equals, string_free } = string_module

// ==========================================
// Math & Other Modules
// ==========================================

// Import math functions
math = import("math")

// Import additional utilities as needed
// testing = import("testing")
// concurrent = import("concurrent")
// json = import("json")
// http = import("http")

// ==========================================
// Helper Functions & Utilities
// ==========================================

// Core utility functions
panic = (msg: RawPtr<i8>) void {
    inline.c("""
        panic(${msg.addr});
    """)
}

sizeof<T> = () i64 {
    inline.c("""
        return sizeof(T);
    """)
}

printf = (format: RawPtr<i8>, ...) i32 {
    inline.c("""
        return printf(${format.addr}, ...);
    """)
}

// ==========================================
// Option & Result Helper Functions
// ==========================================

option_is_some<T>: (opt: Option<T>) bool = {
    opt ?
        | Some(_) { return true }
        | None { return false }
}

option_is_none<T>: (opt: Option<T>) bool  = {
    return !option_is_some(opt)
}

option_unwrap<T>: (opt: Option<T>) T = {
    opt ?
        | Some(value) { return value }
        | None { panic("Attempted to unwrap None") }
}

option_unwrap_or<T>: (opt: Option<T>, default: T) T = {
    opt ?
        | Some(value) { return value }
        | None { return default }
}

result_is_ok<T, E>: (res: Result<T, E>) bool = {
    res ?
        | Ok(_) { return true }
        | Err(_) { return false }
}

result_is_err<T, E>: (res: Result<T, E>) bool  = {
    return !result_is_ok(res)
}

result_unwrap<T, E>: (res: Result<T, E>) T = {
    res ?
        | Ok(value) { return value }
        | Err(_) { panic("Attempted to unwrap Err") }
}

result_unwrap_err<T, E>: (res: Result<T, E>) E = {
    res ?
        | Ok(_) { panic("Attempted to unwrap_err on Ok") }
        | Err(error) { return error }
}