// Zen Standard Library: Enhanced Testing Framework
// Comprehensive testing utilities for self-hosting

core := @std.core
string := @std.string
io := @std.io
vec := @std.vec
result := @std.result
process := @std.process
fs := @std.fs

// Test result types
TestResult = enum {
    Pass
    Fail(message: string)
    Skip(reason: string)
    Panic(message: string)
}

// Test case structure
TestCase = struct {
    name: string
    test_fn: () TestResult
    timeout_ms: Option<u64>
    should_panic: bool
    ignore: bool
    ignore_reason: Option<string>
}

// Test suite structure
TestSuite = struct {
    name: string
    tests: Vec<TestCase>
    setup: Option<() void>
    teardown: Option<() void>
    parallel: bool
}

// Test runner statistics
TestStats = struct {
    total: u64
    passed: u64
    failed: u64
    skipped: u64
    panicked: u64
    duration_ms: u64
}

// Test runner configuration
TestConfig = struct {
    filter: Option<string>
    parallel: bool
    verbose: bool
    quiet: bool
    fail_fast: bool
    show_output: bool
    test_threads: u64
    timeout_ms: u64
    color: bool
}

// Global test registry
TEST_REGISTRY := vec.new<TestSuite>()

// Global test configuration
TEST_CONFIG := TestConfig {
    filter: none
    parallel: true
    verbose: false
    quiet: false
    fail_fast: false
    show_output: false
    test_threads: process.num_cpus()
    timeout_ms: 60000
    color: true
}

// Assertion context for better error messages
AssertContext = struct {
    file: string
    line: u32
    expression: string
}

// Register a test suite
suite = (name: string) TestSuite {
    return TestSuite {
        name: name
        tests: vec.new<TestCase>()
        setup: none
        teardown: none
        parallel: true
    }
}

// Add test to suite
test = (suite: *TestSuite, name: string, test_fn: () TestResult) void {
    suite.tests.push(TestCase {
        name: name
        test_fn: test_fn
        timeout_ms: none
        should_panic: false
        ignore: false
        ignore_reason: none
    })
}

// Add ignored test
ignore_test = (suite: *TestSuite, name: string, reason: string, test_fn: () TestResult) void {
    suite.tests.push(TestCase {
        name: name
        test_fn: test_fn
        timeout_ms: none
        should_panic: false
        ignore: true
        ignore_reason: some(reason)
    })
}

// Add test that should panic
should_panic = (suite: *TestSuite, name: string, test_fn: () TestResult) void {
    suite.tests.push(TestCase {
        name: name
        test_fn: test_fn
        timeout_ms: none
        should_panic: true
        ignore: false
        ignore_reason: none
    })
}

// Set suite setup function
setup = (suite: *TestSuite, setup_fn: () void) void {
    suite.setup = some(setup_fn)
}

// Set suite teardown function
teardown = (suite: *TestSuite, teardown_fn: () void) void {
    suite.teardown = some(teardown_fn)
}

// Basic assertions
assert = (condition: bool) TestResult {
    if !condition {
        return TestResult.Fail("Assertion failed")
    }
    return TestResult.Pass
}

assert_msg = (condition: bool, message: string) TestResult {
    if !condition {
        return TestResult.Fail(message)
    }
    return TestResult.Pass
}

assert_eq = <T>(left: T, right: T) TestResult {
    if left != right {
        return TestResult.Fail(string.format("Assertion failed: {} != {}", left, right))
    }
    return TestResult.Pass
}

assert_ne = <T>(left: T, right: T) TestResult {
    if left == right {
        return TestResult.Fail(string.format("Assertion failed: {} == {}", left, right))
    }
    return TestResult.Pass
}

assert_lt = <T>(left: T, right: T) TestResult {
    if !(left < right) {
        return TestResult.Fail(string.format("Assertion failed: {} >= {}", left, right))
    }
    return TestResult.Pass
}

assert_le = <T>(left: T, right: T) TestResult {
    if !(left <= right) {
        return TestResult.Fail(string.format("Assertion failed: {} > {}", left, right))
    }
    return TestResult.Pass
}

assert_gt = <T>(left: T, right: T) TestResult {
    if !(left > right) {
        return TestResult.Fail(string.format("Assertion failed: {} <= {}", left, right))
    }
    return TestResult.Pass
}

assert_ge = <T>(left: T, right: T) TestResult {
    if !(left >= right) {
        return TestResult.Fail(string.format("Assertion failed: {} < {}", left, right))
    }
    return TestResult.Pass
}

// String assertions
assert_contains = (haystack: string, needle: string) TestResult {
    if !string.contains(haystack, needle) {
        return TestResult.Fail(string.format("String '{}' does not contain '{}'", haystack, needle))
    }
    return TestResult.Pass
}

assert_starts_with = (text: string, prefix: string) TestResult {
    if !string.starts_with(text, prefix) {
        return TestResult.Fail(string.format("String '{}' does not start with '{}'", text, prefix))
    }
    return TestResult.Pass
}

assert_ends_with = (text: string, suffix: string) TestResult {
    if !string.ends_with(text, suffix) {
        return TestResult.Fail(string.format("String '{}' does not end with '{}'", text, suffix))
    }
    return TestResult.Pass
}

assert_matches = (text: string, pattern: string) TestResult {
    if !string.matches(text, pattern) {
        return TestResult.Fail(string.format("String '{}' does not match pattern '{}'", text, pattern))
    }
    return TestResult.Pass
}

// Collection assertions
assert_empty = <T>(collection: Vec<T>) TestResult {
    if !collection.is_empty() {
        return TestResult.Fail(string.format("Collection is not empty, has {} elements", collection.len()))
    }
    return TestResult.Pass
}

assert_not_empty = <T>(collection: Vec<T>) TestResult {
    if collection.is_empty() {
        return TestResult.Fail("Collection is empty")
    }
    return TestResult.Pass
}

assert_len = <T>(collection: Vec<T>, expected: u64) TestResult {
    actual := collection.len()
    if actual != expected {
        return TestResult.Fail(string.format("Collection has {} elements, expected {}", actual, expected))
    }
    return TestResult.Pass
}

assert_contains_elem = <T>(collection: Vec<T>, elem: T) TestResult {
    if !collection.contains(elem) {
        return TestResult.Fail(string.format("Collection does not contain element {}", elem))
    }
    return TestResult.Pass
}

// Option/Result assertions
assert_some = <T>(opt: Option<T>) TestResult {
    if opt.is_none() {
        return TestResult.Fail("Expected Some, got None")
    }
    return TestResult.Pass
}

assert_none = <T>(opt: Option<T>) TestResult {
    if opt.is_some() {
        return TestResult.Fail("Expected None, got Some")
    }
    return TestResult.Pass
}

assert_ok = <T, E>(res: Result<T, E>) TestResult {
    if res.is_err() {
        return TestResult.Fail("Expected Ok, got Err")
    }
    return TestResult.Pass
}

assert_err = <T, E>(res: Result<T, E>) TestResult {
    if res.is_ok() {
        return TestResult.Fail("Expected Err, got Ok")
    }
    return TestResult.Pass
}

// Float assertions with epsilon
assert_float_eq = (left: f64, right: f64, epsilon: f64) TestResult {
    diff := if left > right { left - right } else { right - left }
    if diff > epsilon {
        return TestResult.Fail(string.format("Float values differ: {} != {} (diff: {})", left, right, diff))
    }
    return TestResult.Pass
}

// Panic assertion
assert_panics = (f: () void) TestResult {
    // This would need runtime support for catching panics
    // For now, just call the function
    f()
    return TestResult.Fail("Function did not panic")
}

// Run a single test case
run_test = (test: TestCase) TestResult {
    if test.ignore {
        reason := test.ignore_reason.unwrap_or("ignored")
        return TestResult.Skip(reason)
    }
    
    // Set up panic handler if needed
    if test.should_panic {
        // Would need runtime support
        result := test.test_fn()
        if result == TestResult.Pass {
            return TestResult.Fail("Test should have panicked but didn't")
        }
        return TestResult.Pass
    }
    
    // Run with timeout if specified
    if let some(timeout) = test.timeout_ms {
        // Would need runtime support for timeouts
        return test.test_fn()
    }
    
    return test.test_fn()
}

// Run a test suite
run_suite = (suite: TestSuite, config: TestConfig) TestStats {
    stats := TestStats {
        total: suite.tests.len()
        passed: 0
        failed: 0
        skipped: 0
        panicked: 0
        duration_ms: 0
    }
    
    start_time := core.timestamp_ms()
    
    // Run setup if present
    if let some(setup_fn) = suite.setup {
        setup_fn()
    }
    
    // Run tests
    for test in suite.tests {
        // Apply filter if present
        if let some(filter) = config.filter {
            if !string.contains(test.name, filter) {
                stats.skipped += 1
                continue
            }
        }
        
        // Print test name if verbose
        if config.verbose {
            io.print(string.format("test {} ... ", test.name))
        }
        
        // Run test
        result := run_test(test)
        
        // Update stats and print result
        match result {
            TestResult.Pass => {
                stats.passed += 1
                if config.verbose {
                    print_colored("ok", Color.Green, config.color)
                }
            }
            TestResult.Fail(msg) => {
                stats.failed += 1
                if config.verbose {
                    print_colored("FAILED", Color.Red, config.color)
                }
                if !config.quiet {
                    io.println(string.format("  {}", msg))
                }
                if config.fail_fast {
                    break
                }
            }
            TestResult.Skip(reason) => {
                stats.skipped += 1
                if config.verbose {
                    print_colored("ignored", Color.Yellow, config.color)
                    io.println(string.format(" ({})", reason))
                }
            }
            TestResult.Panic(msg) => {
                stats.panicked += 1
                if config.verbose {
                    print_colored("PANIC", Color.Red, config.color)
                }
                if !config.quiet {
                    io.println(string.format("  {}", msg))
                }
                if config.fail_fast {
                    break
                }
            }
        }
    }
    
    // Run teardown if present
    if let some(teardown_fn) = suite.teardown {
        teardown_fn()
    }
    
    stats.duration_ms = core.timestamp_ms() - start_time
    return stats
}

// Run all registered test suites
run_all = () TestStats {
    total_stats := TestStats {
        total: 0
        passed: 0
        failed: 0
        skipped: 0
        panicked: 0
        duration_ms: 0
    }
    
    start_time := core.timestamp_ms()
    
    for suite in TEST_REGISTRY {
        if !TEST_CONFIG.quiet {
            io.println("")
            io.println(string.format("running {} tests from {}", suite.tests.len(), suite.name))
        }
        
        stats := run_suite(suite, TEST_CONFIG)
        
        total_stats.total += stats.total
        total_stats.passed += stats.passed
        total_stats.failed += stats.failed
        total_stats.skipped += stats.skipped
        total_stats.panicked += stats.panicked
    }
    
    total_stats.duration_ms = core.timestamp_ms() - start_time
    
    // Print summary
    print_summary(total_stats)
    
    return total_stats
}

// Print test summary
print_summary = (stats: TestStats) void {
    io.println("")
    io.println(string.format("test result: {}", 
        if stats.failed == 0 && stats.panicked == 0 {
            print_colored("ok", Color.Green, TEST_CONFIG.color)
            "ok"
        } else {
            print_colored("FAILED", Color.Red, TEST_CONFIG.color)
            "FAILED"
        }
    ))
    
    io.print(string.format(". {} passed", stats.passed))
    
    if stats.failed > 0 {
        io.print(string.format("; {} failed", stats.failed))
    }
    
    if stats.skipped > 0 {
        io.print(string.format("; {} ignored", stats.skipped))
    }
    
    if stats.panicked > 0 {
        io.print(string.format("; {} panicked", stats.panicked))
    }
    
    io.println(string.format("; finished in {:.2}s", stats.duration_ms / 1000.0))
}

// Color codes for terminal output
Color = enum {
    Black
    Red
    Green
    Yellow
    Blue
    Magenta
    Cyan
    White
}

// Print colored text
print_colored = (text: string, color: Color, use_color: bool) void {
    if !use_color {
        io.print(text)
        return
    }
    
    color_code := match color {
        Color.Black => "30"
        Color.Red => "31"
        Color.Green => "32"
        Color.Yellow => "33"
        Color.Blue => "34"
        Color.Magenta => "35"
        Color.Cyan => "36"
        Color.White => "37"
    }
    
    io.print(string.format("\x1b[{}m{}\x1b[0m", color_code, text))
}

// Benchmark function
benchmark = (name: string, f: () void, iterations: u64) void {
    start := core.timestamp_ns()
    
    for _ in 0..iterations {
        f()
    }
    
    elapsed := core.timestamp_ns() - start
    per_iter := elapsed / iterations
    
    io.println(string.format("benchmark {}: {} ns/iter", name, per_iter))
}

// Test data generators
generate_random_int = (min: i32, max: i32) i32 {
    return core.random_range(min, max)
}

generate_random_string = (length: u64) string {
    chars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    result := ""
    
    for _ in 0..length {
        idx := core.random_range(0, string.len(chars))
        result = string.concat(result, string.char_at(chars, idx))
    }
    
    return result
}

generate_random_vec = <T>(size: u64, generator: () T) Vec<T> {
    vec := vec.with_capacity<T>(size)
    
    for _ in 0..size {
        vec.push(generator())
    }
    
    return vec
}

// Property-based testing helper
property = <T>(name: string, generator: () T, predicate: (T) bool, iterations: u64) TestResult {
    for i in 0..iterations {
        value := generator()
        if !predicate(value) {
            return TestResult.Fail(string.format("Property '{}' failed on iteration {} with value {}", name, i, value))
        }
    }
    return TestResult.Pass
}

// Test fixture support
Fixture<T> = struct {
    setup: () T
    teardown: (T) void
}

with_fixture = <T, R>(fixture: Fixture<T>, test_fn: (T) R) R {
    data := fixture.setup()
    defer fixture.teardown(data)
    return test_fn(data)
}

// Main test runner entry point
main = () i32 {
    // Parse command line arguments
    args := process.args()
    
    for i in 1..args.len() {
        arg := args[i]
        
        if arg == "--filter" && i + 1 < args.len() {
            TEST_CONFIG.filter = some(args[i + 1])
        } else if arg == "--verbose" || arg == "-v" {
            TEST_CONFIG.verbose = true
        } else if arg == "--quiet" || arg == "-q" {
            TEST_CONFIG.quiet = true
        } else if arg == "--fail-fast" {
            TEST_CONFIG.fail_fast = true
        } else if arg == "--no-parallel" {
            TEST_CONFIG.parallel = false
        } else if arg == "--no-color" {
            TEST_CONFIG.color = false
        } else if arg == "--show-output" {
            TEST_CONFIG.show_output = true
        }
    }
    
    // Run all tests
    stats := run_all()
    
    // Return exit code
    if stats.failed > 0 || stats.panicked > 0 {
        return 1
    }
    return 0
}