// Zen Standard Library: Process Management (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics

{ compiler } = @std
{ Result } = @std.core.result

// Syscall numbers (Linux x86-64)
SYS_FORK = 57
SYS_EXECVE = 59
SYS_WAIT4 = 61
SYS_EXIT = 60
SYS_GETPID = 39
SYS_GETPPID = 110
SYS_KILL = 62

// Wait options
WNOHANG = 1
WUNTRACED = 2

// Signals
SIGTERM = 15
SIGKILL = 9
SIGINT = 2
SIGHUP = 1

ProcessError: { code: i32, message: StaticString }

ProcessError.from_errno = (errno: i64) ProcessError {
    code = (0 - errno) as i32
    return ProcessError { code: code, message: "Process error" }
}

// Process ID type
Pid: { value: i32 }

Pid.current = () Pid {
    result = compiler.syscall0(SYS_GETPID)
    return Pid { value: result as i32 }
}

Pid.parent = () Pid {
    result = compiler.syscall0(SYS_GETPPID)
    return Pid { value: result as i32 }
}

// Fork the current process
fork = () Result<Pid, ProcessError> {
    result = compiler.syscall0(SYS_FORK)
    result < 0 ? { return Result.Err(ProcessError.from_errno(result)) }
    return Result.Ok(Pid { value: result as i32 })
}

// Exit the current process
exit = (code: i32) void {
    compiler.syscall1(SYS_EXIT, code)
}

// Wait for child process
// Returns (pid, status)
wait = () Result<i32, ProcessError> {
    status: i32 = 0
    result = compiler.syscall4(SYS_WAIT4, -1, compiler.ptr_to_int(&status.ref()), 0, 0)
    result < 0 ? { return Result.Err(ProcessError.from_errno(result)) }
    return Result.Ok(status)
}

// Wait for specific child (non-blocking)
waitpid = (pid: Pid, options: i32) Result<i32, ProcessError> {
    status: i32 = 0
    result = compiler.syscall4(SYS_WAIT4, pid.value, compiler.ptr_to_int(&status.ref()), options, 0)
    result < 0 ? { return Result.Err(ProcessError.from_errno(result)) }
    return Result.Ok(status)
}

// Send signal to process
kill = (pid: Pid, signal: i32) Result<(), ProcessError> {
    result = compiler.syscall2(SYS_KILL, pid.value, signal)
    result < 0 ? { return Result.Err(ProcessError.from_errno(result)) }
    return Result.Ok(())
}

// Extract exit status from wait status
exit_status = (status: i32) i32 {
    return (status >> 8) & 255
}

// Check if process exited normally
exited_normally = (status: i32) bool {
    return (status & 127) == 0
}

// Check if process was signaled
was_signaled = (status: i32) bool {
    return (status & 127) != 0
}
