// Zen Standard Library: prctl (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Process control operations

{ compiler } = @std
{ Result } = @std.core.result

// ============================================================================
// Linux x86-64 Syscall Numbers
// ============================================================================

SYS_PRCTL = 157
SYS_ARCH_PRCTL = 158

// ============================================================================
// prctl Options
// ============================================================================

// Process naming
PR_SET_NAME = 15
PR_GET_NAME = 16

// Signal handling
PR_SET_PDEATHSIG = 1    // Signal sent on parent death
PR_GET_PDEATHSIG = 2

// Core dump settings
PR_SET_DUMPABLE = 4
PR_GET_DUMPABLE = 3

// Timing
PR_SET_KEEPCAPS = 8
PR_GET_KEEPCAPS = 7

// Seccomp (secure computing mode)
PR_GET_SECCOMP = 21
PR_SET_SECCOMP = 22

// No new privileges
PR_SET_NO_NEW_PRIVS = 38
PR_GET_NO_NEW_PRIVS = 39

// Speculation controls (Spectre mitigations)
PR_GET_SPECULATION_CTRL = 52
PR_SET_SPECULATION_CTRL = 53

// Timer slack (for power saving)
PR_SET_TIMERSLACK = 29
PR_GET_TIMERSLACK = 30

// Memory merge (KSM)
PR_SET_MM = 35

// Child subreaper
PR_SET_CHILD_SUBREAPER = 36
PR_GET_CHILD_SUBREAPER = 37

// Thread naming (for debugging)
PR_SET_VMA = 1379718253  // 0x53564d41

// ============================================================================
// arch_prctl Options (x86-64 specific)
// ============================================================================

ARCH_SET_GS = 4097    // 0x1001
ARCH_SET_FS = 4098    // 0x1002
ARCH_GET_FS = 4099    // 0x1003
ARCH_GET_GS = 4100    // 0x1004

// ============================================================================
// Basic prctl Operations
// ============================================================================

// Generic prctl call
prctl = (option: i32, arg2: i64, arg3: i64, arg4: i64, arg5: i64) Result<i64, i32> {
    result = compiler.syscall5(SYS_PRCTL, option, arg2, arg3, arg4, arg5)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result)
}

// ============================================================================
// Process Name
// ============================================================================

// Set the name of the current thread (max 15 chars + null)
// Visible in /proc/self/comm and tools like top/htop
set_thread_name = (name_ptr: i64) Result<(), i32> {
    result = compiler.syscall2(SYS_PRCTL, PR_SET_NAME, name_ptr)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Get the name of the current thread
// Buffer must be at least 16 bytes
get_thread_name = (buf_ptr: i64) Result<(), i32> {
    result = compiler.syscall2(SYS_PRCTL, PR_GET_NAME, buf_ptr)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// ============================================================================
// Parent Death Signal
// ============================================================================

// Set signal to receive when parent process dies
set_parent_death_signal = (sig: i32) Result<(), i32> {
    result = compiler.syscall2(SYS_PRCTL, PR_SET_PDEATHSIG, sig)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Get the current parent death signal
get_parent_death_signal = () Result<i32, i32> {
    sig: i32 = 0
    result = compiler.syscall2(SYS_PRCTL, PR_GET_PDEATHSIG, compiler.ptr_to_int(&sig.ref()))
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(sig)
}

// ============================================================================
// Dumpable (Core Dumps)
// ============================================================================

SUID_DUMP_DISABLE = 0
SUID_DUMP_USER = 1
SUID_DUMP_ROOT = 2

// Set whether process can be dumped
set_dumpable = (value: i32) Result<(), i32> {
    result = compiler.syscall2(SYS_PRCTL, PR_SET_DUMPABLE, value)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Get dumpable state
get_dumpable = () Result<i32, i32> {
    result = compiler.syscall1(SYS_PRCTL, PR_GET_DUMPABLE)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as i32)
}

// ============================================================================
// No New Privileges
// ============================================================================

// Prevent gaining new privileges (for sandboxing)
set_no_new_privs = () Result<(), i32> {
    result = compiler.syscall5(SYS_PRCTL, PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Check if no_new_privs is set
get_no_new_privs = () Result<bool, i32> {
    result = compiler.syscall5(SYS_PRCTL, PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result != 0)
}

// ============================================================================
// Timer Slack
// ============================================================================

// Set timer slack in nanoseconds (power saving)
// Higher values allow kernel to batch timer wakeups
set_timer_slack = (slack_ns: u64) Result<(), i32> {
    result = compiler.syscall2(SYS_PRCTL, PR_SET_TIMERSLACK, slack_ns)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Get current timer slack
get_timer_slack = () Result<u64, i32> {
    result = compiler.syscall5(SYS_PRCTL, PR_GET_TIMERSLACK, 0, 0, 0, 0)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as u64)
}

// ============================================================================
// Child Subreaper
// ============================================================================

// Become a subreaper for orphaned descendant processes
// Orphaned descendants will be reparented to this process instead of init
set_child_subreaper = (enabled: bool) Result<(), i32> {
    val = enabled ? { 1 } : { 0 }
    result = compiler.syscall2(SYS_PRCTL, PR_SET_CHILD_SUBREAPER, val)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Check if this process is a child subreaper
get_child_subreaper = () Result<bool, i32> {
    flag: i32 = 0
    result = compiler.syscall2(SYS_PRCTL, PR_GET_CHILD_SUBREAPER, compiler.ptr_to_int(&flag.ref()))
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(flag != 0)
}

// ============================================================================
// Seccomp (Secure Computing)
// ============================================================================

SECCOMP_MODE_DISABLED = 0
SECCOMP_MODE_STRICT = 1
SECCOMP_MODE_FILTER = 2

// Get seccomp mode
get_seccomp = () Result<i32, i32> {
    result = compiler.syscall1(SYS_PRCTL, PR_GET_SECCOMP)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as i32)
}

// Enable strict seccomp mode (only read/write/exit/sigreturn allowed)
// WARNING: This is irreversible!
set_seccomp_strict = () Result<(), i32> {
    result = compiler.syscall2(SYS_PRCTL, PR_SET_SECCOMP, SECCOMP_MODE_STRICT)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// ============================================================================
// arch_prctl (x86-64 specific)
// ============================================================================

// Set FS base register (for TLS)
arch_set_fs = (addr: u64) Result<(), i32> {
    result = compiler.syscall2(SYS_ARCH_PRCTL, ARCH_SET_FS, addr)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Get FS base register
arch_get_fs = () Result<u64, i32> {
    addr: u64 = 0
    result = compiler.syscall2(SYS_ARCH_PRCTL, ARCH_GET_FS, compiler.ptr_to_int(&addr.ref()))
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(addr)
}

// Set GS base register
arch_set_gs = (addr: u64) Result<(), i32> {
    result = compiler.syscall2(SYS_ARCH_PRCTL, ARCH_SET_GS, addr)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Get GS base register
arch_get_gs = () Result<u64, i32> {
    addr: u64 = 0
    result = compiler.syscall2(SYS_ARCH_PRCTL, ARCH_GET_GS, compiler.ptr_to_int(&addr.ref()))
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(addr)
}
