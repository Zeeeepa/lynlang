// Zen Standard Library: Seccomp (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Secure computing mode for syscall filtering/sandboxing

{ compiler } = @std
{ Result } = @std.core.result

// ============================================================================
// Syscall Numbers (x86-64)
// ============================================================================

SYS_PRCTL = 157
SYS_SECCOMP = 317

// ============================================================================
// Seccomp Modes
// ============================================================================

SECCOMP_MODE_DISABLED = 0
SECCOMP_MODE_STRICT = 1      // Only read, write, _exit, sigreturn
SECCOMP_MODE_FILTER = 2      // BPF filter

// ============================================================================
// Seccomp Operations (for seccomp syscall)
// ============================================================================

SECCOMP_SET_MODE_STRICT = 0
SECCOMP_SET_MODE_FILTER = 1
SECCOMP_GET_ACTION_AVAIL = 2
SECCOMP_GET_NOTIF_SIZES = 3

// ============================================================================
// Seccomp Filter Flags
// ============================================================================

SECCOMP_FILTER_FLAG_TSYNC = 1          // Sync all threads
SECCOMP_FILTER_FLAG_LOG = 2            // Log filtered syscalls
SECCOMP_FILTER_FLAG_SPEC_ALLOW = 4     // Allow speculation
SECCOMP_FILTER_FLAG_NEW_LISTENER = 8   // Return notification fd
SECCOMP_FILTER_FLAG_TSYNC_ESRCH = 16   // Return -ESRCH on sync failure

// ============================================================================
// Seccomp Return Actions
// ============================================================================

SECCOMP_RET_KILL_PROCESS = 2147483648  // Kill the process
SECCOMP_RET_KILL_THREAD = 0            // Kill the thread
SECCOMP_RET_TRAP = 196608              // Send SIGSYS
SECCOMP_RET_ERRNO = 327680             // Return errno (ORed with errno value)
SECCOMP_RET_USER_NOTIF = 2143289344    // Notify userspace
SECCOMP_RET_TRACE = 2130706432         // Notify tracer
SECCOMP_RET_LOG = 2147221504           // Log and allow
SECCOMP_RET_ALLOW = 2147418112         // Allow syscall

// ============================================================================
// BPF Constants for Filter Building
// ============================================================================

// BPF instruction classes
BPF_LD = 0
BPF_LDX = 1
BPF_ST = 2
BPF_STX = 3
BPF_ALU = 4
BPF_JMP = 5
BPF_RET = 6
BPF_MISC = 7

// BPF ld/ldx fields
BPF_W = 0           // Word (32-bit)
BPF_H = 8           // Half-word (16-bit)
BPF_B = 16          // Byte
BPF_ABS = 32        // Absolute offset
BPF_IND = 64        // Indirect
BPF_MEM = 96        // Memory
BPF_LEN = 128       // Packet length
BPF_MSH = 160       // IP header length

// BPF alu/jmp fields
BPF_ADD = 0
BPF_SUB = 16
BPF_MUL = 32
BPF_DIV = 48
BPF_OR = 64
BPF_AND = 80
BPF_LSH = 96
BPF_RSH = 112
BPF_NEG = 128
BPF_MOD = 144
BPF_XOR = 160

BPF_JA = 0          // Jump always
BPF_JEQ = 16        // Jump if equal
BPF_JGT = 32        // Jump if greater
BPF_JGE = 48        // Jump if greater or equal
BPF_JSET = 64       // Jump if set

BPF_K = 0           // Constant
BPF_X = 8           // Index register

// seccomp_data offsets
SECCOMP_DATA_NR = 0           // Syscall number
SECCOMP_DATA_ARCH = 4         // Architecture
SECCOMP_DATA_IP = 8           // Instruction pointer
SECCOMP_DATA_ARGS = 16        // Syscall arguments (6 * 8 bytes)

// Architecture constant for x86-64
AUDIT_ARCH_X86_64 = 3221225534  // 0xc000003e

// ============================================================================
// BPF Instruction
// ============================================================================

BpfInsn: {
    code: u16,
    jt: u8,       // Jump true
    jf: u8,       // Jump false
    k: u32        // Constant
}

// ============================================================================
// BPF Program
// ============================================================================

BpfProg: {
    len: u16,
    filter: i64   // Pointer to BpfInsn array
}

// ============================================================================
// Prctl Constants
// ============================================================================

PR_SET_SECCOMP = 22
PR_GET_SECCOMP = 21
PR_SET_NO_NEW_PRIVS = 38
PR_GET_NO_NEW_PRIVS = 39

// ============================================================================
// Core Functions
// ============================================================================

// Enable strict mode (only read, write, _exit, sigreturn allowed)
seccomp_strict = () Result<(), i32> {
    result = compiler.syscall3(SYS_PRCTL, PR_SET_SECCOMP, SECCOMP_MODE_STRICT, 0)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Set no_new_privs (required before seccomp filter without CAP_SYS_ADMIN)
set_no_new_privs = () Result<(), i32> {
    result = compiler.syscall4(SYS_PRCTL, PR_SET_NO_NEW_PRIVS, 1, 0, 0)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Check if no_new_privs is set
get_no_new_privs = () Result<bool, i32> {
    result = compiler.syscall4(SYS_PRCTL, PR_GET_NO_NEW_PRIVS, 0, 0, 0)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(result != 0)
}

// Install BPF filter
seccomp_filter = (prog_ptr: i64, flags: u32) Result<(), i32> {
    result = compiler.syscall3(SYS_SECCOMP, SECCOMP_SET_MODE_FILTER, flags, prog_ptr)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Get current seccomp mode
seccomp_mode = () Result<i32, i32> {
    result = compiler.syscall3(SYS_PRCTL, PR_GET_SECCOMP, 0, 0)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(result as i32)
}

// ============================================================================
// BPF Instruction Helpers
// ============================================================================

// Load syscall number
bpf_load_syscall_nr = () BpfInsn {
    return BpfInsn {
        code: (BPF_LD | BPF_W | BPF_ABS) as u16,
        jt: 0,
        jf: 0,
        k: SECCOMP_DATA_NR
    }
}

// Load architecture
bpf_load_arch = () BpfInsn {
    return BpfInsn {
        code: (BPF_LD | BPF_W | BPF_ABS) as u16,
        jt: 0,
        jf: 0,
        k: SECCOMP_DATA_ARCH
    }
}

// Jump if equal
bpf_jeq = (value: u32, jt: u8, jf: u8) BpfInsn {
    return BpfInsn {
        code: (BPF_JMP | BPF_JEQ | BPF_K) as u16,
        jt: jt,
        jf: jf,
        k: value
    }
}

// Return action
bpf_ret = (action: u32) BpfInsn {
    return BpfInsn {
        code: (BPF_RET | BPF_K) as u16,
        jt: 0,
        jf: 0,
        k: action
    }
}

// ============================================================================
// Convenience: Simple Syscall Allowlist
// ============================================================================

// Build a simple allowlist filter that allows only specified syscalls
// syscalls: pointer to array of syscall numbers (i32)
// count: number of syscalls in array
// Returns BpfProg (caller must manage memory)
build_allowlist = (syscalls: i64, count: usize, filter_buf: i64) BpfProg {
    // Filter structure:
    // 1. Load arch, verify x86-64
    // 2. Load syscall number
    // 3. For each allowed syscall: jump to ALLOW if match
    // 4. Return KILL

    pos: usize = 0

    // Load architecture
    compiler.store<BpfInsn>(compiler.int_to_ptr(filter_buf + (pos * 8) as i64), bpf_load_arch())
    pos = pos + 1

    // Verify x86-64 (jump to kill if not)
    kill_offset = (count + 2) as u8  // Skip to kill instruction
    compiler.store<BpfInsn>(compiler.int_to_ptr(filter_buf + (pos * 8) as i64), bpf_jeq(AUDIT_ARCH_X86_64, 0, kill_offset))
    pos = pos + 1

    // Load syscall number
    compiler.store<BpfInsn>(compiler.int_to_ptr(filter_buf + (pos * 8) as i64), bpf_load_syscall_nr())
    pos = pos + 1

    // Check each allowed syscall
    i: usize = 0
    i < count ? {
        nr = compiler.load<i32>(compiler.int_to_ptr(syscalls + (i * 4) as i64))
        remaining = (count - i - 1) as u8
        allow_offset = (remaining + 1) as u8  // Jump to allow instruction
        compiler.store<BpfInsn>(compiler.int_to_ptr(filter_buf + (pos * 8) as i64), bpf_jeq(nr as u32, allow_offset, 0))
        pos = pos + 1
        i = i + 1
    }

    // Kill (default action)
    compiler.store<BpfInsn>(compiler.int_to_ptr(filter_buf + (pos * 8) as i64), bpf_ret(SECCOMP_RET_KILL_PROCESS))
    pos = pos + 1

    // Allow
    compiler.store<BpfInsn>(compiler.int_to_ptr(filter_buf + (pos * 8) as i64), bpf_ret(SECCOMP_RET_ALLOW))
    pos = pos + 1

    return BpfProg {
        len: pos as u16,
        filter: filter_buf
    }
}
