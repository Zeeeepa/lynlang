// Zen Standard Library: Resource Limits (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Process resource limits and usage

{ compiler } = @std
{ Result } = @std.core.result

// ============================================================================
// Linux x86-64 Syscall Numbers
// ============================================================================

SYS_GETRLIMIT = 97
SYS_SETRLIMIT = 160
SYS_PRLIMIT64 = 302
SYS_GETRUSAGE = 98

// ============================================================================
// Resource Types
// ============================================================================

RLIMIT_CPU = 0        // CPU time in seconds
RLIMIT_FSIZE = 1      // Maximum file size
RLIMIT_DATA = 2       // Maximum data segment size
RLIMIT_STACK = 3      // Maximum stack size
RLIMIT_CORE = 4       // Maximum core file size
RLIMIT_RSS = 5        // Maximum resident set size
RLIMIT_NPROC = 6      // Maximum number of processes
RLIMIT_NOFILE = 7     // Maximum number of open files
RLIMIT_MEMLOCK = 8    // Maximum locked memory
RLIMIT_AS = 9         // Maximum address space
RLIMIT_LOCKS = 10     // Maximum file locks
RLIMIT_SIGPENDING = 11 // Maximum pending signals
RLIMIT_MSGQUEUE = 12  // Maximum message queue bytes
RLIMIT_NICE = 13      // Maximum nice priority
RLIMIT_RTPRIO = 14    // Maximum realtime priority
RLIMIT_RTTIME = 15    // Maximum realtime timeout

// Special value meaning "unlimited"
RLIM_INFINITY = 18446744073709551615  // -1 as unsigned

// ============================================================================
// Resource Limit Structure
// ============================================================================

RLimit: {
    soft: u64,  // Current limit
    hard: u64   // Maximum limit (requires privilege to raise)
}

RLimit.new = (soft: u64, hard: u64) RLimit {
    return RLimit { soft: soft, hard: hard }
}

RLimit.unlimited = () RLimit {
    return RLimit { soft: RLIM_INFINITY, hard: RLIM_INFINITY }
}

// ============================================================================
// Get/Set Resource Limits
// ============================================================================

// Get resource limit for current process
getrlimit = (resource: i32) Result<RLimit, i32> {
    rlimit = RLimit { soft: 0, hard: 0 }
    result = compiler.syscall2(
        SYS_GETRLIMIT,
        resource,
        compiler.ptr_to_int(&rlimit.ref())
    )
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(rlimit)
}

// Set resource limit for current process
// Can only lower soft limit or raise up to hard limit
// Raising hard limit requires CAP_SYS_RESOURCE
setrlimit = (resource: i32, rlimit: Ptr<RLimit>) Result<(), i32> {
    result = compiler.syscall2(
        SYS_SETRLIMIT,
        resource,
        compiler.ptr_to_int(rlimit)
    )
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Get and optionally set resource limit (more flexible)
// pid = 0 for current process
// Pass null for new_limit to only get current limit
prlimit = (pid: i32, resource: i32, new_limit: i64, old_limit: i64) Result<(), i32> {
    result = compiler.syscall4(
        SYS_PRLIMIT64,
        pid,
        resource,
        new_limit,
        old_limit
    )
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// ============================================================================
// Resource Usage
// ============================================================================

RUSAGE_SELF = 0       // Current process
RUSAGE_CHILDREN = -1  // Terminated children
RUSAGE_THREAD = 1     // Current thread

// Timeval structure (matches kernel layout)
Timeval: {
    sec: i64,   // Seconds
    usec: i64   // Microseconds
}

// Resource usage structure (simplified - kernel struct is larger)
RUsage: {
    user_time: Timeval,   // User CPU time
    sys_time: Timeval,    // System CPU time
    maxrss: i64,          // Maximum resident set size (KB)
    // Additional fields exist but are less commonly used
    ixrss: i64,           // Integral shared memory size
    idrss: i64,           // Integral unshared data size
    isrss: i64,           // Integral unshared stack size
    minflt: i64,          // Page reclaims (soft page faults)
    majflt: i64,          // Page faults (hard page faults)
    nswap: i64,           // Swaps
    inblock: i64,         // Block input operations
    oublock: i64,         // Block output operations
    msgsnd: i64,          // IPC messages sent
    msgrcv: i64,          // IPC messages received
    nsignals: i64,        // Signals received
    nvcsw: i64,           // Voluntary context switches
    nivcsw: i64           // Involuntary context switches
}

// Get resource usage
getrusage = (who: i32) Result<RUsage, i32> {
    // Allocate full rusage struct (18 fields * 8 bytes = 144 bytes)
    rusage_ptr = compiler.raw_allocate(144)
    compiler.memset(rusage_ptr, 0, 144)

    result = compiler.syscall2(
        SYS_GETRUSAGE,
        who,
        compiler.ptr_to_int(rusage_ptr)
    )

    result < 0 ? {
        compiler.raw_deallocate(rusage_ptr, 144)
        return Result.Err((0 - result) as i32)
    }

    // Extract fields
    rusage = RUsage {
        user_time: Timeval {
            sec: compiler.load<i64>(rusage_ptr),
            usec: compiler.load<i64>(compiler.gep(rusage_ptr, 8))
        },
        sys_time: Timeval {
            sec: compiler.load<i64>(compiler.gep(rusage_ptr, 16)),
            usec: compiler.load<i64>(compiler.gep(rusage_ptr, 24))
        },
        maxrss: compiler.load<i64>(compiler.gep(rusage_ptr, 32)),
        ixrss: compiler.load<i64>(compiler.gep(rusage_ptr, 40)),
        idrss: compiler.load<i64>(compiler.gep(rusage_ptr, 48)),
        isrss: compiler.load<i64>(compiler.gep(rusage_ptr, 56)),
        minflt: compiler.load<i64>(compiler.gep(rusage_ptr, 64)),
        majflt: compiler.load<i64>(compiler.gep(rusage_ptr, 72)),
        nswap: compiler.load<i64>(compiler.gep(rusage_ptr, 80)),
        inblock: compiler.load<i64>(compiler.gep(rusage_ptr, 88)),
        oublock: compiler.load<i64>(compiler.gep(rusage_ptr, 96)),
        msgsnd: compiler.load<i64>(compiler.gep(rusage_ptr, 104)),
        msgrcv: compiler.load<i64>(compiler.gep(rusage_ptr, 112)),
        nsignals: compiler.load<i64>(compiler.gep(rusage_ptr, 120)),
        nvcsw: compiler.load<i64>(compiler.gep(rusage_ptr, 128)),
        nivcsw: compiler.load<i64>(compiler.gep(rusage_ptr, 136))
    }

    compiler.raw_deallocate(rusage_ptr, 144)
    return Result.Ok(rusage)
}

// ============================================================================
// Convenience Functions
// ============================================================================

// Get maximum number of open files
get_max_open_files = () Result<u64, i32> {
    rlimit = getrlimit(RLIMIT_NOFILE)
    rlimit ? {
        | Ok(r) { return Result.Ok(r.soft) }
        | Err(e) { return Result.Err(e) }
    }
}

// Set maximum number of open files
set_max_open_files = (limit: u64) Result<(), i32> {
    current = getrlimit(RLIMIT_NOFILE)
    current ? {
        | Ok(r) {
            new_limit = RLimit.new(limit, r.hard)
            return setrlimit(RLIMIT_NOFILE, &new_limit.ref())
        }
        | Err(e) { return Result.Err(e) }
    }
}

// Get maximum stack size
get_stack_size = () Result<u64, i32> {
    rlimit = getrlimit(RLIMIT_STACK)
    rlimit ? {
        | Ok(r) { return Result.Ok(r.soft) }
        | Err(e) { return Result.Err(e) }
    }
}

// Get process CPU time usage in microseconds
get_cpu_time = () Result<i64, i32> {
    usage = getrusage(RUSAGE_SELF)
    usage ? {
        | Ok(r) {
            user_us = r.user_time.sec * 1000000 + r.user_time.usec
            sys_us = r.sys_time.sec * 1000000 + r.sys_time.usec
            return Result.Ok(user_us + sys_us)
        }
        | Err(e) { return Result.Err(e) }
    }
}
