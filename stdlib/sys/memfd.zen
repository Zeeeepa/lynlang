// Zen Standard Library: memfd (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Memory file descriptors for anonymous shared memory

{ compiler } = @std
{ Result } = @std.core.result

// ============================================================================
// Linux x86-64 Syscall Numbers
// ============================================================================

SYS_MEMFD_CREATE = 319
SYS_MMAP = 9
SYS_MUNMAP = 11
SYS_FTRUNCATE = 77
SYS_CLOSE = 3
SYS_FCNTL = 72
SYS_WRITE = 1
SYS_READ = 0
SYS_LSEEK = 8

// ============================================================================
// memfd_create Flags
// ============================================================================

MFD_CLOEXEC = 1           // Close-on-exec
MFD_ALLOW_SEALING = 2     // Allow sealing operations
MFD_HUGETLB = 4           // Use huge pages

// Huge page sizes (combined with MFD_HUGETLB)
MFD_HUGE_64KB = 1073741824   // 16 << 26
MFD_HUGE_512KB = 1275068416  // 19 << 26
MFD_HUGE_1MB = 1342177280    // 20 << 26
MFD_HUGE_2MB = 1409286144    // 21 << 26
MFD_HUGE_8MB = 1543503872    // 23 << 26
MFD_HUGE_16MB = 1610612736   // 24 << 26
MFD_HUGE_32MB = 1677721600   // 25 << 26
MFD_HUGE_256MB = 1879048192  // 28 << 26
MFD_HUGE_512MB = 1946157056  // 29 << 26
MFD_HUGE_1GB = 2013265920    // 30 << 26
MFD_HUGE_2GB = 2080374784    // 31 << 26

// ============================================================================
// Seal Flags (for F_ADD_SEALS)
// ============================================================================

F_SEAL_SEAL = 1      // Prevent further sealing
F_SEAL_SHRINK = 2    // Prevent file from shrinking
F_SEAL_GROW = 4      // Prevent file from growing
F_SEAL_WRITE = 8     // Prevent writes
F_SEAL_FUTURE_WRITE = 16  // Prevent future writes (existing mappings OK)

F_ADD_SEALS = 1033   // fcntl command to add seals
F_GET_SEALS = 1034   // fcntl command to get seals

// ============================================================================
// Memory Protection Flags
// ============================================================================

PROT_NONE = 0
PROT_READ = 1
PROT_WRITE = 2
PROT_EXEC = 4

MAP_SHARED = 1
MAP_PRIVATE = 2
MAP_ANONYMOUS = 32
MAP_POPULATE = 32768

// ============================================================================
// MemFd - Memory File Descriptor
// ============================================================================
// Creates an anonymous file in memory that can be:
// - Memory-mapped into process address space
// - Shared between processes via fd passing
// - Sealed to prevent modifications

MemFd: {
    fd: i32,
    size: usize
}

// Create a new memory file descriptor
// name: name for debugging (shown in /proc/self/fd/)
// flags: MFD_CLOEXEC | MFD_ALLOW_SEALING etc.
MemFd.create = (name_ptr: i64, flags: u32) Result<MemFd, i32> {
    fd = compiler.syscall2(SYS_MEMFD_CREATE, name_ptr, flags)
    fd < 0 ? { return Result.Err((0 - fd) as i32) }

    return Result.Ok(MemFd { fd: fd as i32, size: 0 })
}

// Create with common defaults (cloexec + allow sealing)
MemFd.new = (name_ptr: i64) Result<MemFd, i32> {
    return MemFd.create(name_ptr, MFD_CLOEXEC | MFD_ALLOW_SEALING)
}

// Set the size of the memory file
MemFd.truncate = (self: MutPtr<MemFd>, size: usize) Result<(), i32> {
    result = compiler.syscall2(SYS_FTRUNCATE, self.val.fd, size)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    self.val.size = size
    return Result.Ok(())
}

// Map the memory file into process address space
MemFd.map = (self: MutPtr<MemFd>, offset: usize, length: usize, prot: i32) Result<i64, i32> {
    addr = compiler.syscall6(
        SYS_MMAP,
        0,              // Let kernel choose address
        length,
        prot,
        MAP_SHARED,
        self.val.fd,
        offset
    )
    addr < 0 ? { return Result.Err((0 - addr) as i32) }
    return Result.Ok(addr)
}

// Map entire file
MemFd.map_all = (self: MutPtr<MemFd>, prot: i32) Result<i64, i32> {
    return self.map(0, self.val.size, prot)
}

// Unmap a region
MemFd.unmap = (addr: i64, length: usize) Result<(), i32> {
    result = compiler.syscall2(SYS_MUNMAP, addr, length)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// ============================================================================
// Sealing Operations
// ============================================================================

// Add seals to prevent certain operations
MemFd.add_seals = (self: MutPtr<MemFd>, seals: u32) Result<(), i32> {
    result = compiler.syscall3(SYS_FCNTL, self.val.fd, F_ADD_SEALS, seals)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Get current seals
MemFd.get_seals = (self: Ptr<MemFd>) Result<u32, i32> {
    result = compiler.syscall2(SYS_FCNTL, self.val.fd, F_GET_SEALS)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as u32)
}

// Seal the file completely (no modifications allowed)
MemFd.seal_all = (self: MutPtr<MemFd>) Result<(), i32> {
    seals = F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE
    return self.add_seals(seals)
}

// ============================================================================
// Read/Write Operations
// ============================================================================

// Write data to the memory file
MemFd.write = (self: MutPtr<MemFd>, buf: i64, len: usize) Result<usize, i32> {
    result = compiler.syscall3(SYS_WRITE, self.val.fd, buf, len)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as usize)
}

// Read data from the memory file
MemFd.read = (self: MutPtr<MemFd>, buf: i64, len: usize) Result<usize, i32> {
    result = compiler.syscall3(SYS_READ, self.val.fd, buf, len)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as usize)
}

// Seek to position
MemFd.seek = (self: MutPtr<MemFd>, offset: i64, whence: i32) Result<i64, i32> {
    result = compiler.syscall3(SYS_LSEEK, self.val.fd, offset, whence)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result)
}

// ============================================================================
// Lifecycle
// ============================================================================

// Get raw file descriptor (for passing to other processes)
MemFd.raw_fd = (self: Ptr<MemFd>) i32 {
    return self.val.fd
}

// Get current size
MemFd.len = (self: Ptr<MemFd>) usize {
    return self.val.size
}

// Close the memory file
MemFd.close = (self: MutPtr<MemFd>) void {
    compiler.syscall1(SYS_CLOSE, self.val.fd)
}

// ============================================================================
// SharedMemory - Higher-level wrapper
// ============================================================================
// Combines memfd + mmap for easy shared memory usage

SharedMemory: {
    memfd: MemFd,
    addr: i64,
    size: usize
}

// Create shared memory region of given size
SharedMemory.new = (name_ptr: i64, size: usize) Result<SharedMemory, i32> {
    // Create memfd
    memfd_result = MemFd.new(name_ptr)
    memfd_result ? {
        | Err(e) { return Result.Err(e) }
        | Ok(mfd) {
            // Set size
            mfd_mut = mfd
            truncate_result = mfd_mut.truncate(size)
            truncate_result ? {
                | Err(e) {
                    mfd_mut.close()
                    return Result.Err(e)
                }
                | Ok(_) { }
            }

            // Map it
            map_result = mfd_mut.map_all(PROT_READ | PROT_WRITE)
            map_result ? {
                | Err(e) {
                    mfd_mut.close()
                    return Result.Err(e)
                }
                | Ok(addr) {
                    return Result.Ok(SharedMemory {
                        memfd: mfd_mut,
                        addr: addr,
                        size: size
                    })
                }
            }
        }
    }
}

// Get pointer to shared memory
SharedMemory.ptr = (self: Ptr<SharedMemory>) i64 {
    return self.val.addr
}

// Get size
SharedMemory.len = (self: Ptr<SharedMemory>) usize {
    return self.val.size
}

// Get raw fd for sharing
SharedMemory.fd = (self: Ptr<SharedMemory>) i32 {
    return self.val.memfd.fd
}

// Close and unmap
SharedMemory.close = (self: MutPtr<SharedMemory>) void {
    MemFd.unmap(self.val.addr, self.val.size)
    self.val.memfd.close()
}
