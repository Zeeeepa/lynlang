// Zen Standard Library: Scheduler Operations (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// CPU affinity, scheduling policy, and priority control

{ compiler } = @std
{ Result } = @std.core.result

// ============================================================================
// Linux x86-64 Syscall Numbers
// ============================================================================

SYS_SCHED_YIELD = 24
SYS_SCHED_SETSCHEDULER = 144
SYS_SCHED_GETSCHEDULER = 145
SYS_SCHED_SETPARAM = 142
SYS_SCHED_GETPARAM = 143
SYS_SCHED_GET_PRIORITY_MAX = 146
SYS_SCHED_GET_PRIORITY_MIN = 147
SYS_SCHED_SETAFFINITY = 203
SYS_SCHED_GETAFFINITY = 204
SYS_GETCPU = 309

// ============================================================================
// Scheduling Policies
// ============================================================================

SCHED_NORMAL = 0      // Default time-sharing
SCHED_FIFO = 1        // First-in-first-out realtime
SCHED_RR = 2          // Round-robin realtime
SCHED_BATCH = 3       // Batch processing
SCHED_IDLE = 5        // Very low priority background

// ============================================================================
// Basic Scheduler Operations
// ============================================================================

// Yield CPU to other threads/processes
sched_yield = () void {
    compiler.syscall0(SYS_SCHED_YIELD)
}

// Get scheduling policy for a process
// pid = 0 means current process
sched_getscheduler = (pid: i32) Result<i32, i32> {
    result = compiler.syscall1(SYS_SCHED_GETSCHEDULER, pid)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as i32)
}

// Get maximum priority for a scheduling policy
sched_get_priority_max = (policy: i32) Result<i32, i32> {
    result = compiler.syscall1(SYS_SCHED_GET_PRIORITY_MAX, policy)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as i32)
}

// Get minimum priority for a scheduling policy
sched_get_priority_min = (policy: i32) Result<i32, i32> {
    result = compiler.syscall1(SYS_SCHED_GET_PRIORITY_MIN, policy)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as i32)
}

// ============================================================================
// CPU Affinity
// ============================================================================

// CPU set for affinity operations
// Supports up to 64 CPUs (can be extended)
CpuSet: {
    mask: u64
}

CpuSet.new = () CpuSet {
    return CpuSet { mask: 0 }
}

// Set all CPUs
CpuSet.all = () CpuSet {
    return CpuSet { mask: 18446744073709551615 }  // All bits set
}

// Set a specific CPU
CpuSet.set = (self: MutPtr<CpuSet>, cpu: i32) void {
    cpu >= 0 ? {
        cpu < 64 ? {
            bit = 1 << cpu
            self.val.mask = self.val.mask | bit
        }
    }
}

// Clear a specific CPU
CpuSet.clear = (self: MutPtr<CpuSet>, cpu: i32) void {
    cpu >= 0 ? {
        cpu < 64 ? {
            bit = 1 << cpu
            self.val.mask = self.val.mask & (18446744073709551615 ^ bit)
        }
    }
}

// Check if a CPU is set
CpuSet.is_set = (self: Ptr<CpuSet>, cpu: i32) bool {
    cpu < 0 ? { return false }
    cpu >= 64 ? { return false }
    bit = 1 << cpu
    return (self.val.mask & bit) != 0
}

// Count set CPUs
CpuSet.count = (self: Ptr<CpuSet>) i32 {
    return compiler.ctpop(self.val.mask) as i32
}

// Set CPU affinity for a process
// pid = 0 means current process
sched_setaffinity = (pid: i32, cpuset: Ptr<CpuSet>) Result<(), i32> {
    // sched_setaffinity(pid, sizeof(mask), &mask)
    result = compiler.syscall3(
        SYS_SCHED_SETAFFINITY,
        pid,
        8,  // size of u64
        compiler.ptr_to_int(cpuset)
    )
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}

// Get CPU affinity for a process
// pid = 0 means current process
sched_getaffinity = (pid: i32) Result<CpuSet, i32> {
    cpuset = CpuSet.new()
    result = compiler.syscall3(
        SYS_SCHED_GETAFFINITY,
        pid,
        8,  // size of u64
        compiler.ptr_to_int(&cpuset.ref())
    )
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(cpuset)
}

// ============================================================================
// CPU Information
// ============================================================================

// Get the CPU and NUMA node the calling thread is running on
getcpu = () Result<CpuInfo, i32> {
    cpu: i32 = 0
    node: i32 = 0
    result = compiler.syscall3(
        SYS_GETCPU,
        compiler.ptr_to_int(&cpu.ref()),
        compiler.ptr_to_int(&node.ref()),
        0  // tcache (obsolete, pass NULL)
    )
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(CpuInfo { cpu: cpu, node: node })
}

CpuInfo: {
    cpu: i32,   // CPU number
    node: i32   // NUMA node
}

// ============================================================================
// Nice Value (Process Priority)
// ============================================================================

SYS_GETPRIORITY = 140
SYS_SETPRIORITY = 141

PRIO_PROCESS = 0
PRIO_PGRP = 1
PRIO_USER = 2

// Get nice value for current process (returns -20 to 19)
getpriority = () Result<i32, i32> {
    // getpriority returns 20-nice, so we need to adjust
    result = compiler.syscall2(SYS_GETPRIORITY, PRIO_PROCESS, 0)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    // Kernel returns 20 - nice value, so convert back
    nice = 20 - result
    return Result.Ok(nice as i32)
}

// Set nice value for current process (-20 = highest, 19 = lowest priority)
// Requires CAP_SYS_NICE to increase priority (lower nice value)
setpriority = (nice: i32) Result<(), i32> {
    result = compiler.syscall3(SYS_SETPRIORITY, PRIO_PROCESS, 0, nice)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(())
}
