// Zen Standard Library: PRNG (Pseudo-Random Number Generator)
// Seeded random number generation using Linear Congruential Generator
// For cryptographic/kernel randomness, use @std.sys.random.getrandom instead

// Random number generator state
Rng: {
    state: i64
}

// Create new RNG with seed
rng_new = (seed: i64) Rng {
    return Rng {
        state: seed
    }
}

// Linear Congruential Generator formula
// rng_next = (state * 1103515245 + 12345) % 2^31
rng_next = (rng: MutPtr<Rng>) i64 {
    rng.val.state = (rng.val.state * 1103515245 + 12345) % 2147483647
    return rng.val.state
}

// Get random i32
rng_next_i32 = (rng: MutPtr<Rng>) i32 {
    return cast(rng_next(rng), i32)
}

// Get random i64
rng_next_i64 = (rng: MutPtr<Rng>) i64 {
    return rng_next(rng)
}

// Get random u32
rng_next_u32 = (rng: MutPtr<Rng>) u32 {
    return cast(rng_next(rng), u32)
}

// Get random u64
rng_next_u64 = (rng: MutPtr<Rng>) u64 {
    return cast(rng_next(rng), u64)
}

// Get random float between 0 and 1
rng_next_f64 = (rng: MutPtr<Rng>) f64 {
    val = cast(rng_next(rng), f64)
    // Normalize to 0.0 - 1.0
    return val / 2147483647.0
}

// Get random in range [0, max)
rng_next_bounded = (rng: MutPtr<Rng>, max: i64) i64 {
    max <= 0 ?
    | true { return 0 }
    | false { }

    val ::= rng_next(rng)
    val < 0 ?
    | true { val = 0 - val }
    | false { }

    return val % max
}

// Global default RNG
default_rng = () Rng {
    return rng_new(12345)
}

// Global random (convenience)
random = () i64 {
    rng ::= default_rng()
    return rng_next(rng.mut_ref())
}

// Global random in range
random_bounded = (max: i64) i64 {
    rng ::= default_rng()
    return rng_next_bounded(rng.mut_ref(), max)
}
