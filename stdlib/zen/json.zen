// Zen JSON Module - Pure Zen implementation
// Provides JSON parsing and serialization capabilities

core := @std.core
io := @std.io
string := @std.string
vec := @std.vec
hashmap := @std.hashmap
result := @std.result
math := @std.math

// JSON value types
JsonValue := enum {
    Null
    Bool(value: bool)
    Number(value: f64)
    String(value: string)
    Array(values: Vec<JsonValue>)
    Object(fields: HashMap<string, JsonValue>)
}

// JSON error types
JsonError := enum {
    UnexpectedToken(pos: usize, expected: string, found: string)
    UnexpectedEof
    InvalidNumber(pos: usize)
    InvalidString(pos: usize, reason: string)
    InvalidEscape(pos: usize)
    TrailingComma(pos: usize)
    DuplicateKey(key: string)
    MaxDepthExceeded
    InvalidUnicode(pos: usize)
}

// JSON parser state
Parser := struct {
    input: string
    pos: usize
    line: usize
    column: usize
    max_depth: usize
    current_depth: usize
}

// JSON formatter options
FormatOptions := struct {
    indent: string
    compact: bool
    sort_keys: bool
    escape_unicode: bool
}

// Default format options
default_format = () FormatOptions {
    return FormatOptions{
        indent: "  ",
        compact: false,
        sort_keys: false,
        escape_unicode: false
    }
}

// Compact format options
compact_format = () FormatOptions {
    return FormatOptions{
        indent: "",
        compact: true,
        sort_keys: false,
        escape_unicode: false
    }
}

// Pretty format options
pretty_format = () FormatOptions {
    return FormatOptions{
        indent: "    ",
        compact: false,
        sort_keys: true,
        escape_unicode: false
    }
}

// Parse JSON string
parse = (input: string) Result<JsonValue, JsonError> {
    parser := Parser{
        input: input,
        pos: 0,
        line: 1,
        column: 1,
        max_depth: 100,
        current_depth: 0
    }
    
    skip_whitespace(&mut parser)
    value := parse_value(&mut parser)?
    skip_whitespace(&mut parser)
    
    if (parser.pos < string.len(parser.input)) {
        return Result.Err(JsonError.UnexpectedToken(
            parser.pos,
            "end of input",
            string.substring(parser.input, parser.pos, parser.pos + 1)
        ))
    }
    
    return Result.Ok(value)
}

// Parse a JSON value
parse_value = (parser: &mut Parser) Result<JsonValue, JsonError> {
    skip_whitespace(parser)
    
    if (parser.pos >= string.len(parser.input)) {
        return Result.Err(JsonError.UnexpectedEof)
    }
    
    // Check depth limit
    if (parser.current_depth >= parser.max_depth) {
        return Result.Err(JsonError.MaxDepthExceeded)
    }
    
    ch := string.char_at(parser.input, parser.pos)
    
    if (ch == 'n') {
        return parse_null(parser)
    } else if (ch == 't' || ch == 'f') {
        return parse_bool(parser)
    } else if (ch == '"') {
        return parse_string(parser)
    } else if (ch == '[') {
        return parse_array(parser)
    } else if (ch == '{') {
        return parse_object(parser)
    } else if (ch == '-' || is_digit(ch)) {
        return parse_number(parser)
    } else {
        return Result.Err(JsonError.UnexpectedToken(
            parser.pos,
            "value",
            string.from_char(ch)
        ))
    }
}

// Parse null
parse_null = (parser: &mut Parser) Result<JsonValue, JsonError> {
    if (!consume_literal(parser, "null")) {
        return Result.Err(JsonError.UnexpectedToken(
            parser.pos,
            "null",
            string.substring(parser.input, parser.pos, math.min(parser.pos + 4, string.len(parser.input)))
        ))
    }
    return Result.Ok(JsonValue.Null)
}

// Parse boolean
parse_bool = (parser: &mut Parser) Result<JsonValue, JsonError> {
    if (consume_literal(parser, "true")) {
        return Result.Ok(JsonValue.Bool(true))
    } else if (consume_literal(parser, "false")) {
        return Result.Ok(JsonValue.Bool(false))
    } else {
        return Result.Err(JsonError.UnexpectedToken(
            parser.pos,
            "true or false",
            string.substring(parser.input, parser.pos, math.min(parser.pos + 5, string.len(parser.input)))
        ))
    }
}

// Parse number
parse_number = (parser: &mut Parser) Result<JsonValue, JsonError> {
    start := parser.pos
    
    // Handle negative sign
    if (peek_char(parser) == '-') {
        advance(parser)
    }
    
    // Parse integer part
    if (peek_char(parser) == '0') {
        advance(parser)
        // After leading zero, must be . or e/E or end
        ch := peek_char(parser)
        if (is_digit(ch)) {
            return Result.Err(JsonError.InvalidNumber(parser.pos))
        }
    } else if (is_digit(peek_char(parser))) {
        while (is_digit(peek_char(parser))) {
            advance(parser)
        }
    } else {
        return Result.Err(JsonError.InvalidNumber(parser.pos))
    }
    
    // Parse fractional part
    if (peek_char(parser) == '.') {
        advance(parser)
        if (!is_digit(peek_char(parser))) {
            return Result.Err(JsonError.InvalidNumber(parser.pos))
        }
        while (is_digit(peek_char(parser))) {
            advance(parser)
        }
    }
    
    // Parse exponent
    ch := peek_char(parser)
    if (ch == 'e' || ch == 'E') {
        advance(parser)
        ch = peek_char(parser)
        if (ch == '+' || ch == '-') {
            advance(parser)
        }
        if (!is_digit(peek_char(parser))) {
            return Result.Err(JsonError.InvalidNumber(parser.pos))
        }
        while (is_digit(peek_char(parser))) {
            advance(parser)
        }
    }
    
    // Parse the number
    num_str := string.substring(parser.input, start, parser.pos)
    num := string.parse_f64(num_str)
    
    if (num.is_err()) {
        return Result.Err(JsonError.InvalidNumber(start))
    }
    
    return Result.Ok(JsonValue.Number(num.unwrap()))
}

// Parse string
parse_string = (parser: &mut Parser) Result<JsonValue, JsonError> {
    // Consume opening quote
    if (!consume_char(parser, '"')) {
        return Result.Err(JsonError.UnexpectedToken(
            parser.pos,
            "\"",
            string.from_char(peek_char(parser))
        ))
    }
    
    result := string.new()
    
    while (true) {
        if (parser.pos >= string.len(parser.input)) {
            return Result.Err(JsonError.UnexpectedEof)
        }
        
        ch := peek_char(parser)
        
        if (ch == '"') {
            advance(parser)
            break
        } else if (ch == '\\') {
            advance(parser)
            escaped := parse_escape(parser)?
            string.append(result, escaped)
        } else if (ch < 0x20) {
            return Result.Err(JsonError.InvalidString(
                parser.pos,
                "control character in string"
            ))
        } else {
            string.push_char(result, ch)
            advance(parser)
        }
    }
    
    return Result.Ok(JsonValue.String(result))
}

// Parse escape sequence
parse_escape = (parser: &mut Parser) Result<string, JsonError> {
    if (parser.pos >= string.len(parser.input)) {
        return Result.Err(JsonError.UnexpectedEof)
    }
    
    ch := peek_char(parser)
    advance(parser)
    
    if (ch == '"') {
        return Result.Ok("\"")
    } else if (ch == '\\') {
        return Result.Ok("\\")
    } else if (ch == '/') {
        return Result.Ok("/")
    } else if (ch == 'b') {
        return Result.Ok("\b")
    } else if (ch == 'f') {
        return Result.Ok("\f")
    } else if (ch == 'n') {
        return Result.Ok("\n")
    } else if (ch == 'r') {
        return Result.Ok("\r")
    } else if (ch == 't') {
        return Result.Ok("\t")
    } else if (ch == 'u') {
        // Unicode escape
        return parse_unicode_escape(parser)
    } else {
        return Result.Err(JsonError.InvalidEscape(parser.pos - 1))
    }
}

// Parse unicode escape sequence
parse_unicode_escape = (parser: &mut Parser) Result<string, JsonError> {
    if (parser.pos + 4 > string.len(parser.input)) {
        return Result.Err(JsonError.UnexpectedEof)
    }
    
    hex_str := string.substring(parser.input, parser.pos, parser.pos + 4)
    parser.pos += 4
    
    code_point := parse_hex(hex_str)
    if (code_point.is_err()) {
        return Result.Err(JsonError.InvalidUnicode(parser.pos - 4))
    }
    
    // Convert code point to UTF-8
    return Result.Ok(char_to_utf8(code_point.unwrap()))
}

// Parse array
parse_array = (parser: &mut Parser) Result<JsonValue, JsonError> {
    // Consume opening bracket
    if (!consume_char(parser, '[')) {
        return Result.Err(JsonError.UnexpectedToken(
            parser.pos,
            "[",
            string.from_char(peek_char(parser))
        ))
    }
    
    parser.current_depth += 1
    defer parser.current_depth -= 1
    
    values := vec.new<JsonValue>()
    skip_whitespace(parser)
    
    // Check for empty array
    if (peek_char(parser) == ']') {
        advance(parser)
        return Result.Ok(JsonValue.Array(values))
    }
    
    // Parse array elements
    while (true) {
        value := parse_value(parser)?
        vec.push(values, value)
        
        skip_whitespace(parser)
        ch := peek_char(parser)
        
        if (ch == ']') {
            advance(parser)
            break
        } else if (ch == ',') {
            advance(parser)
            skip_whitespace(parser)
            
            // Check for trailing comma
            if (peek_char(parser) == ']') {
                return Result.Err(JsonError.TrailingComma(parser.pos))
            }
        } else {
            return Result.Err(JsonError.UnexpectedToken(
                parser.pos,
                ", or ]",
                string.from_char(ch)
            ))
        }
    }
    
    return Result.Ok(JsonValue.Array(values))
}

// Parse object
parse_object = (parser: &mut Parser) Result<JsonValue, JsonError> {
    // Consume opening brace
    if (!consume_char(parser, '{')) {
        return Result.Err(JsonError.UnexpectedToken(
            parser.pos,
            "{",
            string.from_char(peek_char(parser))
        ))
    }
    
    parser.current_depth += 1
    defer parser.current_depth -= 1
    
    fields := hashmap.new<string, JsonValue>()
    skip_whitespace(parser)
    
    // Check for empty object
    if (peek_char(parser) == '}') {
        advance(parser)
        return Result.Ok(JsonValue.Object(fields))
    }
    
    // Parse object fields
    while (true) {
        skip_whitespace(parser)
        
        // Parse key
        if (peek_char(parser) != '"') {
            return Result.Err(JsonError.UnexpectedToken(
                parser.pos,
                "string key",
                string.from_char(peek_char(parser))
            ))
        }
        
        key_value := parse_string(parser)?
        key := match key_value {
            JsonValue.String(s) => s
            _ => return Result.Err(JsonError.InvalidString(parser.pos, "expected string key"))
        }
        
        // Check for duplicate key
        if (hashmap.contains(fields, key)) {
            return Result.Err(JsonError.DuplicateKey(key))
        }
        
        skip_whitespace(parser)
        
        // Parse colon
        if (!consume_char(parser, ':')) {
            return Result.Err(JsonError.UnexpectedToken(
                parser.pos,
                ":",
                string.from_char(peek_char(parser))
            ))
        }
        
        skip_whitespace(parser)
        
        // Parse value
        value := parse_value(parser)?
        hashmap.insert(fields, key, value)
        
        skip_whitespace(parser)
        ch := peek_char(parser)
        
        if (ch == '}') {
            advance(parser)
            break
        } else if (ch == ',') {
            advance(parser)
            skip_whitespace(parser)
            
            // Check for trailing comma
            if (peek_char(parser) == '}') {
                return Result.Err(JsonError.TrailingComma(parser.pos))
            }
        } else {
            return Result.Err(JsonError.UnexpectedToken(
                parser.pos,
                ", or }",
                string.from_char(ch)
            ))
        }
    }
    
    return Result.Ok(JsonValue.Object(fields))
}

// Stringify JSON value
stringify = (value: JsonValue) string {
    return format(value, default_format())
}

// Format JSON value with options
format = (value: JsonValue, options: FormatOptions) string {
    formatter := Formatter{
        output: string.new(),
        options: options,
        depth: 0
    }
    format_value(&mut formatter, value)
    return formatter.output
}

// JSON formatter state
Formatter := struct {
    output: string
    options: FormatOptions
    depth: usize
}

// Format a value
format_value = (fmt: &mut Formatter, value: JsonValue) void {
    match value {
        JsonValue.Null => {
            string.append(fmt.output, "null")
        }
        JsonValue.Bool(b) => {
            string.append(fmt.output, if (b) "true" else "false")
        }
        JsonValue.Number(n) => {
            string.append(fmt.output, string.format("{}", n))
        }
        JsonValue.String(s) => {
            format_string(fmt, s)
        }
        JsonValue.Array(arr) => {
            format_array(fmt, arr)
        }
        JsonValue.Object(obj) => {
            format_object(fmt, obj)
        }
    }
}

// Format string with escaping
format_string = (fmt: &mut Formatter, s: string) void {
    string.push_char(fmt.output, '"')
    
    for (ch in s) {
        if (ch == '"') {
            string.append(fmt.output, "\\\"")
        } else if (ch == '\\') {
            string.append(fmt.output, "\\\\")
        } else if (ch == '\b') {
            string.append(fmt.output, "\\b")
        } else if (ch == '\f') {
            string.append(fmt.output, "\\f")
        } else if (ch == '\n') {
            string.append(fmt.output, "\\n")
        } else if (ch == '\r') {
            string.append(fmt.output, "\\r")
        } else if (ch == '\t') {
            string.append(fmt.output, "\\t")
        } else if (ch < 0x20 || (fmt.options.escape_unicode && ch > 0x7F)) {
            string.append(fmt.output, string.format("\\u{:04x}", ch as u32))
        } else {
            string.push_char(fmt.output, ch)
        }
    }
    
    string.push_char(fmt.output, '"')
}

// Format array
format_array = (fmt: &mut Formatter, arr: Vec<JsonValue>) void {
    string.push_char(fmt.output, '[')
    
    if (vec.is_empty(arr)) {
        string.push_char(fmt.output, ']')
        return
    }
    
    if (!fmt.options.compact) {
        string.push_char(fmt.output, '\n')
        fmt.depth += 1
    }
    
    i := 0
    while (i < vec.len(arr)) {
        if (i > 0) {
            string.push_char(fmt.output, ',')
            if (!fmt.options.compact) {
                string.push_char(fmt.output, '\n')
            } else {
                string.push_char(fmt.output, ' ')
            }
        }
        
        if (!fmt.options.compact) {
            add_indent(fmt)
        }
        
        format_value(fmt, arr[i])
        i += 1
    }
    
    if (!fmt.options.compact) {
        fmt.depth -= 1
        string.push_char(fmt.output, '\n')
        add_indent(fmt)
    }
    
    string.push_char(fmt.output, ']')
}

// Format object
format_object = (fmt: &mut Formatter, obj: HashMap<string, JsonValue>) void {
    string.push_char(fmt.output, '{')
    
    if (hashmap.is_empty(obj)) {
        string.push_char(fmt.output, '}')
        return
    }
    
    if (!fmt.options.compact) {
        string.push_char(fmt.output, '\n')
        fmt.depth += 1
    }
    
    // Get keys
    keys := hashmap.keys(obj)
    if (fmt.options.sort_keys) {
        vec.sort(keys)
    }
    
    first := true
    for (key in keys) {
        if (!first) {
            string.push_char(fmt.output, ',')
            if (!fmt.options.compact) {
                string.push_char(fmt.output, '\n')
            } else {
                string.push_char(fmt.output, ' ')
            }
        }
        first = false
        
        if (!fmt.options.compact) {
            add_indent(fmt)
        }
        
        format_string(fmt, key)
        string.push_char(fmt.output, ':')
        if (!fmt.options.compact) {
            string.push_char(fmt.output, ' ')
        }
        
        value := hashmap.get(obj, key).unwrap()
        format_value(fmt, value)
    }
    
    if (!fmt.options.compact) {
        fmt.depth -= 1
        string.push_char(fmt.output, '\n')
        add_indent(fmt)
    }
    
    string.push_char(fmt.output, '}')
}

// Add indentation
add_indent = (fmt: &mut Formatter) void {
    i := 0
    while (i < fmt.depth) {
        string.append(fmt.output, fmt.options.indent)
        i += 1
    }
}

// Helper functions
skip_whitespace = (parser: &mut Parser) void {
    while (parser.pos < string.len(parser.input)) {
        ch := string.char_at(parser.input, parser.pos)
        if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n') {
            if (ch == '\n') {
                parser.line += 1
                parser.column = 1
            } else {
                parser.column += 1
            }
            parser.pos += 1
        } else {
            break
        }
    }
}

peek_char = (parser: &Parser) char {
    if (parser.pos < string.len(parser.input)) {
        return string.char_at(parser.input, parser.pos)
    }
    return '\0'
}

advance = (parser: &mut Parser) void {
    if (parser.pos < string.len(parser.input)) {
        ch := string.char_at(parser.input, parser.pos)
        parser.pos += 1
        if (ch == '\n') {
            parser.line += 1
            parser.column = 1
        } else {
            parser.column += 1
        }
    }
}

consume_char = (parser: &mut Parser, expected: char) bool {
    if (peek_char(parser) == expected) {
        advance(parser)
        return true
    }
    return false
}

consume_literal = (parser: &mut Parser, literal: string) bool {
    if (parser.pos + string.len(literal) > string.len(parser.input)) {
        return false
    }
    
    substr := string.substring(parser.input, parser.pos, parser.pos + string.len(literal))
    if (substr == literal) {
        parser.pos += string.len(literal)
        parser.column += string.len(literal)
        return true
    }
    return false
}

is_digit = (ch: char) bool {
    return ch >= '0' && ch <= '9'
}

parse_hex = (s: string) Result<u32, JsonError> {
    value := 0u32
    for (ch in s) {
        value *= 16
        if (ch >= '0' && ch <= '9') {
            value += (ch - '0') as u32
        } else if (ch >= 'a' && ch <= 'f') {
            value += (ch - 'a' + 10) as u32
        } else if (ch >= 'A' && ch <= 'F') {
            value += (ch - 'A' + 10) as u32
        } else {
            return Result.Err(JsonError.InvalidUnicode(0))
        }
    }
    return Result.Ok(value)
}

char_to_utf8 = (code_point: u32) string {
    if (code_point <= 0x7F) {
        return string.from_char(code_point as char)
    } else if (code_point <= 0x7FF) {
        bytes: [2]u8 = [
            0xC0 | ((code_point >> 6) & 0x1F) as u8,
            0x80 | (code_point & 0x3F) as u8
        ]
        return string.from_bytes(bytes)
    } else if (code_point <= 0xFFFF) {
        bytes: [3]u8 = [
            0xE0 | ((code_point >> 12) & 0x0F) as u8,
            0x80 | ((code_point >> 6) & 0x3F) as u8,
            0x80 | (code_point & 0x3F) as u8
        ]
        return string.from_bytes(bytes)
    } else {
        bytes: [4]u8 = [
            0xF0 | ((code_point >> 18) & 0x07) as u8,
            0x80 | ((code_point >> 12) & 0x3F) as u8,
            0x80 | ((code_point >> 6) & 0x3F) as u8,
            0x80 | (code_point & 0x3F) as u8
        ]
        return string.from_bytes(bytes)
    }
}

// Accessor methods for JsonValue
is_null = (value: &JsonValue) bool {
    match value {
        JsonValue.Null => true
        _ => false
    }
}

as_bool = (value: &JsonValue) Option<bool> {
    match value {
        JsonValue.Bool(b) => Option.Some(b)
        _ => Option.None
    }
}

as_number = (value: &JsonValue) Option<f64> {
    match value {
        JsonValue.Number(n) => Option.Some(n)
        _ => Option.None
    }
}

as_string = (value: &JsonValue) Option<string> {
    match value {
        JsonValue.String(s) => Option.Some(s)
        _ => Option.None
    }
}

as_array = (value: &JsonValue) Option<&Vec<JsonValue>> {
    match value {
        JsonValue.Array(arr) => Option.Some(&arr)
        _ => Option.None
    }
}

as_object = (value: &JsonValue) Option<&HashMap<string, JsonValue>> {
    match value {
        JsonValue.Object(obj) => Option.Some(&obj)
        _ => Option.None
    }
}

// Get field from object
get = (value: &JsonValue, key: string) Option<&JsonValue> {
    match value {
        JsonValue.Object(obj) => hashmap.get(obj, key)
        _ => Option.None
    }
}

// Get array element
at = (value: &JsonValue, index: usize) Option<&JsonValue> {
    match value {
        JsonValue.Array(arr) => {
            if (index < vec.len(arr)) {
                Option.Some(&arr[index])
            } else {
                Option.None
            }
        }
        _ => Option.None
    }
}