// Zen Standard Library - I/O Module
// Input/Output operations implemented in pure Zen

core := @std.core

// File handle type
File := struct {
    handle: *void
    path: core.String
    mode: FileMode
    is_open: bool
}

// File modes
FileMode := enum {
    Read
    Write
    Append
    ReadWrite
}

// Standard streams (will be initialized by runtime)
stdin: File = File{ handle: @builtin.stdin, path: "<stdin>", mode: .Read, is_open: true }
stdout: File = File{ handle: @builtin.stdout, path: "<stdout>", mode: .Write, is_open: true }
stderr: File = File{ handle: @builtin.stderr, path: "<stderr>", mode: .Write, is_open: true }

// Print functions
print = (s: core.String) void {
    write_string(&stdout, s)
}

println = (s: core.String) void {
    print(s)
    print("\n")
}

print_int = (value: i64) void {
    buffer: [32]byte
    len := format_int(value, &buffer[0], 32)
    s := core.String{ data: &buffer[0], len: len }
    print(s)
}

print_uint = (value: u64) void {
    buffer: [32]byte
    len := format_uint(value, &buffer[0], 32)
    s := core.String{ data: &buffer[0], len: len }
    print(s)
}

print_float = (value: f64) void {
    buffer: [64]byte
    len := format_float(value, &buffer[0], 64)
    s := core.String{ data: &buffer[0], len: len }
    print(s)
}

eprint = (s: core.String) void {
    write_string(&stderr, s)
}

eprintln = (s: core.String) void {
    eprint(s)
    eprint("\n")
}

// Format functions
format_int = (value: i64, buffer: *byte, size: usize) usize {
    if (size == 0) return 0
    
    is_negative := value < 0
    if (is_negative) {
        value = -value
    }
    
    // Convert to string backwards
    i := size - 1
    if (value == 0) {
        buffer[i] = '0'
        return 1
    }
    
    len := usize(0)
    while (value > 0 && i > 0) {
        digit := byte(value % 10)
        buffer[i] = '0' + digit
        value = value / 10
        i = i - 1
        len = len + 1
    }
    
    // Add negative sign if needed
    if (is_negative && i > 0) {
        buffer[i] = '-'
        i = i - 1
        len = len + 1
    }
    
    // Shift to beginning of buffer
    core.move(byte, buffer, buffer + i + 1, len)
    return len
}

format_uint = (value: u64, buffer: *byte, size: usize) usize {
    if (size == 0) return 0
    
    // Convert to string backwards
    i := size - 1
    if (value == 0) {
        buffer[i] = '0'
        return 1
    }
    
    len := usize(0)
    while (value > 0 && i < size) {
        digit := byte(value % 10)
        buffer[i] = '0' + digit
        value = value / 10
        i = i - 1
        len = len + 1
    }
    
    // Shift to beginning of buffer
    core.move(byte, buffer, buffer + i + 1, len)
    return len
}

format_float = (value: f64, buffer: *byte, size: usize) usize {
    // Simplified float formatting
    // In real implementation, this would use proper float-to-string algorithm
    
    if (size < 10) return 0
    
    // Handle negative
    i := usize(0)
    if (value < 0) {
        buffer[i] = '-'
        i = i + 1
        value = -value
    }
    
    // Integer part
    int_part := i64(value)
    int_len := format_int(int_part, buffer + i, size - i)
    i = i + int_len
    
    // Decimal point
    if (i < size) {
        buffer[i] = '.'
        i = i + 1
    }
    
    // Fractional part (6 decimal places)
    frac_part := value - f64(int_part)
    digits := 6
    while (digits > 0 && i < size) {
        frac_part = frac_part * 10
        digit := i64(frac_part)
        buffer[i] = '0' + byte(digit)
        i = i + 1
        frac_part = frac_part - f64(digit)
        digits = digits - 1
    }
    
    return i
}

// File operations
open = (path: core.String, mode: FileMode) core.Result(File, core.String) {
    handle := @builtin.fopen(path, mode)
    if (handle == null) {
        return core.Result(File, core.String).Err("Failed to open file")
    }
    
    file := File{
        handle: handle,
        path: path,
        mode: mode,
        is_open: true
    }
    return core.Result(File, core.String).Ok(file)
}

close = (file: *File) void {
    if (file.is_open) {
        @builtin.fclose(file.handle)
        file.is_open = false
    }
}

read = (file: *File, buffer: *byte, size: usize) core.Result(usize, core.String) {
    if (!file.is_open) {
        return core.Result(usize, core.String).Err("File not open")
    }
    
    bytes_read := @builtin.fread(buffer, 1, size, file.handle)
    return core.Result(usize, core.String).Ok(bytes_read)
}

write = (file: *File, buffer: *byte, size: usize) core.Result(usize, core.String) {
    if (!file.is_open) {
        return core.Result(usize, core.String).Err("File not open")
    }
    
    bytes_written := @builtin.fwrite(buffer, 1, size, file.handle)
    return core.Result(usize, core.String).Ok(bytes_written)
}

write_string = (file: *File, s: core.String) core.Result(usize, core.String) {
    return write(file, s.data, s.len)
}

read_line = (file: *File, buffer: *byte, size: usize) core.Result(usize, core.String) {
    if (!file.is_open) {
        return core.Result(usize, core.String).Err("File not open")
    }
    
    i := usize(0)
    while (i < size - 1) {
        result := read(file, buffer + i, 1)
        match (result) {
            .Ok(bytes) => {
                if (bytes == 0) break  // EOF
                if (buffer[i] == '\n') {
                    i = i + 1
                    break
                }
                i = i + 1
            }
            .Err(msg) => return core.Result(usize, core.String).Err(msg)
        }
    }
    
    buffer[i] = 0  // Null terminate
    return core.Result(usize, core.String).Ok(i)
}

// Flush output
flush = (file: *File) void {
    if (file.is_open) {
        @builtin.fflush(file.handle)
    }
}

// Export public functions
export {
    // Types
    File, FileMode,
    
    // Standard streams
    stdin, stdout, stderr,
    
    // Print functions
    print, println, print_int, print_uint, print_float,
    eprint, eprintln,
    
    // File operations
    open, close, read, write, write_string, read_line, flush,
    
    // Format functions
    format_int, format_uint, format_float
}