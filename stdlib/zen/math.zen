// Zen Standard Library - Math Module
// Mathematical functions and constants

core := @std.core

// Mathematical constants
PI = 3.14159265358979323846
E = 2.71828182845904523536
TAU = 6.28318530717958647692
PHI = 1.61803398874989484820  // Golden ratio
SQRT2 = 1.41421356237309504880
SQRT3 = 1.73205080756887729352
LN2 = 0.69314718055994530941
LN10 = 2.30258509299404568401

// Basic math functions

// Absolute value
abs = (x: i64) i64 {
    return x < 0 ? -x : x
}

abs_f32 = (x: f32) f32 {
    return x < 0.0 ? -x : x
}

abs_f64 = (x: f64) f64 {
    return x < 0.0 ? -x : x
}

// Min and max
min = (a: i64, b: i64) i64 {
    return a < b ? a : b
}

max = (a: i64, b: i64) i64 {
    return a > b ? a : b
}

min_f32 = (a: f32, b: f32) f32 {
    return a < b ? a : b
}

max_f32 = (a: f32, b: f32) f32 {
    return a > b ? a : b
}

min_f64 = (a: f64, b: f64) f64 {
    return a < b ? a : b
}

max_f64 = (a: f64, b: f64) f64 {
    return a > b ? a : b
}

// Clamp value between min and max
clamp = (value: i64, min_val: i64, max_val: i64) i64 {
    return min(max(value, min_val), max_val)
}

clamp_f32 = (value: f32, min_val: f32, max_val: f32) f32 {
    return min_f32(max_f32(value, min_val), max_val)
}

clamp_f64 = (value: f64, min_val: f64, max_val: f64) f64 {
    return min_f64(max_f64(value, min_val), max_val)
}

// Sign function
sign = (x: i64) i64 {
    if x > 0 {
        return 1
    } else if x < 0 {
        return -1
    }
    return 0
}

sign_f32 = (x: f32) f32 {
    if x > 0.0 {
        return 1.0
    } else if x < 0.0 {
        return -1.0
    }
    return 0.0
}

sign_f64 = (x: f64) f64 {
    if x > 0.0 {
        return 1.0
    } else if x < 0.0 {
        return -1.0
    }
    return 0.0
}

// Power function (integer)
pow = (base: i64, exp: i64) i64 {
    if exp < 0 {
        return 0  // Integer division by power
    }
    
    result := 1
    e := exp
    b := base
    
    loop e > 0 {
        if e & 1 == 1 {
            result = result * b
        }
        b = b * b
        e = e >> 1
    }
    
    return result
}

// Factorial
factorial = (n: i64) i64 {
    if n < 0 {
        core.panic("factorial of negative number")
    }
    
    result := 1
    i := 2
    loop i <= n {
        result = result * i
        i = i + 1
    }
    
    return result
}

// Greatest common divisor (Euclidean algorithm)
gcd = (a: i64, b: i64) i64 {
    a_val := abs(a)
    b_val := abs(b)
    
    loop b_val != 0 {
        temp := b_val
        b_val = a_val % b_val
        a_val = temp
    }
    
    return a_val
}

// Least common multiple
lcm = (a: i64, b: i64) i64 {
    if a == 0 || b == 0 {
        return 0
    }
    return abs(a * b) / gcd(a, b)
}

// Check if number is prime
is_prime = (n: i64) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false
    }
    
    i := 5
    loop i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false
        }
        i = i + 6
    }
    
    return true
}

// Square root approximation (Newton's method)
sqrt = (x: f64) f64 {
    if x < 0.0 {
        core.panic("sqrt of negative number")
    }
    if x == 0.0 {
        return 0.0
    }
    
    guess := x
    epsilon := 0.000001
    
    loop abs_f64(guess * guess - x) > epsilon {
        guess = (guess + x / guess) / 2.0
    }
    
    return guess
}

// Cubic root approximation
cbrt = (x: f64) f64 {
    if x == 0.0 {
        return 0.0
    }
    
    neg := x < 0.0
    val := abs_f64(x)
    
    guess := val
    epsilon := 0.000001
    
    loop abs_f64(guess * guess * guess - val) > epsilon {
        guess = (2.0 * guess + val / (guess * guess)) / 3.0
    }
    
    return neg ? -guess : guess
}

// Floor function
floor = (x: f64) i64 {
    i := x as i64
    if x < 0.0 && x != i as f64 {
        return i - 1
    }
    return i
}

// Ceiling function
ceil = (x: f64) i64 {
    i := x as i64
    if x > 0.0 && x != i as f64 {
        return i + 1
    }
    return i
}

// Round to nearest integer
round = (x: f64) i64 {
    if x >= 0.0 {
        return floor(x + 0.5)
    }
    return ceil(x - 0.5)
}

// Truncate decimal part
trunc = (x: f64) i64 {
    return x as i64
}

// Linear interpolation
lerp = (a: f64, b: f64, t: f64) f64 {
    return a + (b - a) * t
}

// Map value from one range to another
map_range = (value: f64, in_min: f64, in_max: f64, out_min: f64, out_max: f64) f64 {
    return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
}

// Modulo that always returns positive result
mod_positive = (a: i64, b: i64) i64 {
    result := a % b
    return result < 0 ? result + abs(b) : result
}

// Check if two floats are approximately equal
approx_equal = (a: f64, b: f64, epsilon: f64) bool {
    return abs_f64(a - b) < epsilon
}

// Degrees to radians
deg_to_rad = (degrees: f64) f64 {
    return degrees * PI / 180.0
}

// Radians to degrees
rad_to_deg = (radians: f64) f64 {
    return radians * 180.0 / PI
}

// Trigonometric functions approximations

// Sine approximation using Taylor series
sin = (x: f64) f64 {
    // Normalize angle to [-pi, pi]
    angle := x
    loop angle > PI {
        angle = angle - TAU
    }
    loop angle < -PI {
        angle = angle + TAU
    }
    
    // Taylor series: sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...
    result := angle
    term := angle
    i := 1
    
    loop i < 10 {
        term = term * -angle * angle / ((2.0 * i as f64) * (2.0 * i as f64 + 1.0))
        result = result + term
        i = i + 1
    }
    
    return result
}

// Cosine approximation using Taylor series
cos = (x: f64) f64 {
    // cos(x) = sin(x + pi/2)
    return sin(x + PI / 2.0)
}

// Tangent approximation
tan = (x: f64) f64 {
    c := cos(x)
    if approx_equal(c, 0.0, 0.000001) {
        core.panic("tan undefined at this angle")
    }
    return sin(x) / c
}

// Exponential approximation using Taylor series
exp = (x: f64) f64 {
    // e^x = 1 + x + x^2/2! + x^3/3! + ...
    result := 1.0
    term := 1.0
    i := 1
    
    loop i < 20 {
        term = term * x / i as f64
        result = result + term
        i = i + 1
    }
    
    return result
}

// Natural logarithm approximation
ln = (x: f64) f64 {
    if x <= 0.0 {
        core.panic("ln of non-positive number")
    }
    
    // Use series expansion for ln(1+y) where y = (x-1)/(x+1)
    // ln(x) = 2 * (y + y^3/3 + y^5/5 + ...)
    
    // First normalize x to be close to 1
    exp_adjust := 0
    val := x
    
    loop val > 2.0 {
        val = val / E
        exp_adjust = exp_adjust + 1
    }
    
    loop val < 0.5 {
        val = val * E
        exp_adjust = exp_adjust - 1
    }
    
    y := (val - 1.0) / (val + 1.0)
    y2 := y * y
    
    result := y
    term := y
    i := 1
    
    loop i < 20 {
        term = term * y2
        result = result + term / (2.0 * i as f64 + 1.0)
        i = i + 1
    }
    
    return 2.0 * result + exp_adjust as f64
}

// Logarithm base 10
log10 = (x: f64) f64 {
    return ln(x) / LN10
}

// Logarithm base 2
log2 = (x: f64) f64 {
    return ln(x) / LN2
}

// General logarithm
log = (x: f64, base: f64) f64 {
    return ln(x) / ln(base)
}

// Hyperbolic functions

sinh = (x: f64) f64 {
    ex := exp(x)
    return (ex - 1.0 / ex) / 2.0
}

cosh = (x: f64) f64 {
    ex := exp(x)
    return (ex + 1.0 / ex) / 2.0
}

tanh = (x: f64) f64 {
    ex := exp(2.0 * x)
    return (ex - 1.0) / (ex + 1.0)
}

// Statistical functions

// Mean of array
mean = (values: []f64) f64 {
    if values.len() == 0 {
        return 0.0
    }
    
    sum := 0.0
    for v in values {
        sum = sum + v
    }
    
    return sum / values.len() as f64
}

// Variance of array
variance = (values: []f64) f64 {
    if values.len() == 0 {
        return 0.0
    }
    
    m := mean(values)
    sum := 0.0
    
    for v in values {
        diff := v - m
        sum = sum + diff * diff
    }
    
    return sum / values.len() as f64
}

// Standard deviation
std_dev = (values: []f64) f64 {
    return sqrt(variance(values))
}

// Random number generation (simple linear congruential generator)
RandomState = struct {
    seed: u64
}

// Create new random state
random_new = (seed: u64) RandomState {
    return RandomState { seed: seed }
}

// Generate next random number
random_next = (state: *RandomState) u64 {
    state.seed = (state.seed * 1103515245 + 12345) & 0x7fffffff
    return state.seed
}

// Generate random float between 0 and 1
random_float = (state: *RandomState) f64 {
    return random_next(state) as f64 / 0x7fffffff as f64
}

// Generate random integer in range [min, max)
random_range = (state: *RandomState, min: i64, max: i64) i64 {
    if min >= max {
        return min
    }
    range := (max - min) as u64
    return min + (random_next(state) % range) as i64
}

// Bit manipulation utilities

// Count set bits
popcount = (x: u64) i32 {
    count := 0
    val := x
    loop val != 0 {
        count = count + 1
        val = val & (val - 1)
    }
    return count
}

// Count leading zeros
clz = (x: u64) i32 {
    if x == 0 {
        return 64
    }
    
    count := 0
    val := x
    
    if val & 0xffffffff00000000 == 0 { count = count + 32; val = val << 32 }
    if val & 0xffff000000000000 == 0 { count = count + 16; val = val << 16 }
    if val & 0xff00000000000000 == 0 { count = count + 8; val = val << 8 }
    if val & 0xf000000000000000 == 0 { count = count + 4; val = val << 4 }
    if val & 0xc000000000000000 == 0 { count = count + 2; val = val << 2 }
    if val & 0x8000000000000000 == 0 { count = count + 1 }
    
    return count
}

// Count trailing zeros
ctz = (x: u64) i32 {
    if x == 0 {
        return 64
    }
    return popcount((x & -x) - 1)
}

// Check if power of 2
is_power_of_2 = (x: u64) bool {
    return x != 0 && (x & (x - 1)) == 0
}

// Next power of 2
next_power_of_2 = (x: u64) u64 {
    if x == 0 {
        return 1
    }
    
    val := x - 1
    val = val | (val >> 1)
    val = val | (val >> 2)
    val = val | (val >> 4)
    val = val | (val >> 8)
    val = val | (val >> 16)
    val = val | (val >> 32)
    
    return val + 1
}