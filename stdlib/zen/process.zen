// Zen Process Module - Pure Zen implementation
// Provides process and subprocess management capabilities

core := @std.core
io := @std.io
string := @std.string
vec := @std.vec
hashmap := @std.hashmap
result := @std.result
fs := @std.fs

// Process exit status
ExitStatus := enum {
    Success(code: i32)
    Failed(code: i32)
    Signaled(signal: i32)
    Stopped(signal: i32)
}

// Process I/O configuration
Stdio := enum {
    Inherit    // Use parent's stdio
    Piped      // Create new pipe
    Null       // Redirect to /dev/null
}

// Child process handle
Child := struct {
    pid: u32
    stdin: Option<Pipe>
    stdout: Option<Pipe>
    stderr: Option<Pipe>
    status: Option<ExitStatus>
}

// Pipe for IPC
Pipe := struct {
    read_fd: i32
    write_fd: i32
}

// Command builder
Command := struct {
    program: string
    args: Vec<string>
    env: HashMap<string, string>
    current_dir: Option<string>
    stdin: Stdio
    stdout: Stdio
    stderr: Stdio
}

// Process information
ProcessInfo := struct {
    pid: u32
    ppid: u32
    name: string
    cmd_line: Vec<string>
    env: HashMap<string, string>
    cwd: string
    uid: u32
    gid: u32
    memory_usage: usize
    cpu_usage: f32
    start_time: u64
}

// Signal types
Signal := enum {
    SIGHUP = 1
    SIGINT = 2
    SIGQUIT = 3
    SIGILL = 4
    SIGTRAP = 5
    SIGABRT = 6
    SIGBUS = 7
    SIGFPE = 8
    SIGKILL = 9
    SIGUSR1 = 10
    SIGSEGV = 11
    SIGUSR2 = 12
    SIGPIPE = 13
    SIGALRM = 14
    SIGTERM = 15
    SIGCHLD = 17
    SIGCONT = 18
    SIGSTOP = 19
    SIGTSTP = 20
    SIGTTIN = 21
    SIGTTOU = 22
}

// Process error types
ProcessError := enum {
    NotFound
    PermissionDenied
    InvalidArgument
    ResourceBusy
    PipeBroken
    WouldBlock
    TimedOut
    Other(msg: string)
}

// Create new command
command = (program: string) Command {
    return Command{
        program: program,
        args: vec.new<string>(),
        env: hashmap.new<string, string>(),
        current_dir: Option.None,
        stdin: Stdio.Inherit,
        stdout: Stdio.Inherit,
        stderr: Stdio.Inherit
    }
}

// Add argument
add_arg = (cmd: &mut Command, arg: string) &mut Command {
    vec.push(cmd.args, arg)
    return cmd
}

// Add multiple arguments
add_args = (cmd: &mut Command, args: []string) &mut Command {
    for (arg in args) {
        vec.push(cmd.args, arg)
    }
    return cmd
}

// Set environment variable
set_env = (cmd: &mut Command, key: string, value: string) &mut Command {
    hashmap.insert(cmd.env, key, value)
    return cmd
}

// Set multiple environment variables
set_envs = (cmd: &mut Command, vars: HashMap<string, string>) &mut Command {
    hashmap.foreach(vars, (k, v) => {
        hashmap.insert(cmd.env, k, v)
    })
    return cmd
}

// Clear environment
clear_env = (cmd: &mut Command) &mut Command {
    cmd.env = hashmap.new<string, string>()
    return cmd
}

// Set current directory
set_current_dir = (cmd: &mut Command, dir: string) &mut Command {
    cmd.current_dir = Option.Some(dir)
    return cmd
}

// Configure stdin
set_stdin = (cmd: &mut Command, cfg: Stdio) &mut Command {
    cmd.stdin = cfg
    return cmd
}

// Configure stdout
set_stdout = (cmd: &mut Command, cfg: Stdio) &mut Command {
    cmd.stdout = cfg
    return cmd
}

// Configure stderr
set_stderr = (cmd: &mut Command, cfg: Stdio) &mut Command {
    cmd.stderr = cfg
    return cmd
}

// Spawn child process
spawn = (cmd: &Command) Result<Child, ProcessError> {
    // Prepare stdio
    stdin_pipe := match cmd.stdin {
        Stdio.Piped => Option.Some(create_pipe()?)
        _ => Option.None
    }
    
    stdout_pipe := match cmd.stdout {
        Stdio.Piped => Option.Some(create_pipe()?)
        _ => Option.None
    }
    
    stderr_pipe := match cmd.stderr {
        Stdio.Piped => Option.Some(create_pipe()?)
        _ => Option.None
    }
    
    // Fork and exec
    pid := fork()?
    
    if (pid == 0) {
        // Child process
        setup_child_stdio(stdin_pipe, stdout_pipe, stderr_pipe, cmd)?
        
        // Change directory if specified
        match cmd.current_dir {
            Option.Some(dir) => {
                fs.set_current_dir(dir)?
            }
            _ => {}
        }
        
        // Set environment
        if (!hashmap.is_empty(cmd.env)) {
            hashmap.foreach(cmd.env, (key, value) => {
                set_env_var(key, value)
            })
        }
        
        // Execute program
        exec(cmd.program, cmd.args)?
        
        // Should never reach here
        exit(1)
    }
    
    // Parent process
    child := Child{
        pid: pid,
        stdin: stdin_pipe,
        stdout: stdout_pipe,
        stderr: stderr_pipe,
        status: Option.None
    }
    
    return Result.Ok(child)
}

// Run command and wait for completion
run = (cmd: &Command) Result<ExitStatus, ProcessError> {
    child := spawn(cmd)?
    return wait(&mut child)
}

// Run command and capture output
output = (cmd: &mut Command) Result<Output, ProcessError> {
    // Force piped output
    cmd.stdout = Stdio.Piped
    cmd.stderr = Stdio.Piped
    
    child := spawn(cmd)?
    
    // Read output
    stdout_data := vec.new<u8>()
    stderr_data := vec.new<u8>()
    
    match child.stdout {
        Option.Some(pipe) => {
            read_all_from_pipe(pipe, &mut stdout_data)?
        }
        _ => {}
    }
    
    match child.stderr {
        Option.Some(pipe) => {
            read_all_from_pipe(pipe, &mut stderr_data)?
        }
        _ => {}
    }
    
    // Wait for completion
    status := wait(&mut child)?
    
    return Result.Ok(Output{
        status: status,
        stdout: stdout_data,
        stderr: stderr_data
    })
}

// Command output
Output := struct {
    status: ExitStatus
    stdout: Vec<u8>
    stderr: Vec<u8>
}

// Wait for child to complete
wait = (child: &mut Child) Result<ExitStatus, ProcessError> {
    if (child.status.is_some()) {
        return Result.Ok(child.status.unwrap())
    }
    
    status := waitpid(child.pid)?
    child.status = Option.Some(status)
    return Result.Ok(status)
}

// Try to wait without blocking
try_wait = (child: &mut Child) Result<Option<ExitStatus>, ProcessError> {
    if (child.status.is_some()) {
        return Result.Ok(child.status)
    }
    
    result := try_waitpid(child.pid)?
    match result {
        Option.Some(status) => {
            child.status = Option.Some(status)
        }
        _ => {}
    }
    
    return Result.Ok(result)
}

// Kill child process
kill = (child: &mut Child) Result<void, ProcessError> {
    return send_signal(child.pid, Signal.SIGKILL)
}

// Send signal to child
signal = (child: &mut Child, sig: Signal) Result<void, ProcessError> {
    return send_signal(child.pid, sig)
}

// Write to child stdin
write_stdin = (child: &mut Child, data: &[u8]) Result<usize, ProcessError> {
    match child.stdin {
        Option.Some(pipe) => {
            return write_to_pipe(pipe, data)
        }
        _ => {
            return Result.Err(ProcessError.InvalidArgument)
        }
    }
}

// Read from child stdout
read_stdout = (child: &mut Child, buf: &mut [u8]) Result<usize, ProcessError> {
    match child.stdout {
        Option.Some(pipe) => {
            return read_from_pipe(pipe, buf)
        }
        _ => {
            return Result.Err(ProcessError.InvalidArgument)
        }
    }
}

// Read from child stderr
read_stderr = (child: &mut Child, buf: &mut [u8]) Result<usize, ProcessError> {
    match child.stderr {
        Option.Some(pipe) => {
            return read_from_pipe(pipe, buf)
        }
        _ => {
            return Result.Err(ProcessError.InvalidArgument)
        }
    }
}

// Get current process ID
pid = () u32 {
    return getpid()
}

// Get parent process ID
ppid = () u32 {
    return getppid()
}

// Get process information
get_process_info = (pid: u32) Result<ProcessInfo, ProcessError> {
    // Read from /proc/[pid]/stat and other files
    stat_path := string.format("/proc/{}/stat", pid)
    stat_data := fs.read_file(stat_path)?
    
    cmdline_path := string.format("/proc/{}/cmdline", pid)
    cmdline_data := fs.read_file(cmdline_path)?
    
    cwd_path := string.format("/proc/{}/cwd", pid)
    cwd := fs.readlink(cwd_path)?
    
    // Parse process information
    info := parse_proc_stat(stat_data)?
    info.cwd = cwd
    info.cmd_line = parse_cmdline(cmdline_data)
    
    return Result.Ok(info)
}

// List all processes
list_processes = () Result<Vec<ProcessInfo>, ProcessError> {
    processes := vec.new<ProcessInfo>()
    
    // Read /proc directory
    entries := fs.read_dir("/proc")?
    
    for (entry in entries) {
        // Check if directory name is a PID
        if (is_numeric(entry.name)) {
            pid := string.parse_u32(entry.name)?
            info := get_process_info(pid)
            if (info.is_ok()) {
                vec.push(processes, info.unwrap())
            }
        }
    }
    
    return Result.Ok(processes)
}

// Environment variables
get_env = (key: string) Option<string> {
    return getenv(key)
}

set_env_var = (key: string, value: string) void {
    setenv(key, value, true)
}

remove_env_var = (key: string) void {
    unsetenv(key)
}

// Get all environment variables
env_vars = () HashMap<string, string> {
    vars := hashmap.new<string, string>()
    env := environ()
    
    for (entry in env) {
        parts := string.split_once(entry, "=")
        if (parts.is_some()) {
            pair := parts.unwrap()
            hashmap.insert(vars, pair.0, pair.1)
        }
    }
    
    return vars
}

// Working directory
current_dir = () Result<string, ProcessError> {
    return getcwd()
}

set_current_dir = (path: string) Result<void, ProcessError> {
    return chdir(path)
}

// Exit current process
exit = (code: i32) ! {
    _exit(code)
}

// Abort process
abort = () ! {
    _abort()
}

// Sleep for duration in milliseconds
sleep = (ms: u64) void {
    usleep(ms * 1000)
}

// Execute shell command
shell = (cmd: string) Result<ExitStatus, ProcessError> {
    return command("sh")
        .add_arg("-c")
        .add_arg(cmd)
        .run()
}

// Execute shell command and capture output
shell_output = (cmd: string) Result<Output, ProcessError> {
    return command("sh")
        .add_arg("-c")
        .add_arg(cmd)
        .output()
}

// Helper functions
create_pipe = () Result<Pipe, ProcessError> {
    fds := pipe2()?
    return Result.Ok(Pipe{
        read_fd: fds.0,
        write_fd: fds.1
    })
}

setup_child_stdio = (stdin: Option<Pipe>, stdout: Option<Pipe>, stderr: Option<Pipe>, cmd: &Command) Result<void, ProcessError> {
    // Setup stdin
    match cmd.stdin {
        Stdio.Piped => {
            if (stdin.is_some()) {
                pipe := stdin.unwrap()
                dup2(pipe.read_fd, 0)?
                close(pipe.read_fd)?
                close(pipe.write_fd)?
            }
        }
        Stdio.Null => {
            fd := open("/dev/null", O_RDONLY)?
            dup2(fd, 0)?
            close(fd)?
        }
        _ => {}
    }
    
    // Setup stdout
    match cmd.stdout {
        Stdio.Piped => {
            if (stdout.is_some()) {
                pipe := stdout.unwrap()
                dup2(pipe.write_fd, 1)?
                close(pipe.read_fd)?
                close(pipe.write_fd)?
            }
        }
        Stdio.Null => {
            fd := open("/dev/null", O_WRONLY)?
            dup2(fd, 1)?
            close(fd)?
        }
        _ => {}
    }
    
    // Setup stderr
    match cmd.stderr {
        Stdio.Piped => {
            if (stderr.is_some()) {
                pipe := stderr.unwrap()
                dup2(pipe.write_fd, 2)?
                close(pipe.read_fd)?
                close(pipe.write_fd)?
            }
        }
        Stdio.Null => {
            fd := open("/dev/null", O_WRONLY)?
            dup2(fd, 2)?
            close(fd)?
        }
        _ => {}
    }
    
    return Result.Ok(void)
}

read_all_from_pipe = (pipe: Pipe, data: &mut Vec<u8>) Result<void, ProcessError> {
    buf: [4096]u8
    loop {
        n := read(pipe.read_fd, &buf)?
        if (n == 0) break
        vec.extend(data, buf[..n])
    }
    return Result.Ok(void)
}

write_to_pipe = (pipe: Pipe, data: &[u8]) Result<usize, ProcessError> {
    return write(pipe.write_fd, data)
}

read_from_pipe = (pipe: Pipe, buf: &mut [u8]) Result<usize, ProcessError> {
    return read(pipe.read_fd, buf)
}

parse_proc_stat = (data: string) Result<ProcessInfo, ProcessError> {
    // Simplified parsing of /proc/[pid]/stat
    // Format: pid (comm) state ppid pgrp session tty_nr ...
    
    parts := string.split(data, " ")
    if (vec.len(parts) < 4) {
        return Result.Err(ProcessError.InvalidArgument)
    }
    
    info := ProcessInfo{
        pid: string.parse_u32(parts[0])?,
        name: string.trim(parts[1], "()"),
        ppid: string.parse_u32(parts[3])?,
        cmd_line: vec.new<string>(),
        env: hashmap.new<string, string>(),
        cwd: "",
        uid: 0,
        gid: 0,
        memory_usage: 0,
        cpu_usage: 0.0,
        start_time: 0
    }
    
    return Result.Ok(info)
}

parse_cmdline = (data: string) Vec<string> {
    // Split by null bytes
    return string.split(data, "\0")
}

is_numeric = (s: string) bool {
    if (string.is_empty(s)) return false
    
    for (c in s) {
        if (c < '0' || c > '9') return false
    }
    return true
}

// System calls (would be implemented with FFI)
@extern("fork")
fork = () Result<u32, ProcessError>

@extern("exec")
exec = (program: string, args: Vec<string>) Result<void, ProcessError>

@extern("waitpid")
waitpid = (pid: u32) Result<ExitStatus, ProcessError>

@extern("try_waitpid")
try_waitpid = (pid: u32) Result<Option<ExitStatus>, ProcessError>

@extern("kill")
send_signal = (pid: u32, signal: Signal) Result<void, ProcessError>

@extern("getpid")
getpid = () u32

@extern("getppid")
getppid = () u32

@extern("pipe2")
pipe2 = () Result<(i32, i32), ProcessError>

@extern("dup2")
dup2 = (oldfd: i32, newfd: i32) Result<void, ProcessError>

@extern("close")
close = (fd: i32) Result<void, ProcessError>

@extern("open")
open = (path: string, flags: i32) Result<i32, ProcessError>

@extern("read")
read = (fd: i32, buf: &mut [u8]) Result<usize, ProcessError>

@extern("write")
write = (fd: i32, data: &[u8]) Result<usize, ProcessError>

@extern("getenv")
getenv = (key: string) Option<string>

@extern("setenv")
setenv = (key: string, value: string, overwrite: bool) void

@extern("unsetenv")
unsetenv = (key: string) void

@extern("environ")
environ = () []string

@extern("getcwd")
getcwd = () Result<string, ProcessError>

@extern("chdir")
chdir = (path: string) Result<void, ProcessError>

@extern("_exit")
_exit = (code: i32) !

@extern("_abort")
_abort = () !

@extern("usleep")
usleep = (microseconds: u64) void

// File open flags
O_RDONLY := 0
O_WRONLY := 1
O_RDWR := 2