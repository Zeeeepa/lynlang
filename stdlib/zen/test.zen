// Testing Framework for Zen
// Provides comprehensive testing utilities and assertions

core := @std.core
io := @std.io
string := @std.string
fs := @std.fs
process := @std.process

// Test result
TestResult = enum {
    Passed,
    Failed -> reason: string,
    Skipped -> reason: string,
    Panicked -> message: string,
}

// Test case
TestCase = {
    name: string,
    func: *() TestResult,
    file: string,
    line: u32,
    tags: []string,
    timeout: u64,
}

// Test suite
TestSuite = {
    name: string,
    tests: []TestCase,
    setup: Option<*() void>,
    teardown: Option<*() void>,
    parallel: bool,
}

// Test runner
TestRunner = {
    suites: []TestSuite,
    filter: Option<string>,
    verbose: bool,
    parallel: bool,
    stop_on_failure: bool,
    timeout: u64,
    results: []TestRunResult,
}

// Test run result
TestRunResult = {
    suite: string,
    test: string,
    result: TestResult,
    duration: u64,
    output: string,
}

// Benchmark result
BenchmarkResult = {
    name: string,
    iterations: u64,
    total_time: u64,
    avg_time: f64,
    min_time: u64,
    max_time: u64,
    ops_per_sec: f64,
}

// Test context
TestContext = {
    name: string,
    failed: bool,
    messages: []string,
    benchmarks: []BenchmarkResult,
}

// Global test registry
TEST_REGISTRY := []TestSuite {}
CURRENT_CONTEXT := Option<&TestContext> { .None }

// Register a test suite
register_suite = (suite: TestSuite) void {
    TEST_REGISTRY.push(suite)
}

// Create a test
test = (name: string, func: *() void) TestCase {
    wrapper := () TestResult => {
        ctx := TestContext {
            name: name,
            failed: false,
            messages: [],
            benchmarks: [],
        }
        
        CURRENT_CONTEXT = .Some -> &ctx;
        
        // Run test with panic handling
        result := catch_panic(() void => func());
        
        result ?
            | .Ok => {
                ctx.failed ? | true => .Failed -> reason: ctx.messages.join("\n")
                           | false => .Passed
            }
            | .Err -> msg => .Panicked -> message: msg
    }
    
    return TestCase {
        name: name,
        func: wrapper,
        file: __FILE__,
        line: __LINE__,
        tags: [],
        timeout: 30000,  // 30 seconds default
    }
}

// Skip a test
skip = (name: string, reason: string) TestCase {
    return TestCase {
        name: name,
        func: () TestResult => .Skipped -> reason: reason,
        file: __FILE__,
        line: __LINE__,
        tags: [],
        timeout: 0,
    }
}

// Assert equality
assert_eq<T> = (actual: T, expected: T, message: string = "") void {
    actual != expected ? | true => {
        ctx := CURRENT_CONTEXT ?
            | .Some -> c => c
            | .None => panic("assert_eq called outside test context")
        
        msg := message.is_empty() ? 
            | true => "Expected $(expected), got $(actual)"
            | false => message;
        
        ctx.messages.push(msg);
        ctx.failed = true;
        
        panic(msg)
    }
}

// Assert inequality
assert_ne<T> = (actual: T, expected: T, message: string = "") void {
    actual == expected ? | true => {
        ctx := CURRENT_CONTEXT ?
            | .Some -> c => c
            | .None => panic("assert_ne called outside test context")
        
        msg := message.is_empty() ?
            | true => "Expected not equal to $(expected), but got $(actual)"
            | false => message;
        
        ctx.messages.push(msg);
        ctx.failed = true;
        
        panic(msg)
    }
}

// Assert true
assert = (condition: bool, message: string = "") void {
    condition ? | false => {
        ctx := CURRENT_CONTEXT ?
            | .Some -> c => c
            | .None => panic("assert called outside test context")
        
        msg := message.is_empty() ?
            | true => "Assertion failed"
            | false => message;
        
        ctx.messages.push(msg);
        ctx.failed = true;
        
        panic(msg)
    }
}

// Assert false
assert_false = (condition: bool, message: string = "") void {
    condition ? | true => {
        ctx := CURRENT_CONTEXT ?
            | .Some -> c => c
            | .None => panic("assert_false called outside test context")
        
        msg := message.is_empty() ?
            | true => "Expected false but got true"
            | false => message;
        
        ctx.messages.push(msg);
        ctx.failed = true;
        
        panic(msg)
    }
}

// Assert less than
assert_lt<T> = (actual: T, expected: T, message: string = "") void {
    actual >= expected ? | true => {
        ctx := CURRENT_CONTEXT ?
            | .Some -> c => c
            | .None => panic("assert_lt called outside test context")
        
        msg := message.is_empty() ?
            | true => "Expected $(actual) < $(expected)"
            | false => message;
        
        ctx.messages.push(msg);
        ctx.failed = true;
        
        panic(msg)
    }
}

// Assert greater than
assert_gt<T> = (actual: T, expected: T, message: string = "") void {
    actual <= expected ? | true => {
        ctx := CURRENT_CONTEXT ?
            | .Some -> c => c
            | .None => panic("assert_gt called outside test context")
        
        msg := message.is_empty() ?
            | true => "Expected $(actual) > $(expected)"
            | false => message;
        
        ctx.messages.push(msg);
        ctx.failed = true;
        
        panic(msg)
    }
}

// Assert contains (for strings)
assert_contains = (haystack: string, needle: string, message: string = "") void {
    haystack.contains(needle) ? | false => {
        ctx := CURRENT_CONTEXT ?
            | .Some -> c => c
            | .None => panic("assert_contains called outside test context")
        
        msg := message.is_empty() ?
            | true => "Expected '$(haystack)' to contain '$(needle)'"
            | false => message;
        
        ctx.messages.push(msg);
        ctx.failed = true;
        
        panic(msg)
    }
}

// Assert panic
assert_panic = (func: *() void, expected_msg: string = "") void {
    result := catch_panic(func);
    
    result ?
        | .Ok => {
            ctx := CURRENT_CONTEXT ?
                | .Some -> c => c
                | .None => panic("assert_panic called outside test context")
            
            msg := "Expected panic but function completed normally";
            ctx.messages.push(msg);
            ctx.failed = true;
            panic(msg)
        }
        | .Err -> msg => {
            expected_msg.is_empty() ? | false => {
                msg.contains(expected_msg) ? | false => {
                    ctx := CURRENT_CONTEXT ?
                        | .Some -> c => c
                        | .None => panic("assert_panic called outside test context")
                    
                    err := "Expected panic message containing '$(expected_msg)', got '$(msg)'";
                    ctx.messages.push(err);
                    ctx.failed = true;
                    panic(err)
                }
            }
        }
}

// Assert no panic
assert_no_panic = (func: *() void) void {
    result := catch_panic(func);
    
    result ?
        | .Err -> msg => {
            ctx := CURRENT_CONTEXT ?
                | .Some -> c => c
                | .None => panic("assert_no_panic called outside test context")
            
            err := "Expected no panic but got: $(msg)";
            ctx.messages.push(err);
            ctx.failed = true;
            panic(err)
        }
}

// Assert result is Ok
assert_ok<T, E> = (result: Result<T, E>) T {
    result ?
        | .Ok -> value => return value
        | .Err -> err => {
            ctx := CURRENT_CONTEXT ?
                | .Some -> c => c
                | .None => panic("assert_ok called outside test context")
            
            msg := "Expected Ok but got Err: $(err)";
            ctx.messages.push(msg);
            ctx.failed = true;
            panic(msg)
        }
}

// Assert result is Err
assert_err<T, E> = (result: Result<T, E>) E {
    result ?
        | .Err -> err => return err
        | .Ok -> value => {
            ctx := CURRENT_CONTEXT ?
                | .Some -> c => c
                | .None => panic("assert_err called outside test context")
            
            msg := "Expected Err but got Ok: $(value)";
            ctx.messages.push(msg);
            ctx.failed = true;
            panic(msg)
        }
}

// Assert option is Some
assert_some<T> = (option: Option<T>) T {
    option ?
        | .Some -> value => return value
        | .None => {
            ctx := CURRENT_CONTEXT ?
                | .Some -> c => c
                | .None => panic("assert_some called outside test context")
            
            msg := "Expected Some but got None";
            ctx.messages.push(msg);
            ctx.failed = true;
            panic(msg)
        }
}

// Assert option is None
assert_none<T> = (option: Option<T>) void {
    option ?
        | .Some -> value => {
            ctx := CURRENT_CONTEXT ?
                | .Some -> c => c
                | .None => panic("assert_none called outside test context")
            
            msg := "Expected None but got Some: $(value)";
            ctx.messages.push(msg);
            ctx.failed = true;
            panic(msg)
        }
}

// Benchmark a function
benchmark = (name: string, func: *() void, iterations: u64 = 1000) BenchmarkResult {
    times := [];
    total_time := 0u64;
    min_time := u64.MAX;
    max_time := 0u64;
    
    // Warmup
    i := 0;
    loop i < 10 {
        func();
        i += 1
    }
    
    // Actual benchmark
    i = 0;
    loop i < iterations {
        start := get_time_nanos();
        func();
        end := get_time_nanos();
        
        elapsed := end - start;
        times.push(elapsed);
        total_time += elapsed;
        
        elapsed < min_time ? | true => min_time = elapsed;
        elapsed > max_time ? | true => max_time = elapsed;
        
        i += 1
    }
    
    avg_time := total_time as f64 / iterations as f64;
    ops_per_sec := 1_000_000_000.0 / avg_time;
    
    result := BenchmarkResult {
        name: name,
        iterations: iterations,
        total_time: total_time,
        avg_time: avg_time,
        min_time: min_time,
        max_time: max_time,
        ops_per_sec: ops_per_sec,
    }
    
    // Store in context if in test
    CURRENT_CONTEXT ?
        | .Some -> ctx => ctx.benchmarks.push(result)
    
    return result
}

// Create test runner
TestRunner.new = () TestRunner {
    return TestRunner {
        suites: [],
        filter: .None,
        verbose: false,
        parallel: false,
        stop_on_failure: false,
        timeout: 300000,  // 5 minutes default
        results: [],
    }
}

// Add test suite to runner
TestRunner.add_suite = (self: &TestRunner, suite: TestSuite) void {
    self.suites.push(suite)
}

// Set filter pattern
TestRunner.filter = (self: &TestRunner, pattern: string) void {
    self.filter = .Some -> pattern
}

// Run all tests
TestRunner.run = (self: &TestRunner) bool {
    io.print("Running tests...\n\n");
    
    total_tests := 0;
    passed := 0;
    failed := 0;
    skipped := 0;
    
    loop suite in self.suites {
        self.verbose ? | true => io.print("Suite: $(suite.name)\n")
        
        // Run setup
        suite.setup ?
            | .Some -> setup => setup()
        
        // Run tests
        loop test in suite.tests {
            // Apply filter
            self.filter ?
                | .Some -> pattern => {
                    test.name.contains(pattern) ? | false => continue
                }
            
            total_tests += 1;
            
            self.verbose ? | true => io.print("  Test: $(test.name)... ")
            
            start := get_time_millis();
            result := run_test_with_timeout(test, test.timeout);
            duration := get_time_millis() - start;
            
            // Store result
            self.results.push(TestRunResult {
                suite: suite.name,
                test: test.name,
                result: result,
                duration: duration,
                output: "",
            });
            
            // Update counters and print result
            result ?
                | .Passed => {
                    passed += 1;
                    self.verbose ? | true => io.print("✓ PASSED ($(duration)ms)\n")
                }
                | .Failed -> reason => {
                    failed += 1;
                    io.print("✗ FAILED: $(test.name)\n");
                    io.print("    $(reason)\n");
                    io.print("    at $(test.file):$(test.line)\n\n");
                    
                    self.stop_on_failure ? | true => break
                }
                | .Skipped -> reason => {
                    skipped += 1;
                    self.verbose ? | true => io.print("⊘ SKIPPED: $(reason)\n")
                }
                | .Panicked -> message => {
                    failed += 1;
                    io.print("✗ PANICKED: $(test.name)\n");
                    io.print("    $(message)\n");
                    io.print("    at $(test.file):$(test.line)\n\n");
                    
                    self.stop_on_failure ? | true => break
                }
        }
        
        // Run teardown
        suite.teardown ?
            | .Some -> teardown => teardown()
    }
    
    // Print summary
    io.print("\n");
    io.print("═" * 50 + "\n");
    io.print("Test Summary\n");
    io.print("═" * 50 + "\n");
    io.print("Total:   $(total_tests)\n");
    io.print("Passed:  $(passed) ✓\n");
    io.print("Failed:  $(failed) ✗\n");
    io.print("Skipped: $(skipped) ⊘\n");
    
    return failed == 0
}

// Run test with timeout
run_test_with_timeout = (test: TestCase, timeout: u64) TestResult {
    timeout == 0 ? | true => return test.func()
    
    // Run test in separate thread with timeout
    result_channel := Channel.new<TestResult>(1);
    
    thread := spawn(() void => {
        result := test.func();
        result_channel.send(result)?
    }, "test-$(test.name)")?;
    
    // Wait for result or timeout
    start := get_time_millis();
    
    loop {
        channel_result := result_channel.try_recv();
        
        channel_result ?
            | .Ok -> result => {
                thread.join()?;
                return result
            }
        
        get_time_millis() - start > timeout ? | true => {
            // Test timed out
            thread.kill()?;
            return .Failed -> reason: "Test timed out after $(timeout)ms"
        }
        
        sleep(10)
    }
}

// Generate test report
generate_report = (runner: &TestRunner, format: string) string {
    format ?
        | "json" => generate_json_report(runner)
        | "xml" => generate_xml_report(runner)
        | "junit" => generate_junit_report(runner)
        | _ => generate_text_report(runner)
}

// Generate text report
generate_text_report = (runner: &TestRunner) string {
    report := "Test Results\n";
    report += "============\n\n";
    
    loop result in runner.results {
        status := result.result ?
            | .Passed => "✓"
            | .Failed -> _ => "✗"
            | .Skipped -> _ => "⊘"
            | .Panicked -> _ => "!"
        
        report += "$(status) $(result.suite)::$(result.test) ($(result.duration)ms)\n";
        
        result.result ?
            | .Failed -> reason => report += "  Failure: $(reason)\n"
            | .Panicked -> msg => report += "  Panic: $(msg)\n"
            | .Skipped -> reason => report += "  Skipped: $(reason)\n"
    }
    
    return report
}

// Macro for defining test suites
define_suite = (name: string, body: *() void) void {
    suite := TestSuite {
        name: name,
        tests: [],
        setup: .None,
        teardown: .None,
        parallel: false,
    }
    
    // Execute body to populate suite
    CURRENT_SUITE := &suite;
    body();
    CURRENT_SUITE := null;
    
    register_suite(suite)
}

// Helper to catch panics
catch_panic = (func: *() void) Result<void, string> {
    // This would use platform-specific panic handling
    // For now, simplified implementation
    
    error_handler := set_panic_handler((msg: string) void => {
        return .Err -> msg
    });
    
    func();
    
    restore_panic_handler(error_handler);
    return .Ok
}

// Get current time in nanoseconds
get_time_nanos = () u64 {
    return __zen_time_nanos()
}

// Get current time in milliseconds
get_time_millis = () u64 {
    return __zen_time_millis()
}

// External functions
extern __zen_time_nanos = () u64
extern __zen_time_millis = () u64
extern set_panic_handler = (handler: *(string) void) *void
extern restore_panic_handler = (handler: *void) void

// Test discovery attribute (for compile-time registration)
comptime {
    // This would scan for functions marked with @test attribute
    // and automatically register them
}