// Zen Standard Library - Date/Time Module
// Date and time handling implemented in pure Zen

core := @std.core
string := @std.string
math := @std.math

// Date/Time representation
DateTime := struct {
    year: i32
    month: u8      // 1-12
    day: u8        // 1-31
    hour: u8       // 0-23
    minute: u8     // 0-59
    second: u8     // 0-59
    nanosecond: u32
    timezone: TimeZone
}

// Date only
Date := struct {
    year: i32
    month: u8
    day: u8
}

// Time only
Time := struct {
    hour: u8
    minute: u8
    second: u8
    nanosecond: u32
}

// Duration between two times
Duration := struct {
    seconds: i64
    nanoseconds: u32
}

// Time zone information
TimeZone := struct {
    name: core.String
    offset_seconds: i32  // Offset from UTC in seconds
}

// Common time zones
UTC := TimeZone{ name: "UTC", offset_seconds: 0 }
EST := TimeZone{ name: "EST", offset_seconds: -18000 }  // -5 hours
EDT := TimeZone{ name: "EDT", offset_seconds: -14400 }  // -4 hours
PST := TimeZone{ name: "PST", offset_seconds: -28800 }  // -8 hours
PDT := TimeZone{ name: "PDT", offset_seconds: -25200 }  // -7 hours

// Day of week enum
DayOfWeek := enum {
    Sunday = 0
    Monday = 1
    Tuesday = 2
    Wednesday = 3
    Thursday = 4
    Friday = 5
    Saturday = 6
}

// Month enum
Month := enum {
    January = 1
    February = 2
    March = 3
    April = 4
    May = 5
    June = 6
    July = 7
    August = 8
    September = 9
    October = 10
    November = 11
    December = 12
}

// Get current date/time
now = () DateTime {
    timestamp := @builtin.time_now()  // Unix timestamp in nanoseconds
    return from_unix_nano(timestamp)
}

// Get current date
today = () Date {
    dt := now()
    return Date{
        year: dt.year
        month: dt.month
        day: dt.day
    }
}

// Create DateTime from components
new_datetime = (year: i32, month: u8, day: u8, hour: u8, minute: u8, second: u8) DateTime {
    return DateTime{
        year: year
        month: month
        day: day
        hour: hour
        minute: minute
        second: second
        nanosecond: 0
        timezone: UTC
    }
}

// Create Date
new_date = (year: i32, month: u8, day: u8) Date {
    return Date{
        year: year
        month: month
        day: day
    }
}

// Create Time
new_time = (hour: u8, minute: u8, second: u8) Time {
    return Time{
        hour: hour
        minute: minute
        second: second
        nanosecond: 0
    }
}

// Convert Unix timestamp to DateTime
from_unix = (seconds: i64) DateTime {
    return from_unix_nano(seconds * 1_000_000_000)
}

// Convert Unix nanosecond timestamp to DateTime
from_unix_nano = (nanos: i64) DateTime {
    seconds := nanos / 1_000_000_000
    remaining_nanos := (nanos % 1_000_000_000) as u32
    
    // Calculate date from Unix epoch (1970-01-01)
    days := seconds / 86400
    remaining_seconds := seconds % 86400
    
    // Calculate time components
    hour := (remaining_seconds / 3600) as u8
    minute := ((remaining_seconds % 3600) / 60) as u8
    second := (remaining_seconds % 60) as u8
    
    // Calculate date components (simplified - doesn't handle leap years perfectly)
    date := date_from_days(days)
    
    return DateTime{
        year: date.year
        month: date.month
        day: date.day
        hour: hour
        minute: minute
        second: second
        nanosecond: remaining_nanos
        timezone: UTC
    }
}

// Convert days since epoch to date
date_from_days = (days: i64) Date {
    // Simplified algorithm - proper implementation would handle leap years
    year := 1970
    remaining_days := days
    
    while remaining_days >= 365 {
        if is_leap_year(year) and remaining_days >= 366 {
            remaining_days = remaining_days - 366
        } else if !is_leap_year(year) {
            remaining_days = remaining_days - 365
        } else {
            break
        }
        year = year + 1
    }
    
    // Find month and day
    month := 1
    days_in_months := get_days_in_months(year)
    
    while month <= 12 and remaining_days >= days_in_months[month - 1] {
        remaining_days = remaining_days - days_in_months[month - 1]
        month = month + 1
    }
    
    return Date{
        year: year
        month: month as u8
        day: (remaining_days + 1) as u8
    }
}

// Convert DateTime to Unix timestamp
to_unix = (dt: DateTime) i64 {
    return to_unix_nano(dt) / 1_000_000_000
}

// Convert DateTime to Unix nanosecond timestamp
to_unix_nano = (dt: DateTime) i64 {
    // Calculate days since epoch
    days := days_since_epoch(dt.year, dt.month, dt.day)
    
    // Calculate seconds
    seconds := days * 86400 +
               dt.hour as i64 * 3600 +
               dt.minute as i64 * 60 +
               dt.second as i64
    
    // Adjust for timezone
    seconds = seconds - dt.timezone.offset_seconds as i64
    
    return seconds * 1_000_000_000 + dt.nanosecond as i64
}

// Calculate days since Unix epoch
days_since_epoch = (year: i32, month: u8, day: u8) i64 {
    days := 0 as i64
    
    // Add days for complete years
    y := 1970
    while y < year {
        days = days + if is_leap_year(y) { 366 } else { 365 }
        y = y + 1
    }
    
    // Add days for complete months
    days_in_months := get_days_in_months(year)
    m := 1
    while m < month {
        days = days + days_in_months[m - 1] as i64
        m = m + 1
    }
    
    // Add remaining days
    days = days + (day - 1) as i64
    
    return days
}

// Check if year is leap year
is_leap_year = (year: i32) bool {
    if year % 400 == 0 {
        return true
    }
    if year % 100 == 0 {
        return false
    }
    return year % 4 == 0
}

// Get days in each month for a year
get_days_in_months = (year: i32) [12]u8 {
    feb_days := if is_leap_year(year) { 29 } else { 28 }
    return [31, feb_days, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
}

// Add duration to DateTime
add = (dt: DateTime, duration: Duration) DateTime {
    nanos := to_unix_nano(dt) + duration.seconds * 1_000_000_000 + duration.nanoseconds as i64
    result := from_unix_nano(nanos)
    result.timezone = dt.timezone
    return result
}

// Subtract duration from DateTime
subtract = (dt: DateTime, duration: Duration) DateTime {
    nanos := to_unix_nano(dt) - duration.seconds * 1_000_000_000 - duration.nanoseconds as i64
    result := from_unix_nano(nanos)
    result.timezone = dt.timezone
    return result
}

// Calculate duration between two DateTimes
diff = (dt1: DateTime, dt2: DateTime) Duration {
    nanos1 := to_unix_nano(dt1)
    nanos2 := to_unix_nano(dt2)
    diff_nanos := nanos1 - nanos2
    
    return Duration{
        seconds: diff_nanos / 1_000_000_000
        nanoseconds: (math.abs(diff_nanos) % 1_000_000_000) as u32
    }
}

// Format DateTime as string
format = (dt: DateTime, fmt: core.String) core.String {
    result := core.String{}
    i := 0
    
    while i < fmt.len {
        if fmt[i] == '%' and i + 1 < fmt.len {
            i = i + 1
            c := fmt[i]
            
            switch c {
                'Y' => result.append_string(string.from_int(dt.year))
                'y' => result.append_string(string.from_int(dt.year % 100))
                'm' => result.append_string(pad_zero(dt.month, 2))
                'd' => result.append_string(pad_zero(dt.day, 2))
                'H' => result.append_string(pad_zero(dt.hour, 2))
                'M' => result.append_string(pad_zero(dt.minute, 2))
                'S' => result.append_string(pad_zero(dt.second, 2))
                'B' => result.append_string(month_name(dt.month))
                'b' => result.append_string(month_abbr(dt.month))
                'A' => result.append_string(weekday_name(day_of_week(dt)))
                'a' => result.append_string(weekday_abbr(day_of_week(dt)))
                'Z' => result.append_string(dt.timezone.name)
                '%' => result.append('%')
                _ => {
                    result.append('%')
                    result.append(c)
                }
            }
        } else {
            result.append(fmt[i])
        }
        i = i + 1
    }
    
    return result
}

// Common format functions
to_iso8601 = (dt: DateTime) core.String {
    return format(dt, "%Y-%m-%dT%H:%M:%S")
}

to_rfc3339 = (dt: DateTime) core.String {
    base := format(dt, "%Y-%m-%dT%H:%M:%S")
    if dt.timezone.offset_seconds == 0 {
        return base + "Z"
    } else {
        hours := dt.timezone.offset_seconds / 3600
        minutes := (math.abs(dt.timezone.offset_seconds) % 3600) / 60
        sign := if dt.timezone.offset_seconds < 0 { "-" } else { "+" }
        return base + sign + pad_zero(math.abs(hours), 2) + ":" + pad_zero(minutes, 2)
    }
}

// Parse ISO 8601 date string
parse_iso8601 = (s: core.String) ?DateTime {
    // Simplified parser for YYYY-MM-DDTHH:MM:SS format
    if s.len < 19 {
        return null
    }
    
    year := string.parse_int(string.substring(s, 0, 4)) ?? return null
    month := string.parse_int(string.substring(s, 5, 7)) ?? return null
    day := string.parse_int(string.substring(s, 8, 10)) ?? return null
    hour := string.parse_int(string.substring(s, 11, 13)) ?? return null
    minute := string.parse_int(string.substring(s, 14, 16)) ?? return null
    second := string.parse_int(string.substring(s, 17, 19)) ?? return null
    
    return DateTime{
        year: year
        month: month as u8
        day: day as u8
        hour: hour as u8
        minute: minute as u8
        second: second as u8
        nanosecond: 0
        timezone: UTC
    }
}

// Get day of week
day_of_week = (dt: DateTime) DayOfWeek {
    // Zeller's congruence algorithm
    year := dt.year
    month := dt.month as i32
    day := dt.day as i32
    
    if month < 3 {
        month = month + 12
        year = year - 1
    }
    
    century := year / 100
    year_of_century := year % 100
    
    h := (day + (13 * (month + 1)) / 5 + year_of_century + 
          year_of_century / 4 + century / 4 - 2 * century) % 7
    
    // Convert to Sunday = 0
    return ((h + 6) % 7) as DayOfWeek
}

// Helper functions
pad_zero = (n: u64, width: u32) core.String {
    s := string.from_int(n)
    while s.len < width {
        s = "0" + s
    }
    return s
}

month_name = (month: u8) core.String {
    return switch month {
        1 => "January"
        2 => "February"
        3 => "March"
        4 => "April"
        5 => "May"
        6 => "June"
        7 => "July"
        8 => "August"
        9 => "September"
        10 => "October"
        11 => "November"
        12 => "December"
        _ => "Unknown"
    }
}

month_abbr = (month: u8) core.String {
    return switch month {
        1 => "Jan"
        2 => "Feb"
        3 => "Mar"
        4 => "Apr"
        5 => "May"
        6 => "Jun"
        7 => "Jul"
        8 => "Aug"
        9 => "Sep"
        10 => "Oct"
        11 => "Nov"
        12 => "Dec"
        _ => "???"
    }
}

weekday_name = (day: DayOfWeek) core.String {
    return switch day {
        .Sunday => "Sunday"
        .Monday => "Monday"
        .Tuesday => "Tuesday"
        .Wednesday => "Wednesday"
        .Thursday => "Thursday"
        .Friday => "Friday"
        .Saturday => "Saturday"
    }
}

weekday_abbr = (day: DayOfWeek) core.String {
    return switch day {
        .Sunday => "Sun"
        .Monday => "Mon"
        .Tuesday => "Tue"
        .Wednesday => "Wed"
        .Thursday => "Thu"
        .Friday => "Fri"
        .Saturday => "Sat"
    }
}

// Duration helpers
hours = (h: i64) Duration {
    return Duration{ seconds: h * 3600, nanoseconds: 0 }
}

minutes = (m: i64) Duration {
    return Duration{ seconds: m * 60, nanoseconds: 0 }
}

seconds = (s: i64) Duration {
    return Duration{ seconds: s, nanoseconds: 0 }
}

milliseconds = (ms: i64) Duration {
    return Duration{ 
        seconds: ms / 1000, 
        nanoseconds: ((ms % 1000) * 1_000_000) as u32 
    }
}

microseconds = (us: i64) Duration {
    return Duration{ 
        seconds: us / 1_000_000, 
        nanoseconds: ((us % 1_000_000) * 1000) as u32 
    }
}

nanoseconds = (ns: i64) Duration {
    return Duration{ 
        seconds: ns / 1_000_000_000, 
        nanoseconds: (ns % 1_000_000_000) as u32 
    }
}

// Timer for measuring elapsed time
Timer := struct {
    start: i64
}

// Start a timer
start_timer = () Timer {
    return Timer{ start: @builtin.time_now() }
}

// Get elapsed time since timer started
elapsed = (timer: *Timer) Duration {
    current := @builtin.time_now()
    diff := current - timer.start
    return nanoseconds(diff)
}

// Reset timer
reset = (timer: *Timer) void {
    timer.start = @builtin.time_now()
}

// Sleep for duration
sleep = (duration: Duration) void {
    nanos := duration.seconds * 1_000_000_000 + duration.nanoseconds as i64
    @builtin.sleep_ns(nanos)
}

// Compare dates
before = (dt1: DateTime, dt2: DateTime) bool {
    return to_unix_nano(dt1) < to_unix_nano(dt2)
}

after = (dt1: DateTime, dt2: DateTime) bool {
    return to_unix_nano(dt1) > to_unix_nano(dt2)
}

equal = (dt1: DateTime, dt2: DateTime) bool {
    return to_unix_nano(dt1) == to_unix_nano(dt2)
}

// Get start of day
start_of_day = (dt: DateTime) DateTime {
    return DateTime{
        year: dt.year
        month: dt.month
        day: dt.day
        hour: 0
        minute: 0
        second: 0
        nanosecond: 0
        timezone: dt.timezone
    }
}

// Get end of day
end_of_day = (dt: DateTime) DateTime {
    return DateTime{
        year: dt.year
        month: dt.month
        day: dt.day
        hour: 23
        minute: 59
        second: 59
        nanosecond: 999_999_999
        timezone: dt.timezone
    }
}

// Add days
add_days = (dt: DateTime, days: i32) DateTime {
    return add(dt, Duration{ seconds: days as i64 * 86400, nanoseconds: 0 })
}

// Add months (handles varying month lengths)
add_months = (dt: DateTime, months: i32) DateTime {
    total_months := dt.year * 12 + dt.month as i32 + months
    new_year := total_months / 12
    new_month := (total_months % 12) as u8
    
    if new_month == 0 {
        new_month = 12
        new_year = new_year - 1
    }
    
    // Handle day overflow
    days_in_new_month := get_days_in_months(new_year)[new_month - 1]
    new_day := if dt.day > days_in_new_month { days_in_new_month } else { dt.day }
    
    return DateTime{
        year: new_year
        month: new_month
        day: new_day
        hour: dt.hour
        minute: dt.minute
        second: dt.second
        nanosecond: dt.nanosecond
        timezone: dt.timezone
    }
}

// Add years
add_years = (dt: DateTime, years: i32) DateTime {
    new_year := dt.year + years
    
    // Handle Feb 29 in non-leap years
    new_day := dt.day
    if dt.month == 2 and dt.day == 29 and !is_leap_year(new_year) {
        new_day = 28
    }
    
    return DateTime{
        year: new_year
        month: dt.month
        day: new_day
        hour: dt.hour
        minute: dt.minute
        second: dt.second
        nanosecond: dt.nanosecond
        timezone: dt.timezone
    }
}