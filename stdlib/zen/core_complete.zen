// Zen Standard Library: Core Module
// Core types and utilities for the Zen language

// Basic Option type for handling nullable values
Option<T> = 
    | Some(value: T)
    | None

// Result type for error handling
Result<T, E> = 
    | Ok(value: T)
    | Err(error: E)

// Range type for iteration
Range = {
    start: i64,
    end: i64,
    step: i64,
}

// Create a range from start to end (exclusive)
range = (start: i64, end: i64) Range {
    return Range {
        start: start,
        end: end,
        step: 1,
    }
}

// Create a range with custom step
range_step = (start: i64, end: i64, step: i64) Range {
    return Range {
        start: start,
        end: end,
        step: step,
    }
}

// Create an inclusive range
range_inclusive = (start: i64, end: i64) Range {
    return Range {
        start: start,
        end: end + 1,
        step: 1,
    }
}

// Min function
min = (a: i64, b: i64) i64 {
    a < b ?
        | true => return a
        | false => return b
}

// Max function
max = (a: i64, b: i64) i64 {
    a > b ?
        | true => return a
        | false => return b
}

// Absolute value
abs = (n: i64) i64 {
    n < 0 ?
        | true => return -n
        | false => return n
}

// Clamp value between min and max
clamp = (value: i64, min_val: i64, max_val: i64) i64 {
    value < min_val ?
        | true => return min_val
        | false => {
            value > max_val ?
                | true => return max_val
                | false => return value
        }
}

// Check if value is in range
in_range = (value: i64, start: i64, end: i64) bool {
    return value >= start && value < end
}

// Swap two values (requires mutable references in real implementation)
swap = (a: *i64, b: *i64) void {
    temp := *a
    *a = *b
    *b = temp
}

// Identity function
identity<T> = (x: T) T {
    return x
}

// Constant function
constant<T> = (x: T) (y: T) T {
    return x
}

// Compose two functions
compose<A, B, C> = (f: (B) C, g: (A) B) (A) C {
    return (x: A) C {
        return f(g(x))
    }
}

// Apply function n times
apply_n<T> = (f: (T) T, n: i64, x: T) T {
    result ::= x
    i ::= 0
    loop {
        if i >= n {
            break
        }
        result = f(result)
        i = i + 1
    }
    return result
}

// Type aliases for common types
type Int = i32
type Long = i64
type Float = f32
type Double = f64
type Byte = i8
type UInt = u32
type ULong = u64
type Size = usize
type Char = i8
type Bool = bool
type String = *i8

// Memory alignment helpers
align_to = (value: usize, alignment: usize) usize {
    mask := alignment - 1
    return (value + mask) & ~mask
}

is_aligned = (value: usize, alignment: usize) bool {
    return (value & (alignment - 1)) == 0
}

// Bit manipulation utilities
set_bit = (value: u64, bit: u64) u64 {
    return value | (1 << bit)
}

clear_bit = (value: u64, bit: u64) u64 {
    return value & ~(1 << bit)
}

toggle_bit = (value: u64, bit: u64) u64 {
    return value ^ (1 << bit)
}

test_bit = (value: u64, bit: u64) bool {
    return (value & (1 << bit)) != 0
}

count_ones = (value: u64) i32 {
    count ::= 0
    v ::= value
    loop {
        if v == 0 {
            break
        }
        count = count + 1
        v = v & (v - 1)
    }
    return count
}

count_zeros = (value: u64) i32 {
    return 64 - count_ones(value)
}

// Export all public functions and types
export {
    Option,
    Result,
    Range,
    range,
    range_step,
    range_inclusive,
    min,
    max,
    abs,
    clamp,
    in_range,
    swap,
    identity,
    constant,
    compose,
    apply_n,
    Int,
    Long,
    Float,
    Double,
    Byte,
    UInt,
    ULong,
    Size,
    Char,
    Bool,
    String,
    align_to,
    is_aligned,
    set_bit,
    clear_bit,
    toggle_bit,
    test_bit,
    count_ones,
    count_zeros,
}