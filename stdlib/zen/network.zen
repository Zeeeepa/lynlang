// Zen Network Module - Pure Zen implementation
// Provides networking capabilities for TCP/UDP communication

core := @std.core
io := @std.io
string := @std.string
vec := @std.vec
result := @std.result
mem := @std.mem

// Network address family
AddressFamily := enum {
    IPv4
    IPv6
    Unix
}

// Socket type
SocketType := enum {
    Stream    // TCP
    Datagram  // UDP
    Raw
}

// Protocol type
Protocol := enum {
    TCP
    UDP
    ICMP
    RAW
}

// Socket options
SocketOption := enum {
    ReuseAddr
    ReusePort
    KeepAlive
    NoDelay
    Broadcast
    Linger
    RecvBufferSize
    SendBufferSize
    RecvTimeout
    SendTimeout
}

// IP Address representation
IpAddress := enum {
    V4(octets: [4]u8)
    V6(segments: [8]u16)
}

// Socket address
SocketAddr := struct {
    ip: IpAddress
    port: u16
}

// Network error types
NetworkError := enum {
    ConnectionRefused
    ConnectionReset
    ConnectionAborted
    NotConnected
    AddrInUse
    AddrNotAvailable
    NetworkDown
    NetworkUnreachable
    HostUnreachable
    TimedOut
    PermissionDenied
    Interrupted
    InvalidInput
    WouldBlock
    Other(msg: string)
}

// Socket handle
Socket := struct {
    fd: i32
    family: AddressFamily
    sock_type: SocketType
    protocol: Protocol
    is_connected: bool
    local_addr: Option<SocketAddr>
    remote_addr: Option<SocketAddr>
}

// TCP listener
TcpListener := struct {
    socket: Socket
    backlog: u32
}

// TCP stream
TcpStream := struct {
    socket: Socket
    read_timeout: Option<u64>
    write_timeout: Option<u64>
}

// UDP socket
UdpSocket := struct {
    socket: Socket
}

// Parse IP address from string
parse_ip = (addr: string) Result<IpAddress, NetworkError> {
    // Check for IPv4
    if (string.contains(addr, ".")) {
        parts := string.split(addr, ".")
        if (vec.len(parts) != 4) {
            return Result.Err(NetworkError.InvalidInput)
        }
        
        octets: [4]u8 = [0, 0, 0, 0]
        i := 0
        while (i < 4) {
            val := string.parse_u8(parts[i])
            if (val.is_err()) {
                return Result.Err(NetworkError.InvalidInput)
            }
            octets[i] = val.unwrap()
            i += 1
        }
        
        return Result.Ok(IpAddress.V4(octets))
    }
    
    // Check for IPv6
    if (string.contains(addr, ":")) {
        parts := string.split(addr, ":")
        if (vec.len(parts) > 8) {
            return Result.Err(NetworkError.InvalidInput)
        }
        
        segments: [8]u16 = [0, 0, 0, 0, 0, 0, 0, 0]
        // Simplified IPv6 parsing (doesn't handle :: compression)
        i := 0
        while (i < vec.len(parts) && i < 8) {
            val := string.parse_u16_hex(parts[i])
            if (val.is_err()) {
                return Result.Err(NetworkError.InvalidInput)
            }
            segments[i] = val.unwrap()
            i += 1
        }
        
        return Result.Ok(IpAddress.V6(segments))
    }
    
    return Result.Err(NetworkError.InvalidInput)
}

// Create socket address
socket_addr = (ip: IpAddress, port: u16) SocketAddr {
    return SocketAddr{
        ip: ip,
        port: port
    }
}

// Parse socket address from string (e.g., "127.0.0.1:8080")
parse_socket_addr = (addr: string) Result<SocketAddr, NetworkError> {
    // Find last colon for port
    last_colon := string.rfind(addr, ":")
    if (last_colon.is_none()) {
        return Result.Err(NetworkError.InvalidInput)
    }
    
    colon_pos := last_colon.unwrap()
    ip_str := string.substring(addr, 0, colon_pos)
    port_str := string.substring(addr, colon_pos + 1, string.len(addr))
    
    // Handle IPv6 addresses in brackets [::1]:8080
    if (string.starts_with(ip_str, "[") && string.ends_with(ip_str, "]")) {
        ip_str = string.substring(ip_str, 1, string.len(ip_str) - 1)
    }
    
    ip := parse_ip(ip_str)?
    port := string.parse_u16(port_str)?
    
    return Result.Ok(socket_addr(ip, port))
}

// Format IP address as string
ip_to_string = (ip: IpAddress) string {
    match ip {
        IpAddress.V4(octets) => {
            return string.format("{}.{}.{}.{}", 
                octets[0], octets[1], octets[2], octets[3])
        }
        IpAddress.V6(segments) => {
            result := ""
            i := 0
            while (i < 8) {
                if (i > 0) string.append(result, ":")
                string.append(result, string.format("{:x}", segments[i]))
                i += 1
            }
            return result
        }
    }
}

// Format socket address as string
socket_addr_to_string = (addr: SocketAddr) string {
    ip_str := ip_to_string(addr.ip)
    
    // Add brackets for IPv6
    match addr.ip {
        IpAddress.V6(_) => {
            return string.format("[{}]:{}", ip_str, addr.port)
        }
        _ => {
            return string.format("{}:{}", ip_str, addr.port)
        }
    }
}

// Create new TCP listener
tcp_bind = (addr: SocketAddr) Result<TcpListener, NetworkError> {
    // Create socket
    socket := create_socket(
        match addr.ip {
            IpAddress.V4(_) => AddressFamily.IPv4
            IpAddress.V6(_) => AddressFamily.IPv6
        },
        SocketType.Stream,
        Protocol.TCP
    )?
    
    // Set socket options
    set_socket_option(socket, SocketOption.ReuseAddr, true)?
    
    // Bind to address
    bind_socket(socket, addr)?
    
    // Listen with default backlog
    backlog := 128u32
    listen_socket(socket, backlog)?
    
    return Result.Ok(TcpListener{
        socket: socket,
        backlog: backlog
    })
}

// Accept connection
tcp_accept = (listener: &TcpListener) Result<(TcpStream, SocketAddr), NetworkError> {
    // Accept connection
    result := accept_socket(listener.socket)?
    new_socket := result.0
    remote_addr := result.1
    
    stream := TcpStream{
        socket: new_socket,
        read_timeout: Option.None,
        write_timeout: Option.None
    }
    
    return Result.Ok((stream, remote_addr))
}

// Connect to TCP server
tcp_connect = (addr: SocketAddr) Result<TcpStream, NetworkError> {
    // Create socket
    socket := create_socket(
        match addr.ip {
            IpAddress.V4(_) => AddressFamily.IPv4
            IpAddress.V6(_) => AddressFamily.IPv6
        },
        SocketType.Stream,
        Protocol.TCP
    )?
    
    // Connect to remote
    connect_socket(socket, addr)?
    
    stream := TcpStream{
        socket: socket,
        read_timeout: Option.None,
        write_timeout: Option.None
    }
    
    return Result.Ok(stream)
}

// Read from TCP stream
tcp_read = (stream: &mut TcpStream, buf: &mut [u8]) Result<usize, NetworkError> {
    return recv_from_socket(stream.socket, buf, 0)
}

// Write to TCP stream
tcp_write = (stream: &mut TcpStream, data: &[u8]) Result<usize, NetworkError> {
    return send_to_socket(stream.socket, data, 0)
}

// Read exact number of bytes
tcp_read_exact = (stream: &mut TcpStream, buf: &mut [u8]) Result<void, NetworkError> {
    total_read := 0usize
    while (total_read < buf.len()) {
        n := tcp_read(stream, buf[total_read..])?
        if (n == 0) {
            return Result.Err(NetworkError.ConnectionReset)
        }
        total_read += n
    }
    return Result.Ok(void)
}

// Write all data
tcp_write_all = (stream: &mut TcpStream, data: &[u8]) Result<void, NetworkError> {
    total_written := 0usize
    while (total_written < data.len()) {
        n := tcp_write(stream, data[total_written..])?
        if (n == 0) {
            return Result.Err(NetworkError.ConnectionReset)
        }
        total_written += n
    }
    return Result.Ok(void)
}

// Shutdown TCP stream
tcp_shutdown = (stream: &mut TcpStream, how: ShutdownHow) Result<void, NetworkError> {
    return shutdown_socket(stream.socket, how)
}

// Create UDP socket
udp_bind = (addr: SocketAddr) Result<UdpSocket, NetworkError> {
    // Create socket
    socket := create_socket(
        match addr.ip {
            IpAddress.V4(_) => AddressFamily.IPv4
            IpAddress.V6(_) => AddressFamily.IPv6
        },
        SocketType.Datagram,
        Protocol.UDP
    )?
    
    // Bind to address
    bind_socket(socket, addr)?
    
    return Result.Ok(UdpSocket{
        socket: socket
    })
}

// Send datagram
udp_send_to = (socket: &UdpSocket, data: &[u8], addr: SocketAddr) Result<usize, NetworkError> {
    return sendto_socket(socket.socket, data, addr, 0)
}

// Receive datagram
udp_recv_from = (socket: &UdpSocket, buf: &mut [u8]) Result<(usize, SocketAddr), NetworkError> {
    return recvfrom_socket(socket.socket, buf, 0)
}

// Connect UDP socket to specific peer
udp_connect = (socket: &mut UdpSocket, addr: SocketAddr) Result<void, NetworkError> {
    return connect_socket(socket.socket, addr)
}

// Send to connected peer
udp_send = (socket: &UdpSocket, data: &[u8]) Result<usize, NetworkError> {
    return send_to_socket(socket.socket, data, 0)
}

// Receive from connected peer
udp_recv = (socket: &UdpSocket, buf: &mut [u8]) Result<usize, NetworkError> {
    return recv_from_socket(socket.socket, buf, 0)
}

// Shutdown modes
ShutdownHow := enum {
    Read
    Write
    Both
}

// Get local address
get_local_addr = (socket: &Socket) Result<SocketAddr, NetworkError> {
    if (socket.local_addr.is_some()) {
        return Result.Ok(socket.local_addr.unwrap())
    }
    return Result.Err(NetworkError.NotConnected)
}

// Get remote address
get_peer_addr = (socket: &Socket) Result<SocketAddr, NetworkError> {
    if (socket.remote_addr.is_some()) {
        return Result.Ok(socket.remote_addr.unwrap())
    }
    return Result.Err(NetworkError.NotConnected)
}

// Set socket timeout
set_timeout = (socket: &mut Socket, timeout: Option<u64>) Result<void, NetworkError> {
    match timeout {
        Option.Some(ms) => {
            set_socket_option(socket, SocketOption.RecvTimeout, ms)?
            set_socket_option(socket, SocketOption.SendTimeout, ms)?
        }
        Option.None => {
            set_socket_option(socket, SocketOption.RecvTimeout, 0u64)?
            set_socket_option(socket, SocketOption.SendTimeout, 0u64)?
        }
    }
    return Result.Ok(void)
}

// Set TCP nodelay
tcp_set_nodelay = (stream: &mut TcpStream, nodelay: bool) Result<void, NetworkError> {
    return set_socket_option(stream.socket, SocketOption.NoDelay, nodelay)
}

// Set TCP keepalive
tcp_set_keepalive = (stream: &mut TcpStream, keepalive: bool) Result<void, NetworkError> {
    return set_socket_option(stream.socket, SocketOption.KeepAlive, keepalive)
}

// Low-level socket operations (would be implemented with FFI)
@extern("socket")
create_socket = (family: AddressFamily, sock_type: SocketType, protocol: Protocol) Result<Socket, NetworkError>

@extern("bind")
bind_socket = (socket: Socket, addr: SocketAddr) Result<void, NetworkError>

@extern("listen")
listen_socket = (socket: Socket, backlog: u32) Result<void, NetworkError>

@extern("accept")
accept_socket = (socket: Socket) Result<(Socket, SocketAddr), NetworkError>

@extern("connect")
connect_socket = (socket: Socket, addr: SocketAddr) Result<void, NetworkError>

@extern("send")
send_to_socket = (socket: Socket, data: &[u8], flags: i32) Result<usize, NetworkError>

@extern("recv")
recv_from_socket = (socket: Socket, buf: &mut [u8], flags: i32) Result<usize, NetworkError>

@extern("sendto")
sendto_socket = (socket: Socket, data: &[u8], addr: SocketAddr, flags: i32) Result<usize, NetworkError>

@extern("recvfrom")
recvfrom_socket = (socket: Socket, buf: &mut [u8], flags: i32) Result<(usize, SocketAddr), NetworkError>

@extern("shutdown")
shutdown_socket = (socket: Socket, how: ShutdownHow) Result<void, NetworkError>

@extern("setsockopt")
set_socket_option = (socket: Socket, option: SocketOption, value: any) Result<void, NetworkError>

@extern("getsockopt")
get_socket_option = (socket: Socket, option: SocketOption) Result<any, NetworkError>

@extern("close")
close_socket = (socket: Socket) Result<void, NetworkError>

// Helper to create localhost addresses
localhost_v4 = (port: u16) SocketAddr {
    return socket_addr(IpAddress.V4([127, 0, 0, 1]), port)
}

localhost_v6 = (port: u16) SocketAddr {
    return socket_addr(IpAddress.V6([0, 0, 0, 0, 0, 0, 0, 1]), port)
}

// Any address (0.0.0.0 or ::)
any_v4 = (port: u16) SocketAddr {
    return socket_addr(IpAddress.V4([0, 0, 0, 0]), port)
}

any_v6 = (port: u16) SocketAddr {
    return socket_addr(IpAddress.V6([0, 0, 0, 0, 0, 0, 0, 0]), port)
}