// Zen Standard Library - Collections Module
// Data structures and algorithms

core := @std.core
mem := @std.mem

// Dynamic array implementation
Vec<T> = struct {
    data: *T
    len: usize
    capacity: usize
}

// Create new vector
vec_new = <T>() Vec<T> {
    return Vec<T> {
        data: null
        len: 0
        capacity: 0
    }
}

// Create vector with capacity
vec_with_capacity = <T>(capacity: usize) Vec<T> {
    if capacity == 0 {
        return vec_new<T>()
    }
    
    return Vec<T> {
        data: mem.alloc<T>(capacity)
        len: 0
        capacity: capacity
    }
}

// Push element to vector
vec_push = <T>(vec: *Vec<T>, value: T) void {
    if vec.len >= vec.capacity {
        // Need to grow
        new_capacity := vec.capacity == 0 ? 1 : vec.capacity * 2
        new_data := mem.alloc<T>(new_capacity)
        
        // Copy old data
        if vec.data != null {
            mem.copy(new_data, vec.data, vec.len * @sizeof(T))
            mem.free(vec.data)
        }
        
        vec.data = new_data
        vec.capacity = new_capacity
    }
    
    vec.data[vec.len] = value
    vec.len = vec.len + 1
}

// Pop element from vector
vec_pop = <T>(vec: *Vec<T>) Option<T> {
    if vec.len == 0 {
        return none
    }
    
    vec.len = vec.len - 1
    return some(vec.data[vec.len])
}

// Get element at index
vec_get = <T>(vec: Vec<T>, index: usize) Option<T> {
    if index >= vec.len {
        return none
    }
    return some(vec.data[index])
}

// Set element at index
vec_set = <T>(vec: *Vec<T>, index: usize, value: T) bool {
    if index >= vec.len {
        return false
    }
    vec.data[index] = value
    return true
}

// Clear vector
vec_clear = <T>(vec: *Vec<T>) void {
    vec.len = 0
}

// Free vector memory
vec_free = <T>(vec: *Vec<T>) void {
    if vec.data != null {
        mem.free(vec.data)
        vec.data = null
        vec.len = 0
        vec.capacity = 0
    }
}

// Insert element at index
vec_insert = <T>(vec: *Vec<T>, index: usize, value: T) bool {
    if index > vec.len {
        return false
    }
    
    // Ensure capacity
    if vec.len >= vec.capacity {
        new_capacity := vec.capacity == 0 ? 1 : vec.capacity * 2
        new_data := mem.alloc<T>(new_capacity)
        
        if vec.data != null {
            // Copy elements before insertion point
            if index > 0 {
                mem.copy(new_data, vec.data, index * @sizeof(T))
            }
            // Copy elements after insertion point
            if index < vec.len {
                mem.copy(
                    new_data + (index + 1) * @sizeof(T),
                    vec.data + index * @sizeof(T),
                    (vec.len - index) * @sizeof(T)
                )
            }
            mem.free(vec.data)
        }
        
        vec.data = new_data
        vec.capacity = new_capacity
    } else if index < vec.len {
        // Shift elements right
        mem.move(
            vec.data + (index + 1) * @sizeof(T),
            vec.data + index * @sizeof(T),
            (vec.len - index) * @sizeof(T)
        )
    }
    
    vec.data[index] = value
    vec.len = vec.len + 1
    return true
}

// Remove element at index
vec_remove = <T>(vec: *Vec<T>, index: usize) Option<T> {
    if index >= vec.len {
        return none
    }
    
    value := vec.data[index]
    
    // Shift elements left
    if index < vec.len - 1 {
        mem.move(
            vec.data + index * @sizeof(T),
            vec.data + (index + 1) * @sizeof(T),
            (vec.len - index - 1) * @sizeof(T)
        )
    }
    
    vec.len = vec.len - 1
    return some(value)
}

// Linked list node
ListNode<T> = struct {
    value: T
    next: *ListNode<T>
}

// Linked list
List<T> = struct {
    head: *ListNode<T>
    tail: *ListNode<T>
    len: usize
}

// Create new list
list_new = <T>() List<T> {
    return List<T> {
        head: null
        tail: null
        len: 0
    }
}

// Push to front of list
list_push_front = <T>(list: *List<T>, value: T) void {
    node := mem.alloc<ListNode<T>>(1)
    node.value = value
    node.next = list.head
    
    list.head = node
    if list.tail == null {
        list.tail = node
    }
    list.len = list.len + 1
}

// Push to back of list
list_push_back = <T>(list: *List<T>, value: T) void {
    node := mem.alloc<ListNode<T>>(1)
    node.value = value
    node.next = null
    
    if list.tail != null {
        list.tail.next = node
    } else {
        list.head = node
    }
    list.tail = node
    list.len = list.len + 1
}

// Pop from front of list
list_pop_front = <T>(list: *List<T>) Option<T> {
    if list.head == null {
        return none
    }
    
    node := list.head
    value := node.value
    list.head = node.next
    
    if list.head == null {
        list.tail = null
    }
    
    mem.free(node)
    list.len = list.len - 1
    return some(value)
}

// Free list memory
list_free = <T>(list: *List<T>) void {
    current := list.head
    loop current != null {
        next := current.next
        mem.free(current)
        current = next
    }
    
    list.head = null
    list.tail = null
    list.len = 0
}

// Hash map bucket
HashBucket<K, V> = struct {
    key: K
    value: V
    next: *HashBucket<K, V>
}

// Hash map
HashMap<K, V> = struct {
    buckets: *(*HashBucket<K, V>)
    capacity: usize
    size: usize
}

// Simple hash function
hash_int = (key: i64) u64 {
    val := key as u64
    val = val ^ (val >> 33)
    val = val * 0xff51afd7ed558ccd
    val = val ^ (val >> 33)
    val = val * 0xc4ceb9fe1a85ec53
    val = val ^ (val >> 33)
    return val
}

// Create new hash map
hashmap_new = <K, V>(capacity: usize) HashMap<K, V> {
    cap := capacity == 0 ? 16 : capacity
    
    return HashMap<K, V> {
        buckets: mem.alloc<*HashBucket<K, V>>(cap)
        capacity: cap
        size: 0
    }
}

// Insert into hash map
hashmap_insert = <K, V>(map: *HashMap<K, V>, key: K, value: V) void {
    // TODO: Implement generic hash function
    hash := hash_int(key as i64) as usize
    index := hash % map.capacity
    
    bucket := mem.alloc<HashBucket<K, V>>(1)
    bucket.key = key
    bucket.value = value
    bucket.next = map.buckets[index]
    
    map.buckets[index] = bucket
    map.size = map.size + 1
    
    // Resize if load factor > 0.75
    if map.size * 4 > map.capacity * 3 {
        hashmap_resize(map)
    }
}

// Get from hash map
hashmap_get = <K, V>(map: HashMap<K, V>, key: K) Option<V> {
    hash := hash_int(key as i64) as usize
    index := hash % map.capacity
    
    current := map.buckets[index]
    loop current != null {
        if current.key == key {
            return some(current.value)
        }
        current = current.next
    }
    
    return none
}

// Remove from hash map
hashmap_remove = <K, V>(map: *HashMap<K, V>, key: K) Option<V> {
    hash := hash_int(key as i64) as usize
    index := hash % map.capacity
    
    current := map.buckets[index]
    prev := null as *HashBucket<K, V>
    
    loop current != null {
        if current.key == key {
            value := current.value
            
            if prev != null {
                prev.next = current.next
            } else {
                map.buckets[index] = current.next
            }
            
            mem.free(current)
            map.size = map.size - 1
            return some(value)
        }
        
        prev = current
        current = current.next
    }
    
    return none
}

// Resize hash map
hashmap_resize = <K, V>(map: *HashMap<K, V>) void {
    new_capacity := map.capacity * 2
    new_buckets := mem.alloc<*HashBucket<K, V>>(new_capacity)
    
    // Rehash all entries
    i := 0
    loop i < map.capacity {
        current := map.buckets[i]
        loop current != null {
            next := current.next
            
            hash := hash_int(current.key as i64) as usize
            new_index := hash % new_capacity
            
            current.next = new_buckets[new_index]
            new_buckets[new_index] = current
            
            current = next
        }
        i = i + 1
    }
    
    mem.free(map.buckets)
    map.buckets = new_buckets
    map.capacity = new_capacity
}

// Free hash map memory
hashmap_free = <K, V>(map: *HashMap<K, V>) void {
    i := 0
    loop i < map.capacity {
        current := map.buckets[i]
        loop current != null {
            next := current.next
            mem.free(current)
            current = next
        }
        i = i + 1
    }
    
    mem.free(map.buckets)
    map.buckets = null
    map.capacity = 0
    map.size = 0
}

// Binary heap (min heap)
Heap<T> = struct {
    data: Vec<T>
}

// Create new heap
heap_new = <T>() Heap<T> {
    return Heap<T> {
        data: vec_new<T>()
    }
}

// Get parent index
heap_parent = (index: usize) usize {
    return (index - 1) / 2
}

// Get left child index
heap_left = (index: usize) usize {
    return 2 * index + 1
}

// Get right child index
heap_right = (index: usize) usize {
    return 2 * index + 2
}

// Swap elements
heap_swap = <T>(heap: *Heap<T>, i: usize, j: usize) void {
    temp := heap.data.data[i]
    heap.data.data[i] = heap.data.data[j]
    heap.data.data[j] = temp
}

// Push to heap
heap_push = <T>(heap: *Heap<T>, value: T) void {
    vec_push(&heap.data, value)
    
    // Bubble up
    index := heap.data.len - 1
    loop index > 0 {
        parent := heap_parent(index)
        
        if heap.data.data[index] < heap.data.data[parent] {
            heap_swap(heap, index, parent)
            index = parent
        } else {
            break
        }
    }
}

// Pop from heap
heap_pop = <T>(heap: *Heap<T>) Option<T> {
    if heap.data.len == 0 {
        return none
    }
    
    if heap.data.len == 1 {
        return vec_pop(&heap.data)
    }
    
    // Save minimum value
    min_val := heap.data.data[0]
    
    // Move last element to root
    heap.data.data[0] = heap.data.data[heap.data.len - 1]
    heap.data.len = heap.data.len - 1
    
    // Bubble down
    index := 0
    loop index < heap.data.len {
        smallest := index
        left := heap_left(index)
        right := heap_right(index)
        
        if left < heap.data.len && heap.data.data[left] < heap.data.data[smallest] {
            smallest = left
        }
        
        if right < heap.data.len && heap.data.data[right] < heap.data.data[smallest] {
            smallest = right
        }
        
        if smallest != index {
            heap_swap(heap, index, smallest)
            index = smallest
        } else {
            break
        }
    }
    
    return some(min_val)
}

// Peek at minimum
heap_peek = <T>(heap: Heap<T>) Option<T> {
    if heap.data.len == 0 {
        return none
    }
    return some(heap.data.data[0])
}

// Free heap memory
heap_free = <T>(heap: *Heap<T>) void {
    vec_free(&heap.data)
}

// Queue implementation
Queue<T> = struct {
    data: Vec<T>
    front: usize
}

// Create new queue
queue_new = <T>() Queue<T> {
    return Queue<T> {
        data: vec_new<T>()
        front: 0
    }
}

// Enqueue element
queue_push = <T>(queue: *Queue<T>, value: T) void {
    vec_push(&queue.data, value)
}

// Dequeue element
queue_pop = <T>(queue: *Queue<T>) Option<T> {
    if queue.front >= queue.data.len {
        return none
    }
    
    value := queue.data.data[queue.front]
    queue.front = queue.front + 1
    
    // Reset if queue is empty
    if queue.front >= queue.data.len {
        queue.front = 0
        queue.data.len = 0
    }
    
    return some(value)
}

// Peek at front
queue_peek = <T>(queue: Queue<T>) Option<T> {
    if queue.front >= queue.data.len {
        return none
    }
    return some(queue.data.data[queue.front])
}

// Get queue size
queue_size = <T>(queue: Queue<T>) usize {
    return queue.data.len - queue.front
}

// Free queue memory
queue_free = <T>(queue: *Queue<T>) void {
    vec_free(&queue.data)
    queue.front = 0
}

// Stack implementation (wrapper around Vec)
Stack<T> = struct {
    data: Vec<T>
}

// Create new stack
stack_new = <T>() Stack<T> {
    return Stack<T> {
        data: vec_new<T>()
    }
}

// Push to stack
stack_push = <T>(stack: *Stack<T>, value: T) void {
    vec_push(&stack.data, value)
}

// Pop from stack
stack_pop = <T>(stack: *Stack<T>) Option<T> {
    return vec_pop(&stack.data)
}

// Peek at top
stack_peek = <T>(stack: Stack<T>) Option<T> {
    if stack.data.len == 0 {
        return none
    }
    return some(stack.data.data[stack.data.len - 1])
}

// Get stack size
stack_size = <T>(stack: Stack<T>) usize {
    return stack.data.len
}

// Free stack memory
stack_free = <T>(stack: *Stack<T>) void {
    vec_free(&stack.data)
}

// Set implementation (using hash map)
Set<T> = struct {
    map: HashMap<T, bool>
}

// Create new set
set_new = <T>() Set<T> {
    return Set<T> {
        map: hashmap_new<T, bool>(16)
    }
}

// Add to set
set_add = <T>(set: *Set<T>, value: T) void {
    hashmap_insert(&set.map, value, true)
}

// Check if contains
set_contains = <T>(set: Set<T>, value: T) bool {
    return match hashmap_get(set.map, value) {
        some(_) => true
        none => false
    }
}

// Remove from set
set_remove = <T>(set: *Set<T>, value: T) bool {
    return match hashmap_remove(&set.map, value) {
        some(_) => true
        none => false
    }
}

// Get set size
set_size = <T>(set: Set<T>) usize {
    return set.map.size
}

// Free set memory
set_free = <T>(set: *Set<T>) void {
    hashmap_free(&set.map)
}