// Zen Standard Library - String Module
// String manipulation functions implemented in pure Zen

core := @std.core

// String builder for efficient string construction
StringBuilder := struct {
    buffer: *byte
    len: usize
    cap: usize
}

// Create new string builder
new_builder = (initial_cap: usize) StringBuilder {
    buffer := core.alloc(byte, initial_cap)
    return StringBuilder{
        buffer: buffer,
        len: 0,
        cap: initial_cap
    }
}

// Append string to builder
append = (sb: *StringBuilder, s: core.String) void {
    ensure_capacity(sb, sb.len + s.len)
    core.copy(byte, sb.buffer + sb.len, s.data, s.len)
    sb.len = sb.len + s.len
}

// Append single character
append_char = (sb: *StringBuilder, c: byte) void {
    ensure_capacity(sb, sb.len + 1)
    sb.buffer[sb.len] = c
    sb.len = sb.len + 1
}

// Ensure capacity
ensure_capacity = (sb: *StringBuilder, needed: usize) void {
    if (needed <= sb.cap) return
    
    new_cap := sb.cap * 2
    if (new_cap < needed) {
        new_cap = needed
    }
    
    new_buffer := core.alloc(byte, new_cap)
    core.copy(byte, new_buffer, sb.buffer, sb.len)
    core.free(sb.buffer)
    sb.buffer = new_buffer
    sb.cap = new_cap
}

// Convert builder to string
to_string = (sb: *StringBuilder) core.String {
    return core.String{
        data: sb.buffer,
        len: sb.len
    }
}

// String comparison
equals = (a: core.String, b: core.String) bool {
    if (a.len != b.len) return false
    
    i := usize(0)
    while (i < a.len) {
        if (a.data[i] != b.data[i]) return false
        i = i + 1
    }
    return true
}

// String comparison (case insensitive)
equals_ignore_case = (a: core.String, b: core.String) bool {
    if (a.len != b.len) return false
    
    i := usize(0)
    while (i < a.len) {
        ac := to_lower_char(a.data[i])
        bc := to_lower_char(b.data[i])
        if (ac != bc) return false
        i = i + 1
    }
    return true
}

// Compare strings lexicographically
compare = (a: core.String, b: core.String) i32 {
    min_len := core.min(usize, a.len, b.len)
    
    i := usize(0)
    while (i < min_len) {
        if (a.data[i] < b.data[i]) return -1
        if (a.data[i] > b.data[i]) return 1
        i = i + 1
    }
    
    if (a.len < b.len) return -1
    if (a.len > b.len) return 1
    return 0
}

// Check if string starts with prefix
starts_with = (s: core.String, prefix: core.String) bool {
    if (prefix.len > s.len) return false
    
    i := usize(0)
    while (i < prefix.len) {
        if (s.data[i] != prefix.data[i]) return false
        i = i + 1
    }
    return true
}

// Check if string ends with suffix
ends_with = (s: core.String, suffix: core.String) bool {
    if (suffix.len > s.len) return false
    
    offset := s.len - suffix.len
    i := usize(0)
    while (i < suffix.len) {
        if (s.data[offset + i] != suffix.data[i]) return false
        i = i + 1
    }
    return true
}

// Find substring
index_of = (s: core.String, needle: core.String) core.Option(usize) {
    if (needle.len > s.len) return core.Option(usize).None
    
    i := usize(0)
    while (i <= s.len - needle.len) {
        found := true
        j := usize(0)
        while (j < needle.len) {
            if (s.data[i + j] != needle.data[j]) {
                found = false
                break
            }
            j = j + 1
        }
        if (found) return core.Option(usize).Some(i)
        i = i + 1
    }
    return core.Option(usize).None
}

// Find character
index_of_char = (s: core.String, c: byte) core.Option(usize) {
    i := usize(0)
    while (i < s.len) {
        if (s.data[i] == c) return core.Option(usize).Some(i)
        i = i + 1
    }
    return core.Option(usize).None
}

// Get substring
substring = (s: core.String, start: usize, end: usize) core.String {
    if (start >= s.len) return core.String{ data: s.data + s.len, len: 0 }
    if (end > s.len) end = s.len
    if (start >= end) return core.String{ data: s.data + start, len: 0 }
    
    return core.String{
        data: s.data + start,
        len: end - start
    }
}

// Trim whitespace from both ends
trim = (s: core.String) core.String {
    start := usize(0)
    while (start < s.len && is_whitespace(s.data[start])) {
        start = start + 1
    }
    
    end := s.len
    while (end > start && is_whitespace(s.data[end - 1])) {
        end = end - 1
    }
    
    return substring(s, start, end)
}

// Trim whitespace from start
trim_start = (s: core.String) core.String {
    start := usize(0)
    while (start < s.len && is_whitespace(s.data[start])) {
        start = start + 1
    }
    return substring(s, start, s.len)
}

// Trim whitespace from end
trim_end = (s: core.String) core.String {
    end := s.len
    while (end > 0 && is_whitespace(s.data[end - 1])) {
        end = end - 1
    }
    return substring(s, 0, end)
}

// Convert to uppercase
to_upper = (s: core.String) core.String {
    result := core.alloc(byte, s.len)
    i := usize(0)
    while (i < s.len) {
        result[i] = to_upper_char(s.data[i])
        i = i + 1
    }
    return core.String{ data: result, len: s.len }
}

// Convert to lowercase
to_lower = (s: core.String) core.String {
    result := core.alloc(byte, s.len)
    i := usize(0)
    while (i < s.len) {
        result[i] = to_lower_char(s.data[i])
        i = i + 1
    }
    return core.String{ data: result, len: s.len }
}

// Character classification
is_whitespace = (c: byte) bool {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

is_digit = (c: byte) bool {
    return c >= '0' && c <= '9'
}

is_alpha = (c: byte) bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
}

is_alnum = (c: byte) bool {
    return is_alpha(c) || is_digit(c)
}

// Character conversion
to_upper_char = (c: byte) byte {
    if (c >= 'a' && c <= 'z') {
        return c - 32
    }
    return c
}

to_lower_char = (c: byte) byte {
    if (c >= 'A' && c <= 'Z') {
        return c + 32
    }
    return c
}

// Parse integer from string
parse_int = (s: core.String) core.Result(i64, core.String) {
    if (s.len == 0) {
        return core.Result(i64, core.String).Err("Empty string")
    }
    
    i := usize(0)
    negative := false
    
    if (s.data[0] == '-') {
        negative = true
        i = 1
    } else if (s.data[0] == '+') {
        i = 1
    }
    
    result := i64(0)
    while (i < s.len) {
        if (!is_digit(s.data[i])) {
            return core.Result(i64, core.String).Err("Invalid digit")
        }
        
        digit := i64(s.data[i] - '0')
        result = result * 10 + digit
        i = i + 1
    }
    
    if (negative) {
        result = -result
    }
    
    return core.Result(i64, core.String).Ok(result)
}

// Parse unsigned integer from string
parse_uint = (s: core.String) core.Result(u64, core.String) {
    if (s.len == 0) {
        return core.Result(u64, core.String).Err("Empty string")
    }
    
    i := usize(0)
    if (s.data[0] == '+') {
        i = 1
    }
    
    result := u64(0)
    while (i < s.len) {
        if (!is_digit(s.data[i])) {
            return core.Result(u64, core.String).Err("Invalid digit")
        }
        
        digit := u64(s.data[i] - '0')
        result = result * 10 + digit
        i = i + 1
    }
    
    return core.Result(u64, core.String).Ok(result)
}

// Export public functions
export {
    // String builder
    StringBuilder, new_builder, append, append_char, to_string,
    
    // Comparison
    equals, equals_ignore_case, compare,
    
    // Search
    starts_with, ends_with, index_of, index_of_char,
    
    // Manipulation
    substring, trim, trim_start, trim_end, to_upper, to_lower,
    
    // Character classification
    is_whitespace, is_digit, is_alpha, is_alnum,
    to_upper_char, to_lower_char,
    
    // Parsing
    parse_int, parse_uint
}