// Zen Standard Library - HTTP Module
// HTTP client and server functionality implemented in pure Zen

core := @std.core
network := @std.network
string := @std.string
json := @std.json

// HTTP methods
Method := enum {
    GET
    POST
    PUT
    DELETE
    HEAD
    OPTIONS
    PATCH
    CONNECT
    TRACE
}

// HTTP status codes
StatusCode := enum {
    // 1xx Informational
    Continue = 100
    SwitchingProtocols = 101
    
    // 2xx Success
    OK = 200
    Created = 201
    Accepted = 202
    NoContent = 204
    
    // 3xx Redirection
    MovedPermanently = 301
    Found = 302
    SeeOther = 303
    NotModified = 304
    TemporaryRedirect = 307
    PermanentRedirect = 308
    
    // 4xx Client Error
    BadRequest = 400
    Unauthorized = 401
    Forbidden = 403
    NotFound = 404
    MethodNotAllowed = 405
    RequestTimeout = 408
    Conflict = 409
    Gone = 410
    UnprocessableEntity = 422
    TooManyRequests = 429
    
    // 5xx Server Error
    InternalServerError = 500
    NotImplemented = 501
    BadGateway = 502
    ServiceUnavailable = 503
    GatewayTimeout = 504
}

// HTTP headers container
Headers := struct {
    entries: []HeaderEntry
}

HeaderEntry := struct {
    name: core.String
    value: core.String
}

// Create new headers
new_headers = () Headers {
    return Headers{
        entries: []HeaderEntry{}
    }
}

// Add header
add_header = (h: *Headers, name: core.String, value: core.String) void {
    entry := HeaderEntry{
        name: name
        value: value
    }
    h.entries.append(entry)
}

// Get header value
get_header = (h: *Headers, name: core.String) ?core.String {
    i := 0
    while i < h.entries.len {
        if string.equals_ignore_case(h.entries[i].name, name) {
            return h.entries[i].value
        }
        i = i + 1
    }
    return null
}

// HTTP request
Request := struct {
    method: Method
    url: core.String
    headers: Headers
    body: ?[]u8
}

// HTTP response
Response := struct {
    status: StatusCode
    headers: Headers
    body: []u8
}

// URL structure
URL := struct {
    scheme: core.String    // http or https
    host: core.String
    port: u16
    path: core.String
    query: ?core.String
    fragment: ?core.String
}

// Parse URL
parse_url = (url_str: core.String) ?URL {
    // Find scheme
    scheme_end := string.index_of(url_str, "://")
    if scheme_end == -1 {
        return null
    }
    
    scheme := string.substring(url_str, 0, scheme_end)
    rest := string.substring(url_str, scheme_end + 3, url_str.len)
    
    // Find host and port
    path_start := string.index_of(rest, "/")
    host_part := if path_start != -1 {
        string.substring(rest, 0, path_start)
    } else {
        rest
    }
    
    // Parse host and port
    port_sep := string.last_index_of(host_part, ":")
    host := core.String{}
    port := 0
    
    if port_sep != -1 {
        host = string.substring(host_part, 0, port_sep)
        port_str := string.substring(host_part, port_sep + 1, host_part.len)
        port = string.parse_int(port_str) ?? 0
    } else {
        host = host_part
        port = if string.equals(scheme, "https") { 443 } else { 80 }
    }
    
    // Parse path, query, fragment
    path := core.String{ data: "/" }
    query := null
    fragment := null
    
    if path_start != -1 {
        path_part := string.substring(rest, path_start, rest.len)
        
        // Check for query
        query_start := string.index_of(path_part, "?")
        if query_start != -1 {
            path = string.substring(path_part, 0, query_start)
            
            // Check for fragment
            frag_start := string.index_of(path_part, "#")
            if frag_start != -1 and frag_start > query_start {
                query = string.substring(path_part, query_start + 1, frag_start)
                fragment = string.substring(path_part, frag_start + 1, path_part.len)
            } else {
                query = string.substring(path_part, query_start + 1, path_part.len)
            }
        } else {
            // Check for fragment without query
            frag_start := string.index_of(path_part, "#")
            if frag_start != -1 {
                path = string.substring(path_part, 0, frag_start)
                fragment = string.substring(path_part, frag_start + 1, path_part.len)
            } else {
                path = path_part
            }
        }
    }
    
    return URL{
        scheme: scheme
        host: host
        port: port
        path: path
        query: query
        fragment: fragment
    }
}

// HTTP Client
Client := struct {
    timeout: u32  // milliseconds
    headers: Headers  // Default headers
}

// Create new HTTP client
new_client = () Client {
    return Client{
        timeout: 30000  // 30 seconds default
        headers: new_headers()
    }
}

// Perform HTTP request
do_request = (client: *Client, req: Request) ?Response {
    // Parse URL
    url := parse_url(req.url) ?? return null
    
    // Connect to server
    conn := network.connect_tcp(url.host, url.port) ?? return null
    defer network.close(&conn)
    
    // Build HTTP request string
    request_line := format_method(req.method) + " " + url.path
    if url.query != null {
        request_line = request_line + "?" + url.query
    }
    request_line = request_line + " HTTP/1.1\r\n"
    
    // Send request line
    network.send(&conn, request_line.as_bytes())
    
    // Send headers
    network.send(&conn, ("Host: " + url.host + "\r\n").as_bytes())
    
    // Add default client headers
    i := 0
    while i < client.headers.entries.len {
        header_line := client.headers.entries[i].name + ": " + 
                      client.headers.entries[i].value + "\r\n"
        network.send(&conn, header_line.as_bytes())
        i = i + 1
    }
    
    // Add request headers
    i = 0
    while i < req.headers.entries.len {
        header_line := req.headers.entries[i].name + ": " + 
                      req.headers.entries[i].value + "\r\n"
        network.send(&conn, header_line.as_bytes())
        i = i + 1
    }
    
    // Add content length if body exists
    if req.body != null {
        content_length := "Content-Length: " + string.from_int(req.body.len) + "\r\n"
        network.send(&conn, content_length.as_bytes())
    }
    
    // End headers
    network.send(&conn, "\r\n".as_bytes())
    
    // Send body if exists
    if req.body != null {
        network.send(&conn, req.body)
    }
    
    // Read response
    return read_response(&conn)
}

// Read HTTP response from connection
read_response = (conn: *network.Connection) ?Response {
    // Read status line
    status_line := read_line(conn) ?? return null
    parts := string.split(status_line, " ")
    if parts.len < 2 {
        return null
    }
    
    status_code := string.parse_int(parts[1]) ?? 500
    
    // Read headers
    headers := new_headers()
    loop {
        line := read_line(conn) ?? break
        if line.len == 0 {
            break  // Empty line marks end of headers
        }
        
        colon := string.index_of(line, ":")
        if colon != -1 {
            name := string.trim(string.substring(line, 0, colon))
            value := string.trim(string.substring(line, colon + 1, line.len))
            add_header(&headers, name, value)
        }
    }
    
    // Read body
    body := []u8{}
    content_length_str := get_header(&headers, "Content-Length")
    
    if content_length_str != null {
        content_length := string.parse_int(content_length_str) ?? 0
        body = core.alloc(u8, content_length)
        network.receive(conn, body)
    } else {
        // Read until connection closes or chunked encoding
        transfer_encoding := get_header(&headers, "Transfer-Encoding")
        if transfer_encoding != null and string.contains(transfer_encoding, "chunked") {
            body = read_chunked_body(conn)
        } else {
            // Read until EOF
            buffer := core.alloc(u8, 4096)
            total := core.String{}
            loop {
                n := network.receive_partial(conn, buffer) ?? break
                if n == 0 { break }
                total.append_bytes(buffer[0..n])
            }
            body = total.as_bytes()
        }
    }
    
    return Response{
        status: status_code
        headers: headers
        body: body
    }
}

// Read a line from connection
read_line = (conn: *network.Connection) ?core.String {
    line := core.String{}
    buffer := [1]u8{}
    
    loop {
        n := network.receive(conn, buffer) ?? return null
        if n == 0 {
            return if line.len > 0 { line } else { null }
        }
        
        if buffer[0] == '\r' {
            // Expect \n next
            network.receive(conn, buffer)
            if buffer[0] == '\n' {
                return line
            }
        } else if buffer[0] == '\n' {
            return line
        } else {
            line.append(buffer[0])
        }
    }
}

// Read chunked body
read_chunked_body = (conn: *network.Connection) []u8 {
    result := core.String{}
    
    loop {
        // Read chunk size
        size_line := read_line(conn) ?? break
        chunk_size := string.parse_hex(size_line) ?? 0
        
        if chunk_size == 0 {
            // Last chunk
            read_line(conn)  // Read trailing CRLF
            break
        }
        
        // Read chunk data
        chunk := core.alloc(u8, chunk_size)
        network.receive(conn, chunk)
        result.append_bytes(chunk)
        
        // Read trailing CRLF
        read_line(conn)
    }
    
    return result.as_bytes()
}

// Format HTTP method
format_method = (method: Method) core.String {
    return switch method {
        .GET => "GET"
        .POST => "POST"
        .PUT => "PUT"
        .DELETE => "DELETE"
        .HEAD => "HEAD"
        .OPTIONS => "OPTIONS"
        .PATCH => "PATCH"
        .CONNECT => "CONNECT"
        .TRACE => "TRACE"
    }
}

// Convenience methods for common requests
get = (client: *Client, url: core.String) ?Response {
    req := Request{
        method: .GET
        url: url
        headers: new_headers()
        body: null
    }
    return do_request(client, req)
}

post = (client: *Client, url: core.String, body: []u8) ?Response {
    req := Request{
        method: .POST
        url: url
        headers: new_headers()
        body: body
    }
    return do_request(client, req)
}

post_json = (client: *Client, url: core.String, data: json.Value) ?Response {
    headers := new_headers()
    add_header(&headers, "Content-Type", "application/json")
    
    body := json.stringify(data).as_bytes()
    
    req := Request{
        method: .POST
        url: url
        headers: headers
        body: body
    }
    return do_request(client, req)
}

// HTTP Server
Server := struct {
    port: u16
    handlers: []Handler
    listener: ?network.Listener
}

Handler := struct {
    path: core.String
    method: Method
    handler: fn(*ServerRequest) ServerResponse
}

ServerRequest := struct {
    method: Method
    path: core.String
    headers: Headers
    body: []u8
    params: []Param  // URL parameters
}

ServerResponse := struct {
    status: StatusCode
    headers: Headers
    body: []u8
}

Param := struct {
    name: core.String
    value: core.String
}

// Create new HTTP server
new_server = (port: u16) Server {
    return Server{
        port: port
        handlers: []Handler{}
        listener: null
    }
}

// Add route handler
handle = (server: *Server, method: Method, path: core.String, 
         handler: fn(*ServerRequest) ServerResponse) void {
    h := Handler{
        path: path
        method: method
        handler: handler
    }
    server.handlers.append(h)
}

// Start server
start = (server: *Server) ?void {
    listener := network.listen_tcp(server.port) ?? return null
    server.listener = listener
    
    loop {
        conn := network.accept(&listener) ?? continue
        
        // Handle connection in new fiber/thread if available
        handle_connection(server, conn)
    }
}

// Handle client connection
handle_connection = (server: *Server, conn: network.Connection) void {
    defer network.close(&conn)
    
    // Read request
    req := read_request(&conn) ?? return
    
    // Find handler
    handler := find_handler(server, req.method, req.path)
    
    // Generate response
    response := if handler != null {
        handler.handler(&req)
    } else {
        // 404 Not Found
        headers := new_headers()
        add_header(&headers, "Content-Type", "text/plain")
        ServerResponse{
            status: .NotFound
            headers: headers
            body: "404 Not Found".as_bytes()
        }
    }
    
    // Send response
    send_response(&conn, response)
}

// Read HTTP request
read_request = (conn: *network.Connection) ?ServerRequest {
    // Read request line
    request_line := read_line(conn) ?? return null
    parts := string.split(request_line, " ")
    if parts.len < 2 {
        return null
    }
    
    method := parse_method(parts[0]) ?? .GET
    path := parts[1]
    
    // Parse path and query parameters
    params := []Param{}
    actual_path := path
    query_start := string.index_of(path, "?")
    if query_start != -1 {
        actual_path = string.substring(path, 0, query_start)
        query := string.substring(path, query_start + 1, path.len)
        params = parse_query_params(query)
    }
    
    // Read headers
    headers := new_headers()
    loop {
        line := read_line(conn) ?? break
        if line.len == 0 {
            break
        }
        
        colon := string.index_of(line, ":")
        if colon != -1 {
            name := string.trim(string.substring(line, 0, colon))
            value := string.trim(string.substring(line, colon + 1, line.len))
            add_header(&headers, name, value)
        }
    }
    
    // Read body
    body := []u8{}
    content_length_str := get_header(&headers, "Content-Length")
    if content_length_str != null {
        content_length := string.parse_int(content_length_str) ?? 0
        body = core.alloc(u8, content_length)
        network.receive(conn, body)
    }
    
    return ServerRequest{
        method: method
        path: actual_path
        headers: headers
        body: body
        params: params
    }
}

// Parse HTTP method string
parse_method = (s: core.String) ?Method {
    if string.equals(s, "GET") { return .GET }
    if string.equals(s, "POST") { return .POST }
    if string.equals(s, "PUT") { return .PUT }
    if string.equals(s, "DELETE") { return .DELETE }
    if string.equals(s, "HEAD") { return .HEAD }
    if string.equals(s, "OPTIONS") { return .OPTIONS }
    if string.equals(s, "PATCH") { return .PATCH }
    if string.equals(s, "CONNECT") { return .CONNECT }
    if string.equals(s, "TRACE") { return .TRACE }
    return null
}

// Parse query parameters
parse_query_params = (query: core.String) []Param {
    params := []Param{}
    pairs := string.split(query, "&")
    
    i := 0
    while i < pairs.len {
        eq := string.index_of(pairs[i], "=")
        if eq != -1 {
            name := url_decode(string.substring(pairs[i], 0, eq))
            value := url_decode(string.substring(pairs[i], eq + 1, pairs[i].len))
            params.append(Param{ name: name, value: value })
        }
        i = i + 1
    }
    
    return params
}

// URL decode
url_decode = (s: core.String) core.String {
    result := core.String{}
    i := 0
    
    while i < s.len {
        if s[i] == '%' and i + 2 < s.len {
            // Decode hex
            high := hex_to_int(s[i + 1])
            low := hex_to_int(s[i + 2])
            if high != -1 and low != -1 {
                result.append((high << 4) | low)
                i = i + 3
            } else {
                result.append(s[i])
                i = i + 1
            }
        } else if s[i] == '+' {
            result.append(' ')
            i = i + 1
        } else {
            result.append(s[i])
            i = i + 1
        }
    }
    
    return result
}

// Convert hex char to int
hex_to_int = (c: u8) i8 {
    if c >= '0' and c <= '9' {
        return c - '0'
    } else if c >= 'A' and c <= 'F' {
        return c - 'A' + 10
    } else if c >= 'a' and c <= 'f' {
        return c - 'a' + 10
    } else {
        return -1
    }
}

// Find handler for request
find_handler = (server: *Server, method: Method, path: core.String) ?*Handler {
    i := 0
    while i < server.handlers.len {
        if server.handlers[i].method == method and 
           string.equals(server.handlers[i].path, path) {
            return &server.handlers[i]
        }
        i = i + 1
    }
    return null
}

// Send HTTP response
send_response = (conn: *network.Connection, resp: ServerResponse) void {
    // Status line
    status_text := get_status_text(resp.status)
    status_line := "HTTP/1.1 " + string.from_int(resp.status) + " " + status_text + "\r\n"
    network.send(conn, status_line.as_bytes())
    
    // Headers
    i := 0
    while i < resp.headers.entries.len {
        header_line := resp.headers.entries[i].name + ": " + 
                      resp.headers.entries[i].value + "\r\n"
        network.send(conn, header_line.as_bytes())
        i = i + 1
    }
    
    // Content-Length
    content_length := "Content-Length: " + string.from_int(resp.body.len) + "\r\n"
    network.send(conn, content_length.as_bytes())
    
    // End headers
    network.send(conn, "\r\n".as_bytes())
    
    // Body
    if resp.body.len > 0 {
        network.send(conn, resp.body)
    }
}

// Get status text
get_status_text = (code: StatusCode) core.String {
    return switch code {
        .OK => "OK"
        .Created => "Created"
        .Accepted => "Accepted"
        .NoContent => "No Content"
        .MovedPermanently => "Moved Permanently"
        .Found => "Found"
        .NotModified => "Not Modified"
        .BadRequest => "Bad Request"
        .Unauthorized => "Unauthorized"
        .Forbidden => "Forbidden"
        .NotFound => "Not Found"
        .MethodNotAllowed => "Method Not Allowed"
        .InternalServerError => "Internal Server Error"
        .BadGateway => "Bad Gateway"
        .ServiceUnavailable => "Service Unavailable"
        _ => "Unknown"
    }
}