// Zen Standard Library - Utility Functions
// Common utility functions for everyday programming

core := @std.core
string := @std.string
vec := @std.vec
io := @std.io

// Result type for error handling
Result<T, E> = enum {
    Ok -> value: T,
    Err -> error: E,
}

// Option type for nullable values
Option<T> = enum {
    Some -> value: T,
    None,
}

// Pair type for two values
Pair<A, B> = {
    first: A,
    second: B,
}

// Triple type for three values
Triple<A, B, C> = {
    first: A,
    second: B,
    third: C,
}

// Identity function - returns its input unchanged
identity = <T>(x: T) T {
    return x
}

// Constant function - returns a function that always returns the same value
constant = <T>(value: T) fn() T {
    return () T { return value }
}

// Compose two functions
compose = <A, B, C>(f: fn(B) C, g: fn(A) B) fn(A) C {
    return (x: A) C { return f(g(x)) }
}

// Pipe value through multiple functions
pipe = <T>(value: T, funcs: ...fn(T) T) T {
    result := value
    for f in funcs {
        result = f(result)
    }
    return result
}

// Apply function n times
apply_n = <T>(f: fn(T) T, n: i32, initial: T) T {
    result := initial
    for i in 0..n {
        result = f(result)
    }
    return result
}

// Swap two values
swap = <T>(a: *T, b: *T) void {
    temp := *a
    *a = *b
    *b = temp
}

// Min of two values
min = <T: Ord>(a: T, b: T) T {
    return if a < b { a } else { b }
}

// Max of two values
max = <T: Ord>(a: T, b: T) T {
    return if a > b { a } else { b }
}

// Clamp value between min and max
clamp = <T: Ord>(value: T, min_val: T, max_val: T) T {
    return max(min_val, min(max_val, value))
}

// Check if value is in range [min, max]
in_range = <T: Ord>(value: T, min_val: T, max_val: T) bool {
    return value >= min_val && value <= max_val
}

// Map function over Option
map_option = <A, B>(opt: Option<A>, f: fn(A) B) Option<B> {
    match opt {
        | Some(value) => Option<B>.Some(f(value))
        | None => Option<B>.None
    }
}

// Map function over Result
map_result = <T, E, U>(res: Result<T, E>, f: fn(T) U) Result<U, E> {
    match res {
        | Ok(value) => Result<U, E>.Ok(f(value))
        | Err(error) => Result<U, E>.Err(error)
    }
}

// Unwrap Option with default value
unwrap_or = <T>(opt: Option<T>, default: T) T {
    match opt {
        | Some(value) => value
        | None => default
    }
}

// Unwrap Option with default function
unwrap_or_else = <T>(opt: Option<T>, f: fn() T) T {
    match opt {
        | Some(value) => value
        | None => f()
    }
}

// Chain Options
and_then = <A, B>(opt: Option<A>, f: fn(A) Option<B>) Option<B> {
    match opt {
        | Some(value) => f(value)
        | None => Option<B>.None
    }
}

// Combine two Options
zip_options = <A, B>(a: Option<A>, b: Option<B>) Option<Pair<A, B>> {
    match (a, b) {
        | (Some(x), Some(y)) => Option<Pair<A, B>>.Some(Pair { first: x, second: y })
        | _ => Option<Pair<A, B>>.None
    }
}

// Filter values
filter = <T>(items: Vec<T>, predicate: fn(T) bool) Vec<T> {
    result := vec.new<T>()
    for item in items {
        if predicate(item) {
            result.push(item)
        }
    }
    return result
}

// Map function over vector
map = <A, B>(items: Vec<A>, f: fn(A) B) Vec<B> {
    result := vec.new<B>()
    for item in items {
        result.push(f(item))
    }
    return result
}

// Reduce/fold vector
reduce = <T, R>(items: Vec<T>, initial: R, f: fn(R, T) R) R {
    result := initial
    for item in items {
        result = f(result, item)
    }
    return result
}

// Find first element matching predicate
find = <T>(items: Vec<T>, predicate: fn(T) bool) Option<T> {
    for item in items {
        if predicate(item) {
            return Option<T>.Some(item)
        }
    }
    return Option<T>.None
}

// Check if any element matches predicate
any = <T>(items: Vec<T>, predicate: fn(T) bool) bool {
    for item in items {
        if predicate(item) {
            return true
        }
    }
    return false
}

// Check if all elements match predicate
all = <T>(items: Vec<T>, predicate: fn(T) bool) bool {
    for item in items {
        if !predicate(item) {
            return false
        }
    }
    return true
}

// Partition vector into two based on predicate
partition = <T>(items: Vec<T>, predicate: fn(T) bool) Pair<Vec<T>, Vec<T>> {
    true_items := vec.new<T>()
    false_items := vec.new<T>()
    
    for item in items {
        if predicate(item) {
            true_items.push(item)
        } else {
            false_items.push(item)
        }
    }
    
    return Pair { first: true_items, second: false_items }
}

// Take first n elements
take = <T>(items: Vec<T>, n: usize) Vec<T> {
    result := vec.new<T>()
    count := min(n, items.len())
    
    for i in 0..count {
        result.push(items[i])
    }
    
    return result
}

// Drop first n elements
drop = <T>(items: Vec<T>, n: usize) Vec<T> {
    result := vec.new<T>()
    
    for i in n..items.len() {
        result.push(items[i])
    }
    
    return result
}

// Zip two vectors into pairs
zip = <A, B>(as: Vec<A>, bs: Vec<B>) Vec<Pair<A, B>> {
    result := vec.new<Pair<A, B>>()
    len := min(as.len(), bs.len())
    
    for i in 0..len {
        result.push(Pair { first: as[i], second: bs[i] })
    }
    
    return result
}

// Unzip pairs into two vectors
unzip = <A, B>(pairs: Vec<Pair<A, B>>) Pair<Vec<A>, Vec<B>> {
    as := vec.new<A>()
    bs := vec.new<B>()
    
    for pair in pairs {
        as.push(pair.first)
        bs.push(pair.second)
    }
    
    return Pair { first: as, second: bs }
}

// Flatten nested vector
flatten = <T>(items: Vec<Vec<T>>) Vec<T> {
    result := vec.new<T>()
    
    for subvec in items {
        for item in subvec {
            result.push(item)
        }
    }
    
    return result
}

// Create range of integers
range = (start: i32, end: i32) Vec<i32> {
    result := vec.new<i32>()
    
    for i in start..end {
        result.push(i)
    }
    
    return result
}

// Repeat value n times
repeat = <T: Clone>(value: T, n: usize) Vec<T> {
    result := vec.new<T>()
    
    for _ in 0..n {
        result.push(value.clone())
    }
    
    return result
}

// Memoize function results
memoize = <A: Hash + Eq, B>(f: fn(A) B) fn(A) B {
    cache := map.new<A, B>()
    
    return (arg: A) B {
        cache.get(arg) ?
            | Some(result) => result
            | None => {
                result := f(arg)
                cache.insert(arg, result)
                result
            }
    }
}

// Curry a two-argument function
curry = <A, B, C>(f: fn(A, B) C) fn(A) fn(B) C {
    return (a: A) fn(B) C {
        return (b: B) C {
            return f(a, b)
        }
    }
}

// Uncurry a curried function
uncurry = <A, B, C>(f: fn(A) fn(B) C) fn(A, B) C {
    return (a: A, b: B) C {
        return f(a)(b)
    }
}

// Timing utilities
time_it = <T>(f: fn() T) Pair<T, f64> {
    start := core.time_ns()
    result := f()
    end := core.time_ns()
    duration := (end - start) as f64 / 1_000_000_000.0
    return Pair { first: result, second: duration }
}

// Print and return value (for debugging)
debug = <T>(value: T, label: string) T {
    io.print(label)
    io.print(": ")
    io.print_debug(value)
    io.print("\n")
    return value
}

// Assert with custom message
assert_eq = <T: Eq>(expected: T, actual: T, msg: string) void {
    if expected != actual {
        io.print("Assertion failed: ")
        io.print(msg)
        io.print("\n  Expected: ")
        io.print_debug(expected)
        io.print("\n  Actual: ")
        io.print_debug(actual)
        io.print("\n")
        core.panic("assertion failed")
    }
}

// Lazy evaluation wrapper
Lazy<T> = {
    computed: bool,
    value: Option<T>,
    compute: fn() T,
}

// Create lazy value
lazy = <T>(f: fn() T) Lazy<T> {
    return Lazy {
        computed: false,
        value: Option<T>.None,
        compute: f,
    }
}

// Force lazy evaluation
force = <T>(l: *Lazy<T>) T {
    if !l.computed {
        l.value = Option<T>.Some(l.compute())
        l.computed = true
    }
    
    match l.value {
        | Some(v) => v
        | None => core.panic("lazy value not computed")
    }
}