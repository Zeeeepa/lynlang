// Zen Standard Library - Regular Expression Module
// Regular expression matching and manipulation in pure Zen

core := @std.core
string := @std.string

// Regex pattern representation
Pattern := struct {
    source: core.String
    flags: Flags
    compiled: CompiledPattern
}

// Regex flags
Flags := struct {
    case_insensitive: bool
    multiline: bool
    dot_all: bool
    global: bool
    unicode: bool
}

// Compiled pattern for efficient matching
CompiledPattern := struct {
    nodes: []Node
    capture_groups: []CaptureGroup
}

// Pattern nodes
Node := 
    | Literal(char: u8)
    | CharClass(chars: []u8, negated: bool)
    | Dot
    | Start
    | End
    | WordBoundary
    | Group(nodes: []Node, capture: bool, name: ?core.String)
    | Alternative(branches: [][]Node)
    | Quantifier(node: *Node, min: u32, max: ?u32, greedy: bool)
    | Backreference(group: u32)
    | Lookahead(nodes: []Node, positive: bool)
    | Lookbehind(nodes: []Node, positive: bool)

// Capture group info
CaptureGroup := struct {
    index: u32
    name: ?core.String
    start: usize
    end: usize
}

// Match result
Match := struct {
    text: core.String
    start: usize
    end: usize
    groups: []Group
}

Group := struct {
    text: core.String
    start: usize
    end: usize
    name: ?core.String
}

// Compile a regex pattern
compile = (pattern: core.String, flags: Flags) ?Pattern {
    parser := Parser{
        source: pattern
        pos: 0
        flags: flags
        groups: []CaptureGroup{}
        group_counter: 0
    }
    
    nodes := parse_pattern(&parser) ?? return null
    
    return Pattern{
        source: pattern
        flags: flags
        compiled: CompiledPattern{
            nodes: nodes
            capture_groups: parser.groups
        }
    }
}

// Convenience function without flags
compile_simple = (pattern: core.String) ?Pattern {
    return compile(pattern, Flags{
        case_insensitive: false
        multiline: false
        dot_all: false
        global: false
        unicode: false
    })
}

// Parser state
Parser := struct {
    source: core.String
    pos: usize
    flags: Flags
    groups: []CaptureGroup
    group_counter: u32
}

// Parse the pattern
parse_pattern = (p: *Parser) ?[]Node {
    nodes := []Node{}
    
    while p.pos < p.source.len {
        c := p.source[p.pos]
        
        node := switch c {
            '^' => {
                p.pos = p.pos + 1
                Node.Start
            }
            '$' => {
                p.pos = p.pos + 1
                Node.End
            }
            '.' => {
                p.pos = p.pos + 1
                Node.Dot
            }
            '\\' => parse_escape(p) ?? return null
            '[' => parse_char_class(p) ?? return null
            '(' => parse_group(p) ?? return null
            '|' => {
                // Handle alternation
                p.pos = p.pos + 1
                right := parse_pattern(p) ?? return null
                return [Node.Alternative(branches: [nodes, right])]
            }
            '*', '+', '?', '{' => {
                if nodes.len == 0 {
                    return null  // Quantifier without target
                }
                parse_quantifier(p, &nodes[nodes.len - 1]) ?? return null
                continue
            }
            _ => {
                p.pos = p.pos + 1
                Node.Literal(char: c)
            }
        }
        
        nodes.append(node)
    }
    
    return nodes
}

// Parse escape sequence
parse_escape = (p: *Parser) ?Node {
    p.pos = p.pos + 1  // Skip '\'
    if p.pos >= p.source.len {
        return null
    }
    
    c := p.source[p.pos]
    p.pos = p.pos + 1
    
    return switch c {
        'd' => Node.CharClass(chars: digits(), negated: false)
        'D' => Node.CharClass(chars: digits(), negated: true)
        'w' => Node.CharClass(chars: word_chars(), negated: false)
        'W' => Node.CharClass(chars: word_chars(), negated: true)
        's' => Node.CharClass(chars: whitespace(), negated: false)
        'S' => Node.CharClass(chars: whitespace(), negated: true)
        'b' => Node.WordBoundary
        'n' => Node.Literal(char: '\n')
        'r' => Node.Literal(char: '\r')
        't' => Node.Literal(char: '\t')
        '0'..'9' => Node.Backreference(group: c - '0')
        _ => Node.Literal(char: c)
    }
}

// Parse character class [abc]
parse_char_class = (p: *Parser) ?Node {
    p.pos = p.pos + 1  // Skip '['
    
    negated := false
    if p.pos < p.source.len and p.source[p.pos] == '^' {
        negated = true
        p.pos = p.pos + 1
    }
    
    chars := []u8{}
    
    while p.pos < p.source.len and p.source[p.pos] != ']' {
        c := p.source[p.pos]
        
        if c == '\\' {
            p.pos = p.pos + 1
            if p.pos < p.source.len {
                chars.append(p.source[p.pos])
                p.pos = p.pos + 1
            }
        } else if p.pos + 2 < p.source.len and p.source[p.pos + 1] == '-' {
            // Range like a-z
            start := c
            p.pos = p.pos + 2
            end := p.source[p.pos]
            p.pos = p.pos + 1
            
            i := start
            while i <= end {
                chars.append(i)
                i = i + 1
            }
        } else {
            chars.append(c)
            p.pos = p.pos + 1
        }
    }
    
    if p.pos >= p.source.len {
        return null  // Unclosed character class
    }
    
    p.pos = p.pos + 1  // Skip ']'
    
    return Node.CharClass(chars: chars, negated: negated)
}

// Parse group (...)
parse_group = (p: *Parser) ?Node {
    p.pos = p.pos + 1  // Skip '('
    
    capture := true
    name := null
    
    // Check for special group types
    if p.pos + 1 < p.source.len and p.source[p.pos] == '?' {
        p.pos = p.pos + 1
        next := p.source[p.pos]
        
        if next == ':' {
            // Non-capturing group
            capture = false
            p.pos = p.pos + 1
        } else if next == '=' {
            // Positive lookahead
            p.pos = p.pos + 1
            nodes := parse_until_close(p) ?? return null
            return Node.Lookahead(nodes: nodes, positive: true)
        } else if next == '!' {
            // Negative lookahead
            p.pos = p.pos + 1
            nodes := parse_until_close(p) ?? return null
            return Node.Lookahead(nodes: nodes, positive: false)
        } else if next == '<' {
            p.pos = p.pos + 1
            if p.pos < p.source.len {
                if p.source[p.pos] == '=' {
                    // Positive lookbehind
                    p.pos = p.pos + 1
                    nodes := parse_until_close(p) ?? return null
                    return Node.Lookbehind(nodes: nodes, positive: true)
                } else if p.source[p.pos] == '!' {
                    // Negative lookbehind
                    p.pos = p.pos + 1
                    nodes := parse_until_close(p) ?? return null
                    return Node.Lookbehind(nodes: nodes, positive: false)
                } else {
                    // Named group (?<name>...)
                    name = parse_group_name(p) ?? return null
                }
            }
        }
    }
    
    nodes := parse_until_close(p) ?? return null
    
    if capture {
        group := CaptureGroup{
            index: p.group_counter
            name: name
            start: 0
            end: 0
        }
        p.groups.append(group)
        p.group_counter = p.group_counter + 1
    }
    
    return Node.Group(nodes: nodes, capture: capture, name: name)
}

// Parse group name
parse_group_name = (p: *Parser) ?core.String {
    name := core.String{}
    
    while p.pos < p.source.len and p.source[p.pos] != '>' {
        name.append(p.source[p.pos])
        p.pos = p.pos + 1
    }
    
    if p.pos >= p.source.len {
        return null
    }
    
    p.pos = p.pos + 1  // Skip '>'
    return name
}

// Parse until closing parenthesis
parse_until_close = (p: *Parser) ?[]Node {
    nodes := []Node{}
    depth := 1
    
    while p.pos < p.source.len and depth > 0 {
        c := p.source[p.pos]
        
        if c == '(' {
            depth = depth + 1
        } else if c == ')' {
            depth = depth - 1
            if depth == 0 {
                p.pos = p.pos + 1
                break
            }
        }
        
        // Parse normally but track depth
        node := parse_single_node(p) ?? return null
        nodes.append(node)
    }
    
    if depth != 0 {
        return null  // Unmatched parenthesis
    }
    
    return nodes
}

// Parse single node (helper)
parse_single_node = (p: *Parser) ?Node {
    if p.pos >= p.source.len {
        return null
    }
    
    c := p.source[p.pos]
    p.pos = p.pos + 1
    
    return switch c {
        '\\' => {
            p.pos = p.pos - 1
            parse_escape(p)
        }
        _ => Node.Literal(char: c)
    }
}

// Parse quantifier
parse_quantifier = (p: *Parser, node: *Node) ?void {
    c := p.source[p.pos]
    p.pos = p.pos + 1
    
    min := 0
    max := null
    
    switch c {
        '*' => {
            min = 0
            max = null
        }
        '+' => {
            min = 1
            max = null
        }
        '?' => {
            min = 0
            max = 1
        }
        '{' => {
            // Parse {n,m} quantifier
            result := parse_counted_quantifier(p) ?? return null
            min = result.0
            max = result.1
        }
    }
    
    // Check for lazy quantifier
    greedy := true
    if p.pos < p.source.len and p.source[p.pos] == '?' {
        greedy = false
        p.pos = p.pos + 1
    }
    
    *node = Node.Quantifier(node: node, min: min, max: max, greedy: greedy)
}

// Parse {n,m} quantifier
parse_counted_quantifier = (p: *Parser) ?(u32, ?u32) {
    min_str := core.String{}
    
    while p.pos < p.source.len and p.source[p.pos] >= '0' and p.source[p.pos] <= '9' {
        min_str.append(p.source[p.pos])
        p.pos = p.pos + 1
    }
    
    if min_str.len == 0 {
        return null
    }
    
    min := string.parse_int(min_str) ?? return null
    
    if p.pos >= p.source.len {
        return null
    }
    
    if p.source[p.pos] == '}' {
        p.pos = p.pos + 1
        return (min, min)  // {n} means exactly n
    }
    
    if p.source[p.pos] != ',' {
        return null
    }
    
    p.pos = p.pos + 1
    
    if p.pos < p.source.len and p.source[p.pos] == '}' {
        p.pos = p.pos + 1
        return (min, null)  // {n,} means n or more
    }
    
    max_str := core.String{}
    while p.pos < p.source.len and p.source[p.pos] >= '0' and p.source[p.pos] <= '9' {
        max_str.append(p.source[p.pos])
        p.pos = p.pos + 1
    }
    
    if p.pos >= p.source.len or p.source[p.pos] != '}' {
        return null
    }
    
    p.pos = p.pos + 1
    max := string.parse_int(max_str) ?? return null
    
    return (min, max)
}

// Character class helpers
digits = () []u8 {
    return ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
}

word_chars = () []u8 {
    chars := []u8{}
    
    // Add a-z
    i := 'a'
    while i <= 'z' {
        chars.append(i)
        i = i + 1
    }
    
    // Add A-Z
    i = 'A'
    while i <= 'Z' {
        chars.append(i)
        i = i + 1
    }
    
    // Add 0-9
    i = '0'
    while i <= '9' {
        chars.append(i)
        i = i + 1
    }
    
    // Add underscore
    chars.append('_')
    
    return chars
}

whitespace = () []u8 {
    return [' ', '\t', '\n', '\r', '\f']
}

// Test if pattern matches string
test = (pattern: *Pattern, text: core.String) bool {
    matcher := Matcher{
        pattern: pattern
        text: text
        pos: 0
        groups: []Group{}
    }
    
    return match_nodes(&matcher, pattern.compiled.nodes, 0)
}

// Find first match
find = (pattern: *Pattern, text: core.String) ?Match {
    start := 0
    
    while start < text.len {
        matcher := Matcher{
            pattern: pattern
            text: text
            pos: start
            groups: []Group{}
        }
        
        if match_nodes(&matcher, pattern.compiled.nodes, start) {
            return Match{
                text: string.substring(text, start, matcher.pos)
                start: start
                end: matcher.pos
                groups: matcher.groups
            }
        }
        
        start = start + 1
    }
    
    return null
}

// Find all matches
find_all = (pattern: *Pattern, text: core.String) []Match {
    matches := []Match{}
    pos := 0
    
    while pos < text.len {
        matcher := Matcher{
            pattern: pattern
            text: text
            pos: pos
            groups: []Group{}
        }
        
        if match_nodes(&matcher, pattern.compiled.nodes, pos) {
            match := Match{
                text: string.substring(text, pos, matcher.pos)
                start: pos
                end: matcher.pos
                groups: matcher.groups
            }
            matches.append(match)
            pos = matcher.pos
            
            if pos == match.start {
                pos = pos + 1  // Avoid infinite loop on zero-width matches
            }
        } else {
            pos = pos + 1
        }
    }
    
    return matches
}

// Replace first match
replace = (pattern: *Pattern, text: core.String, replacement: core.String) core.String {
    match := find(pattern, text) ?? return text
    
    result := core.String{}
    result.append_string(string.substring(text, 0, match.start))
    result.append_string(expand_replacement(replacement, match))
    result.append_string(string.substring(text, match.end, text.len))
    
    return result
}

// Replace all matches
replace_all = (pattern: *Pattern, text: core.String, replacement: core.String) core.String {
    matches := find_all(pattern, text)
    if matches.len == 0 {
        return text
    }
    
    result := core.String{}
    last_end := 0
    
    i := 0
    while i < matches.len {
        match := matches[i]
        result.append_string(string.substring(text, last_end, match.start))
        result.append_string(expand_replacement(replacement, match))
        last_end = match.end
        i = i + 1
    }
    
    result.append_string(string.substring(text, last_end, text.len))
    return result
}

// Expand replacement string with backreferences
expand_replacement = (replacement: core.String, match: Match) core.String {
    result := core.String{}
    i := 0
    
    while i < replacement.len {
        if replacement[i] == '$' and i + 1 < replacement.len {
            next := replacement[i + 1]
            if next >= '0' and next <= '9' {
                group_idx := next - '0'
                if group_idx < match.groups.len {
                    result.append_string(match.groups[group_idx].text)
                }
                i = i + 2
            } else if next == '$' {
                result.append('$')
                i = i + 2
            } else {
                result.append('$')
                i = i + 1
            }
        } else {
            result.append(replacement[i])
            i = i + 1
        }
    }
    
    return result
}

// Split string by pattern
split = (pattern: *Pattern, text: core.String) []core.String {
    parts := []core.String{}
    matches := find_all(pattern, text)
    
    if matches.len == 0 {
        parts.append(text)
        return parts
    }
    
    last_end := 0
    i := 0
    while i < matches.len {
        match := matches[i]
        parts.append(string.substring(text, last_end, match.start))
        last_end = match.end
        i = i + 1
    }
    
    // Add remaining part
    if last_end < text.len {
        parts.append(string.substring(text, last_end, text.len))
    }
    
    return parts
}

// Matcher state
Matcher := struct {
    pattern: *Pattern
    text: core.String
    pos: usize
    groups: []Group
}

// Match nodes at current position
match_nodes = (m: *Matcher, nodes: []Node, start_pos: usize) bool {
    i := 0
    while i < nodes.len {
        if !match_node(m, nodes[i]) {
            return false
        }
        i = i + 1
    }
    return true
}

// Match single node
match_node = (m: *Matcher, node: Node) bool {
    return switch node {
        .Literal(char) => match_literal(m, char)
        .CharClass(chars, negated) => match_char_class(m, chars, negated)
        .Dot => match_dot(m)
        .Start => m.pos == 0
        .End => m.pos == m.text.len
        .WordBoundary => match_word_boundary(m)
        .Group(nodes, capture, name) => match_group(m, nodes, capture, name)
        .Alternative(branches) => match_alternative(m, branches)
        .Quantifier(n, min, max, greedy) => match_quantifier(m, n, min, max, greedy)
        .Backreference(group) => match_backreference(m, group)
        .Lookahead(nodes, positive) => match_lookahead(m, nodes, positive)
        .Lookbehind(nodes, positive) => match_lookbehind(m, nodes, positive)
    }
}

// Match literal character
match_literal = (m: *Matcher, char: u8) bool {
    if m.pos >= m.text.len {
        return false
    }
    
    c := m.text[m.pos]
    if m.pattern.flags.case_insensitive {
        c = to_lower(c)
        char = to_lower(char)
    }
    
    if c == char {
        m.pos = m.pos + 1
        return true
    }
    
    return false
}

// Match character class
match_char_class = (m: *Matcher, chars: []u8, negated: bool) bool {
    if m.pos >= m.text.len {
        return false
    }
    
    c := m.text[m.pos]
    if m.pattern.flags.case_insensitive {
        c = to_lower(c)
    }
    
    found := false
    i := 0
    while i < chars.len {
        test_c := chars[i]
        if m.pattern.flags.case_insensitive {
            test_c = to_lower(test_c)
        }
        if c == test_c {
            found = true
            break
        }
        i = i + 1
    }
    
    if found != negated {
        m.pos = m.pos + 1
        return true
    }
    
    return false
}

// Match dot (any character)
match_dot = (m: *Matcher) bool {
    if m.pos >= m.text.len {
        return false
    }
    
    c := m.text[m.pos]
    if !m.pattern.flags.dot_all and c == '\n' {
        return false
    }
    
    m.pos = m.pos + 1
    return true
}

// Match word boundary
match_word_boundary = (m: *Matcher) bool {
    is_word_before := false
    is_word_after := false
    
    if m.pos > 0 {
        is_word_before = is_word_char(m.text[m.pos - 1])
    }
    
    if m.pos < m.text.len {
        is_word_after = is_word_char(m.text[m.pos])
    }
    
    return is_word_before != is_word_after
}

// Check if character is word character
is_word_char = (c: u8) bool {
    return (c >= 'a' and c <= 'z') or
           (c >= 'A' and c <= 'Z') or
           (c >= '0' and c <= '9') or
           c == '_'
}

// Match group
match_group = (m: *Matcher, nodes: []Node, capture: bool, name: ?core.String) bool {
    start := m.pos
    
    if !match_nodes(m, nodes, start) {
        return false
    }
    
    if capture {
        group := Group{
            text: string.substring(m.text, start, m.pos)
            start: start
            end: m.pos
            name: name
        }
        m.groups.append(group)
    }
    
    return true
}

// Match alternative
match_alternative = (m: *Matcher, branches: [][]Node) bool {
    i := 0
    while i < branches.len {
        saved_pos := m.pos
        saved_groups := m.groups  // Should deep copy
        
        if match_nodes(m, branches[i], saved_pos) {
            return true
        }
        
        m.pos = saved_pos
        m.groups = saved_groups
        i = i + 1
    }
    
    return false
}

// Match quantifier
match_quantifier = (m: *Matcher, node: *Node, min: u32, max: ?u32, greedy: bool) bool {
    count := 0
    positions := []usize{}
    
    // Match minimum required
    while count < min {
        saved_pos := m.pos
        if !match_node(m, *node) {
            return false
        }
        if m.pos == saved_pos {
            // Zero-width match
            if count == 0 {
                return false
            }
            break
        }
        positions.append(m.pos)
        count = count + 1
    }
    
    if greedy {
        // Greedy: match as many as possible
        loop {
            if max != null and count >= max {
                break
            }
            
            saved_pos := m.pos
            if !match_node(m, *node) {
                break
            }
            if m.pos == saved_pos {
                break  // Zero-width match
            }
            positions.append(m.pos)
            count = count + 1
        }
    } else {
        // Lazy: match as few as possible
        // This is simplified - proper implementation would need backtracking
    }
    
    return true
}

// Match backreference
match_backreference = (m: *Matcher, group: u32) bool {
    if group >= m.groups.len {
        return false
    }
    
    group_text := m.groups[group].text
    i := 0
    while i < group_text.len {
        if m.pos >= m.text.len or m.text[m.pos] != group_text[i] {
            return false
        }
        m.pos = m.pos + 1
        i = i + 1
    }
    
    return true
}

// Match lookahead
match_lookahead = (m: *Matcher, nodes: []Node, positive: bool) bool {
    saved_pos := m.pos
    result := match_nodes(m, nodes, saved_pos)
    m.pos = saved_pos  // Restore position (lookahead doesn't consume)
    return result == positive
}

// Match lookbehind
match_lookbehind = (m: *Matcher, nodes: []Node, positive: bool) bool {
    // Simplified - proper lookbehind is complex
    return true
}

// Case conversion helper
to_lower = (c: u8) u8 {
    if c >= 'A' and c <= 'Z' {
        return c + 32
    }
    return c
}