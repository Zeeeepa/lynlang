// Thread and Concurrency Module for Zen
// Provides threading, synchronization, and concurrency primitives

core := @std.core
io := @std.io

// Thread handle
Thread = {
    id: u64,
    handle: *void,
    name: string,
    joinable: bool,
}

// Thread function type
ThreadFunc = *() void

// Mutex for synchronization
Mutex = {
    handle: *void,
    locked: bool,
}

// Read-write lock
RwLock = {
    handle: *void,
    readers: i32,
    writer: bool,
}

// Condition variable
CondVar = {
    handle: *void,
    mutex: &Mutex,
}

// Semaphore
Semaphore = {
    handle: *void,
    count: i32,
    max_count: i32,
}

// Atomic types
Atomic<T> = {
    value: T,
    lock: Mutex,
}

// Thread pool
ThreadPool = {
    threads: []Thread,
    task_queue: Channel<Task>,
    shutdown: Atomic<bool>,
    active_tasks: Atomic<i32>,
}

// Task for thread pool
Task = {
    func: *() void,
    priority: i32,
}

// Channel for message passing
Channel<T> = {
    buffer: []T,
    capacity: usize,
    read_pos: Atomic<usize>,
    write_pos: Atomic<usize>,
    closed: Atomic<bool>,
    readers_waiting: CondVar,
    writers_waiting: CondVar,
    mutex: Mutex,
}

// Thread-local storage
ThreadLocal<T> = {
    key: u64,
    destructor: *(T) void,
}

// Barrier for synchronization
Barrier = {
    count: i32,
    waiting: Atomic<i32>,
    generation: Atomic<i32>,
    mutex: Mutex,
    cond: CondVar,
}

// Create a new thread
spawn = (func: ThreadFunc, name: string) Result<Thread, string> {
    handle := __zen_thread_create(func);
    
    handle == null ? | true => 
        return .Err -> "Failed to create thread"
    
    return .Ok -> Thread {
        id: __zen_thread_id(handle),
        handle: handle,
        name: name,
        joinable: true,
    }
}

// Create thread with parameters
spawn_with<T> = (func: *(T) void, arg: T, name: string) Result<Thread, string> {
    // Create wrapper that captures the argument
    wrapper := () void => func(arg);
    
    return spawn(wrapper, name)
}

// Join a thread
Thread.join = (self: &Thread) Result<void, string> {
    self.joinable ? | false =>
        return .Err -> "Thread is not joinable"
    
    result := __zen_thread_join(self.handle);
    
    result != 0 ? | true =>
        return .Err -> "Failed to join thread"
    
    self.joinable = false;
    return .Ok
}

// Detach a thread
Thread.detach = (self: &Thread) Result<void, string> {
    self.joinable ? | false =>
        return .Err -> "Thread is already detached"
    
    __zen_thread_detach(self.handle);
    self.joinable = false;
    
    return .Ok
}

// Get current thread
current_thread = () Thread {
    return Thread {
        id: __zen_thread_current_id(),
        handle: __zen_thread_current(),
        name: "current",
        joinable: false,
    }
}

// Sleep current thread
sleep = (millis: u64) void {
    __zen_thread_sleep(millis)
}

// Yield current thread
yield = () void {
    __zen_thread_yield()
}

// Get number of hardware threads
hardware_concurrency = () u32 {
    return __zen_thread_hardware_concurrency()
}

// Create a mutex
Mutex.new = () Mutex {
    return Mutex {
        handle: __zen_mutex_create(),
        locked: false,
    }
}

// Lock mutex
Mutex.lock = (self: &Mutex) void {
    __zen_mutex_lock(self.handle);
    self.locked = true
}

// Try to lock mutex
Mutex.try_lock = (self: &Mutex) bool {
    result := __zen_mutex_try_lock(self.handle);
    result ? | true => self.locked = true;
    return result
}

// Unlock mutex
Mutex.unlock = (self: &Mutex) void {
    self.locked = false;
    __zen_mutex_unlock(self.handle)
}

// RAII lock guard
LockGuard = {
    mutex: &Mutex,
}

// Create lock guard (automatically locks)
LockGuard.new = (mutex: &Mutex) LockGuard {
    mutex.lock();
    return LockGuard { mutex: mutex }
}

// Destroy lock guard (automatically unlocks)
LockGuard.drop = (self: &LockGuard) void {
    self.mutex.unlock()
}

// Create read-write lock
RwLock.new = () RwLock {
    return RwLock {
        handle: __zen_rwlock_create(),
        readers: 0,
        writer: false,
    }
}

// Acquire read lock
RwLock.read_lock = (self: &RwLock) void {
    __zen_rwlock_read_lock(self.handle);
    self.readers += 1
}

// Acquire write lock
RwLock.write_lock = (self: &RwLock) void {
    __zen_rwlock_write_lock(self.handle);
    self.writer = true
}

// Release read lock
RwLock.read_unlock = (self: &RwLock) void {
    self.readers -= 1;
    __zen_rwlock_read_unlock(self.handle)
}

// Release write lock
RwLock.write_unlock = (self: &RwLock) void {
    self.writer = false;
    __zen_rwlock_write_unlock(self.handle)
}

// Create condition variable
CondVar.new = (mutex: &Mutex) CondVar {
    return CondVar {
        handle: __zen_condvar_create(),
        mutex: mutex,
    }
}

// Wait on condition variable
CondVar.wait = (self: &CondVar) void {
    __zen_condvar_wait(self.handle, self.mutex.handle)
}

// Wait with timeout
CondVar.wait_timeout = (self: &CondVar, millis: u64) bool {
    return __zen_condvar_wait_timeout(self.handle, self.mutex.handle, millis)
}

// Signal one waiting thread
CondVar.signal = (self: &CondVar) void {
    __zen_condvar_signal(self.handle)
}

// Signal all waiting threads
CondVar.broadcast = (self: &CondVar) void {
    __zen_condvar_broadcast(self.handle)
}

// Create semaphore
Semaphore.new = (initial_count: i32, max_count: i32) Semaphore {
    return Semaphore {
        handle: __zen_semaphore_create(initial_count, max_count),
        count: initial_count,
        max_count: max_count,
    }
}

// Wait on semaphore (decrement)
Semaphore.wait = (self: &Semaphore) void {
    __zen_semaphore_wait(self.handle);
    self.count -= 1
}

// Try wait on semaphore
Semaphore.try_wait = (self: &Semaphore) bool {
    result := __zen_semaphore_try_wait(self.handle);
    result ? | true => self.count -= 1;
    return result
}

// Signal semaphore (increment)
Semaphore.signal = (self: &Semaphore) void {
    self.count < self.max_count ? | true => {
        __zen_semaphore_signal(self.handle);
        self.count += 1
    }
}

// Create atomic value
Atomic.new<T> = (value: T) Atomic<T> {
    return Atomic<T> {
        value: value,
        lock: Mutex.new(),
    }
}

// Load atomic value
Atomic.load<T> = (self: &Atomic<T>) T {
    guard := LockGuard.new(&self.lock);
    value := self.value;
    guard.drop();
    return value
}

// Store atomic value
Atomic.store<T> = (self: &Atomic<T>, value: T) void {
    guard := LockGuard.new(&self.lock);
    self.value = value;
    guard.drop()
}

// Compare and swap
Atomic.compare_exchange<T> = (self: &Atomic<T>, expected: T, desired: T) bool {
    guard := LockGuard.new(&self.lock);
    
    self.value == expected ? | true => {
        self.value = desired;
        guard.drop();
        return true
    }
    
    guard.drop();
    return false
}

// Atomic fetch and add
Atomic.fetch_add = (self: &Atomic<i32>, value: i32) i32 {
    guard := LockGuard.new(&self.lock);
    old := self.value;
    self.value += value;
    guard.drop();
    return old
}

// Create channel
Channel.new<T> = (capacity: usize) Channel<T> {
    return Channel<T> {
        buffer: core.alloc_array<T>(capacity),
        capacity: capacity,
        read_pos: Atomic.new(0),
        write_pos: Atomic.new(0),
        closed: Atomic.new(false),
        readers_waiting: CondVar.new(&mutex),
        writers_waiting: CondVar.new(&mutex),
        mutex: Mutex.new(),
    }
}

// Send value to channel
Channel.send<T> = (self: &Channel<T>, value: T) Result<void, string> {
    guard := LockGuard.new(&self.mutex);
    
    self.closed.load() ? | true => {
        guard.drop();
        return .Err -> "Channel is closed"
    }
    
    // Wait while buffer is full
    loop self.is_full() && !self.closed.load() {
        self.writers_waiting.wait()
    }
    
    self.closed.load() ? | true => {
        guard.drop();
        return .Err -> "Channel is closed"
    }
    
    // Add to buffer
    write_pos := self.write_pos.load();
    self.buffer[write_pos % self.capacity] = value;
    self.write_pos.store((write_pos + 1) % self.capacity);
    
    // Signal waiting readers
    self.readers_waiting.signal();
    
    guard.drop();
    return .Ok
}

// Receive value from channel
Channel.recv<T> = (self: &Channel<T>) Result<T, string> {
    guard := LockGuard.new(&self.mutex);
    
    // Wait while buffer is empty
    loop self.is_empty() && !self.closed.load() {
        self.readers_waiting.wait()
    }
    
    self.is_empty() && self.closed.load() ? | true => {
        guard.drop();
        return .Err -> "Channel is closed and empty"
    }
    
    // Read from buffer
    read_pos := self.read_pos.load();
    value := self.buffer[read_pos % self.capacity];
    self.read_pos.store((read_pos + 1) % self.capacity);
    
    // Signal waiting writers
    self.writers_waiting.signal();
    
    guard.drop();
    return .Ok -> value
}

// Try to receive (non-blocking)
Channel.try_recv<T> = (self: &Channel<T>) Result<T, string> {
    guard := LockGuard.new(&self.mutex);
    
    self.is_empty() ? | true => {
        guard.drop();
        return .Err -> "Channel is empty"
    }
    
    // Read from buffer
    read_pos := self.read_pos.load();
    value := self.buffer[read_pos % self.capacity];
    self.read_pos.store((read_pos + 1) % self.capacity);
    
    // Signal waiting writers
    self.writers_waiting.signal();
    
    guard.drop();
    return .Ok -> value
}

// Close channel
Channel.close<T> = (self: &Channel<T>) void {
    guard := LockGuard.new(&self.mutex);
    self.closed.store(true);
    self.readers_waiting.broadcast();
    self.writers_waiting.broadcast();
    guard.drop()
}

// Check if channel is empty
Channel.is_empty<T> = (self: &Channel<T>) bool {
    return self.read_pos.load() == self.write_pos.load()
}

// Check if channel is full
Channel.is_full<T> = (self: &Channel<T>) bool {
    next_write := (self.write_pos.load() + 1) % self.capacity;
    return next_write == self.read_pos.load()
}

// Create thread pool
ThreadPool.new = (num_threads: usize) ThreadPool {
    pool := ThreadPool {
        threads: [],
        task_queue: Channel.new<Task>(100),
        shutdown: Atomic.new(false),
        active_tasks: Atomic.new(0),
    }
    
    // Spawn worker threads
    i := 0;
    loop i < num_threads {
        thread := spawn(() void => pool.worker(), "worker-$(i)") ?
            | .Ok -> t => t
            | .Err => continue
        
        pool.threads.push(thread);
        i += 1
    }
    
    return pool
}

// Worker thread function
ThreadPool.worker = (self: &ThreadPool) void {
    loop !self.shutdown.load() {
        task := self.task_queue.recv() ?
            | .Ok -> t => t
            | .Err => break
        
        self.active_tasks.fetch_add(1);
        task.func();
        self.active_tasks.fetch_add(-1)
    }
}

// Submit task to thread pool
ThreadPool.submit = (self: &ThreadPool, func: *() void, priority: i32) Result<void, string> {
    self.shutdown.load() ? | true =>
        return .Err -> "Thread pool is shutting down"
    
    task := Task {
        func: func,
        priority: priority,
    }
    
    return self.task_queue.send(task)
}

// Shutdown thread pool
ThreadPool.shutdown = (self: &ThreadPool) void {
    self.shutdown.store(true);
    self.task_queue.close();
    
    // Join all threads
    loop thread in self.threads {
        thread.join()?
    }
}

// Wait for all tasks to complete
ThreadPool.wait = (self: &ThreadPool) void {
    loop self.active_tasks.load() > 0 {
        yield()
    }
}

// Create thread-local storage
ThreadLocal.new<T> = (destructor: *(T) void) ThreadLocal<T> {
    return ThreadLocal<T> {
        key: __zen_tls_create(destructor),
        destructor: destructor,
    }
}

// Get thread-local value
ThreadLocal.get<T> = (self: &ThreadLocal<T>) *T {
    return __zen_tls_get(self.key)
}

// Set thread-local value
ThreadLocal.set<T> = (self: &ThreadLocal<T>, value: *T) void {
    __zen_tls_set(self.key, value)
}

// Create barrier
Barrier.new = (count: i32) Barrier {
    return Barrier {
        count: count,
        waiting: Atomic.new(0),
        generation: Atomic.new(0),
        mutex: Mutex.new(),
        cond: CondVar.new(&mutex),
    }
}

// Wait at barrier
Barrier.wait = (self: &Barrier) bool {
    guard := LockGuard.new(&self.mutex);
    
    gen := self.generation.load();
    waiting := self.waiting.fetch_add(1) + 1;
    
    waiting == self.count ? | true => {
        // Last thread to arrive
        self.generation.store(gen + 1);
        self.waiting.store(0);
        self.cond.broadcast();
        guard.drop();
        return true
    }
    
    // Wait for other threads
    loop self.generation.load() == gen {
        self.cond.wait()
    }
    
    guard.drop();
    return false
}

// Parallel for loop
parallel_for = (start: i32, end: i32, func: *(i32) void) void {
    num_threads := hardware_concurrency();
    pool := ThreadPool.new(num_threads);
    
    chunk_size := (end - start) / num_threads;
    
    i := start;
    loop i < end {
        chunk_start := i;
        chunk_end := min(i + chunk_size, end);
        
        pool.submit(() void => {
            j := chunk_start;
            loop j < chunk_end {
                func(j);
                j += 1
            }
        }, 0)?;
        
        i += chunk_size
    }
    
    pool.wait();
    pool.shutdown()
}

// Parallel map
parallel_map<T, U> = (data: []T, func: *(T) U) []U {
    results := core.alloc_array<U>(data.len);
    mutex := Mutex.new();
    
    parallel_for(0, data.len, (i: i32) void => {
        result := func(data[i]);
        
        guard := LockGuard.new(&mutex);
        results[i] = result;
        guard.drop()
    });
    
    return results
}

// Future for async operations
Future<T> = {
    value: Option<T>,
    error: Option<string>,
    ready: Atomic<bool>,
    cond: CondVar,
    mutex: Mutex,
}

// Create future
Future.new<T> = () Future<T> {
    return Future<T> {
        value: .None,
        error: .None,
        ready: Atomic.new(false),
        cond: CondVar.new(&mutex),
        mutex: Mutex.new(),
    }
}

// Wait for future result
Future.wait<T> = (self: &Future<T>) Result<T, string> {
    guard := LockGuard.new(&self.mutex);
    
    loop !self.ready.load() {
        self.cond.wait()
    }
    
    self.error ?
        | .Some -> err => {
            guard.drop();
            return .Err -> err
        }
    
    self.value ?
        | .Some -> val => {
            guard.drop();
            return .Ok -> val
        }
        | .None => {
            guard.drop();
            return .Err -> "Future has no value"
        }
}

// Set future result
Future.set<T> = (self: &Future<T>, value: T) void {
    guard := LockGuard.new(&self.mutex);
    self.value = .Some -> value;
    self.ready.store(true);
    self.cond.broadcast();
    guard.drop()
}

// Set future error
Future.set_error<T> = (self: &Future<T>, error: string) void {
    guard := LockGuard.new(&self.mutex);
    self.error = .Some -> error;
    self.ready.store(true);
    self.cond.broadcast();
    guard.drop()
}

// Async function helper
async<T> = (func: *() T) Future<T> {
    future := Future.new<T>();
    
    spawn(() void => {
        result := func();
        future.set(result)
    }, "async")?;
    
    return future
}

// External functions (implemented in runtime)
extern __zen_thread_create = (func: *() void) *void
extern __zen_thread_join = (handle: *void) i32
extern __zen_thread_detach = (handle: *void) void
extern __zen_thread_current = () *void
extern __zen_thread_current_id = () u64
extern __zen_thread_id = (handle: *void) u64
extern __zen_thread_sleep = (millis: u64) void
extern __zen_thread_yield = () void
extern __zen_thread_hardware_concurrency = () u32
extern __zen_mutex_create = () *void
extern __zen_mutex_lock = (handle: *void) void
extern __zen_mutex_try_lock = (handle: *void) bool
extern __zen_mutex_unlock = (handle: *void) void
extern __zen_rwlock_create = () *void
extern __zen_rwlock_read_lock = (handle: *void) void
extern __zen_rwlock_write_lock = (handle: *void) void
extern __zen_rwlock_read_unlock = (handle: *void) void
extern __zen_rwlock_write_unlock = (handle: *void) void
extern __zen_condvar_create = () *void
extern __zen_condvar_wait = (handle: *void, mutex: *void) void
extern __zen_condvar_wait_timeout = (handle: *void, mutex: *void, millis: u64) bool
extern __zen_condvar_signal = (handle: *void) void
extern __zen_condvar_broadcast = (handle: *void) void
extern __zen_semaphore_create = (initial: i32, max: i32) *void
extern __zen_semaphore_wait = (handle: *void) void
extern __zen_semaphore_try_wait = (handle: *void) bool
extern __zen_semaphore_signal = (handle: *void) void
extern __zen_tls_create = (destructor: *(*void) void) u64
extern __zen_tls_get = (key: u64) *void
extern __zen_tls_set = (key: u64, value: *void) void