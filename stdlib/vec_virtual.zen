// Dynamic Vector with Virtual Dispatch Allocator Support
// Demonstrates how collections can use trait objects for allocators

{ Option, Result } = @std
{ AllocatorError, Ptr, MutPtr, RawPtr } = @memory_unified
{ AllocatorDyn, get_default_allocator_dyn } = @memory_virtual

// Dynamic vector using virtual dispatch allocator
DynVecVirtual<T> = {
    data: MutPtr<T>
    len: usize
    capacity: usize
    allocator: AllocatorDyn  // Uses trait object instead of concrete type
}

// Create empty vector with virtual allocator
DynVecVirtual<T>.new = (alloc: AllocatorDyn) DynVecVirtual<T> {
    return DynVecVirtual<T> {
        data: @null_ptr(),
        len: 0,
        capacity: 0,
        allocator: alloc
    }
}

// Create with default allocator
DynVecVirtual<T>.new_default = () DynVecVirtual<T> {
    return DynVecVirtual<T>.new(get_default_allocator_dyn())
}

// Create with initial capacity
DynVecVirtual<T>.with_capacity = (alloc: AllocatorDyn, cap: usize) DynVecVirtual<T> {
    (cap == 0) ? {
        return DynVecVirtual<T>.new(alloc)
    }
    
    // Allocate initial buffer using virtual dispatch
    result = alloc.alloc_array<T>(cap)
    result ?
        | Ok(ptr) {
            return DynVecVirtual<T> {
                data: @ptrcast(MutPtr<T>, ptr),
                len: 0,
                capacity: cap,
                allocator: alloc
            }
        }
        | Err(_) {
            // Fall back to empty vector on allocation failure
            return DynVecVirtual<T>.new(alloc)
        }
}

// Push element to vector
DynVecVirtual<T>.push = (self: MutPtr<DynVecVirtual<T>>, value: T) void {
    // Grow if needed
    (self.len >= self.capacity) ? {
        self.grow()
    }
    
    // Add element
    self.data[self.len] = value
    self.len = self.len + 1
}

// Get element by index
DynVecVirtual<T>.get = (self: Ptr<DynVecVirtual<T>>, index: usize) Option<T> {
    (index >= self.len) ? {
        return Option.None
    } : {
        return Option.Some(self.data[index])
    }
}

// Set element by index
DynVecVirtual<T>.set = (self: MutPtr<DynVecVirtual<T>>, index: usize, value: T) bool {
    (index >= self.len) ? {
        return false
    }
    
    self.data[index] = value
    return true
}

// Pop last element
DynVecVirtual<T>.pop = (self: MutPtr<DynVecVirtual<T>>) Option<T> {
    (self.len == 0) ? {
        return Option.None
    }
    
    self.len = self.len - 1
    return Option.Some(self.data[self.len])
}

// Clear all elements
DynVecVirtual<T>.clear = (self: MutPtr<DynVecVirtual<T>>) void {
    self.len = 0
}

// Get current length
DynVecVirtual<T>.len = (self: Ptr<DynVecVirtual<T>>) usize {
    return self.len
}

// Check if empty
DynVecVirtual<T>.is_empty = (self: Ptr<DynVecVirtual<T>>) bool {
    return self.len == 0
}

// Get capacity
DynVecVirtual<T>.capacity = (self: Ptr<DynVecVirtual<T>>) usize {
    return self.capacity
}

// Internal growth function using virtual dispatch
DynVecVirtual<T>.grow = (self: MutPtr<DynVecVirtual<T>>) void {
    new_capacity = (self.capacity == 0) ? 4 : self.capacity * 2
    
    // Allocate new buffer using virtual dispatch
    new_result = self.allocator.alloc_array<T>(new_capacity)
    new_result ?
        | Ok(new_ptr) {
            new_data = @ptrcast(MutPtr<T>, new_ptr)
            
            // Copy existing data
            i = 0
            loop {
                (i >= self.len) ? { break }
                new_data[i] = self.data[i]
                i = i + 1
            }
            
            // Free old buffer using virtual dispatch
            (self.capacity > 0) ? {
                self.allocator.free_array(self.data, self.capacity)
            }
            
            // Update pointers
            self.data = new_data
            self.capacity = new_capacity
        }
        | Err(_) {
            // Allocation failed - can't grow
            // In production, might want to panic or handle differently
        }
}

// Reserve at least n elements of capacity
DynVecVirtual<T>.reserve = (self: MutPtr<DynVecVirtual<T>>, additional: usize) void {
    required = self.len + additional
    (required > self.capacity) ? {
        // Calculate new capacity
        new_capacity = self.capacity
        loop {
            (new_capacity >= required) ? { break }
            new_capacity = (new_capacity == 0) ? 4 : new_capacity * 2
        }
        
        // Allocate new buffer
        new_result = self.allocator.alloc_array<T>(new_capacity)
        new_result ?
            | Ok(new_ptr) {
                new_data = @ptrcast(MutPtr<T>, new_ptr)
                
                // Copy existing data
                i = 0
                loop {
                    (i >= self.len) ? { break }
                    new_data[i] = self.data[i]
                    i = i + 1
                }
                
                // Free old buffer
                (self.capacity > 0) ? {
                    self.allocator.free_array(self.data, self.capacity)
                }
                
                // Update pointers
                self.data = new_data
                self.capacity = new_capacity
            }
            | Err(_) {
                // Allocation failed
            }
    }
}

// Shrink capacity to match length
DynVecVirtual<T>.shrink_to_fit = (self: MutPtr<DynVecVirtual<T>>) void {
    (self.len < self.capacity) ? {
        (self.len == 0) ? {
            // Free everything
            (self.capacity > 0) ? {
                self.allocator.free_array(self.data, self.capacity)
            }
            self.data = @null_ptr()
            self.capacity = 0
        } : {
            // Reallocate to exact size
            new_result = self.allocator.alloc_array<T>(self.len)
            new_result ?
                | Ok(new_ptr) {
                    new_data = @ptrcast(MutPtr<T>, new_ptr)
                    
                    // Copy data
                    i = 0
                    loop {
                        (i >= self.len) ? { break }
                        new_data[i] = self.data[i]
                        i = i + 1
                    }
                    
                    // Free old buffer
                    self.allocator.free_array(self.data, self.capacity)
                    
                    // Update pointers
                    self.data = new_data
                    self.capacity = self.len
                }
                | Err(_) {
                    // Keep current allocation if shrink fails
                }
        }
    }
}

// Insert element at index
DynVecVirtual<T>.insert = (self: MutPtr<DynVecVirtual<T>>, index: usize, value: T) bool {
    (index > self.len) ? {
        return false
    }
    
    // Grow if needed
    (self.len >= self.capacity) ? {
        self.grow()
    }
    
    // Shift elements right
    i = self.len
    loop {
        (i <= index) ? { break }
        self.data[i] = self.data[i - 1]
        i = i - 1
    }
    
    // Insert new element
    self.data[index] = value
    self.len = self.len + 1
    return true
}

// Remove element at index
DynVecVirtual<T>.remove = (self: MutPtr<DynVecVirtual<T>>, index: usize) Option<T> {
    (index >= self.len) ? {
        return Option.None
    }
    
    // Save value
    value = self.data[index]
    
    // Shift elements left
    i = index
    loop {
        (i >= self.len - 1) ? { break }
        self.data[i] = self.data[i + 1]
        i = i + 1
    }
    
    self.len = self.len - 1
    return Option.Some(value)
}

// Destructor - free memory using virtual dispatch
DynVecVirtual<T>.destroy = (self: MutPtr<DynVecVirtual<T>>) void {
    (self.capacity > 0) ? {
        self.allocator.free_array(self.data, self.capacity)
    }
    self.data = @null_ptr()
    self.len = 0
    self.capacity = 0
}