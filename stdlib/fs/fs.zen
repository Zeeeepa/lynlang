// Zen Standard Library: File System Module
// High-level file system operations

core = @std
io = @std

// Import path utilities from dedicated path module
path = @std

// File metadata
FileMetadata: {
    size: i64,
    is_dir: bool,
    is_file: bool,
    is_symlink: bool,
    permissions: i32,
    modified_time: i64,
    created_time: i64,
}

// External functions for file system operations
stat = (path: Ptr<u8>, buf: Ptr<void>) i32 {
    inline.c("""
        return stat(${path.addr}, ${buf.addr});
    """)
}

mkdir = (path: Ptr<u8>, mode: i32) i32 {
    inline.c("""
        return mkdir(${path.addr}, ${mode});
    """)
}

rmdir = (path: Ptr<u8>) i32 {
    inline.c("""
        return rmdir(${path.addr});
    """)
}

unlink = (path: Ptr<u8>) i32 {
    inline.c("""
        return unlink(${path.addr});
    """)
}

rename = (old_path: Ptr<u8>, new_path: Ptr<u8>) i32 {
    inline.c("""
        return rename(${old_path.addr}, ${new_path.addr});
    """)
}

getcwd = (buf: Ptr<u8>, size: i64) Ptr<u8> {
    inline.c("""
        return getcwd(${buf.addr}, ${size});
    """)
}

chdir = (path: Ptr<u8>) i32 {
    inline.c("""
        return chdir(${path.addr});
    """)
}

access = (path: Ptr<u8>, mode: i32) i32 {
    inline.c("""
        return access(${path.addr}, ${mode});
    """)
}

// File access modes for access()
F_OK = 0  // Check existence
R_OK = 4  // Check read permission
W_OK = 2  // Check write permission  
X_OK = 1  // Check execute permission

// Check if file exists
exists = (path: string) bool   {
    access(path, F_OK) == 0 ? 
        | true { true } 
        | false { false }
}

// Check if path is a directory
is_dir = (path: string) bool   {
    // Would use stat() to check S_ISDIR
    // Simplified for now
    false
}

// Check if path is a file
is_file = (path: string) bool   {
    // Would use stat() to check S_ISREG
    // Simplified for now
    exists(path) && !is_dir(path)
}

// Create a directory
create_dir = (path: string) Result<void, string> {
    result := mkdir(path, 0o755)
    result == 0 ? 
        | true { Result.Ok(void) }
        | false { Result.Err("Failed to create directory") }
}

// Create directory and all parent directories
create_dir_all = (path: string) Result<void, string> {
    // Would recursively create parent directories
    create_dir(path)
}

// Remove an empty directory
remove_dir = (path: string) Result<void, string> {
    result := rmdir(path)
    result == 0 ? 
        | true { Result.Ok(void) }
        | false { Result.Err("Failed to remove directory") }
}

// Remove a file
remove_file = (path: string) Result<void, string> {
    result := unlink(path)
    result == 0 ? 
        | true { Result.Ok(void) }
        | false { Result.Err("File not found: ${path}") }
}

// Rename/move a file or directory
rename_path = (from: string, to: string) Result<void, string> {
    result := rename(from, to)
    result == 0 ? 
        | true { Result.Ok(void) }
        | false { Result.Err("Failed to rename") }
}

// Get current working directory
current_dir = () Result<string, string> {
    buffer: Array<u8, 4096>
    result := getcwd(buffer.ptr(), 4096)
    result != null ? 
        | true { Result.Ok(string.from_cstring(result)) }
        | false { Result.Err("Failed to get current directory") }
}

// Change current directory
set_current_dir = (path: string) Result<void, string> {
    result := chdir(path.cstr())
    result == 0 ? 
        | true { Result.Ok(void) }
        | false { Result.Err("Directory not found: ${path}") }
}

// Read entire file to string
read_to_string = (path: string) io.IOResult<string> {
    file := io.open(path, io.FileMode:ReadOnly)?
    defer io.close(file)
    
    // Get file size (would use stat)
    // For now, use a fixed buffer
    buffer: [65536]u8
    bytes_read := io.read(file, Ptr<u8>(buffer[0]), 65536)?
    
    io.IOResult:Ok(string(buffer[0..bytes_read]))
}

// Write string to file
write_string = (path: string, content: string) io.IOResult<void> {
    file := io.open(path, io.FileMode:WriteOnly)?
    defer io.close(file)
    
    io.write(file, content.data, content.len)?
    io.IOResult:Ok({})
}

// Copy file
copy_file = (from: string, to: string) io.IOResult<i64> {
    source := io.open(from, io.FileMode:ReadOnly)?
    defer io.close(source)
    
    dest := io.open(to, io.FileMode:WriteOnly)?
    defer io.close(dest)
    
    buffer: [8192]u8
    total_copied := 0i64
    
    loop {
        bytes_read := io.read(source, Ptr<u8>(buffer[0]), 8192)?
        bytes_read == 0 ? | true { break | false => { }}
        
        io.write(dest, Ptr<u8>(buffer[0]), bytes_read)?
        total_copied = total_copied + bytes_read
    }
    
    io.IOResult:Ok(total_copied)
}

// Directory entry
DirEntry: {
    name: string,
    path: string,
}

// Read directory (simplified - would use opendir/readdir)
read_dir = (path: string) io.IOResult<DynVec<DirEntry>> {
    // Placeholder - would use opendir/readdir/closedir
    io.IOResult:Ok(DynVec<DirEntry>{})
}

// Walk directory tree recursively
walk_dir = (path: string, callback: (DirEntry) void) io.IOResult<void> {
    entries := read_dir(path)?
    
    // TODO: Replace with proper iteration once array iterators are available
    // Would be: array_iter(entries).loop((entry) { callback(entry); ... })
    // For now, using index-based iteration
    i := 0
    loop {

        i < entries.len ? | false { { break  }} | true {}
        entry := entries[i]
        callback(entry)
        is_dir(entry.path) ? | true {
            walk_dir(entry.path, callback)?
        } | false {}
        i = i + 1
    }
    
    io.IOResult:Ok({})
}