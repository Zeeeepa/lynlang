// Zen Standard Library: File System Module
// High-level file system operations

core = @std
io = @std

// Import path utilities from dedicated path module
path = @std

// File metadata
FileMetadata: {
    size: i64,
    is_dir: bool,
    is_file: bool,
    is_symlink: bool,
    permissions: i32,
    modified_time: i64,
    created_time: i64,
}

// External functions for file system operations
stat = (path: *u8, buf: RawPtr<void>) i32 {
    inline.c("""
        return stat(${path.addr}, ${buf.addr});
    """)
}

mkdir = (path: *u8, mode: i32) i32 {
    inline.c("""
        return mkdir(${path.addr}, ${mode});
    """)
}

rmdir = (path: *u8) i32 {
    inline.c("""
        return rmdir(${path.addr});
    """)
}

unlink = (path: *u8) i32 {
    inline.c("""
        return unlink(${path.addr});
    """)
}

rename = (old_path: *u8, new_path: *u8) i32 {
    inline.c("""
        return rename(${old_path.addr}, ${new_path.addr});
    """)
}

getcwd = (buf: *u8, size: i64) *u8 {
    inline.c("""
        return getcwd(${buf.addr}, ${size});
    """)
}

chdir = (path: *u8) i32 {
    inline.c("""
        return chdir(${path.addr});
    """)
}

access = (path: *u8, mode: i32) i32 {
    inline.c("""
        return access(${path.addr}, ${mode});
    """)
}

// File access modes for access()
F_OK : 0  // Check existence
R_OK : 4  // Check read permission
W_OK : 2  // Check write permission
X_OK : 1  // Check execute permission

// Check if file exists
exists = (path: string) bool   {
    access(path, F_OK) == 0 ? | true { true | false => false }
}

// Check if path is a directory
is_dir = (path: string) bool   {
    // Would use stat() to check S_ISDIR
    // Simplified for now
    false
}

// Check if path is a file
is_file = (path: string) bool   {
    // Would use stat() to check S_ISREG
    // Simplified for now
    exists(path) && !is_dir(path)
}

// Create a directory
create_dir = (path: string) io.IOResult<void> {
    result := mkdir(path, 0o755)
    result == 0 ? | true { io.IOResult:Ok({ }})
                 | false { io.IOResult:Err(io.IOError:Other("Failed to create directory")) }
}

// Create directory and all parent directories
create_dir_all = (path: string) io.IOResult<void> {
    // Would recursively create parent directories
    create_dir(path)
}

// Remove an empty directory
remove_dir = (path: string) io.IOResult<void> {
    result := rmdir(path)
    result == 0 ? | true { io.IOResult:Ok({ }})
                 | false { io.IOResult:Err(io.IOError:Other("Failed to remove directory")) }
}

// Remove a file
remove_file = (path: string) io.IOResult<void> {
    result := unlink(path)
    result == 0 ? | true { io.IOResult:Ok({ }})
                 | false { io.IOResult:Err(io.IOError:FileNotFound(path)) }
}

// Rename/move a file or directory
rename_path = (from: string, to: string) io.IOResult<void> {
    result := rename(from, to)
    result == 0 ? | true { io.IOResult:Ok({ }})
                 | false { io.IOResult:Err(io.IOError:Other("Failed to rename")) }
}

// Get current working directory
current_dir = () io.IOResult<string> {
    buffer: [4096]u8
    result := getcwd(&buffer[0], 4096)
    result != 0 ? | true { io.IOResult:Ok(string(buffer)) }
                 | false { io.IOResult:Err(io.IOError:Other("Failed to get current directory")) }
}

// Change current directory
set_current_dir = (path: string) io.IOResult<void> {
    result := chdir(path)
    result == 0 ? | true { io.IOResult:Ok({ }})
                 | false { io.IOResult:Err(io.IOError:FileNotFound(path)) }
}

// Read entire file to string
read_to_string = (path: string) io.IOResult<string> {
    file := io.open(path, io.FileMode:ReadOnly)?
    defer io.close(file)
    
    // Get file size (would use stat)
    // For now, use a fixed buffer
    buffer: [65536]u8
    bytes_read := io.read(file, &buffer[0], 65536)?
    
    io.IOResult:Ok(string(buffer[0..bytes_read]))
}

// Write string to file
write_string = (path: string, content: string) io.IOResult<void> {
    file := io.open(path, io.FileMode:WriteOnly)?
    defer io.close(file)
    
    io.write(file, content.data, content.len)?
    io.IOResult:Ok({})
}

// Copy file
copy_file = (from: string, to: string) io.IOResult<i64> {
    source := io.open(from, io.FileMode:ReadOnly)?
    defer io.close(source)
    
    dest := io.open(to, io.FileMode:WriteOnly)?
    defer io.close(dest)
    
    buffer: [8192]u8
    total_copied := 0i64
    
    loop {
        bytes_read := io.read(source, &buffer[0], 8192)?
        bytes_read == 0 ? | true { break | false => { }}
        
        io.write(dest, &buffer[0], bytes_read)?
        total_copied = total_copied + bytes_read
    }
    
    io.IOResult:Ok(total_copied)
}

// Directory entry
DirEntry: {
    name: string,
    path: string,
}

// Read directory (simplified - would use opendir/readdir)
read_dir = (path: string) io.IOResult<DynVec<DirEntry>> {
    // Placeholder - would use opendir/readdir/closedir
    io.IOResult:Ok(DynVec<DirEntry>{})
}

// Walk directory tree recursively
walk_dir = (path: string, callback: (DirEntry) void) io.IOResult<void> {
    entries := read_dir(path)?
    
    // TODO: Replace with proper iteration once array iterators are available
    // Would be: array_iter(entries).loop((entry) { callback(entry); ... })
    // For now, using index-based iteration
    i := 0
    loop {

        i < entries.len ? | false { { break  }} | true {}
        entry := entries[i]
        callback(entry)
        is_dir(entry.path) ? | true {
            walk_dir(entry.path, callback)?
        } | false {}
        i = i + 1
    }
    
    io.IOResult:Ok({})
}