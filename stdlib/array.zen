// Array utilities for Zen - complements Vec<T,N> and DynVec<T>
// Provides additional array processing functions for fixed arrays

core := @std
vec_module = import("vec")

// Re-export the main vector types for convenience
Vec := vec_module.Vec
DynVec := vec_module.DynVec

// Array processing utilities for fixed arrays [T; N]
// These complement the vector types with additional array-specific functions

// Convert fixed array to Vec
array_to_vec<T, N> = (arr: [T; N]) Vec<T, N> {
    return Vec<T, N>.from_array(arr)
}

// Convert fixed array to DynVec
array_to_dyn_vec<T, N> = (arr: [T; N]) DynVec<T> {
    vec := Vec<T, N>.from_array(arr)
    return vec.to_dynamic()
}

// Array utilities for working with fixed arrays [T; N]
// These work directly on the language's built-in array type

// Find element in fixed array
array_find<T, N> = (arr: [T; N], value: T) core.Option<usize> {
    i ::= 0
    loop {
        i >= N ? { return core.Option:None }
        arr[i] == value ? { return core.Option:Some(i) }
        i = i + 1
    }
    return core.Option:None
}

// Check if array contains element
array_contains<T, N> = (arr: [T; N], value: T) bool {
    result := array_find(arr, value)
    return result ? | Some(_) => true | None => false
}

// Apply function to each element in array
array_for_each<T, N> = (arr: [T; N], f: (T) void) void {
    i ::= 0
    loop {
        i >= N ? { break }
        f(arr[i])
        i = i + 1
    }
}

// Map function over array - returns new array
array_map<T, U, N> = (arr: [T; N], f: (T) U) [U; N] {
    result := [core.default<U>(); N]
    i ::= 0
    loop {
        i >= N ? { break }
        result[i] = f(arr[i])
        i = i + 1
    }
    return result
}

// Filter array to Vec (since filtered result may be smaller)
array_filter<T, N> = (arr: [T; N], predicate: (T) bool) DynVec<T> {
    result := DynVec<T>.new()
    i ::= 0
    loop {
        i >= N ? { break }
        predicate(arr[i]) ? {
            result.push(arr[i])
        }
        i = i + 1
    }
    return result
}

// Reduce array to single value
array_reduce<T, U, N> = (arr: [T; N], initial: U, f: (U, T) U) U {
    acc ::= initial
    i ::= 0
    loop {
        i >= N ? { break }
        acc = f(acc, arr[i])
        i = i + 1
    }
    return acc
}

// Reverse array in place
array_reverse<T, N> = (arr: *[T; N]) void {
    N <= 1 ? { return }
    
    left ::= 0
    right ::= N - 1
    
    loop {
        left >= right ? { break }
        temp := arr[left]
        arr[left] = arr[right] 
        arr[right] = temp
        left = left + 1
        right = right - 1
    }
}

// Sort array using quicksort
array_sort<T, N> = (arr: *[T; N], compare: (T, T) i32) void {
    N <= 1 ? { return }
    array_quicksort(arr, 0, N - 1, compare)
}

// Quicksort implementation (internal)
array_quicksort<T, N> = (arr: *[T; N], low: usize, high: usize, compare: (T, T) i32) void {
    low >= high ? { return }
    
    pivot_index := array_partition(arr, low, high, compare)
    pivot_index > 0 ? {
        array_quicksort(arr, low, pivot_index - 1, compare)
    }
    array_quicksort(arr, pivot_index + 1, high, compare)
}

// Partition for quicksort (internal)
array_partition<T, N> = (arr: *[T; N], low: usize, high: usize, compare: (T, T) i32) usize {
    pivot := arr[high]
    i ::= low
    
    j ::= low
    loop {
        j >= high ? { break }
        compare(arr[j], pivot) <= 0 ? {
            temp := arr[i]
            arr[i] = arr[j]
            arr[j] = temp
            i = i + 1
        }
        j = j + 1
    }
    
    temp := arr[i]
    arr[i] = arr[high]
    arr[high] = temp
    
    return i
}

// Binary search (array must be sorted)
array_binary_search<T, N> = (arr: [T; N], value: T, compare: (T, T) i32) core.Option<usize> {
    N == 0 ? { return core.Option:None }
    
    left ::= 0
    right ::= N - 1
    
    loop {
        left > right ? { break }
        mid := left + (right - left) / 2
        cmp := compare(arr[mid], value)
        
        cmp == 0 ? { return core.Option:Some(mid) }
        cmp < 0 ? { left = mid + 1 }
        : { right = mid - 1 }
    }
    
    return core.Option:None
}

// Copy array to another array
array_copy<T, N> = (src: [T; N], dest: *[T; N]) void {
    i ::= 0
    loop {
        i >= N ? { break }
        dest[i] = src[i]
        i = i + 1
    }
}

// Fill array with value
array_fill<T, N> = (arr: *[T; N], value: T) void {
    i ::= 0
    loop {
        i >= N ? { break }
        arr[i] = value
        i = i + 1
    }
}

// Check if two arrays are equal
array_equal<T, N> = (a: [T; N], b: [T; N]) bool {
    i ::= 0
    loop {
        i >= N ? { break }
        a[i] != b[i] ? { return false }
        i = i + 1
    }
    return true
}

// Export utility functions and vector types
module.exports = { 
    Vec, DynVec,
    array_to_vec, array_to_dyn_vec,
    array_find, array_contains, array_for_each,
    array_map, array_filter, array_reduce,
    array_reverse, array_sort, array_binary_search,
    array_copy, array_fill, array_equal
}
