// Zen Standard Library: Enhanced Process Module
// Process management and system interaction for self-hosting

core := @std.core
string := @std.string
vec := @std.vec
result := @std.result
io := @std.io
fs := @std.fs

// External C functions for process management
extern fork = () i32
extern execve = (path: *i8, argv: **i8, envp: **i8) i32
extern execvp = (file: *i8, argv: **i8) i32
extern wait = (status: *i32) i32
extern waitpid = (pid: i32, status: *i32, options: i32) i32
extern getpid = () i32
extern getppid = () i32
extern exit = (status: i32) void
extern _exit = (status: i32) void
extern system = (command: *i8) i32
extern pipe = (pipefd: *i32) i32
extern dup2 = (oldfd: i32, newfd: i32) i32
extern close = (fd: i32) i32
extern read = (fd: i32, buf: *i8, count: u64) i64
extern write = (fd: i32, buf: *i8, count: u64) i64
extern kill = (pid: i32, sig: i32) i32
extern signal = (sig: i32, handler: (*void) void) (*void) void
extern getenv = (name: *i8) *i8
extern setenv = (name: *i8, value: *i8, overwrite: i32) i32
extern unsetenv = (name: *i8) i32
extern getcwd = (buf: *i8, size: u64) *i8
extern chdir = (path: *i8) i32
extern sysconf = (name: i32) i64

// Process wait options
WNOHANG := 1
WUNTRACED := 2
WCONTINUED := 8

// Standard file descriptors
STDIN_FD := 0
STDOUT_FD := 1
STDERR_FD := 2

// Signal numbers
SIGHUP := 1
SIGINT := 2
SIGQUIT := 3
SIGILL := 4
SIGABRT := 6
SIGFPE := 8
SIGKILL := 9
SIGSEGV := 11
SIGPIPE := 13
SIGALRM := 14
SIGTERM := 15
SIGUSR1 := 10
SIGUSR2 := 12
SIGCHLD := 17
SIGCONT := 18
SIGSTOP := 19
SIGTSTP := 20

// System configuration names
_SC_ARG_MAX := 0
_SC_CHILD_MAX := 1
_SC_CLK_TCK := 2
_SC_NGROUPS_MAX := 3
_SC_OPEN_MAX := 4
_SC_PAGESIZE := 30
_SC_NPROCESSORS_ONLN := 84

// Exit codes
EXIT_SUCCESS := 0
EXIT_FAILURE := 1

// Process ID type
Pid = i32

// Process exit status
ExitStatus = struct {
    code: i32
    success: bool
    signal: Option<i32>
}

// Process handle
Process = struct {
    pid: Pid
    stdin: Option<i32>
    stdout: Option<i32>
    stderr: Option<i32>
    status: Option<ExitStatus>
}

// Command builder
Command = struct {
    program: string
    args: Vec<string>
    env: Vec<(string, string)>
    working_dir: Option<string>
    stdin: Option<string>
    stdout_capture: bool
    stderr_capture: bool
}

// Process output
Output = struct {
    status: ExitStatus
    stdout: string
    stderr: string
}

// Environment variable iterator
EnvVars = struct {
    vars: Vec<(string, string)>
    index: u64
}

// Get current process ID
id = () Pid {
    return getpid()
}

// Get parent process ID
parent_id = () Pid {
    return getppid()
}

// Exit the current process
exit_process = (code: i32) void {
    exit(code)
}

// Exit immediately without cleanup
abort = () void {
    _exit(EXIT_FAILURE)
}

// Create a new command
command = (program: string) Command {
    return Command {
        program: program
        args: vec.new<string>()
        env: vec.new<(string, string)>()
        working_dir: none
        stdin: none
        stdout_capture: false
        stderr_capture: false
    }
}

// Add argument to command
arg = (cmd: *Command, arg: string) *Command {
    cmd.args.push(arg)
    return cmd
}

// Add multiple arguments to command
args = (cmd: *Command, args: Vec<string>) *Command {
    for a in args {
        cmd.args.push(a)
    }
    return cmd
}

// Set environment variable for command
env_var = (cmd: *Command, key: string, value: string) *Command {
    cmd.env.push((key, value))
    return cmd
}

// Set working directory for command
current_dir = (cmd: *Command, dir: string) *Command {
    cmd.working_dir = some(dir)
    return cmd
}

// Set stdin for command
stdin = (cmd: *Command, input: string) *Command {
    cmd.stdin = some(input)
    return cmd
}

// Capture stdout
stdout = (cmd: *Command) *Command {
    cmd.stdout_capture = true
    return cmd
}

// Capture stderr
stderr = (cmd: *Command) *Command {
    cmd.stderr_capture = true
    return cmd
}

// Execute command and wait for completion
output = (cmd: *Command) Result<Output> {
    // Create pipes for capturing output
    stdout_pipe := [2]i32{}
    stderr_pipe := [2]i32{}
    stdin_pipe := [2]i32{}
    
    if cmd.stdout_capture {
        if pipe(&stdout_pipe[0]) != 0 {
            return Result.Err("Failed to create stdout pipe")
        }
    }
    
    if cmd.stderr_capture {
        if pipe(&stderr_pipe[0]) != 0 {
            return Result.Err("Failed to create stderr pipe")
        }
    }
    
    if cmd.stdin.is_some() {
        if pipe(&stdin_pipe[0]) != 0 {
            return Result.Err("Failed to create stdin pipe")
        }
    }
    
    // Fork process
    pid := fork()
    
    if pid < 0 {
        return Result.Err("Failed to fork process")
    }
    
    if pid == 0 {
        // Child process
        
        // Set up stdin
        if cmd.stdin.is_some() {
            dup2(stdin_pipe[0], STDIN_FD)
            close(stdin_pipe[0])
            close(stdin_pipe[1])
        }
        
        // Set up stdout
        if cmd.stdout_capture {
            dup2(stdout_pipe[1], STDOUT_FD)
            close(stdout_pipe[0])
            close(stdout_pipe[1])
        }
        
        // Set up stderr
        if cmd.stderr_capture {
            dup2(stderr_pipe[1], STDERR_FD)
            close(stderr_pipe[0])
            close(stderr_pipe[1])
        }
        
        // Change working directory if specified
        if let some(dir) = cmd.working_dir {
            chdir(string.to_cstring(dir))
        }
        
        // Set environment variables
        for (key, value) in cmd.env {
            setenv(string.to_cstring(key), string.to_cstring(value), 1)
        }
        
        // Build argv array
        argv := vec.with_capacity<*i8>(cmd.args.len() + 2)
        argv.push(string.to_cstring(cmd.program))
        for arg in cmd.args {
            argv.push(string.to_cstring(arg))
        }
        argv.push(null)
        
        // Execute program
        execvp(string.to_cstring(cmd.program), argv.data())
        
        // If we get here, exec failed
        _exit(127)
    }
    
    // Parent process
    
    // Close unused pipe ends
    if cmd.stdout_capture {
        close(stdout_pipe[1])
    }
    if cmd.stderr_capture {
        close(stderr_pipe[1])
    }
    if cmd.stdin.is_some() {
        close(stdin_pipe[0])
        
        // Write stdin data
        if let some(input) = cmd.stdin {
            input_cstr := string.to_cstring(input)
            write(stdin_pipe[1], input_cstr, string.len(input))
            close(stdin_pipe[1])
        }
    }
    
    // Read output
    stdout_str := ""
    stderr_str := ""
    
    if cmd.stdout_capture {
        stdout_str = read_fd_to_string(stdout_pipe[0])
        close(stdout_pipe[0])
    }
    
    if cmd.stderr_capture {
        stderr_str = read_fd_to_string(stderr_pipe[0])
        close(stderr_pipe[0])
    }
    
    // Wait for child process
    status := 0
    waitpid(pid, &status, 0)
    
    // Parse exit status
    exit_status := parse_wait_status(status)
    
    return Result.Ok(Output {
        status: exit_status
        stdout: stdout_str
        stderr: stderr_str
    })
}

// Spawn a process without waiting
spawn = (cmd: *Command) Result<Process> {
    // Create pipes if needed
    stdin_pipe := [2]i32{}
    stdout_pipe := [2]i32{}
    stderr_pipe := [2]i32{}
    
    has_stdin := cmd.stdin.is_some()
    has_stdout := cmd.stdout_capture
    has_stderr := cmd.stderr_capture
    
    if has_stdin {
        if pipe(&stdin_pipe[0]) != 0 {
            return Result.Err("Failed to create stdin pipe")
        }
    }
    
    if has_stdout {
        if pipe(&stdout_pipe[0]) != 0 {
            return Result.Err("Failed to create stdout pipe")
        }
    }
    
    if has_stderr {
        if pipe(&stderr_pipe[0]) != 0 {
            return Result.Err("Failed to create stderr pipe")
        }
    }
    
    // Fork process
    pid := fork()
    
    if pid < 0 {
        return Result.Err("Failed to fork process")
    }
    
    if pid == 0 {
        // Child process setup (similar to output function)
        // ... (implementation similar to above)
        
        // Execute program
        argv := build_argv(cmd)
        execvp(string.to_cstring(cmd.program), argv.data())
        _exit(127)
    }
    
    // Parent process
    return Result.Ok(Process {
        pid: pid
        stdin: if has_stdin { some(stdin_pipe[1]) } else { none }
        stdout: if has_stdout { some(stdout_pipe[0]) } else { none }
        stderr: if has_stderr { some(stderr_pipe[0]) } else { none }
        status: none
    })
}

// Wait for a process to finish
wait_process = (proc: *Process) Result<ExitStatus> {
    if proc.status.is_some() {
        return Result.Ok(proc.status.unwrap())
    }
    
    status := 0
    result := waitpid(proc.pid, &status, 0)
    
    if result < 0 {
        return Result.Err("Failed to wait for process")
    }
    
    exit_status := parse_wait_status(status)
    proc.status = some(exit_status)
    
    return Result.Ok(exit_status)
}

// Try to wait for a process (non-blocking)
try_wait = (proc: *Process) Result<Option<ExitStatus>> {
    if proc.status.is_some() {
        return Result.Ok(some(proc.status.unwrap()))
    }
    
    status := 0
    result := waitpid(proc.pid, &status, WNOHANG)
    
    if result < 0 {
        return Result.Err("Failed to wait for process")
    }
    
    if result == 0 {
        return Result.Ok(none)
    }
    
    exit_status := parse_wait_status(status)
    proc.status = some(exit_status)
    
    return Result.Ok(some(exit_status))
}

// Kill a process
kill_process = (proc: *Process) Result<void> {
    if kill(proc.pid, SIGKILL) != 0 {
        return Result.Err("Failed to kill process")
    }
    return Result.Ok({})
}

// Send signal to process
signal_process = (proc: *Process, sig: i32) Result<void> {
    if kill(proc.pid, sig) != 0 {
        return Result.Err("Failed to send signal")
    }
    return Result.Ok({})
}

// Get environment variable
env = (name: string) Option<string> {
    value := getenv(string.to_cstring(name))
    if value == null {
        return none
    }
    return some(string.from_cstring(value))
}

// Set environment variable
set_env = (name: string, value: string) Result<void> {
    if setenv(string.to_cstring(name), string.to_cstring(value), 1) != 0 {
        return Result.Err("Failed to set environment variable")
    }
    return Result.Ok({})
}

// Remove environment variable
remove_env = (name: string) Result<void> {
    if unsetenv(string.to_cstring(name)) != 0 {
        return Result.Err("Failed to remove environment variable")
    }
    return Result.Ok({})
}

// Get all environment variables
vars = () EnvVars {
    vars := vec.new<(string, string)>()
    
    // Parse environ array (would need extern environ declaration)
    // For now, return empty
    
    return EnvVars {
        vars: vars
        index: 0
    }
}

// Get current working directory
current_working_dir = () Result<string> {
    buffer := [4096]i8{}
    result := getcwd(&buffer[0], 4096)
    
    if result == null {
        return Result.Err("Failed to get current directory")
    }
    
    return Result.Ok(string.from_cstring(&buffer[0]))
}

// Set current working directory
set_current_dir = (path: string) Result<void> {
    if chdir(string.to_cstring(path)) != 0 {
        return Result.Err("Failed to change directory")
    }
    return Result.Ok({})
}

// Get system page size
page_size = () u64 {
    return sysconf(_SC_PAGESIZE)
}

// Get number of processors
num_cpus = () u64 {
    return sysconf(_SC_NPROCESSORS_ONLN)
}

// Get maximum argument length
arg_max = () u64 {
    return sysconf(_SC_ARG_MAX)
}

// Get maximum number of open files
open_max = () u64 {
    return sysconf(_SC_OPEN_MAX)
}

// Helper: Parse wait status
parse_wait_status = (status: i32) ExitStatus {
    // Check if exited normally
    if (status & 0x7f) == 0 {
        code := (status >> 8) & 0xff
        return ExitStatus {
            code: code
            success: code == 0
            signal: none
        }
    }
    
    // Check if terminated by signal
    if ((status & 0x7f) + 1) >> 1 > 0 {
        sig := status & 0x7f
        return ExitStatus {
            code: -1
            success: false
            signal: some(sig)
        }
    }
    
    return ExitStatus {
        code: -1
        success: false
        signal: none
    }
}

// Helper: Read file descriptor to string
read_fd_to_string = (fd: i32) string {
    buffer := [4096]i8{}
    result := ""
    
    loop {
        bytes_read := read(fd, &buffer[0], 4096)
        if bytes_read <= 0 {
            break
        }
        
        // Convert to string and append
        chunk := string.from_bytes(&buffer[0], bytes_read)
        result = string.concat(result, chunk)
    }
    
    return result
}

// Helper: Build argv array
build_argv = (cmd: *Command) Vec<*i8> {
    argv := vec.with_capacity<*i8>(cmd.args.len() + 2)
    argv.push(string.to_cstring(cmd.program))
    
    for arg in cmd.args {
        argv.push(string.to_cstring(arg))
    }
    
    argv.push(null)
    return argv
}

// Execute a shell command
shell = (command: string) Result<Output> {
    return command("sh")
        .arg("-c")
        .arg(command)
        .stdout()
        .stderr()
        .output()
}

// Check if a command exists in PATH
command_exists = (name: string) bool {
    result := command("which")
        .arg(name)
        .stdout()
        .output()
    
    if result.is_err() {
        return false
    }
    
    return result.unwrap().status.success
}