// type_checker_enhanced.zen - Enhanced type checking with better error messages
// Advanced type inference and validation for Zen

core := @std.core
string := @std.string
io := @std.io
vec := @std.vec
hashmap := @std.hashmap
ast := @std.ast

// Type kinds
TypeKind = enum {
    Primitive(name: string)           // i32, f64, bool, etc.
    Struct(fields: Vec<Field>)        // struct types
    Enum(variants: Vec<Variant>)      // enum types
    Array(element: Type, size: u32)   // fixed-size arrays
    Slice(element: Type)              // dynamic slices
    Pointer(pointee: Type)            // pointer types
    Function(params: Vec<Type>, ret: Type)  // function types
    Generic(name: string, constraints: Vec<Constraint>)  // generic types
    Alias(name: string, actual: Type) // type aliases
    Unknown                            // unresolved type
    Never                             // bottom type (unreachable)
}

// Type representation
Type = struct {
    kind: TypeKind
    mutable: bool
    nullable: bool
    location: ast.SourceLocation
}

// Struct field
Field = struct {
    name: string
    type: Type
    mutable: bool
    default: Option<ast.Expression>
}

// Enum variant
Variant = struct {
    name: string
    payload: Option<Type>
}

// Type constraint for generics
Constraint = enum {
    Implements(behavior: string)
    Extends(base: Type)
    Comparable
    Numeric
    Hashable
}

// Type environment for scoping
TypeEnv = struct {
    parent: Option<*TypeEnv>
    bindings: HashMap<string, Type>
    generics: HashMap<string, Type>
    type_aliases: HashMap<string, Type>
}

// Type checking context
TypeContext = struct {
    env: TypeEnv
    errors: Vec<TypeError>
    warnings: Vec<TypeWarning>
    inferred_types: HashMap<ast.NodeId, Type>
    return_type: Option<Type>
    in_loop: bool
    in_comptime: bool
}

// Type error with detailed information
TypeError = struct {
    kind: TypeErrorKind
    message: string
    expected: Option<Type>
    actual: Option<Type>
    location: ast.SourceLocation
    notes: Vec<string>
    suggestion: Option<string>
}

// Type error kinds
TypeErrorKind = enum {
    TypeMismatch
    UnknownIdentifier
    UnknownType
    InvalidOperation
    MissingField
    ExtraField
    ImmutableAssignment
    InvalidCast
    GenericConstraintViolation
    RecursiveType
    AmbiguousType
}

// Type warning
TypeWarning = struct {
    kind: TypeWarningKind
    message: string
    location: ast.SourceLocation
}

// Type warning kinds
TypeWarningKind = enum {
    UnusedVariable
    UnusedImport
    UnreachableCode
    DeprecatedFeature
    ImplicitConversion
}

// Create a new type environment
new_env = (parent: Option<*TypeEnv>) TypeEnv {
    return TypeEnv {
        parent: parent
        bindings: hashmap.new<string, Type>()
        generics: hashmap.new<string, Type>()
        type_aliases: hashmap.new<string, Type>()
    }
}

// Create a new type context
new_context = () TypeContext {
    return TypeContext {
        env: new_env(none)
        errors: vec.new<TypeError>()
        warnings: vec.new<TypeWarning>()
        inferred_types: hashmap.new<ast.NodeId, Type>()
        return_type: none
        in_loop: false
        in_comptime: false
    }
}

// Look up a type in the environment
lookup_type = (env: *TypeEnv, name: string) Option<Type> {
    // Check current scope
    result := env.bindings.get(name)
    result ? | .Some -> _ => return result
             | .None => {}
    
    // Check parent scope
    env.parent ? | .Some -> parent => return lookup_type(parent, name)
                 | .None => return none
}

// Add a type binding to the environment
bind_type = (env: *TypeEnv, name: string, type: Type) void {
    env.bindings.insert(name, type)
}

// Check if two types are equal
types_equal = (a: Type, b: Type) bool {
    a.kind ? 
        | .Primitive -> name_a => {
            b.kind ? | .Primitive -> name_b => name_a == name_b
                    | _ => false
        }
        | .Array -> (elem_a, size_a) => {
            b.kind ? | .Array -> (elem_b, size_b) => 
                        size_a == size_b && types_equal(elem_a, elem_b)
                    | _ => false
        }
        | .Slice -> elem_a => {
            b.kind ? | .Slice -> elem_b => types_equal(elem_a, elem_b)
                    | _ => false
        }
        | .Pointer -> pointee_a => {
            b.kind ? | .Pointer -> pointee_b => types_equal(pointee_a, pointee_b)
                    | _ => false
        }
        | .Function -> (params_a, ret_a) => {
            b.kind ? | .Function -> (params_b, ret_b) => {
                params_a.len() == params_b.len() && 
                all_types_equal(params_a, params_b) &&
                types_equal(ret_a, ret_b)
            }
                    | _ => false
        }
        | _ => false  // TODO: Handle other type kinds
}

// Check if all types in two lists are equal
all_types_equal = (a: Vec<Type>, b: Vec<Type>) bool {
    a.len() != b.len() ? | true => return false
                        | false => {}
    
    i ::= 0
    loop i < a.len() {
        !types_equal(a.get(i), b.get(i)) ? | true => return false
                                           | false => {}
        i = i + 1
    }
    return true
}

// Check if a type is assignable to another
is_assignable = (from: Type, to: Type) bool {
    // Same types are always assignable
    types_equal(from, to) ? | true => return true
                           | false => {}
    
    // Check for implicit conversions
    from.kind ? 
        | .Primitive -> from_name => {
            to.kind ? | .Primitive -> to_name => {
                // Numeric widening conversions
                is_numeric_widening(from_name, to_name)
            }
                     | _ => false
        }
        | _ => false
}

// Check if a numeric type can be widened to another
is_numeric_widening = (from: string, to: string) bool {
    // i8 -> i16 -> i32 -> i64
    // u8 -> u16 -> u32 -> u64
    // f32 -> f64
    
    from == "i8" && (to == "i16" || to == "i32" || to == "i64") ? | true => true
    | false => from == "i16" && (to == "i32" || to == "i64") ? | true => true
    | false => from == "i32" && to == "i64" ? | true => true
    | false => from == "u8" && (to == "u16" || to == "u32" || to == "u64") ? | true => true
    | false => from == "u16" && (to == "u32" || to == "u64") ? | true => true
    | false => from == "u32" && to == "u64" ? | true => true
    | false => from == "f32" && to == "f64" ? | true => true
    | false => false
}

// Infer the type of an expression
infer_type = (ctx: *TypeContext, expr: ast.Expression) Type {
    expr.kind ?
        | .Literal -> lit => infer_literal_type(lit)
        | .Identifier -> name => {
            lookup_type(&ctx.env, name) ? 
                | .Some -> type => type
                | .None => {
                    add_error(ctx, TypeErrorKind.UnknownIdentifier,
                             string.format("Unknown identifier: {}", name),
                             none, none, expr.location)
                    unknown_type()
                }
        }
        | .Binary -> (left, op, right) => {
            left_type := infer_type(ctx, left)
            right_type := infer_type(ctx, right)
            infer_binary_type(ctx, left_type, op, right_type, expr.location)
        }
        | .Unary -> (op, operand) => {
            operand_type := infer_type(ctx, operand)
            infer_unary_type(ctx, op, operand_type, expr.location)
        }
        | .Call -> (func, args) => {
            func_type := infer_type(ctx, func)
            arg_types := vec.map(args, (arg) Type { infer_type(ctx, arg) })
            infer_call_type(ctx, func_type, arg_types, expr.location)
        }
        | .FieldAccess -> (object, field) => {
            object_type := infer_type(ctx, object)
            infer_field_type(ctx, object_type, field, expr.location)
        }
        | .ArrayLiteral -> elements => {
            elements.len() == 0 ? | true => {
                // Empty array needs type annotation
                add_error(ctx, TypeErrorKind.AmbiguousType,
                         "Cannot infer type of empty array literal",
                         none, none, expr.location)
                unknown_type()
            } | false => {
                // Infer from first element
                elem_type := infer_type(ctx, elements.get(0))
                
                // Check all elements have same type
                i ::= 1
                loop i < elements.len() {
                    elem := elements.get(i)
                    elem_type_i := infer_type(ctx, elem)
                    !types_equal(elem_type, elem_type_i) ? | true => {
                        add_error(ctx, TypeErrorKind.TypeMismatch,
                                 "Array elements must have same type",
                                 some(elem_type), some(elem_type_i), elem.location)
                    } | false => {}
                    i = i + 1
                }
                
                array_type(elem_type, elements.len())
            }
        }
        | _ => unknown_type()  // TODO: Handle other expression kinds
}

// Infer type of a literal
infer_literal_type = (lit: ast.Literal) Type {
    lit ?
        | .Integer -> _ => primitive_type("i32")
        | .Float -> _ => primitive_type("f64")
        | .String -> _ => primitive_type("string")
        | .Bool -> _ => primitive_type("bool")
        | .Char -> _ => primitive_type("char")
}

// Infer type of binary operation
infer_binary_type = (ctx: *TypeContext, left: Type, op: ast.BinaryOp, 
                     right: Type, loc: ast.SourceLocation) Type {
    op ?
        | .Add | .Sub | .Mul | .Div | .Mod => {
            // Arithmetic operations
            is_numeric(left) && is_numeric(right) ? | true => {
                // Result is the wider type
                promote_numeric_types(left, right)
            } | false => {
                add_error(ctx, TypeErrorKind.InvalidOperation,
                         string.format("Cannot apply {} to non-numeric types", op),
                         some(left), some(right), loc)
                unknown_type()
            }
        }
        | .Equal | .NotEqual => {
            // Equality comparison
            types_equal(left, right) || is_assignable(left, right) ? 
                | true => primitive_type("bool")
                | false => {
                    add_error(ctx, TypeErrorKind.TypeMismatch,
                             "Cannot compare incompatible types",
                             some(left), some(right), loc)
                    primitive_type("bool")
                }
        }
        | .Less | .Greater | .LessEqual | .GreaterEqual => {
            // Ordering comparison
            is_comparable(left) && types_equal(left, right) ?
                | true => primitive_type("bool")
                | false => {
                    add_error(ctx, TypeErrorKind.InvalidOperation,
                             "Cannot compare non-comparable types",
                             some(left), some(right), loc)
                    primitive_type("bool")
                }
        }
        | .And | .Or => {
            // Logical operations
            is_bool(left) && is_bool(right) ?
                | true => primitive_type("bool")
                | false => {
                    add_error(ctx, TypeErrorKind.TypeMismatch,
                             "Logical operations require boolean operands",
                             some(primitive_type("bool")), 
                             !is_bool(left) ? some(left) : some(right), loc)
                    primitive_type("bool")
                }
        }
        | _ => unknown_type()
}

// Check if type is numeric
is_numeric = (t: Type) bool {
    t.kind ? | .Primitive -> name => {
        name == "i8" || name == "i16" || name == "i32" || name == "i64" ||
        name == "u8" || name == "u16" || name == "u32" || name == "u64" ||
        name == "f32" || name == "f64"
    }
            | _ => false
}

// Check if type is boolean
is_bool = (t: Type) bool {
    t.kind ? | .Primitive -> name => name == "bool"
            | _ => false
}

// Check if type is comparable
is_comparable = (t: Type) bool {
    is_numeric(t) || t.kind ? 
        | .Primitive -> name => name == "string" || name == "char" || name == "bool"
        | _ => false
}

// Promote numeric types to wider type
promote_numeric_types = (a: Type, b: Type) Type {
    // If same type, return it
    types_equal(a, b) ? | true => return a
                       | false => {}
    
    // Get numeric ranks
    rank_a := numeric_rank(a)
    rank_b := numeric_rank(b)
    
    rank_a >= rank_b ? | true => a
                       | false => b
}

// Get numeric type rank for promotion
numeric_rank = (t: Type) i32 {
    t.kind ? | .Primitive -> name => {
        name == "i8" ? 1 :
        name == "u8" ? 2 :
        name == "i16" ? 3 :
        name == "u16" ? 4 :
        name == "i32" ? 5 :
        name == "u32" ? 6 :
        name == "f32" ? 7 :
        name == "i64" ? 8 :
        name == "u64" ? 9 :
        name == "f64" ? 10 : 0
    }
            | _ => 0
}

// Add an error to the context
add_error = (ctx: *TypeContext, kind: TypeErrorKind, message: string,
            expected: Option<Type>, actual: Option<Type>, 
            location: ast.SourceLocation) void {
    error := TypeError {
        kind: kind
        message: message
        expected: expected
        actual: actual
        location: location
        notes: vec.new<string>()
        suggestion: none
    }
    
    // Add helpful suggestions based on error kind
    error.suggestion = suggest_fix(kind, expected, actual)
    
    ctx.errors.push(error)
}

// Suggest a fix for common type errors
suggest_fix = (kind: TypeErrorKind, expected: Option<Type>, 
              actual: Option<Type>) Option<string> {
    kind ?
        | .TypeMismatch => {
            expected ? | .Some -> exp => {
                actual ? | .Some -> act => {
                    is_numeric(exp) && is_numeric(act) ?
                        | true => some(string.format("Consider casting with 'as {}'", 
                                                     type_to_string(exp)))
                        | false => none
                }
                        | .None => none
            }
                      | .None => none
        }
        | .UnknownIdentifier => some("Did you mean to import this identifier?")
        | .ImmutableAssignment => some("Add '::' to make the binding mutable")
        | _ => none
}

// Convert type to string for error messages
type_to_string = (t: Type) string {
    t.kind ?
        | .Primitive -> name => name
        | .Array -> (elem, size) => string.format("[{}; {}]", type_to_string(elem), size)
        | .Slice -> elem => string.format("[{}]", type_to_string(elem))
        | .Pointer -> pointee => string.format("*{}", type_to_string(pointee))
        | .Function -> (params, ret) => {
            param_str := string.join(vec.map(params, type_to_string), ", ")
            string.format("({}) {}", param_str, type_to_string(ret))
        }
        | .Unknown => "?"
        | .Never => "!"
        | _ => "<complex type>"
}

// Helper constructors for common types
primitive_type = (name: string) Type {
    return Type {
        kind: TypeKind.Primitive(name)
        mutable: false
        nullable: false
        location: ast.SourceLocation{}
    }
}

array_type = (elem: Type, size: u32) Type {
    return Type {
        kind: TypeKind.Array(elem, size)
        mutable: false
        nullable: false
        location: ast.SourceLocation{}
    }
}

unknown_type = () Type {
    return Type {
        kind: TypeKind.Unknown
        mutable: false
        nullable: false
        location: ast.SourceLocation{}
    }
}

// Format type error for display
format_type_error = (error: TypeError) string {
    result := string.format("Type Error [{}]: {}\n", error.kind, error.message)
    result = string.concat(result, string.format("  at {}:{}:{}\n", 
                                                 error.location.file,
                                                 error.location.line,
                                                 error.location.column))
    
    error.expected ? | .Some -> exp => {
        error.actual ? | .Some -> act => {
            result = string.concat(result, 
                string.format("  Expected: {}\n  Actual:   {}\n",
                             type_to_string(exp), type_to_string(act)))
        }
                      | .None => {
            result = string.concat(result,
                string.format("  Expected: {}\n", type_to_string(exp)))
        }
    }
                    | .None => {}
    
    // Add notes
    i ::= 0
    loop i < error.notes.len() {
        note := error.notes.get(i)
        result = string.concat(result, string.format("  Note: {}\n", note))
        i = i + 1
    }
    
    // Add suggestion
    error.suggestion ? | .Some -> sugg => {
        result = string.concat(result, string.format("  Suggestion: {}\n", sugg))
    }
                      | .None => {}
    
    return result
}

// Export type checking utilities
export {
    TypeKind, Type, Field, Variant, Constraint,
    TypeEnv, TypeContext, TypeError, TypeErrorKind,
    TypeWarning, TypeWarningKind,
    new_env, new_context,
    lookup_type, bind_type,
    types_equal, is_assignable,
    infer_type, 
    format_type_error,
    primitive_type, array_type, unknown_type
}