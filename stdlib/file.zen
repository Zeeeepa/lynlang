// File I/O operations for Zen
// Provides file reading, writing, and manipulation utilities

core = @std
mem = @std
string = @std
path = @std
result = @std
sys = @std  // Import unified system calls

// File handle
File: {
    fd: i32,  // File descriptor
    path: core.String,
    mode: FileMode,
    is_open: bool,
}

// File modes
FileMode: 
    Read,
    Write,
    Append,
    ReadWrite,

// File seek positions
SeekFrom: 
    Start(offset: i64),
    Current(offset: i64),
    End(offset: i64),

// File metadata
FileMetadata: {
    size: u64,
    created: u64,    // Unix timestamp
    modified: u64,   // Unix timestamp
    accessed: u64,   // Unix timestamp
    is_dir: bool,
    is_file: bool,
    is_symlink: bool,
    permissions: u32,
}

// Directory entry
DirEntry: {
    name: core.String,
    path: core.String,
    metadata: FileMetadata,
}

// Open a file with specified mode
open = (path: core.String, mode: FileMode) Result<File, core.String>  {
    flags := mode_to_flags(mode)
    fd := sys.sys.__sys_open(path.data, flags, 0o644)
    
    (fd < 0) ?
        | true {
            return Result<File, core.String>.Err(get_error_string(fd))
        }
        | false { }
    
    return Result<File, core.String>.Ok(File{
        fd: fd,
        path: path,
        mode: mode,
        is_open: true,
    })
}

// Create a new file (truncates if exists)
create = (path: core.String) Result<File, core.String>  {
    fd := sys.sys.__sys_open(path.data, sys.O_CREAT | sys.O_WRONLY | sys.O_TRUNC, 0o644)
    
    (fd < 0) ?
        | true {
            return Result<File, core.String>.Err(get_error_string(fd))
        }
        | false { }
    
    return Result<File, core.String>.Ok(File{
        fd: fd,
        path: path,
        mode: FileMode.Write,
        is_open: true,
    })
}

// Read entire file contents as string
read_to_string = (file: &mut File) Result<core.String, core.String>  {
    (!file.is_open) ?
        | true {
            return Result<core.String, core.String>.Err("File is not open")
        }
        | false { }
    
    // Get file size
    stat := get_metadata(file)
    if stat.is_err() {
        return Result<core.String, core.String>.Err(stat.unwrap_err())
    }
    
    size := stat.unwrap().size
    buffer := mem.alloc<u8>(size + 1)
    
    bytes_read := sys.sys.__sys_read(file.fd, buffer, size)
    if bytes_read < 0 {
        mem.free(buffer)
        return Result<core.String, core.String>.Err(get_error_string(bytes_read))
    }
    
    buffer[bytes_read] = 0  // Null terminate
    
    return Result<core.String, core.String>.Ok(core.String{
        data: buffer,
        len: bytes_read,
    })
}

// Read bytes from file
read = (file: &mut File, buffer: &mut Vec<u8>, count: usize) Result<usize, core.String>  {
    if !file.is_open {
        return Result<usize, core.String>.Err("File is not open")
    }
    
    bytes_read := sys.sys.__sys_read(file.fd, buffer.data, count)
    if bytes_read < 0 {
        return Result<usize, core.String>.Err(get_error_string(bytes_read))
    }
    
    return Result<usize, core.String>.Ok(bytes_read)
}

// Read entire file into byte array
read_bytes = (file: &mut File) Result<Vec<u8>, core.String>  {
    if !file.is_open {
        return Result<Vec<u8>, core.String>.Err("File is not open")
    }
    
    // Get file size
    stat := get_metadata(file)
    if stat.is_err() {
        return Result<Vec<u8>, core.String>.Err(stat.unwrap_err())
    }
    
    size := stat.unwrap().size
    buffer := mem.alloc_array<u8>(size)
    
    bytes_read := sys.__sys_read(file.fd, buffer.data, size)
    if bytes_read < 0 {
        mem.free(buffer.data)
        return Result<Vec<u8>, core.String>.Err(get_error_string(bytes_read))
    }
    
    return Result<Vec<u8>, core.String>.Ok(buffer[0:bytes_read])
}

// Write string to file
write_string = (file: &mut File, content: core.String) Result<usize, core.String>  {
    if !file.is_open {
        return Result<usize, core.String>.Err("File is not open")
    }
    
    bytes_written := sys.__sys_write(file.fd, content.data, content.len)
    if bytes_written < 0 {
        return Result<usize, core.String>.Err(get_error_string(bytes_written))
    }
    
    return Result<usize, core.String>.Ok(bytes_written)
}

// Write bytes to file
write = (file: &mut File, buffer: Vec<u8>) Result<usize, core.String>  {
    if !file.is_open {
        return Result<usize, core.String>.Err("File is not open")
    }
    
    bytes_written := sys.__sys_write(file.fd, buffer.data, buffer.len)
    if bytes_written < 0 {
        return Result<usize, core.String>.Err(get_error_string(bytes_written))
    }
    
    return Result<usize, core.String>.Ok(bytes_written)
}

// Write line to file (adds newline)
write_line = (file: &mut File, line: core.String) Result<usize, core.String>  {
    total := 0
    
    // Write the line
    res := write_string(file, line)
    if res.is_err() {
        return res
    }
    total += res.unwrap()
    
    // Write newline
    res = write_string(file, "\n")
    if res.is_err() {
        return res
    }
    total += res.unwrap()
    
    return Result<usize, core.String>.Ok(total)
}

// Seek to position in file
seek = (file: &mut File, pos: SeekFrom) Result<u64, core.String>  {
    if !file.is_open {
        return Result<u64, core.String>.Err("File is not open")
    }
    
    whence: i32
    offset: i64
    
    pos ?
        SeekFrom.Start(off) => {
            whence = sys.SEEK_SET
            offset = off
        },
        SeekFrom.Current(off) => {
            whence = sys.SEEK_CUR
            offset = off
        },
        SeekFrom.End(off) => {
            whence = sys.SEEK_END
            offset = off
        },
    }
    
    new_pos := sys.__sys_lseek(file.fd, offset, whence)
    if new_pos < 0 {
        return Result<u64, core.String>.Err(get_error_string(new_pos))
    }
    
    return Result<u64, core.String>.Ok(new_pos)
}

// Get current position in file
tell = (file: &File) Result<u64, core.String>  {
    if !file.is_open {
        return Result<u64, core.String>.Err("File is not open")
    }
    
    pos := sys.__sys_lseek(file.fd, 0, sys.SEEK_CUR)
    if pos < 0 {
        return Result<u64, core.String>.Err(get_error_string(pos))
    }
    
    return Result<u64, core.String>.Ok(pos)
}

// Flush file buffers
flush = (file: &mut File) Result<void, core.String>  {
    if !file.is_open {
        return Result<void, core.String>.Err("File is not open")
    }
    
    ret := sys.__sys_fsync(file.fd)
    if ret < 0 {
        return Result<void, core.String>.Err(get_error_string(ret))
    }
    
    return Result<void, core.String>.Ok(void)
}

// Close file
close = (file: &mut File) Result<void, core.String>  {
    if !file.is_open {
        return Result<void, core.String>.Ok(void)
    }
    
    ret := sys.__sys_close(file.fd)
    if ret < 0 {
        return Result<void, core.String>.Err(get_error_string(ret))
    }
    
    file.is_open = false
    return Result<void, core.String>.Ok(void)
}

// Get file metadata
get_metadata = (file: &File) Result<FileMetadata, core.String>  {
    if !file.is_open {
        return Result<FileMetadata, core.String>.Err("File is not open")
    }
    
    stat_buf: StatBuf
    ret := sys.__sys_fstat(file.fd, &stat_buf)
    
    if ret < 0 {
        return Result<FileMetadata, core.String>.Err(get_error_string(ret))
    }
    
    return Result<FileMetadata, core.String>.Ok(FileMetadata{
        size: stat_buf.st_size,
        created: stat_buf.st_ctime,
        modified: stat_buf.st_mtime,
        accessed: stat_buf.st_atime,
        is_dir: (stat_buf.st_mode & sys.S_IFDIR) != 0,
        is_file: (stat_buf.st_mode & sys.S_IFREG) != 0,
        is_symlink: (stat_buf.st_mode & sys.S_IFLNK) != 0,
        permissions: stat_buf.st_mode & 0o777,
    })
}

// Check if file exists
exists = (path: core.String) bool   {
    ret := sys.__sys_access(path.data, sys.F_OK)
    return ret == 0
}

// Delete a file
delete = (path: core.String) Result<void, core.String>  {
    ret := sys.__sys_unlink(path.data)
    if ret < 0 {
        return Result<void, core.String>.Err(get_error_string(ret))
    }
    return Result<void, core.String>.Ok(void)
}

// Rename a file
rename = (old_path: core.String, new_path: core.String) Result<void, core.String>  {
    ret := sys.__sys_rename(old_path.data, new_path.data)
    if ret < 0 {
        return Result<void, core.String>.Err(get_error_string(ret))
    }
    return Result<void, core.String>.Ok(void)
}

// Copy a file
copy = (src_path: core.String, dst_path: core.String) Result<u64, core.String>  {
    // Open source file
    src_res := open(src_path, FileMode.Read)
    if src_res.is_err() {
        return Result<u64, core.String>.Err(src_res.unwrap_err())
    }
    src := src_res.unwrap()
    defer close(&mut src)
    
    // Create destination file
    dst_res := create(dst_path)
    if dst_res.is_err() {
        return Result<u64, core.String>.Err(dst_res.unwrap_err())
    }
    dst := dst_res.unwrap()
    defer close(&mut dst)
    
    // Copy data
    buffer: [4096]u8
    total_copied: u64 = 0
    
    loop {
        read_res := read(&mut src, &mut buffer, 4096)
        if read_res.is_err() {
            return Result<u64, core.String>.Err(read_res.unwrap_err())
        }
        
        bytes_read := read_res.unwrap()
        if bytes_read == 0 {
            break
        }
        
        write_res := write(&mut dst, buffer[0:bytes_read])
        if write_res.is_err() {
            return Result<u64, core.String>.Err(write_res.unwrap_err())
        }
        
        total_copied += bytes_read
    }
    
    return Result<u64, core.String>.Ok(total_copied)
}

// Create a directory
create_dir = (path: core.String) Result<void, core.String>  {
    ret := sys.__sys_mkdir(path.data, 0o755)
    if ret < 0 {
        return Result<void, core.String>.Err(get_error_string(ret))
    }
    return Result<void, core.String>.Ok(void)
}

// Create directory and all parent directories
create_dir_all = (path: core.String) Result<void, core.String>  {
    parts := path:split(path)
    current := core.String{ data: "", len: 0 }
    
    for part in parts {
        current = path:join(current, part)
        if !exists(current) {
            res := create_dir(current)
            if res.is_err() {
                return res
            }
        }
    }
    
    return Result<void, core.String>.Ok(void)
}

// Remove a directory (must be empty)
remove_dir = (path: core.String) Result<void, core.String>  {
    ret := sys.__sys_rmdir(path.data)
    if ret < 0 {
        return Result<void, core.String>.Err(get_error_string(ret))
    }
    return Result<void, core.String>.Ok(void)
}

// Read directory contents
read_dir = (path: core.String) Result<DynVec<DirEntry>, core.String>  {
    dir := sys.__sys_opendir(path.data)
    if dir .== None {
        return Result<DynVec<DirEntry>, core.String>.Err("Failed to open directory")
    }
    defer sys.__sys_closedir(dir)
    
    entries: DynVec<DirEntry> = DynVec<DirEntry>{}
    
    loop {
        entry := sys.__sys_readdir(dir)
        if entry .== None {
            break
        }
        
        name := core.String{
            data: entry.d_name,
            len: string.len(entry.d_name),
        }
        
        // Skip . and ..
        if string.equals(name, ".") || string.equals(name, "..") {
            continue
        }
        
        full_path := path:join(path, name)
        
        // Get metadata
        stat_buf: StatBuf
        if sys.__sys_stat(full_path.data, &stat_buf) == 0 {
            metadata := FileMetadata{
                size: stat_buf.st_size,
                created: stat_buf.st_ctime,
                modified: stat_buf.st_mtime,
                accessed: stat_buf.st_atime,
                is_dir: (stat_buf.st_mode & sys.S_IFDIR) != 0,
                is_file: (stat_buf.st_mode & sys.S_IFREG) != 0,
                is_symlink: (stat_buf.st_mode & sys.S_IFLNK) != 0,
                permissions: stat_buf.st_mode & 0o777,
            }
            
            entries.push(DirEntry{
                name: name,
                path: full_path,
                metadata: metadata,
            })
        }
    }
    
    return Result<DynVec<DirEntry>, core.String>.Ok(entries)
}

// Walk directory tree recursively
walk_dir = (path: core.String, callback: fn(DirEntry) void) Result<void, core.String> {
    entries_res := read_dir(path)
    if entries_res.is_err() {
        return Result<void, core.String>.Err(entries_res.unwrap_err())
    }
    
    entries := entries_res.unwrap()
    for entry in entries {
        callback(entry)
        
        if entry.metadata.is_dir {
            walk_res := walk_dir(entry.path, callback)
            if walk_res.is_err() {
                return walk_res
            }
        }
    }
    
    return Result<void, core.String>.Ok(void)
}

// Helper function to convert FileMode to system flags
mode_to_flags = (mode: FileMode) i32   {
    mode ?
        FileMode.Read => sys.O_RDONLY,
        FileMode.Write => sys.O_WRONLY | sys.O_CREAT | sys.O_TRUNC,
        FileMode.Append => sys.O_WRONLY | sys.O_CREAT | sys.O_APPEND,
        FileMode.ReadWrite => sys.O_RDWR | sys.O_CREAT,
    }
}

// Helper to get error string from errno
get_error_string = (errno: i32) core.String {
    errno ?
        -1 => "Operation not permitted",
        -2 => "No such file or directory",
        -3 => "No such process",
        -4 => "Interrupted system call",
        -5 => "I/O error",
        -13 => "Permission denied",
        -17 => "File exists",
        -20 => "Not a directory",
        -21 => "Is a directory",
        -22 => "Invalid argument",
        -24 => "Too many open files",
        -28 => "No space left on device",
        _ => "Unknown error",
    }
}



// All system calls are now in sys.zen module