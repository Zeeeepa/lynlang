// Option type for nullable values

core := @std.core

// Option type - represents a value that may or may not exist
enum Option<T> {
    Some(T),
    None,
}

// Create Some variant
some = <T>(value: T) Option<T> {
    return Option.Some(value)
}

// Create None variant
none = <T>() Option<T> {
    return Option.None
}

// Check if option has value
is_some = <T>(opt: Option<T>) bool {
    opt match {
        | Some(_) => true
        | None => false
    }
}

// Check if option is none
is_none = <T>(opt: Option<T>) bool {
    opt match {
        | Some(_) => false
        | None => true
    }
}

// Get value or panic
unwrap = <T>(opt: Option<T>) T {
    opt match {
        | Some(v) => v
        | None => core.panic("called unwrap on None value")
    }
}

// Get value or default
unwrap_or = <T>(opt: Option<T>, default: T) T {
    opt match {
        | Some(v) => v
        | None => default
    }
}

// Get value or compute default
unwrap_or_else = <T>(opt: Option<T>, f: () T) T {
    opt match {
        | Some(v) => v
        | None => f()
    }
}

// Expect with custom message
expect = <T>(opt: Option<T>, msg: string) T {
    opt match {
        | Some(v) => v
        | None => core.panic(msg)
    }
}

// Map value through function
map = <T, U>(opt: Option<T>, f: (T) U) Option<U> {
    opt match {
        | Some(v) => Option.Some(f(v))
        | None => Option.None
    }
}

// Map or return default
map_or = <T, U>(opt: Option<T>, default: U, f: (T) U) U {
    opt match {
        | Some(v) => f(v)
        | None => default
    }
}

// Map or compute default
map_or_else = <T, U>(opt: Option<T>, default_fn: () U, f: (T) U) U {
    opt match {
        | Some(v) => f(v)
        | None => default_fn()
    }
}

// Chain operations
and_then = <T, U>(opt: Option<T>, f: (T) Option<U>) Option<U> {
    opt match {
        | Some(v) => f(v)
        | None => Option.None
    }
}

// Filter based on predicate
filter = <T>(opt: Option<T>, predicate: (T) bool) Option<T> {
    opt match {
        | Some(v) => {
            if predicate(v) {
                Option.Some(v)
            } else {
                Option.None
            }
        }
        | None => Option.None
    }
}

// Combine with another option
and = <T, U>(opt: Option<T>, other: Option<U>) Option<U> {
    opt match {
        | Some(_) => other
        | None => Option.None
    }
}

// Alternative option
or = <T>(opt: Option<T>, other: Option<T>) Option<T> {
    opt match {
        | Some(v) => Option.Some(v)
        | None => other
    }
}

// Alternative with function
or_else = <T>(opt: Option<T>, f: () Option<T>) Option<T> {
    opt match {
        | Some(v) => Option.Some(v)
        | None => f()
    }
}

// XOR - one or the other but not both
xor = <T>(opt: Option<T>, other: Option<T>) Option<T> {
    (opt.is_some(), other.is_some()) match {
        | (true, false) => opt
        | (false, true) => other
        | _ => Option.None
    }
}

// Get contained value by reference
as_ref = <T>(opt: &Option<T>) Option<&T> {
    opt match {
        | Some(ref v) => Option.Some(v)
        | None => Option.None
    }
}

// Get contained value by mutable reference
as_mut = <T>(opt: &mut Option<T>) Option<&mut T> {
    opt match {
        | Some(ref mut v) => Option.Some(v)
        | None => Option.None
    }
}

// Take value out, leaving None
take = <T>(opt: &mut Option<T>) Option<T> {
    let old = *opt
    *opt = Option.None
    return old
}

// Replace value, returning old value
replace = <T>(opt: &mut Option<T>, value: T) Option<T> {
    let old = *opt
    *opt = Option.Some(value)
    return old
}

// Zip two options
zip = <T, U>(opt1: Option<T>, opt2: Option<U>) Option<(T, U)> {
    (opt1, opt2) match {
        | (Some(v1), Some(v2)) => Option.Some((v1, v2))
        | _ => Option.None
    }
}

// Unzip option of tuple
unzip = <T, U>(opt: Option<(T, U)>) (Option<T>, Option<U>) {
    opt match {
        | Some((v1, v2)) => (Option.Some(v1), Option.Some(v2))
        | None => (Option.None, Option.None)
    }
}

// Flatten nested option
flatten = <T>(opt: Option<Option<T>>) Option<T> {
    opt match {
        | Some(inner) => inner
        | None => Option.None
    }
}

// Convert to Result
ok_or = <T, E>(opt: Option<T>, err: E) Result<T, E> {
    opt match {
        | Some(v) => Result.Ok(v)
        | None => Result.Err(err)
    }
}

// Convert to Result with error function
ok_or_else = <T, E>(opt: Option<T>, err_fn: () E) Result<T, E> {
    opt match {
        | Some(v) => Result.Ok(v)
        | None => Result.Err(err_fn())
    }
}

// Transpose Option of Result
transpose = <T, E>(opt: Option<Result<T, E>>) Result<Option<T>, E> {
    opt match {
        | Some(Ok(v)) => Result.Ok(Option.Some(v))
        | Some(Err(e)) => Result.Err(e)
        | None => Result.Ok(Option.None)
    }
}