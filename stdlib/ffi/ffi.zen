// Zen Standard Library: FFI (Foreign Function Interface)
// C interoperability and dynamic loading

{ compiler } = @std
{ Result } = @std.core.result

// C function pointer type wrapper
CFuncPtr: {
    ptr: RawPtr<u8>
}

// C library handle
CLibrary: {
    handle: RawPtr<u8>,
    path: String
}

// Load a C library dynamically
load_library = (path: String) Result<CLibrary, String> {
    handle = compiler.load_library(path)
    null_ptr = compiler.int_to_ptr(0)

    handle == null_ptr ?
        | true { Result.Err("Failed to load library") }
        | false { Result.Ok(CLibrary { handle: handle, path: path }) }
}

// Get function pointer from library
get_function = (lib: CLibrary, symbol: String) Result<CFuncPtr, String> {
    ptr = compiler.get_symbol(lib.handle, symbol)
    null_ptr = compiler.int_to_ptr(0)

    ptr == null_ptr ?
        | true { Result.Err("Symbol not found") }
        | false { Result.Ok(CFuncPtr { ptr: ptr }) }
}

// Call C function pointer
call_cfunc = (func: CFuncPtr, args: RawPtr<u8>) RawPtr<u8> {
    return compiler.call_external(func.ptr, args)
}

// Unload library
unload_library = (lib: CLibrary) void {
    compiler.unload_library(lib.handle)
}

// Inline C code compilation
inline_c = (code: String) void {
    compiler.inline_c(code)
}
