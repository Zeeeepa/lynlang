// Actor system with allocator-based execution
// Supports both sync and concurrent modes via allocator

build = @std
std := build.import("std")
allocator := build.import("allocator")
runtime := build.import("concurrent_runtime_enhanced")

// Generic message type for actors
Message = (comptime T: type) T

// Actor behavior trait
Behavior = (comptime State: type, comptime Msg: type) {
    handle: (state: Ptr<State>, msg: Msg, ctx: Ptr<ActorContext>) void
}

// Actor context for handling messages
ActorContext: {
    self_ref: ActorRef
    alloc: Ptr<allocator.Allocator>
    system: Ptr<ActorSystem>
    
    spawn: (behavior: anytype, initial_state: anytype) ActorRef {
        return self.system.spawn(behavior, initial_state, self.alloc)
    }
    
    send: (target: ActorRef, msg: anytype) void {
        self.system.send(target, msg)
    }
    
    reply: (msg: anytype) void {
        // Reply to sender if tracking is implemented
    }
}

// Actor reference for sending messages
ActorRef: {
    id: u64
    mailbox: Ptr<Mailbox>
}

// Mailbox for actor messages
Mailbox: {
    messages: DynVec<u8>  // Serialized messages
    message_types: DynVec<u64>  // Type IDs for deserialization
    lock: std.sync.Mutex
    waiting: Option<allocator.Continuation>
    alloc: Ptr<allocator.Allocator>
    
    init: (alloc: Ptr<allocator.Allocator>) Mailbox {
        return Mailbox{
            messages: DynVec<u8>{},
            message_types: DynVec<u64>{},
            lock: std.sync.Mutex.init(),
            waiting: null,
            alloc: alloc
        }
    }
    
    send_raw: (msg_data: Vec<u8>, type_id: u64) void {
        self.lock.lock()
        defer self.lock.unlock()
        
        // Append message data
        old_len := self.messages.len
        new_messages := self.alloc.alloc_slice(u8, old_len + msg_data.len)
        std.mem.copy(u8, new_messages[0..old_len], self.messages)
        std.mem.copy(u8, new_messages[old_len..], msg_data)
        self.alloc.free_slice(self.messages)
        self.messages = new_messages
        
        // Append type ID
        self.message_types.append(type_id)
        
        // Wake up waiting actor if any
        self.waiting ?
            | Some(cont) {
                self.alloc.resume(cont)
                self.waiting = None
            }
            | None { }
    }
    
    receive_raw: () ?(Vec<u8>, u64) {
        self.lock.lock()
        defer self.lock.unlock()
        
        // Check for messages
        loop(() {
            (self.messages.len > 0) ?
                | true {
                    // Extract first message
                    // For simplicity, assume fixed-size messages
                    // Real implementation would include message framing
                    msg_size := 256  // Placeholder
                    msg_data := self.messages[0..msg_size]
                    type_id := self.message_types[0]
                    
                    // Remove from queue
                    self.messages = self.messages[msg_size..]
                    self.message_types = self.message_types[1..]
                    
                    return (msg_data, type_id)
                }
                | false { }
            
            // No messages, wait if concurrent mode
            self.alloc.is_concurrent ?
                | true {
                    cont := self.alloc.suspend()
                    cont ?
                        | Some(c) {
                            self.waiting = Some(c)
                            self.lock.unlock()
                            self.alloc.resume(c)
                            self.lock.lock()
                            // Loop back to check for messages
                        }
                        | None {
                            return None
                        }
                }
                | false {
                    // Sync mode - no messages available
                    return None
                }
        })
    }
}

// Actor instance
Actor: {
    id: u64
    mailbox: Mailbox
    behavior: RawPtr<void>  // Type-erased behavior
    state: RawPtr<void>     // Type-erased state
    alloc: Ptr<allocator.Allocator>
    context: ActorContext
    running: bool
    
    run: () void {
        self.running = true
        
        loop(() {
            !self.running ? break : {}
            
            // Receive next message
            msg_data := self.mailbox.receive_raw()
            msg_data ? {
                // Process message (would need proper deserialization)
                // This is simplified - real implementation would use
                // the behavior's handle method with proper typing
            } : {
                // No message available
                self.alloc.is_concurrent ? {
                    // Already suspended in receive_raw
                } : {
                    // Sync mode - stop if no messages
                    break
                }
            }
        }
    }
    
    stop: () void {
        self.running = false
        
        // Wake up if waiting
        self.mailbox.waiting ? {
            self.alloc.resume(self.mailbox.waiting.?)
        } : {}
    }
}

// Actor system managing all actors
ActorSystem: {
    actors: DynVec<Actor>
    next_actor_id: u64
    event_loop: Option<runtime.EventLoop>
    alloc: Ptr<allocator.Allocator>
    
    init: (alloc: Ptr<allocator.Allocator>) ActorSystem {
        return ActorSystem{
            actors: DynVec<Actor>{},
            next_actor_id: 1,
            event_loop: alloc.is_concurrent ? 
                runtime.EventLoop.init(alloc) : null,
            alloc: alloc
        }
    }
    
    spawn: (behavior: anytype, initial_state: anytype, alloc: ?Ptr<allocator.Allocator>) ActorRef {
        actor_alloc := alloc orelse self.alloc
        
        actor := Actor{
            id: self.next_actor_id,
            mailbox: Mailbox.init(actor_alloc),
            behavior: @ptrCast(RawPtr<void>, &behavior),
            state: @ptrCast(RawPtr<void>, &initial_state),
            alloc: actor_alloc,
            context: ActorContext{
                self_ref: ActorRef{ id: self.next_actor_id, mailbox: undefined },
                alloc: actor_alloc,
                system: self
            },
            running: false
        }
        
        // Set mailbox reference
        actor.context.self_ref.mailbox = &actor.mailbox
        
        self.next_actor_id += 1
        self.actors.append(actor)
        
        // Start actor execution
        actor_alloc.is_concurrent && self.event_loop ? {
            // Spawn concurrent task
            self.event_loop.?.spawn(() => actor.run())
        } : {
            // For sync mode, actors process messages on send
        }
        
        return actor.context.self_ref
    }
    
    send: (target: ActorRef, msg: anytype) void {
        // Serialize message (simplified)
        msg_data := @ptrCast([*]const u8, &msg)[0..@std.sizeOf(@std.TypeOf(msg))]
        { type_id } = @std(@std.TypeOf(msg))
        
        target.mailbox.send_raw(msg_data, type_id)
    }
    
    run: () void {
        self.event_loop ? {
            self.event_loop.?.run()
        } : {
            // Sync mode - process all messages immediately
            i := 0
            loop (i < self.actors.len) {
                self.actors[i].run()
                i += 1
            }
        }
    }
    
    shutdown: () void {
        // Stop all actors
        i := 0
        loop (i < self.actors.len) {
            self.actors[i].stop()
            i += 1
        }
        
        // Wait for completion if concurrent
        self.event_loop ? {
            self.event_loop.?.run()
        } : {}
    }
}

// Example actor behaviors
PingPongMsg: Ping(count: u32)
    | Pong(count: u32)
    | Stop

PingActor: {
    pong_ref: Option<ActorRef>
    
    behavior: Behavior(PingActor, PingPongMsg) = {
        handle: (state, msg, ctx) {
            msg ? 
                | Ping(count) {
                    std.io.print("Ping received: {}\n", count)
                    state.pong_ref ? {
                        ctx.send(state.pong_ref.?, .Pong(count + 1))
                    } : {}
                }
                | Pong(count) {
                    std.io.print("Ping actor got pong: {}\n", count)
                    count < 10 ? {
                        state.pong_ref ? {
                            ctx.send(state.pong_ref.?, .Ping(count + 1))
                        } : {}
                    } : {
                        ctx.send(ctx.self_ref, .Stop)
                        state.pong_ref ? {
                            ctx.send(state.pong_ref.?, .Stop)
                        } : {}
                    }
                }
                | Stop {
                    std.io.print("Ping actor stopping\n")
                }
        }
    }
}

PongActor: {
    behavior: Behavior(void, PingPongMsg) = {
        handle: (state, msg, ctx) {
            msg ?
                | Ping(count) {
                    std.io.print("Pong actor got ping: {}\n", count)
                    ctx.reply(.Pong(count))
                }
                | Pong(count) {
                    std.io.print("Pong received: {}\n", count)
                }
                | Stop {
                    std.io.print("Pong actor stopping\n")
                }
        }
    }
}

// Worker pool pattern
WorkerPool<Job: type, Result: type>: {
    workers: DynVec<ActorRef>
    next_worker: usize
    result_handler: (Result) void
    alloc: Ptr<allocator.Allocator>
    
    init: (
        num_workers: usize, 
        worker_behavior: Behavior(void, Job),
        result_handler: (Result) void,
        system: Ptr<ActorSystem>,
        alloc: Ptr<allocator.Allocator>
    ) WorkerPool<Job, Result> {
        workers := alloc.alloc_slice(ActorRef, num_workers)
        
        loop i := 0; i < num_workers; i += 1 {
            workers[i] = system.spawn(worker_behavior, {}, alloc)
        }
        
        return WorkerPool<Job, Result>{
            workers: workers,
            next_worker: 0,
            result_handler: result_handler,
            alloc: alloc
        }
    }
    
    submit: (job: Job) void {
        // Round-robin distribution
        worker := self.workers[self.next_worker]
        self.next_worker = (self.next_worker + 1) % self.workers.len
        
        // Send job to worker
        // Worker should send result back to a result collector actor
        worker.mailbox.send_raw(
            @ptrCast([*]const u8, &job)[0..@std.sizeOf(Job)],
            @std.typeId(Job)
        )
    }
    
    shutdown: () void {
        // Send stop message to all workers
        loop i := 0; i < self.workers.len; i += 1 {
            // Would send a stop message
        }
    }
}