// FFI Builder Pattern Implementation
// Safe C interop according to Zen language spec v1.1.0
// Provides builder pattern for creating FFI bindings safely

build = @std
core := build.import("core")
{ Vec, DynVec } = @std
string := build.import("string")
mem := build.import("mem")

// Type system for FFI
Type: Void,
    Bool,
    I8, I16, I32, I64,
    U8, U16, U32, U64,
    USize,
    F32, F64,
    String,
    Pointer: {inner: Ptr<Type>},
    Array: {element: Ptr<Type>, size: usize},
    Struct: {fields: DynVec<FieldType>}

FieldType: {
    name: StaticString,
    field_type: Type,
}

// FFI builder for safe C interop
FFI: {
    // Create a new library builder
    lib: (name: StaticString) Ptr<LibBuilder> {
        builder := LibBuilder{
            name: name,
            path_str: None,
            functions: DynVec<FunctionBinding>:new(),
            constants: DynVec<ConstantBinding>:new(),
            structs: DynVec<StructBinding>:new(),
        }
        Ptr:new(builder)
    },
}

LibBuilder: {
    name: StaticString,
    path_str: Option<StaticString> = None,
    functions: DynVec<FunctionBinding> = DynVec<FunctionBinding>:new(),
    constants: DynVec<ConstantBinding> = DynVec<ConstantBinding>:new(),
    structs: DynVec<StructBinding> = DynVec<StructBinding>:new(),
    
    path: (self: Ptr<LibBuilder>, p: StaticString) Ptr<LibBuilder> {
        self.value.path_str = Some(p)
        self
    },
    
    function: (self: Ptr<LibBuilder>, name: StaticString, sig: FnSignature) Ptr<LibBuilder> {
        binding := FunctionBinding{
            name: name,
            signature: sig,
        }
        self.value.functions.push(binding)
        self
    },
    
    constant: (self: Ptr<LibBuilder>, name: StaticString, type: Type) Ptr<LibBuilder> {
        binding := ConstantBinding{
            name: name,
            const_type: type,
        }
        self.value.constants.push(binding)
        self
    },
    
    struct: (self: Ptr<LibBuilder>, name: StaticString, fields: DynVec<FieldType>) Ptr<LibBuilder> {
        binding := StructBinding{
            name: name,
            fields: fields,
        }
        self.value.structs.push(binding)
        self
    },
    
    build: (self: Ptr<LibBuilder>) Ptr<Library> {
        lib := Library{
            name: self.value.name,
            path: self.value.path_str,
            functions: self.value.functions,
            constants: self.value.constants,
            structs: self.value.structs,
            handle: None,
            symbol_cache: HashMap<string, RawPtr<void>>:new(),
        }
        Ptr:new(lib)
    },
}

FunctionBinding: {
    name: StaticString,
    signature: FnSignature,
}

FnSignature: {
    params: DynVec<Type>,
    returns: Type,
    calling_convention: Option<CallingConvention> = None,
    variadic: bool = false,
}

CallingConvention: CDecl      // Default C calling convention
    | StdCall    // Windows standard call
    | FastCall   // Fast calling convention
    | ThisCall   // C++ member function
    | VectorCall // Vector calling convention

ConstantBinding: {
    name: StaticString,
    const_type: Type,
}

StructBinding: {
    name: StaticString,
    fields: DynVec<FieldType>,
}

Library: {
    name: StaticString,
    path: Option<StaticString>,
    functions: DynVec<FunctionBinding>,
    constants: DynVec<ConstantBinding>,
    structs: DynVec<StructBinding>,
    handle: Option<RawPtr<void>> = None,
    symbol_cache: HashMap<StaticString, RawPtr<void>> = HashMap<StaticString, RawPtr<void>>:new(),
    
    // Load the library
    load: (self: Ptr<Library>) Result<void, StaticString> {
        self.value.path ?
            | Some(p) {
                // Call dlopen or equivalent
                handle := load_library(p)
                handle ?
                    | Ok(h) {
                        self.value.handle = Some(h)
                        Ok(void)
                    }
                    | Err(e) { Err(e) }
            }
            | None { Err("No library path specified") }
    },
    
    // Get function pointer with caching
    get_function: (self: Ptr<Library>, name: StaticString) Result<RawPtr<void>, StaticString> {
        // Check cache first
        self.value.symbol_cache.get(name) ?
            | Some(ptr) { Ok(ptr) }
            | None {
                self.value.handle ?
                    | Some(h) {
                        // Call dlsym or equivalent
                        result := get_symbol(h, name)
                        result ?
                            | Ok(ptr) {
                                // Cache the symbol
                                self.value.symbol_cache.insert(name, ptr)
                                Ok(ptr)
                            }
                            | Err(e) { Err(e) }
                    }
                    | None { Err("Library not loaded") }
            }
    },
    
    // Get constant value with caching
    get_constant: (self: Ptr<Library>, name: StaticString) Result<RawPtr<void>, StaticString> {
        self.get_function(name) // Constants use same mechanism as functions
    },
    
    // Unload library and clean up
    unload: (self: Ptr<Library>) Result<void, StaticString> {
        self.value.handle ?
            | Some(h) {
                // Clear cache
                self.value.symbol_cache.clear()
                
                // Platform-specific unload
                result := unload_library(h)
                result ?
                    | Ok(_) {
                        self.value.handle = None
                        Ok(void)
                    }
                    | Err(e) { Err(e) }
            }
            | None { Ok(void) // Already unloaded }
    },
    
    // Call a function with type safety
    call_function<Args, Ret>: (self: Ptr<Library>, name: StaticString, args: Args) Result<Ret, StaticString> {
        fn_ptr := self.get_function(name)
        fn_ptr ?
            | Ok(ptr) {
                // Cast to function type and call
                func := ptr as (Args) Ret
                Ok(func(args))
            }
            | Err(e) { Err(e) }
    },
}

// Platform-specific library loading
load_library = (path: StaticString) Result<RawPtr<void>, StaticString>   {
    @std.target.os ?
        | linux { load_library_linux(path) }
        | windows { load_library_windows(path) }
        | macos { load_library_macos(path) }
        | _ { Err("Unsupported platform") }
}

// Platform-specific library unloading
unload_library = (handle: RawPtr<void>) Result<void, StaticString>   {
    @std.target.os ?
        | linux { unload_library_linux(handle) }
        | windows { unload_library_windows(handle) }
        | macos { unload_library_macos(handle) }
        | _ { Err("Unsupported platform") }
}

// Platform-specific symbol lookup
get_symbol = (handle: RawPtr<void>, name: StaticString) Result<RawPtr<void>, StaticString>   {
    @std.target.os ?
        | linux { get_symbol_linux(handle, name) }
        | windows { get_symbol_windows(handle, name)   }
        | macos { get_symbol_macos(handle, name) }
        | _ { Err("Unsupported platform") }
}

// Linux implementation
dlopen = (filename: StaticString, flag: i32) RawPtr<void> {
    inline.c("""
        return dlopen(${filename.addr}, ${flag});
    """)
}

dlsym = (handle: RawPtr<void>, symbol: StaticString) RawPtr<void> {
    inline.c("""
        return dlsym(${handle.addr}, ${symbol.addr});
    """)
}

dlclose = (handle: RawPtr<void>) i32 {
    inline.c("""
        return dlclose(${handle.addr});
    """)
}

dlerror = () StaticString {
    inline.c("""
        return dlerror();
    """)
}

load_library_linux = (path: StaticString) Result<RawPtr<void>, StaticString>   {
    RTLD_LAZY := 1
    handle := dlopen(path, RTLD_LAZY)
    handle.address \!= 0 ?
        | true { Ok(handle) }
        | false { Err(dlerror()) }
}

get_symbol_linux = (handle: RawPtr<void>, name: StaticString) Result<RawPtr<void>, StaticString>   {
    symbol := dlsym(handle, name)
    symbol.address \!= 0 ?
        | true { Ok(symbol) }
        | false { Err(dlerror()) }
}

unload_library_linux = (handle: RawPtr<void>) Result<void, StaticString>   {
    result := dlclose(handle)
    result == 0 ?
        | true { Ok(void) }
        | false { Err(dlerror()) }
}

// Windows implementation
LoadLibraryA = (lpLibFileName: StaticString) RawPtr<void> {
    inline.c("""
        return LoadLibraryA(${lpLibFileName.addr});
    """)
}

GetProcAddress = (hModule: RawPtr<void>, lpProcName: StaticString) RawPtr<void> {
    inline.c("""
        return GetProcAddress(${hModule.addr}, ${lpProcName.addr});
    """)
}

FreeLibrary = (hModule: RawPtr<void>) bool {
    inline.c("""
        return FreeLibrary(${hModule.addr});
    """)
}

GetLastError = () u32 {
    inline.c("""
        return GetLastError();
    """)
}

load_library_windows = (path: StaticString) Result<RawPtr<void>, StaticString>   {
    handle := LoadLibraryA(path)
    handle.address \!= 0 ?
        | true { Ok(handle) }
        | false { Err("Failed to load library: error code $(GetLastError())") }
}

get_symbol_windows = (handle: RawPtr<void>, name: StaticString) Result<RawPtr<void>, StaticString>   {
    symbol := GetProcAddress(handle, name)
    symbol.address \!= 0 ?
        | true { Ok(symbol) }
        | false { Err("Symbol not found: error code $(GetLastError())") }
}

unload_library_windows = (handle: RawPtr<void>) Result<void, StaticString>   {
    result := FreeLibrary(handle)
    result ?
        | true { Ok(void) }
        | false { Err("Failed to unload library: error code $(GetLastError())") }
}

// macOS implementation (uses same as Linux)  
load_library_macos = (path: StaticString) Result<RawPtr<void>, StaticString>   {
    load_library_linux(path) // macOS uses dlopen/dlsym like Linux
}

get_symbol_macos = (handle: RawPtr<void>, name: StaticString) Result<RawPtr<void>, StaticString>   {
    get_symbol_linux(handle, name)
}

unload_library_macos = (handle: RawPtr<void>) Result<void, StaticString>   {
    unload_library_linux(handle)
}

// Helper functions for common FFI patterns
create_c_string = (s: StaticString) RawPtr<u8>   {
    // Allocate buffer with null terminator
    buffer := mem.alloc<u8>(s.len() + 1)
    
    // Copy string bytes
    (0..s.len()).loop((i) => {
        buffer.value[i] = s.bytes()[i]
    })
    
    // Add null terminator
    buffer.value[s.len()] = 0
    
    buffer
}

free_c_string = (ptr: RawPtr<u8>) void   {
    mem.free(ptr)
}

// Convert C string to Zen string
from_c_string = (ptr: RawPtr<u8>) StaticString   {
    len := 0
    
    // Find null terminator
    loop {
        ptr.value[len] == 0 ? | true { break }
        len = len + 1
    }
    
    // Create string from bytes
    string:from_bytes(ptr, len)
}
