// Zen Standard Library: FFI (Foreign Function Interface)
// C interoperability and dynamic loading
//
// This module provides low-level FFI wrappers for dynamic library loading.
// For Result types with string errors, use the higher-level wrappers in
// your application code after loading.

{ compiler, ptr } = @std

// =============================================================================
// TYPES
// =============================================================================

// C function pointer type wrapper
CFuncPtr: {
    ptr: RawPtr<u8>
}

// C library handle (simple wrapper)
CLibrary: {
    handle: RawPtr<u8>
}

// =============================================================================
// LIBRARY LOADING (Low-level)
// =============================================================================

// Load a C library dynamically (low-level)
// Returns library handle or null on failure
// Use dlerror() via compiler.dlerror() for error messages
load_library_raw = (path: String) RawPtr<u8> {
    return compiler.load_library(path)
}

// Get symbol from library (low-level)
// Returns symbol pointer or null if not found
get_symbol_raw = (handle: RawPtr<u8>, symbol: String) RawPtr<u8> {
    return compiler.get_symbol(handle, symbol)
}

// Unload library (low-level)
unload_library_raw = (handle: RawPtr<u8>) void {
    compiler.unload_library(handle)
}

// =============================================================================
// LIBRARY LOADING (Wrapped)
// =============================================================================

// Load a C library and return a CLibrary wrapper
// Returns CLibrary with null handle on failure
load_library = (path: String) CLibrary {
    handle = compiler.load_library(path)
    return CLibrary { handle: handle }
}

// Get function pointer from library
// Returns CFuncPtr with null ptr on failure
get_function = (lib: CLibrary, symbol: String) CFuncPtr {
    ptr = compiler.get_symbol(lib.handle, symbol)
    return CFuncPtr { ptr: ptr }
}

// Get raw symbol pointer from library
get_symbol = (lib: CLibrary, symbol: String) RawPtr<u8> {
    return compiler.get_symbol(lib.handle, symbol)
}

// Check if library was loaded successfully
is_loaded = (lib: CLibrary) bool {
    return ptr.is_valid(lib.handle)
}

// Check if function pointer is valid
is_valid = (func: CFuncPtr) bool {
    return ptr.is_valid(func.ptr)
}

// Unload library
unload_library = (lib: CLibrary) void {
    compiler.unload_library(lib.handle)
}

// =============================================================================
// USAGE NOTES
// =============================================================================
//
// Basic usage:
//   lib = ffi.load_library("libm.so.6")
//   ffi.is_loaded(lib) ?
//   | true {
//       sin_fn = ffi.get_function(lib, "sin")
//       // Use sin_fn.ptr with compiler intrinsics
//   }
//   | false {
//       io.println("Failed to load library")
//   }
//
// For inline C code: compiler.inline_c("C code here")
