// Zen Standard Library: Memory Mapping (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics

{ compiler } = @std
{ Result } = @std.core.result
{ SYS_MMAP, SYS_MUNMAP, SYS_MPROTECT } = @std.sys.syscall

// Protection flags
PROT_NONE = 0
PROT_READ = 1
PROT_WRITE = 2
PROT_EXEC = 4

// Map flags
MAP_SHARED = 1
MAP_PRIVATE = 2
MAP_ANONYMOUS = 32
MAP_FIXED = 16

MmapError: { code: i32, message: StaticString }

MmapError.from_errno = (errno: i64) MmapError {
    code = (0 - errno) as i32
    return MmapError { code: code, message: "Mmap error" }
}

// Memory-mapped region
Mmap: { addr: i64, len: usize }

// Map anonymous memory (no file backing)
Mmap.anonymous = (len: usize, prot: i32) Result<Mmap, MmapError> {
    flags = MAP_PRIVATE | MAP_ANONYMOUS
    result = compiler.syscall6(SYS_MMAP, 0, len, prot, flags, -1, 0)
    result < 0 ? { return Result.Err(MmapError.from_errno(result)) }
    return Result.Ok(Mmap { addr: result, len: len })
}

// Map with read/write access
Mmap.alloc = (len: usize) Result<Mmap, MmapError> {
    return Mmap.anonymous(len, PROT_READ | PROT_WRITE)
}

// Get pointer to mapped memory
Mmap.ptr = (self: Mmap) Ptr<u8> {
    return compiler.int_to_ptr(self.addr)
}

// Change protection
Mmap.protect = (self: MutPtr<Mmap>, prot: i32) Result<(), MmapError> {
    result = compiler.syscall3(SYS_MPROTECT, self.val.addr, self.val.len, prot)
    result < 0 ? { return Result.Err(MmapError.from_errno(result)) }
    return Result.Ok(())
}

// Unmap memory
Mmap.unmap = (self: MutPtr<Mmap>) Result<(), MmapError> {
    result = compiler.syscall2(SYS_MUNMAP, self.val.addr, self.val.len)
    result < 0 ? { return Result.Err(MmapError.from_errno(result)) }
    self.val.addr = 0
    self.val.len = 0
    return Result.Ok(())
}
