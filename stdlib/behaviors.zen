// Zen Language Behaviors System
// Implements structural contracts (traits/interfaces) as per LANGUAGE_SPEC.zen
// Behaviors are structs containing function pointers - no keywords needed

{ meta } := @std

// ============================================================================
// Core Behavior Definitions
// ============================================================================

// Comparable<T> - Types that can be compared for ordering
Comparable := {
    T: type
    
    // Returns -1 if a < b, 0 if a == b, 1 if a > b
    compare: (a: T, b: T) i32
    
    // Derived operations (implemented using compare)
    less_than := (a: T, b: T) bool {
        return compare(a, b) < 0
    }
    
    less_equal := (a: T, b: T) bool {
        return compare(a, b) <= 0
    }
    
    greater_than := (a: T, b: T) bool {
        return compare(a, b) > 0
    }
    
    greater_equal := (a: T, b: T) bool {
        return compare(a, b) >= 0
    }
    
    equal := (a: T, b: T) bool {
        return compare(a, b) == 0
    }
    
    not_equal := (a: T, b: T) bool {
        return compare(a, b) != 0
    }
}

// Hashable<T> - Types that can produce a hash value
Hashable := {
    T: type
    
    // Produces a hash value for the given value
    hash: (value: T) u64
    
    // Check if two values are hash-equal
    hash_equal := (a: T, b: T) bool {
        return hash(a) == hash(b)
    }
}

// Serializable<T> - Types that can be serialized/deserialized
Serializable := {
    T: type
    Writer: type
    Reader: type
    
    // Serialize value to a writer
    serialize: (value: T, writer: Ptr<Writer>) Result<void, Error>
    
    // Deserialize value from a reader
    deserialize: (reader: Ptr<Reader>) Result<T, Error>
}

// Cloneable<T> - Types that can be deep copied
Cloneable := {
    T: type
    
    // Create a deep copy of the value
    clone: (value: T) T
}

// Default<T> - Types that have a default value
Default := {
    T: type
    
    // Return the default value for this type
    default: () T
}

// Display<T> - Types that can be formatted as strings
Display := {
    T: type
    
    // Convert value to string representation
    to_string: (value: T) string
}

// ============================================================================
// Behavior Implementation Helpers
// ============================================================================

// Check if a type implements a behavior
implements := <T, B>(type_: T, behavior: B) bool {
    // This would use compile-time reflection to check
    // For now, return false as placeholder
    return false
}

// Require a type to implement a behavior (compile-time check)
requires := <T, B>(type_: T, behavior: B) void {
    // This would be a compile-time assertion
    // The compiler would verify the type implements the behavior
}

// Auto-derive common behaviors for a type
derive := <T>(type_: T, behaviors: []Behavior) void {
    // This would auto-generate implementations for common behaviors
    // like Comparable for structs (field-wise comparison)
    // or Hashable (combining field hashes)
}

// ============================================================================
// Built-in Implementations
// ============================================================================

// Comparable for basic types
i32_comparable := Comparable {
    T: i32
    compare: (a: i32, b: i32) i32 {
        a < b ? 
            | true { return -1 }
            | false {
                a > b ?
                    | true { return 1 }
                    | false { return 0 }
            }
    }
}

i64_comparable := Comparable {
    T: i64
    compare: (a: i64, b: i64) i32 {
        a < b ?
            | true { return -1 }
            | false {
                a > b ?
                    | true { return 1 }
                    | false { return 0 }
            }
    }
}

f64_comparable := Comparable {
    T: f64
    compare: (a: f64, b: f64) i32 {
        a < b ?
            | true { return -1 }
            | false {
                a > b ?
                    | true { return 1 }
                    | false { return 0 }
            }
    }
}

string_comparable := Comparable {
    T: string
    compare: (a: string, b: string) i32 {
        // String comparison would use lexicographic ordering
        // Placeholder implementation
        return 0
    }
}

// Hashable for basic types
i32_hashable := Hashable {
    T: i32
    hash: (value: i32) u64 {
        // Simple hash for i32
        return value as u64
    }
}

i64_hashable := Hashable {
    T: i64
    hash: (value: i64) u64 {
        return value as u64
    }
}

string_hashable := Hashable {
    T: string
    hash: (value: string) u64 {
        // FNV-1a hash implementation would go here
        // Placeholder for now
        return 0
    }
}

// Default for basic types
i32_default := Default {
    T: i32
    default: () i32 { return 0 }
}

i64_default := Default {
    T: i64
    default: () i64 { return 0 }
}

f64_default := Default {
    T: f64
    default: () f64 { return 0.0 }
}

bool_default := Default {
    T: bool
    default: () bool { return false }
}

string_default := Default {
    T: string
    default: () string { return "" }
}

// ============================================================================
// Generic Functions Using Behaviors
// ============================================================================

// Sort a slice using a Comparable behavior
sort := <T>(items: []T, comparable: Comparable<T>) void {
    // Quicksort implementation using the compare function
    // This is a placeholder - real implementation would go here
}

// Find max element using Comparable
max := <T>(items: []T, comparable: Comparable<T>) Option<T> {
    items.len == 0 ?
        | true { return Option.None }
        | false {
            max_val ::= items[0]
            (1..items.len).loop((i) {
                comparable.greater_than(items[i], max_val) ?
                    | true { max_val = items[i] }
                    | false { }
            })
            return Option.Some(max_val)
        }
}

// Create a hash map key using Hashable
hash_key := <K>(key: K, hashable: Hashable<K>) u64 {
    return hashable.hash(key)
}

// ============================================================================
// EXPORTS
// ============================================================================

module.exports := {
    // Core behaviors
    Comparable,
    Hashable,
    Serializable,
    Cloneable,
    Default,
    Display,
    
    // Implementation helpers
    implements,
    requires,
    derive,
    
    // Built-in implementations
    i32_comparable,
    i64_comparable,
    f64_comparable,
    string_comparable,
    i32_hashable,
    i64_hashable,
    string_hashable,
    i32_default,
    i64_default,
    f64_default,
    bool_default,
    string_default,
    
    // Generic functions
    sort,
    max,
    hash_key
}