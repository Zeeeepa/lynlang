// utils.zen - General utility functions and helpers
// Pure Zen implementation without comptime imports

core = @std
string = @std
io = @std
{ Vec, DynVec } = @std
math = @std

// Option type for nullable values
Option<T> = 
    | Some(value: T)
    | None

// Result type for error handling
Result<T, E> = 
    | Ok(value: T)
    | Err(error: E)

// Helper to create Some variant
some = <T>(value: T) Option<T> {
    return Option.Some(value)
}

// Helper to create None variant
none = <T>() Option<T> {
    return Option.None
}

// Helper to create Ok result
ok = <T, E>(value: T) Result<T, E> {
    return Result.Ok(value)
}

// Helper to create Err result
err = <T, E>(error: E) Result<T, E> {
    return Result.Err(error)
}

// Check if Option has value
is_some = <T>(opt: Option<T>) bool {
    opt ? | Some(_) { true }
          | None { false }
}

// Check if Option is None
is_none = <T>(opt: Option<T>) bool {
    return !is_some(opt)
}

// Unwrap Option or panic
unwrap = <T>(opt: Option<T>) T {
    opt ? | Some(value) { value }
          | None { core.panic("Called unwrap on None value") }
}

// Unwrap Option or return default
unwrap_or = <T>(opt: Option<T>, default: T) T {
    opt ? | Some(value) { value }
          | None { default }
}

// Map function over Option
map_option = <T, U>(opt: Option<T>, f: (T) U) Option<U> {
    opt ? | Some(value) { some(f(value)) }
          | None { none<U>() }
}

// Check if Result is Ok
is_ok = <T, E>(result: Result<T, E>) bool {
    result ? | Ok(_) { true }
             | Err(_) { false }
}

// Check if Result is Err
is_err = <T, E>(result: Result<T, E>) bool {
    return !is_ok(result)
}

// Unwrap Result or panic
unwrap_result = <T, E>(result: Result<T, E>) T {
    result ? | Ok(value) { value }
             | Err(e) { core.panic("Called unwrap on Err result") }
}

// Map function over Result
map_result = <T, U, E>(result: Result<T, E>, f: (T) U) Result<U, E> {
    result ? | Ok(value) { ok(f(value)) }
             | Err(e) { err<U, E>(e) }
}

// Defer mechanism for cleanup
Defer: {
    callbacks: DynVec<() void>
}

// Create new defer context
defer_new = () Defer   {
    return Defer {
        callbacks: DynVec.new<() void>()
    }
}

// Add cleanup callback
defer_add = (d: *Defer, callback: () void) void {
    d.callbacks.push(callback)
}

// Execute all deferred callbacks in reverse order
defer_run = (d: *Defer) void   {
    i := d.callbacks.len()
    loop i > 0 {
        i = i - 1
        callback := d.callbacks.get(i)
        callback()
    }
}

// Range type for iteration
Range: {
    start: i32
    end: i32
    step: i32
}

// Create inclusive range
range = (start: i32, end: i32) Range   {
    return Range {
        start: start
        end: end
        step: 1
    }
}

// Create range with custom step
range_step = (start: i32, end: i32, step: i32) Range   {
    return Range {
        start: start
        end: end
        step: step
    }
}

// Iterator for range
range_iter = (r: Range, f: (i32) void) void {
    i := r.start
    loop i <= r.end {
        f(i)
        i = i + r.step
    }
}

// Lazy evaluation wrapper
Lazy<T> = {
    computed: bool
    value: T
    compute: () T
}

// Create lazy value
lazy = <T>(compute: () T) Lazy<T> {
    return Lazy<T> {
        computed: false
        value: T{}
        compute: compute
    }
}

// Force lazy evaluation
force = <T>(l: *Lazy<T>) T {
    if !l.computed {
        l.value = l.compute()
        l.computed = true
    }
    return l.value
}

// Memoization wrapper
Memo<K, V> = {
    cache: HashMap<K, V>
    compute: (K) V
}

// Create memoized function
memoize = <K, V>(compute: (K) V) Memo<K, V> {
    return Memo<K, V> {
        cache: hashmap.new<K, V>()
        compute: compute
    }
}

// Get memoized value
memo_get = <K, V>(m: *Memo<K, V>, key: K) V {
    existing := m.cache.get(key)
    existing ? | Some(value) { value }
              | None {
                  value := m.compute(key)
                  m.cache.insert(key, value)
                  value
              }
}

// Pipe operator helper - compose two functions
pipe = <A, B, C>(f: (A) B, g: (B) C) (A) C {
    return (a: A) C { g(f(a)) }
}

// Compose operator helper - reverse of pipe
compose = <A, B, C>(g: (B) C, f: (A) B) (A) C {
    return (a: A) C { g(f(a)) }
}

// Identity function
identity = <T>(x: T) T {
    return x
}

// Constant function
constant = <T>(value: T) () T {
    return () T { value }
}

// Curry a two-argument function
curry2 = <A, B, C>(f: (A, B) C) (A) (B) C {
    return (a: A) (B) C {
        return (b: B) C { f(a, b) }
    }
}

// Uncurry a curried function
uncurry2 = <A, B, C>(f: (A) (B) C) (A, B) C {
    return (a: A, b: B) C { f(a)(b) }
}

// Apply function n times
repeat = <T>(n: i32, f: (T) T, initial: T) T {
    result := initial
    i := 0
    loop i < n {
        result = f(result)
        i = i + 1
    }
    return result
}

// Tap function for side effects in chains
tap = <T>(value: T, f: (T) void) T {
    f(value)
    return value
}

// Swap two values
swap = <T>(a: *T, b: *T) void {
    temp := *a
    *a = *b
    *b = temp
}

// Clamp value between min and max
clamp = <T>(value: T, min: T, max: T) T {
    value < min ? | true { min }
                  | false { value > max ? | true => max }
                                           | false { value }
}

// Linear interpolation
lerp = (a: f32, b: f32, t: f32) f32   {
    return a + (b - a) * t
}

// Check if value is in range
in_range = <T>(value: T, min: T, max: T) bool {
    return value >= min && value <= max
}

// Get maximum of two values
max = <T>(a: T, b: T) T {
    return a > b ? | true { a }
                   | false { b }
}

// Get minimum of two values
min = <T>(a: T, b: T) T {
    return a < b ? | true { a }
                   | false { b }
}

// Convert degrees to radians
deg_to_rad = (degrees: f32) f32   {
    return degrees * math.PI / 180.0
}

// Convert radians to degrees
rad_to_deg = (radians: f32) f32   {
    return radians * 180.0 / math.PI
}

// Simple hash function for strings
hash_string = (s: string) u32   {
    hash := 5381u32
    i := 0
    loop i < string.len(s) {
        c := string.char_at(s, i)
        hash = ((hash << 5) + hash) + c
        i = i + 1
    }
    return hash
}

// Format time duration in human-readable format
format_duration = (seconds: i64) string   {
    seconds < 60 ? | true { string.format("{ }}s", seconds)
                   | false {
        minutes := seconds / 60
        remaining_seconds := seconds % 60
        
        minutes < 60 ? | true { string.format("{ }}m {}s", minutes, remaining_seconds)
                       | false {
            hours := minutes / 60
            remaining_minutes := minutes % 60
            
            hours < 24 ? | true { string.format("{ }}h {}m", hours, remaining_minutes)
                         | false {
                days := hours / 24
                remaining_hours := hours % 24
                string.format("{}d {}h", days, remaining_hours)
            }
        }
    }
}

// Generate unique ID
next_id := 0u64
unique_id = () u64   {
    id := next_id
    next_id = next_id + 1
    return id
}

// Benchmark function execution time
benchmark = <T>(name: string, f: () T) T {
    start := core.time_ns()
    result := f()
    end := core.time_ns()
    duration := (end - start) / 1_000_000  // Convert to milliseconds
    io.println(string.format("Benchmark '{}': {}ms", name, duration))
    return result
}

// Retry function with exponential backoff
retry = <T, E>(f: () Result<T, E>, max_attempts: i32) Result<T, E> {
    attempt := 0
    delay := 100  // Start with 100ms
    
    loop attempt < max_attempts {
        result := f()
        is_ok(result) ? | true { return result }
                        | false {
            attempt = attempt + 1
            attempt < max_attempts ? | true {
                core.sleep_ms(delay)
                delay = delay * 2  // Exponential backoff
            } | false {}
        }
    }
    
    return f()  // Final attempt
}

// Simple assert for testing
assert = (condition: bool, message: string) void   {
    !condition ? | true { core.panic(string.format("Assertion failed: { }}", message))
                 | false {}
}

// Assert equality for testing
assert_eq = <T>(actual: T, expected: T, message: string) void {
    actual != expected ? | true { core.panic( }
        string.format("Assertion failed: {}. Expected: {:?}, Got: {:?}", 
                     message, expected, actual))
                        | false {}
}

// Timing guard for measuring scope duration
TimingGuard: {
    name: string
    start: u64
}

// Start timing a scope
time_scope = (name: string) TimingGuard   {
    return TimingGuard {
        name: name
        start: core.time_ns()
    }
}

// Finish timing (called automatically via defer)
finish_timing = (guard: TimingGuard) void   {
    end := core.time_ns()
    duration := (end - guard.start) / 1_000_000
    io.println(string.format("'{}' took {}ms", guard.name, duration))
}

// Export all utilities
module.exports = {
    Option, Result,
    some, none, ok, err,
    is_some, is_none, is_ok, is_err,
    unwrap, unwrap_or, unwrap_result,
    map_option, map_result,
    Defer, defer_new, defer_add, defer_run,
    Range, range, range_step, range_iter,
    Lazy, lazy, force,
    Memo, memoize, memo_get,
    pipe, compose, identity, constant,
    curry2, uncurry2,
    repeat, tap, swap,
    clamp, lerp, in_range,
    max, min,
    deg_to_rad, rad_to_deg,
    hash_string, format_duration, unique_id,
    benchmark, retry,
    assert, assert_eq,
    TimingGuard, time_scope, finish_timing
}