// Zen Standard Library: Filesystem Operations (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// chmod, chown, access, truncate, sync, and more

{ compiler } = @std
{ Result } = @std.core.result

// ============================================================================
// Syscall Numbers (x86-64)
// ============================================================================

SYS_CHMOD = 90
SYS_FCHMOD = 91
SYS_CHOWN = 92
SYS_FCHOWN = 93
SYS_LCHOWN = 94
SYS_ACCESS = 21
SYS_FACCESSAT = 269
SYS_TRUNCATE = 76
SYS_FTRUNCATE = 77
SYS_SYNC = 162
SYS_SYNCFS = 306
SYS_FSYNC = 74
SYS_FDATASYNC = 75
SYS_FCHMODAT = 268
SYS_FCHOWNAT = 260
SYS_UTIMENSAT = 280

// ============================================================================
// Constants
// ============================================================================

AT_FDCWD = -100
AT_SYMLINK_NOFOLLOW = 256
AT_EMPTY_PATH = 4096

// Access mode flags
F_OK = 0     // Test existence
R_OK = 4     // Test read permission
W_OK = 2     // Test write permission
X_OK = 1     // Test execute permission

// Special timestamp value
UTIME_NOW = 1073741823   // Set to current time (0x3fffffff)
UTIME_OMIT = 1073741822  // Don't change (0x3ffffffe)

// ============================================================================
// Permission Changes (chmod)
// ============================================================================

// Change file mode bits
chmod = (path: i64, mode: u32) Result<(), i32> {
    result = compiler.syscall2(SYS_CHMOD, path, mode)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Change mode on open file descriptor
fchmod = (fd: i32, mode: u32) Result<(), i32> {
    result = compiler.syscall2(SYS_FCHMOD, fd, mode)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Change mode relative to directory fd
fchmodat = (dirfd: i32, path: i64, mode: u32, flags: i32) Result<(), i32> {
    result = compiler.syscall4(SYS_FCHMODAT, dirfd, path, mode, flags)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// ============================================================================
// Ownership Changes (chown)
// ============================================================================

// Change file owner and group
// Use -1 for uid/gid to leave unchanged
chown = (path: i64, uid: u32, gid: u32) Result<(), i32> {
    result = compiler.syscall3(SYS_CHOWN, path, uid, gid)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Change ownership on open file descriptor
fchown = (fd: i32, uid: u32, gid: u32) Result<(), i32> {
    result = compiler.syscall3(SYS_FCHOWN, fd, uid, gid)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Change ownership of symlink itself (not target)
lchown = (path: i64, uid: u32, gid: u32) Result<(), i32> {
    result = compiler.syscall3(SYS_LCHOWN, path, uid, gid)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Change ownership relative to directory fd
fchownat = (dirfd: i32, path: i64, uid: u32, gid: u32, flags: i32) Result<(), i32> {
    result = compiler.syscall5(SYS_FCHOWNAT, dirfd, path, uid, gid, flags)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// ============================================================================
// Access Checks
// ============================================================================

// Check file accessibility
// mode: F_OK, R_OK, W_OK, X_OK (can be ORed together)
access = (path: i64, mode: i32) Result<(), i32> {
    result = compiler.syscall2(SYS_ACCESS, path, mode)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Check access relative to directory fd
faccessat = (dirfd: i32, path: i64, mode: i32, flags: i32) Result<(), i32> {
    result = compiler.syscall4(SYS_FACCESSAT, dirfd, path, mode, flags)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Check if file exists
exists = (path: i64) bool {
    result = access(path, F_OK)
    result ? {
        | Ok(_) { return true }
        | Err(_) { return false }
    }
}

// Check if file is readable
is_readable = (path: i64) bool {
    result = access(path, R_OK)
    result ? {
        | Ok(_) { return true }
        | Err(_) { return false }
    }
}

// Check if file is writable
is_writable = (path: i64) bool {
    result = access(path, W_OK)
    result ? {
        | Ok(_) { return true }
        | Err(_) { return false }
    }
}

// Check if file is executable
is_executable = (path: i64) bool {
    result = access(path, X_OK)
    result ? {
        | Ok(_) { return true }
        | Err(_) { return false }
    }
}

// ============================================================================
// File Truncation
// ============================================================================

// Truncate file to specified length
truncate = (path: i64, length: i64) Result<(), i32> {
    result = compiler.syscall2(SYS_TRUNCATE, path, length)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Truncate open file descriptor
ftruncate = (fd: i32, length: i64) Result<(), i32> {
    result = compiler.syscall2(SYS_FTRUNCATE, fd, length)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// ============================================================================
// Synchronization
// ============================================================================

// Sync all filesystems
sync = () void {
    compiler.syscall0(SYS_SYNC)
}

// Sync filesystem containing fd
syncfs = (fd: i32) Result<(), i32> {
    result = compiler.syscall1(SYS_SYNCFS, fd)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Sync file data and metadata to disk
fsync = (fd: i32) Result<(), i32> {
    result = compiler.syscall1(SYS_FSYNC, fd)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Sync only file data (not metadata)
fdatasync = (fd: i32) Result<(), i32> {
    result = compiler.syscall1(SYS_FDATASYNC, fd)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// ============================================================================
// Timestamps
// ============================================================================

Timespec: {
    tv_sec: i64,
    tv_nsec: i64
}

// Update file access and modification times
// times[0] = atime, times[1] = mtime
// Use UTIME_NOW or UTIME_OMIT for special handling
utimensat = (dirfd: i32, path: i64, times_ptr: i64, flags: i32) Result<(), i32> {
    result = compiler.syscall4(SYS_UTIMENSAT, dirfd, path, times_ptr, flags)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Touch file (update timestamps to now)
touch = (path: i64) Result<(), i32> {
    times: [2]Timespec = [
        Timespec { tv_sec: 0, tv_nsec: UTIME_NOW },
        Timespec { tv_sec: 0, tv_nsec: UTIME_NOW }
    ]
    return utimensat(AT_FDCWD, path, compiler.ptr_to_int(&times.ref() as RawPtr<u8>), 0)
}

// Touch via file descriptor (update timestamps to now)
ftouch = (fd: i32) Result<(), i32> {
    times: [2]Timespec = [
        Timespec { tv_sec: 0, tv_nsec: UTIME_NOW },
        Timespec { tv_sec: 0, tv_nsec: UTIME_NOW }
    ]
    return utimensat(fd, 0, compiler.ptr_to_int(&times.ref() as RawPtr<u8>), AT_EMPTY_PATH)
}
