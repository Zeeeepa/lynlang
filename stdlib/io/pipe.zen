// Zen Standard Library: Pipe I/O (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics

{ compiler } = @std
{ Result } = @std.core.result
{ SYS_PIPE2, SYS_READ, SYS_WRITE, SYS_CLOSE, SYS_FCNTL } = @std.sys.syscall

// Flags
O_CLOEXEC = 524288
O_NONBLOCK = 2048
F_GETFL = 3
F_SETFL = 4

PipeError: { code: i32, message: StaticString }

PipeError.from_errno = (errno: i64) PipeError {
    code = (0 - errno) as i32
    return PipeError { code: code, message: "Pipe error" }
}

Pipe: { read_fd: i32, write_fd: i32 }

Pipe.new = () Result<Pipe, PipeError> {
    fds: [2]i32 = [0, 0]
    result = compiler.syscall2(SYS_PIPE2, compiler.ptr_to_int(&fds.ref()), O_CLOEXEC)
    result < 0 ? { return Result.Err(PipeError.from_errno(result)) }
    return Result.Ok(Pipe { read_fd: fds[0], write_fd: fds[1] })
}

Pipe.read = (self: MutPtr<Pipe>, buf: Ptr<u8>, len: i64) Result<i64, PipeError> {
    result = compiler.syscall3(SYS_READ, self.val.read_fd, compiler.ptr_to_int(buf), len)
    result < 0 ? { return Result.Err(PipeError.from_errno(result)) }
    return Result.Ok(result)
}

Pipe.write = (self: MutPtr<Pipe>, buf: Ptr<u8>, len: i64) Result<i64, PipeError> {
    result = compiler.syscall3(SYS_WRITE, self.val.write_fd, compiler.ptr_to_int(buf), len)
    result < 0 ? { return Result.Err(PipeError.from_errno(result)) }
    return Result.Ok(result)
}

Pipe.close = (self: MutPtr<Pipe>) void {
    compiler.syscall1(SYS_CLOSE, self.val.read_fd)
    compiler.syscall1(SYS_CLOSE, self.val.write_fd)
}
