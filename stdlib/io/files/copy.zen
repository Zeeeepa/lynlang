// Zen Standard Library: File Copy Operations (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// High-performance copy using copy_file_range, sendfile

{ compiler } = @std
{ Result } = @std.core.result
{ Allocator } = @std.memory.allocator

// ============================================================================
// Syscall Numbers (x86-64)
// ============================================================================

SYS_SENDFILE = 40
SYS_COPY_FILE_RANGE = 326

// ============================================================================
// copy_file_range - Kernel-space copy between files
// ============================================================================
// Most efficient for file-to-file copy (no user-space buffering)
// Works across filesystems on Linux 5.3+

// Copy data between two file descriptors using kernel copy
// off_in/off_out: if not 0, pointer to offset (updated after copy)
// Returns number of bytes copied
copy_file_range = (fd_in: i32, off_in: i64, fd_out: i32, off_out: i64, len: usize, flags: u32) Result<usize, i32> {
    result = compiler.syscall6(
        SYS_COPY_FILE_RANGE,
        fd_in,
        off_in,
        fd_out,
        off_out,
        len,
        flags
    )
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(result as usize)
}

// Simple file-to-file copy using copy_file_range
// Copies entire file from current position
copy_fd = (src_fd: i32, dst_fd: i32, len: usize) Result<usize, i32> {
    total: usize = 0
    remaining = len

    remaining > 0 ? {
        // Copy in chunks (kernel may limit per-call)
        chunk = remaining
        chunk > 1073741824 ? { chunk = 1073741824 }  // Max 1GB per call

        result = copy_file_range(src_fd, 0, dst_fd, 0, chunk, 0)
        result ? {
            | Ok(n) {
                n == 0 ? { remaining = 0 }  // EOF
                n > 0 ? {
                    total = total + n
                    remaining = remaining - n
                }
            }
            | Err(e) {
                total > 0 ? { return Result.Ok(total) }
                return Result.Err(e)
            }
        }
    }

    return Result.Ok(total)
}

// ============================================================================
// sendfile - Zero-copy from file to socket
// ============================================================================
// Ideal for serving files over network

// Send file data to socket/pipe without user-space copy
// offset: if not 0, pointer to offset (updated after send)
// Returns number of bytes sent
sendfile = (out_fd: i32, in_fd: i32, offset: i64, count: usize) Result<usize, i32> {
    result = compiler.syscall4(SYS_SENDFILE, out_fd, in_fd, offset, count)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(result as usize)
}

// Send entire file to socket
sendfile_all = (socket_fd: i32, file_fd: i32, len: usize) Result<usize, i32> {
    total: usize = 0
    remaining = len

    remaining > 0 ? {
        result = sendfile(socket_fd, file_fd, 0, remaining)
        result ? {
            | Ok(n) {
                n == 0 ? { remaining = 0 }  // Done
                n > 0 ? {
                    total = total + n
                    remaining = remaining - n
                }
            }
            | Err(e) {
                // EAGAIN means try again (non-blocking socket)
                e == -11 ? { }  // Continue
                e != -11 ? {
                    total > 0 ? { return Result.Ok(total) }
                    return Result.Err(e)
                }
            }
        }
    }

    return Result.Ok(total)
}

// ============================================================================
// Fallback Copy (user-space buffer)
// ============================================================================
// For when copy_file_range/sendfile aren't available

SYS_READ = 0
SYS_WRITE = 1

// Copy between fds using user-space buffer
copy_fd_buffered = (src_fd: i32, dst_fd: i32, buf: i64, buf_size: usize) Result<usize, i32> {
    total: usize = 0

    done = false
    done == false ? {
        // Read chunk
        nread = compiler.syscall3(SYS_READ, src_fd, buf, buf_size)
        nread < 0 ? { return Result.Err(nread as i32) }
        nread == 0 ? { done = true }

        nread > 0 ? {
            // Write all read data
            written: usize = 0
            written < nread as usize ? {
                nwrite = compiler.syscall3(
                    SYS_WRITE,
                    dst_fd,
                    buf + written as i64,
                    nread as usize - written
                )
                nwrite < 0 ? { return Result.Err(nwrite as i32) }
                nwrite == 0 ? { return Result.Err(-28) }  // ENOSPC
                written = written + nwrite as usize
            }
            total = total + nread as usize
        }
    }

    return Result.Ok(total)
}

// ============================================================================
// High-level Copy with Automatic Method Selection
// ============================================================================

// Copy between fds, trying most efficient method first
copy_smart = (src_fd: i32, dst_fd: i32, len: usize, allocator: Allocator) Result<usize, i32> {
    // Try copy_file_range first (most efficient)
    result = copy_fd(src_fd, dst_fd, len)
    result ? {
        | Ok(n) { return Result.Ok(n) }
        | Err(e) {
            // EXDEV (-18): different filesystems on older kernel
            // EINVAL (-22): not supported for these fds
            // Fall back to buffered copy
            (e == -18) | (e == -22) | (e == -38) ? {
                // Allocate buffer
                buf_size: usize = 65536  // 64KB
                buf = allocator.allocate(buf_size)
                buf == 0 ? { return Result.Err(-12) }  // ENOMEM

                copy_result = copy_fd_buffered(src_fd, dst_fd, buf, buf_size)
                allocator.deallocate(buf, buf_size)
                return copy_result
            }
            return Result.Err(e)
        }
    }
}
