// Zen Standard Library: File I/O (Syscall-based)
// Direct syscall implementation for Linux x86-64
// No FFI - uses compiler.syscall* intrinsics

{ compiler } = @std
{ Result } = @std.core.result
{ Option } = @std.core.option
{ String } = @std.collections.string
{ Allocator } = @std.memory.allocator
{ SYS_READ, SYS_WRITE, SYS_OPEN, SYS_CLOSE, SYS_STAT, SYS_FSTAT,
  SYS_LSEEK, SYS_MMAP, SYS_MUNMAP, SYS_ACCESS, SYS_MKDIR, SYS_RMDIR,
  SYS_UNLINK, SYS_RENAME, SYS_GETCWD, SYS_CHDIR } = @std.sys.syscall

// ============================================================================
// Open Flags (Linux)
// ============================================================================

O_RDONLY = 0
O_WRONLY = 1
O_RDWR = 2
O_CREAT = 64      // 0100 octal
O_EXCL = 128      // 0200 octal
O_TRUNC = 512     // 01000 octal
O_APPEND = 1024   // 02000 octal

// File mode permissions
S_IRWXU = 448     // 0700 - owner rwx
S_IRUSR = 256     // 0400 - owner read
S_IWUSR = 128     // 0200 - owner write
S_IXUSR = 64      // 0100 - owner execute
S_IRGRP = 32      // 040 - group read
S_IWGRP = 16      // 020 - group write
S_IROTH = 4       // 04 - other read

// Common permission combos
MODE_644 = 420    // rw-r--r--
MODE_755 = 493    // rwxr-xr-x

// Seek positions
SEEK_SET = 0
SEEK_CUR = 1
SEEK_END = 2

// Access modes
F_OK = 0  // File exists
R_OK = 4  // Read permission
W_OK = 2  // Write permission
X_OK = 1  // Execute permission

// ============================================================================
// FileDescriptor - Raw file handle
// ============================================================================

FileDescriptor: {
    fd: i32
}

// Create from raw fd
FileDescriptor.from_raw = (fd: i32) FileDescriptor {
    return FileDescriptor { fd: fd }
}

// Standard file descriptors
STDIN = FileDescriptor { fd: 0 }
STDOUT = FileDescriptor { fd: 1 }
STDERR = FileDescriptor { fd: 2 }

// ============================================================================
// Low-Level Syscall Wrappers
// ============================================================================

// Open file and return file descriptor
// Returns negative errno on failure
sys_open = (path_ptr: i64, flags: i32, mode: i32) i64 {
    return compiler.syscall3(SYS_OPEN, path_ptr, flags, mode)
}

// Close file descriptor
sys_close = (fd: i32) i64 {
    return compiler.syscall1(SYS_CLOSE, fd)
}

// Read from file descriptor
sys_read = (fd: i32, buf_ptr: i64, count: usize) i64 {
    return compiler.syscall3(SYS_READ, fd, buf_ptr, count)
}

// Write to file descriptor
sys_write = (fd: i32, buf_ptr: i64, count: usize) i64 {
    return compiler.syscall3(SYS_WRITE, fd, buf_ptr, count)
}

// Seek in file
sys_lseek = (fd: i32, offset: i64, whence: i32) i64 {
    return compiler.syscall3(SYS_LSEEK, fd, offset, whence)
}

// Check file access
sys_access = (path_ptr: i64, mode: i32) i64 {
    return compiler.syscall2(SYS_ACCESS, path_ptr, mode)
}

// Create directory
sys_mkdir = (path_ptr: i64, mode: i32) i64 {
    return compiler.syscall2(SYS_MKDIR, path_ptr, mode)
}

// Remove directory
sys_rmdir = (path_ptr: i64) i64 {
    return compiler.syscall1(SYS_RMDIR, path_ptr)
}

// Unlink (delete) file
sys_unlink = (path_ptr: i64) i64 {
    return compiler.syscall1(SYS_UNLINK, path_ptr)
}

// Rename file
sys_rename = (old_ptr: i64, new_ptr: i64) i64 {
    return compiler.syscall2(SYS_RENAME, old_ptr, new_ptr)
}

// Get current working directory
sys_getcwd = (buf_ptr: i64, size: usize) i64 {
    return compiler.syscall2(SYS_GETCWD, buf_ptr, size)
}

// Change directory
sys_chdir = (path_ptr: i64) i64 {
    return compiler.syscall1(SYS_CHDIR, path_ptr)
}

// ============================================================================
// Helper: Convert String to null-terminated C string
// ============================================================================

// Allocate a null-terminated C string from a Zen String
// Caller must deallocate with compiler.raw_deallocate
string_to_cstr = (s: String, allocator: Allocator) i64 {
    len = s.len()
    // Allocate space for string + null terminator
    ptr = allocator.allocate(len + 1)

    // Copy string data
    src_ptr = s.data.addr()
    compiler.memcpy(ptr, src_ptr, len)

    // Add null terminator
    compiler.store<u8>(compiler.gep(ptr, len), 0)

    return ptr
}

// Free C string allocated by string_to_cstr
free_cstr = (ptr: i64, len: usize, allocator: Allocator) void {
    allocator.deallocate(ptr, len + 1)
}

// ============================================================================
// File Operations (High-Level)
// ============================================================================

// I/O Error type
IoError: {
    code: i32,
    message: String
}

// Helper: Create error from errno
errno_to_error = (errno: i64, allocator: Allocator) IoError {
    // Convert negative errno to positive
    code = 0 - errno

    // Simple error messages for common errors
    msg = code ?
        | 1 { String.from("Operation not permitted", allocator) }
        | 2 { String.from("No such file or directory", allocator) }
        | 9 { String.from("Bad file descriptor", allocator) }
        | 13 { String.from("Permission denied", allocator) }
        | 17 { String.from("File exists", allocator) }
        | 20 { String.from("Not a directory", allocator) }
        | 21 { String.from("Is a directory", allocator) }
        | 28 { String.from("No space left on device", allocator) }
        | _ { String.from("Unknown error", allocator) }

    return IoError { code: code, message: msg }
}

// Open file for reading
// Returns file descriptor on success, error on failure
open_read = (path: String, allocator: Allocator) Result<FileDescriptor, IoError> {
    cstr = string_to_cstr(path, allocator)
    result = sys_open(cstr, O_RDONLY, 0)
    free_cstr(cstr, path.len(), allocator)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(FileDescriptor.from_raw(result)) }
}

// Open file for writing (create/truncate)
open_write = (path: String, allocator: Allocator) Result<FileDescriptor, IoError> {
    cstr = string_to_cstr(path, allocator)
    flags = O_WRONLY | O_CREAT | O_TRUNC
    result = sys_open(cstr, flags, MODE_644)
    free_cstr(cstr, path.len(), allocator)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(FileDescriptor.from_raw(result)) }
}

// Open file for appending
open_append = (path: String, allocator: Allocator) Result<FileDescriptor, IoError> {
    cstr = string_to_cstr(path, allocator)
    flags = O_WRONLY | O_CREAT | O_APPEND
    result = sys_open(cstr, flags, MODE_644)
    free_cstr(cstr, path.len(), allocator)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(FileDescriptor.from_raw(result)) }
}

// Open file for read/write
open_readwrite = (path: String, allocator: Allocator) Result<FileDescriptor, IoError> {
    cstr = string_to_cstr(path, allocator)
    flags = O_RDWR | O_CREAT
    result = sys_open(cstr, flags, MODE_644)
    free_cstr(cstr, path.len(), allocator)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(FileDescriptor.from_raw(result)) }
}

// Close file
close = (fd: FileDescriptor, allocator: Allocator) Result<void, IoError> {
    result = sys_close(fd.fd)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(()) }
}

// Read from file into buffer
// Returns number of bytes read
read = (fd: FileDescriptor, buf: i64, count: usize, allocator: Allocator) Result<usize, IoError> {
    result = sys_read(fd.fd, buf, count)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(result) }
}

// Write buffer to file
// Returns number of bytes written
write = (fd: FileDescriptor, buf: i64, count: usize, allocator: Allocator) Result<usize, IoError> {
    result = sys_write(fd.fd, buf, count)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(result) }
}

// Seek in file
seek = (fd: FileDescriptor, offset: i64, whence: i32, allocator: Allocator) Result<i64, IoError> {
    result = sys_lseek(fd.fd, offset, whence)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(result) }
}

// Get file size
file_size = (fd: FileDescriptor, allocator: Allocator) Result<usize, IoError> {
    // Save current position
    current_pos = sys_lseek(fd.fd, 0, SEEK_CUR)
    current_pos < 0 ?
        | true { return Result.Err(errno_to_error(current_pos, allocator)) }
        | false { }

    // Seek to end
    size = sys_lseek(fd.fd, 0, SEEK_END)
    size < 0 ?
        | true { return Result.Err(errno_to_error(size, allocator)) }
        | false { }

    // Restore position
    _ = sys_lseek(fd.fd, current_pos, SEEK_SET)

    return Result.Ok(size)
}

// ============================================================================
// Directory Operations
// ============================================================================

// Check if file exists
file_exists = (path: String, allocator: Allocator) bool {
    cstr = string_to_cstr(path, allocator)
    result = sys_access(cstr, F_OK)
    free_cstr(cstr, path.len(), allocator)
    return result == 0
}

// Create directory
mkdir = (path: String, allocator: Allocator) Result<void, IoError> {
    cstr = string_to_cstr(path, allocator)
    result = sys_mkdir(cstr, MODE_755)
    free_cstr(cstr, path.len(), allocator)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(()) }
}

// Remove directory
rmdir = (path: String, allocator: Allocator) Result<void, IoError> {
    cstr = string_to_cstr(path, allocator)
    result = sys_rmdir(cstr)
    free_cstr(cstr, path.len(), allocator)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(()) }
}

// Delete file
unlink = (path: String, allocator: Allocator) Result<void, IoError> {
    cstr = string_to_cstr(path, allocator)
    result = sys_unlink(cstr)
    free_cstr(cstr, path.len(), allocator)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(()) }
}

// Rename file
rename = (old_path: String, new_path: String, allocator: Allocator) Result<void, IoError> {
    old_cstr = string_to_cstr(old_path, allocator)
    new_cstr = string_to_cstr(new_path, allocator)
    result = sys_rename(old_cstr, new_cstr)
    free_cstr(old_cstr, old_path.len(), allocator)
    free_cstr(new_cstr, new_path.len(), allocator)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(()) }
}

// Get current working directory
getcwd = (allocator: Allocator) Result<String, IoError> {
    // Allocate buffer for path (max 4096 on Linux)
    buf_size = 4096
    buf = allocator.allocate(buf_size)

    result = sys_getcwd(buf, buf_size)

    result == 0 ?
        | true {
            allocator.deallocate(buf, buf_size)
            return Result.Err(errno_to_error(-1, allocator))
        }
        | false {
            // Find null terminator to get actual length
            len = 0
            loop {
                b = compiler.load<u8>(compiler.gep(buf, len))
                b == 0 ?
                    | true {
                        str = String.from_ptr(buf, len, allocator)
                        allocator.deallocate(buf, buf_size)
                        return Result.Ok(str)
                    }
                    | false { len = len + 1 }
                len >= buf_size ?
                    | true {
                        allocator.deallocate(buf, buf_size)
                        return Result.Err(errno_to_error(-36, allocator)) // ENAMETOOLONG
                    }
                    | false { }
            }
            return Result.Err(errno_to_error(-1, allocator))
        }
}

// Change current directory
chdir = (path: String, allocator: Allocator) Result<void, IoError> {
    cstr = string_to_cstr(path, allocator)
    result = sys_chdir(cstr)
    free_cstr(cstr, path.len(), allocator)

    result < 0 ?
        | true { return Result.Err(errno_to_error(result, allocator)) }
        | false { return Result.Ok(()) }
}

// ============================================================================
// Convenience Functions
// ============================================================================

// Read entire file as bytes
read_file = (path: String, allocator: Allocator) Result<Vec<u8>, IoError> {
    // Open file
    fd_result = open_read(path, allocator)
    fd_result ?
        | Err(e) { return Result.Err(e) }
        | Ok(fd) {
            // Get file size
            size_result = file_size(fd, allocator)
            size_result ?
                | Err(e) {
                    _ = close(fd, allocator)
                    return Result.Err(e)
                }
                | Ok(size) {
                    // Allocate buffer
                    buf = allocator.allocate(size)

                    // Read file
                    read_result = read(fd, buf, size, allocator)
                    _ = close(fd, allocator)

                    read_result ?
                        | Err(e) {
                            allocator.deallocate(buf, size)
                            return Result.Err(e)
                        }
                        | Ok(bytes_read) {
                            // Create Vec from buffer
                            vec = Vec<u8>.from_ptr(buf, bytes_read, allocator)
                            return Result.Ok(vec)
                        }
                }
        }
}

// Write bytes to file
write_file = (path: String, data: Vec<u8>, allocator: Allocator) Result<void, IoError> {
    // Open file for writing
    fd_result = open_write(path, allocator)
    fd_result ?
        | Err(e) { return Result.Err(e) }
        | Ok(fd) {
            // Write data
            buf = data.data.addr()
            write_result = write(fd, buf, data.len(), allocator)
            _ = close(fd, allocator)

            write_result ?
                | Err(e) { return Result.Err(e) }
                | Ok(_) { return Result.Ok(()) }
        }
}
