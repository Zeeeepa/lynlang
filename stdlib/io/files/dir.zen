// Zen Standard Library: Directory Operations (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// mkdir, rmdir, getdents for directory manipulation

{ compiler } = @std
{ Result } = @std.core.result
{ Option } = @std.core.option
{ Allocator } = @std.memory.allocator

// ============================================================================
// Syscall Numbers (x86-64)
// ============================================================================

SYS_MKDIR = 83
SYS_RMDIR = 84
SYS_GETDENTS64 = 217
SYS_OPENAT = 257
SYS_CLOSE = 3

// ============================================================================
// Constants
// ============================================================================

AT_FDCWD = -100          // Use current working directory
O_RDONLY = 0
O_DIRECTORY = 65536      // Must be a directory (0o200000)
O_CLOEXEC = 524288       // Close on exec (0o2000000)

// Default directory permissions: rwxr-xr-x (0755)
DEFAULT_DIR_MODE = 493

// ============================================================================
// Directory Entry (matches Linux dirent64)
// ============================================================================

DirEntry: {
    d_ino: u64,       // Inode number
    d_off: i64,       // Offset to next entry
    d_reclen: u16,    // Length of this entry
    d_type: u8,       // File type
    d_name: i64       // Pointer to name (null-terminated, variable length)
}

// File type constants (from d_type)
DT_UNKNOWN = 0
DT_FIFO = 1
DT_CHR = 2
DT_DIR = 4
DT_BLK = 6
DT_REG = 8
DT_LNK = 10
DT_SOCK = 12

// ============================================================================
// Directory Creation/Removal
// ============================================================================

// Create a directory
mkdir = (path_ptr: i64, mode: u32) Result<(), i32> {
    result = compiler.syscall2(SYS_MKDIR, path_ptr, mode)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// Create a directory with default permissions (0755)
mkdir_default = (path_ptr: i64) Result<(), i32> {
    return mkdir(path_ptr, DEFAULT_DIR_MODE)
}

// Create directory and all parent directories
// Returns Ok if directory already exists
mkdir_all = (path_ptr: i64, mode: u32, allocator: Allocator) Result<(), i32> {
    // Try to create directly first
    result = mkdir(path_ptr, mode)
    result ? {
        | Ok(_) { return Result.Ok(()) }
        | Err(e) {
            // EEXIST (-17) means already exists - that's ok
            e == -17 ? { return Result.Ok(()) }
            // ENOENT (-2) means parent doesn't exist - need to create it
            e != -2 ? { return Result.Err(e) }
        }
    }

    // Find the path length
    len: usize = 0
    len < 4096 ? {
        c = compiler.load<u8>(compiler.int_to_ptr(path_ptr + len as i64))
        c == 0 ? { len = 4096 }  // Break
        c != 0 ? { len = len + 1 }
    }

    // Work backwards to find last separator
    i = len
    i > 0 ? {
        i = i - 1
        c = compiler.load<u8>(compiler.int_to_ptr(path_ptr + i as i64))
        c == 47 ? {  // '/'
            // Allocate buffer for parent path
            parent = allocator.allocate(i + 1)
            compiler.memcpy(compiler.int_to_ptr(parent), compiler.int_to_ptr(path_ptr), i)
            compiler.store<u8>(compiler.int_to_ptr(parent + i as i64), 0)

            // Recursively create parent
            parent_result = mkdir_all(parent, mode, allocator)
            allocator.deallocate(parent, i + 1)

            parent_result ? {
                | Err(e) { return Result.Err(e) }
                | Ok(_) { }
            }

            // Now create our directory
            return mkdir(path_ptr, mode)
        }
    }

    return Result.Err(-2)  // ENOENT - no parent found
}

// Remove an empty directory
rmdir = (path_ptr: i64) Result<(), i32> {
    result = compiler.syscall1(SYS_RMDIR, path_ptr)
    result < 0 ? { return Result.Err(result as i32) }
    return Result.Ok(())
}

// ============================================================================
// Directory Reading
// ============================================================================

// Directory handle for iteration
Dir: {
    fd: i32,
    buf: i64,           // Buffer for getdents
    buf_size: usize,
    buf_pos: usize,     // Current position in buffer
    buf_len: usize,     // Valid bytes in buffer
    allocator: Allocator
}

// Open a directory for reading
Dir.open = (path_ptr: i64, allocator: Allocator) Result<Dir, i32> {
    // Open with O_DIRECTORY to ensure it's a directory
    fd = compiler.syscall4(SYS_OPENAT, AT_FDCWD, path_ptr, O_RDONLY | O_DIRECTORY | O_CLOEXEC, 0)
    fd < 0 ? { return Result.Err(fd as i32) }

    // Allocate read buffer (4KB)
    buf_size: usize = 4096
    buf = allocator.allocate(buf_size)
    buf == 0 ? {
        compiler.syscall1(SYS_CLOSE, fd)
        return Result.Err(-12)  // ENOMEM
    }

    dir = Dir {
        fd: fd as i32,
        buf: buf,
        buf_size: buf_size,
        buf_pos: 0,
        buf_len: 0,
        allocator: allocator
    }

    return Result.Ok(dir)
}

// Read next directory entry
Dir.next = (self: MutPtr<Dir>) Option<DirEntry> {
    // Need to read more entries?
    self.val.buf_pos >= self.val.buf_len ? {
        nread = compiler.syscall3(SYS_GETDENTS64, self.val.fd, self.val.buf, self.val.buf_size)
        nread <= 0 ? { return Option.None }
        self.val.buf_len = nread as usize
        self.val.buf_pos = 0
    }

    // Parse entry at current position
    entry_ptr = self.val.buf + self.val.buf_pos as i64

    d_ino = compiler.load<u64>(compiler.int_to_ptr(entry_ptr))
    d_off = compiler.load<i64>(compiler.int_to_ptr(entry_ptr + 8))
    d_reclen = compiler.load<u16>(compiler.int_to_ptr(entry_ptr + 16))
    d_type = compiler.load<u8>(compiler.int_to_ptr(entry_ptr + 18))
    d_name = entry_ptr + 19  // Name starts at offset 19

    entry = DirEntry {
        d_ino: d_ino,
        d_off: d_off,
        d_reclen: d_reclen,
        d_type: d_type,
        d_name: d_name
    }

    // Advance position
    self.val.buf_pos = self.val.buf_pos + d_reclen as usize

    return Option.Some(entry)
}

// Close directory
Dir.close = (self: MutPtr<Dir>) void {
    compiler.syscall1(SYS_CLOSE, self.val.fd)
    self.val.allocator.deallocate(self.val.buf, self.val.buf_size)
    self.val.fd = -1
}

// ============================================================================
// Entry Helpers
// ============================================================================

DirEntry.is_dir = (self: DirEntry) bool {
    return self.d_type == DT_DIR
}

DirEntry.is_file = (self: DirEntry) bool {
    return self.d_type == DT_REG
}

DirEntry.is_symlink = (self: DirEntry) bool {
    return self.d_type == DT_LNK
}

DirEntry.is_dot = (self: DirEntry) bool {
    // Check for "." or ".."
    c0 = compiler.load<u8>(compiler.int_to_ptr(self.d_name))
    c0 != 46 ? { return false }  // Not '.'

    c1 = compiler.load<u8>(compiler.int_to_ptr(self.d_name + 1))
    c1 == 0 ? { return true }    // "."

    c1 != 46 ? { return false }  // Not ".."
    c2 = compiler.load<u8>(compiler.int_to_ptr(self.d_name + 2))
    return c2 == 0               // ".."
}

// Get name length
DirEntry.name_len = (self: DirEntry) usize {
    len: usize = 0
    len < 256 ? {
        c = compiler.load<u8>(compiler.int_to_ptr(self.d_name + len as i64))
        c == 0 ? { return len }
        len = len + 1
    }
    return len
}
