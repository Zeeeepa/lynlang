// Zen Standard Library: splice/tee/vmsplice (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Zero-copy data transfer between file descriptors

{ compiler } = @std
{ Result } = @std.core.result

// ============================================================================
// Linux x86-64 Syscall Numbers
// ============================================================================

SYS_SPLICE = 275
SYS_TEE = 276
SYS_VMSPLICE = 278
SYS_SENDFILE = 40
SYS_COPY_FILE_RANGE = 326
SYS_PIPE2 = 293

// ============================================================================
// Splice Flags
// ============================================================================

SPLICE_F_MOVE = 1        // Move pages instead of copying
SPLICE_F_NONBLOCK = 2    // Non-blocking operation
SPLICE_F_MORE = 4        // More data will follow
SPLICE_F_GIFT = 8        // Gift pages to kernel (vmsplice only)

// ============================================================================
// splice - Move data between two file descriptors
// ============================================================================
// Zero-copy data movement - at least one fd must be a pipe.
//
// Common patterns:
//   socket -> pipe -> file   (network to disk)
//   file -> pipe -> socket   (disk to network)
//
// Returns number of bytes transferred

splice = (fd_in: i32, off_in: i64, fd_out: i32, off_out: i64, len: usize, flags: u32) Result<usize, i32> {
    // off_in and off_out are pointers to offsets (or 0 for current position)
    result = compiler.syscall6(
        SYS_SPLICE,
        fd_in,
        off_in,
        fd_out,
        off_out,
        len,
        flags
    )
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as usize)
}

// Splice from current position (no offset tracking)
splice_simple = (fd_in: i32, fd_out: i32, len: usize, flags: u32) Result<usize, i32> {
    return splice(fd_in, 0, fd_out, 0, len, flags)
}

// ============================================================================
// tee - Duplicate pipe data
// ============================================================================
// Copies data from one pipe to another without consuming it.
// The original pipe still has the data after tee.
//
// Useful for:
//   - Logging data passing through a pipe
//   - Fan-out to multiple consumers

tee = (fd_in: i32, fd_out: i32, len: usize, flags: u32) Result<usize, i32> {
    result = compiler.syscall4(SYS_TEE, fd_in, fd_out, len, flags)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as usize)
}

// ============================================================================
// vmsplice - Splice user pages to pipe
// ============================================================================
// Zero-copy transfer of user memory to a pipe.
// The iovec describes memory regions to splice.

// iovec structure
IoVec: {
    base: i64,   // Pointer to data
    len: usize   // Length of data
}

vmsplice = (fd: i32, iov: i64, nr_segs: usize, flags: u32) Result<usize, i32> {
    result = compiler.syscall4(SYS_VMSPLICE, fd, iov, nr_segs, flags)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as usize)
}

// Simple single-buffer vmsplice
vmsplice_buf = (fd: i32, buf: i64, len: usize, flags: u32) Result<usize, i32> {
    // Create iovec on stack
    iov_ptr = compiler.raw_allocate(16)  // sizeof(IoVec)
    compiler.store<i64>(iov_ptr, buf)
    compiler.store<u64>(compiler.gep(iov_ptr, 8), len as u64)

    result = vmsplice(fd, compiler.ptr_to_int(iov_ptr), 1, flags)

    compiler.raw_deallocate(iov_ptr, 16)
    return result
}

// ============================================================================
// sendfile - Send file to socket
// ============================================================================
// Efficient file-to-socket transfer without user-space copy.
// Commonly used for serving static files over HTTP.

sendfile = (out_fd: i32, in_fd: i32, offset: i64, count: usize) Result<usize, i32> {
    // offset is a pointer to the offset (or 0 to use current position)
    result = compiler.syscall4(SYS_SENDFILE, out_fd, in_fd, offset, count)
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as usize)
}

// Send file from current position
sendfile_simple = (out_fd: i32, in_fd: i32, count: usize) Result<usize, i32> {
    return sendfile(out_fd, in_fd, 0, count)
}

// ============================================================================
// copy_file_range - Copy between files
// ============================================================================
// Server-side copy between files, potentially with reflink (CoW).
// Works on same filesystem, possibly cross-filesystem.

copy_file_range = (fd_in: i32, off_in: i64, fd_out: i32, off_out: i64, len: usize, flags: u32) Result<usize, i32> {
    result = compiler.syscall6(
        SYS_COPY_FILE_RANGE,
        fd_in,
        off_in,
        fd_out,
        off_out,
        len,
        flags
    )
    result < 0 ? { return Result.Err((0 - result) as i32) }
    return Result.Ok(result as usize)
}

// ============================================================================
// Pipe - Helper for splice operations
// ============================================================================
// Creates a pipe for use with splice/tee/vmsplice

Pipe: {
    read_fd: i32,
    write_fd: i32
}

O_CLOEXEC = 524288     // 0x80000
O_NONBLOCK = 2048      // 0x800
O_DIRECT = 16384       // 0x4000

// Create a new pipe
Pipe.new = () Result<Pipe, i32> {
    fds_ptr = compiler.raw_allocate(8)  // Two i32s

    result = compiler.syscall2(SYS_PIPE2, compiler.ptr_to_int(fds_ptr), 0)
    result < 0 ? {
        compiler.raw_deallocate(fds_ptr, 8)
        return Result.Err((0 - result) as i32)
    }

    read_fd = compiler.load<i32>(fds_ptr)
    write_fd = compiler.load<i32>(compiler.gep(fds_ptr, 4))

    compiler.raw_deallocate(fds_ptr, 8)
    return Result.Ok(Pipe { read_fd: read_fd, write_fd: write_fd })
}

// Create pipe with flags
Pipe.with_flags = (flags: i32) Result<Pipe, i32> {
    fds_ptr = compiler.raw_allocate(8)

    result = compiler.syscall2(SYS_PIPE2, compiler.ptr_to_int(fds_ptr), flags)
    result < 0 ? {
        compiler.raw_deallocate(fds_ptr, 8)
        return Result.Err((0 - result) as i32)
    }

    read_fd = compiler.load<i32>(fds_ptr)
    write_fd = compiler.load<i32>(compiler.gep(fds_ptr, 4))

    compiler.raw_deallocate(fds_ptr, 8)
    return Result.Ok(Pipe { read_fd: read_fd, write_fd: write_fd })
}

// Close both ends
Pipe.close = (self: MutPtr<Pipe>) void {
    compiler.syscall1(3, self.val.read_fd)   // SYS_CLOSE
    compiler.syscall1(3, self.val.write_fd)
}

// Close read end
Pipe.close_read = (self: MutPtr<Pipe>) void {
    compiler.syscall1(3, self.val.read_fd)
}

// Close write end
Pipe.close_write = (self: MutPtr<Pipe>) void {
    compiler.syscall1(3, self.val.write_fd)
}

// ============================================================================
// SpliceStream - High-level zero-copy stream
// ============================================================================
// Wraps a pipe for easy zero-copy operations

SpliceStream: {
    pipe: Pipe
}

SpliceStream.new = () Result<SpliceStream, i32> {
    pipe_result = Pipe.new()
    pipe_result ? {
        | Ok(p) { return Result.Ok(SpliceStream { pipe: p }) }
        | Err(e) { return Result.Err(e) }
    }
}

// Read from fd into stream (fd -> pipe)
SpliceStream.read_from = (self: MutPtr<SpliceStream>, fd: i32, len: usize) Result<usize, i32> {
    return splice_simple(fd, self.val.pipe.write_fd, len, SPLICE_F_MOVE)
}

// Write from stream to fd (pipe -> fd)
SpliceStream.write_to = (self: MutPtr<SpliceStream>, fd: i32, len: usize) Result<usize, i32> {
    return splice_simple(self.val.pipe.read_fd, fd, len, SPLICE_F_MOVE)
}

// Transfer data between two fds via the pipe
SpliceStream.transfer = (self: MutPtr<SpliceStream>, in_fd: i32, out_fd: i32, len: usize) Result<usize, i32> {
    // Read into pipe
    read_result = self.read_from(in_fd, len)
    read_result ? {
        | Err(e) { return Result.Err(e) }
        | Ok(n) {
            // Write from pipe
            return self.write_to(out_fd, n)
        }
    }
}

SpliceStream.close = (self: MutPtr<SpliceStream>) void {
    self.val.pipe.close()
}
