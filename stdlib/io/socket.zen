// Zen Standard Library: Socket I/O (Syscall-based)
// Direct syscall implementation for Linux x86-64
// No FFI - uses compiler.syscall* intrinsics

{ compiler } = @std
{ Result } = @std.core.result
{ Option } = @std.core.option
{ SYS_SOCKET, SYS_CONNECT, SYS_ACCEPT, SYS_SENDTO, SYS_RECVFROM,
  SYS_SHUTDOWN, SYS_BIND, SYS_LISTEN, SYS_GETSOCKNAME, SYS_GETPEERNAME,
  SYS_SOCKETPAIR, SYS_SETSOCKOPT, SYS_GETSOCKOPT, SYS_CLOSE } = @std.sys.syscall

// ============================================================================
// Socket Address Families
// ============================================================================

AF_UNIX = 1       // Unix domain sockets
AF_LOCAL = 1      // POSIX name for AF_UNIX
AF_INET = 2       // IPv4
AF_INET6 = 10     // IPv6

// ============================================================================
// Socket Types
// ============================================================================

SOCK_STREAM = 1   // TCP
SOCK_DGRAM = 2    // UDP
SOCK_RAW = 3      // Raw socket
SOCK_NONBLOCK = 2048    // O_NONBLOCK
SOCK_CLOEXEC = 524288   // O_CLOEXEC

// ============================================================================
// Protocol Numbers
// ============================================================================

IPPROTO_IP = 0
IPPROTO_TCP = 6
IPPROTO_UDP = 17

// ============================================================================
// Socket Options Levels
// ============================================================================

SOL_SOCKET = 1
SOL_TCP = 6
SOL_UDP = 17

// ============================================================================
// Socket Options (SOL_SOCKET level)
// ============================================================================

SO_REUSEADDR = 2
SO_TYPE = 3
SO_ERROR = 4
SO_BROADCAST = 6
SO_SNDBUF = 7
SO_RCVBUF = 8
SO_KEEPALIVE = 9
SO_LINGER = 13
SO_REUSEPORT = 15
SO_RCVTIMEO = 20
SO_SNDTIMEO = 21

// TCP Options
TCP_NODELAY = 1
TCP_KEEPIDLE = 4
TCP_KEEPINTVL = 5
TCP_KEEPCNT = 6

// ============================================================================
// Shutdown modes
// ============================================================================

SHUT_RD = 0       // No more reads
SHUT_WR = 1       // No more writes
SHUT_RDWR = 2     // No more reads or writes

// ============================================================================
// Message flags
// ============================================================================

MSG_DONTWAIT = 64
MSG_PEEK = 2
MSG_WAITALL = 256
MSG_NOSIGNAL = 16384

// ============================================================================
// Socket Error Type
// ============================================================================

SocketError: {
    code: i32,
    message: StaticString
}

SocketError.from_errno = (errno: i64) SocketError {
    code = (0 - errno) as i32
    msg = errno ? {
        -9 => "Bad file descriptor"
        -13 => "Permission denied"
        -98 => "Address already in use"
        -99 => "Cannot assign requested address"
        -101 => "Network unreachable"
        -104 => "Connection reset by peer"
        -110 => "Connection timed out"
        -111 => "Connection refused"
        -113 => "No route to host"
        -115 => "Operation in progress"
        _ => "Socket error"
    }
    return SocketError { code: code, message: msg }
}

// ============================================================================
// IPv4 Address (struct sockaddr_in layout)
// ============================================================================

// sockaddr_in is 16 bytes:
// - sin_family: u16 (offset 0)
// - sin_port: u16 (offset 2, network byte order)
// - sin_addr: u32 (offset 4, network byte order)
// - sin_zero: [8]u8 (offset 8, padding)

Ipv4Addr: {
    // Store as packed u32 in network byte order
    addr: u32
}

Ipv4Addr.new = (a: u8, b: u8, c: u8, d: u8) Ipv4Addr {
    // Pack bytes into u32 (network byte order - big endian)
    packed = ((a as u32) << 24) | ((b as u32) << 16) | ((c as u32) << 8) | (d as u32)
    return Ipv4Addr { addr: packed }
}

Ipv4Addr.localhost = () Ipv4Addr {
    return Ipv4Addr.new(127, 0, 0, 1)
}

Ipv4Addr.any = () Ipv4Addr {
    return Ipv4Addr { addr: 0 }
}

Ipv4Addr.broadcast = () Ipv4Addr {
    return Ipv4Addr { addr: 0xFFFFFFFF }
}

// ============================================================================
// Socket Address (IPv4)
// ============================================================================

SocketAddrV4: {
    family: u16,    // AF_INET
    port: u16,      // Network byte order
    addr: u32,      // Network byte order
    zero: i64       // Padding (8 bytes)
}

SocketAddrV4.new = (ip: Ipv4Addr, port: u16) SocketAddrV4 {
    // Convert port to network byte order (big endian)
    port_be = compiler.bswap16(port)
    // Convert addr to network byte order
    addr_be = compiler.bswap32(ip.addr)
    return SocketAddrV4 {
        family: AF_INET as u16,
        port: port_be,
        addr: addr_be,
        zero: 0
    }
}

// ============================================================================
// Low-Level Syscall Wrappers
// ============================================================================

sys_socket = (domain: i32, type_: i32, protocol: i32) i64 {
    return compiler.syscall3(SYS_SOCKET, domain, type_, protocol)
}

sys_bind = (sockfd: i32, addr_ptr: i64, addr_len: i32) i64 {
    return compiler.syscall3(SYS_BIND, sockfd, addr_ptr, addr_len)
}

sys_listen = (sockfd: i32, backlog: i32) i64 {
    return compiler.syscall2(SYS_LISTEN, sockfd, backlog)
}

sys_accept = (sockfd: i32, addr_ptr: i64, addr_len_ptr: i64) i64 {
    return compiler.syscall3(SYS_ACCEPT, sockfd, addr_ptr, addr_len_ptr)
}

sys_connect = (sockfd: i32, addr_ptr: i64, addr_len: i32) i64 {
    return compiler.syscall3(SYS_CONNECT, sockfd, addr_ptr, addr_len)
}

sys_send = (sockfd: i32, buf_ptr: i64, len: i64, flags: i32) i64 {
    return compiler.syscall4(SYS_SENDTO, sockfd, buf_ptr, len, flags)
}

sys_recv = (sockfd: i32, buf_ptr: i64, len: i64, flags: i32) i64 {
    return compiler.syscall4(SYS_RECVFROM, sockfd, buf_ptr, len, flags)
}

sys_sendto = (sockfd: i32, buf_ptr: i64, len: i64, flags: i32, dest_addr: i64, addr_len: i32) i64 {
    return compiler.syscall6(SYS_SENDTO, sockfd, buf_ptr, len, flags, dest_addr, addr_len)
}

sys_recvfrom = (sockfd: i32, buf_ptr: i64, len: i64, flags: i32, src_addr: i64, addr_len_ptr: i64) i64 {
    return compiler.syscall6(SYS_RECVFROM, sockfd, buf_ptr, len, flags, src_addr, addr_len_ptr)
}

sys_shutdown = (sockfd: i32, how: i32) i64 {
    return compiler.syscall2(SYS_SHUTDOWN, sockfd, how)
}

sys_close = (fd: i32) i64 {
    return compiler.syscall1(SYS_CLOSE, fd)
}

sys_setsockopt = (sockfd: i32, level: i32, optname: i32, optval_ptr: i64, optlen: i32) i64 {
    return compiler.syscall5(SYS_SETSOCKOPT, sockfd, level, optname, optval_ptr, optlen)
}

sys_getsockopt = (sockfd: i32, level: i32, optname: i32, optval_ptr: i64, optlen_ptr: i64) i64 {
    return compiler.syscall5(SYS_GETSOCKOPT, sockfd, level, optname, optval_ptr, optlen_ptr)
}

// ============================================================================
// TcpListener - Server socket for accepting connections
// ============================================================================

TcpListener: {
    fd: i32
}

TcpListener.bind = (addr: SocketAddrV4) Result<TcpListener, SocketError> {
    // Create socket
    fd = sys_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
    fd < 0 ? {
        return Result.Err(SocketError.from_errno(fd))
    }

    // Set SO_REUSEADDR
    opt_val = 1
    opt_ptr = compiler.ptr_to_int(&opt_val.ref())
    sys_setsockopt(fd as i32, SOL_SOCKET, SO_REUSEADDR, opt_ptr, 4)

    // Bind to address
    addr_ptr = compiler.ptr_to_int(&addr.ref())
    result = sys_bind(fd as i32, addr_ptr, 16)  // sizeof(sockaddr_in) = 16
    result < 0 ? {
        sys_close(fd as i32)
        return Result.Err(SocketError.from_errno(result))
    }

    return Result.Ok(TcpListener { fd: fd as i32 })
}

TcpListener.listen = (self: MutPtr<TcpListener>, backlog: i32) Result<(), SocketError> {
    result = sys_listen(self.val.fd, backlog)
    result < 0 ? {
        return Result.Err(SocketError.from_errno(result))
    }
    return Result.Ok(())
}

TcpListener.accept = (self: MutPtr<TcpListener>) Result<TcpStream, SocketError> {
    // Accept without getting peer address (pass null)
    client_fd = sys_accept(self.val.fd, 0, 0)
    client_fd < 0 ? {
        return Result.Err(SocketError.from_errno(client_fd))
    }
    return Result.Ok(TcpStream { fd: client_fd as i32 })
}

TcpListener.close = (self: MutPtr<TcpListener>) void {
    sys_close(self.val.fd)
}

// ============================================================================
// TcpStream - Connected TCP socket
// ============================================================================

TcpStream: {
    fd: i32
}

TcpStream.connect = (addr: SocketAddrV4) Result<TcpStream, SocketError> {
    // Create socket
    fd = sys_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
    fd < 0 ? {
        return Result.Err(SocketError.from_errno(fd))
    }

    // Connect to address
    addr_ptr = compiler.ptr_to_int(&addr.ref())
    result = sys_connect(fd as i32, addr_ptr, 16)
    result < 0 ? {
        sys_close(fd as i32)
        return Result.Err(SocketError.from_errno(result))
    }

    return Result.Ok(TcpStream { fd: fd as i32 })
}

TcpStream.read = (self: MutPtr<TcpStream>, buf: Ptr<u8>, len: i64) Result<i64, SocketError> {
    buf_ptr = compiler.ptr_to_int(buf)
    result = sys_recv(self.val.fd, buf_ptr, len, 0)
    result < 0 ? {
        return Result.Err(SocketError.from_errno(result))
    }
    return Result.Ok(result)
}

TcpStream.write = (self: MutPtr<TcpStream>, buf: Ptr<u8>, len: i64) Result<i64, SocketError> {
    buf_ptr = compiler.ptr_to_int(buf)
    result = sys_send(self.val.fd, buf_ptr, len, MSG_NOSIGNAL)
    result < 0 ? {
        return Result.Err(SocketError.from_errno(result))
    }
    return Result.Ok(result)
}

TcpStream.write_all = (self: MutPtr<TcpStream>, buf: Ptr<u8>, len: i64) Result<(), SocketError> {
    written = 0
    written < len ? {
        buf_offset = compiler.raw_ptr_offset(buf, written)
        result = self.write(buf_offset, len - written)
        result ? {
            Ok(n) => { written = written + n }
            Err(e) => { return Result.Err(e) }
        }
    }
    return Result.Ok(())
}

TcpStream.shutdown = (self: MutPtr<TcpStream>, how: i32) Result<(), SocketError> {
    result = sys_shutdown(self.val.fd, how)
    result < 0 ? {
        return Result.Err(SocketError.from_errno(result))
    }
    return Result.Ok(())
}

TcpStream.close = (self: MutPtr<TcpStream>) void {
    sys_close(self.val.fd)
}

TcpStream.set_nodelay = (self: MutPtr<TcpStream>, nodelay: bool) Result<(), SocketError> {
    opt_val = nodelay ? { 1 } : { 0 }
    opt_ptr = compiler.ptr_to_int(&opt_val.ref())
    result = sys_setsockopt(self.val.fd, SOL_TCP, TCP_NODELAY, opt_ptr, 4)
    result < 0 ? {
        return Result.Err(SocketError.from_errno(result))
    }
    return Result.Ok(())
}

// ============================================================================
// UdpSocket - Connectionless UDP socket
// ============================================================================

UdpSocket: {
    fd: i32
}

UdpSocket.bind = (addr: SocketAddrV4) Result<UdpSocket, SocketError> {
    // Create socket
    fd = sys_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
    fd < 0 ? {
        return Result.Err(SocketError.from_errno(fd))
    }

    // Bind to address
    addr_ptr = compiler.ptr_to_int(&addr.ref())
    result = sys_bind(fd as i32, addr_ptr, 16)
    result < 0 ? {
        sys_close(fd as i32)
        return Result.Err(SocketError.from_errno(result))
    }

    return Result.Ok(UdpSocket { fd: fd as i32 })
}

UdpSocket.send_to = (self: MutPtr<UdpSocket>, buf: Ptr<u8>, len: i64, dest: SocketAddrV4) Result<i64, SocketError> {
    buf_ptr = compiler.ptr_to_int(buf)
    dest_ptr = compiler.ptr_to_int(&dest.ref())
    result = sys_sendto(self.val.fd, buf_ptr, len, 0, dest_ptr, 16)
    result < 0 ? {
        return Result.Err(SocketError.from_errno(result))
    }
    return Result.Ok(result)
}

UdpSocket.recv_from = (self: MutPtr<UdpSocket>, buf: Ptr<u8>, len: i64) Result<i64, SocketError> {
    buf_ptr = compiler.ptr_to_int(buf)
    // Receive without getting source address
    result = sys_recvfrom(self.val.fd, buf_ptr, len, 0, 0, 0)
    result < 0 ? {
        return Result.Err(SocketError.from_errno(result))
    }
    return Result.Ok(result)
}

UdpSocket.set_broadcast = (self: MutPtr<UdpSocket>, broadcast: bool) Result<(), SocketError> {
    opt_val = broadcast ? { 1 } : { 0 }
    opt_ptr = compiler.ptr_to_int(&opt_val.ref())
    result = sys_setsockopt(self.val.fd, SOL_SOCKET, SO_BROADCAST, opt_ptr, 4)
    result < 0 ? {
        return Result.Err(SocketError.from_errno(result))
    }
    return Result.Ok(())
}

UdpSocket.close = (self: MutPtr<UdpSocket>) void {
    sys_close(self.val.fd)
}
