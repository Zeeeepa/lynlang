// Zen Standard Library: Unix Domain Sockets (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Local inter-process communication

{ compiler } = @std
{ Result } = @std.core.result
{ Allocator } = @std.memory.allocator
{ String } = @std.collections.string

// ============================================================================
// Linux x86-64 Syscall Numbers
// ============================================================================

SYS_SOCKET = 41
SYS_CONNECT = 42
SYS_ACCEPT = 43
SYS_SENDTO = 44
SYS_RECVFROM = 45
SYS_SHUTDOWN = 48
SYS_BIND = 49
SYS_LISTEN = 50
SYS_SOCKETPAIR = 53
SYS_CLOSE = 3
SYS_UNLINK = 87

// ============================================================================
// Constants
// ============================================================================

AF_UNIX = 1
SOCK_STREAM = 1
SOCK_DGRAM = 2
SOCK_CLOEXEC = 524288

MSG_NOSIGNAL = 16384

SHUT_RD = 0
SHUT_WR = 1
SHUT_RDWR = 2

// Max path length for Unix socket
UNIX_PATH_MAX = 108

// ============================================================================
// Unix Socket Error
// ============================================================================

UnixSocketError: {
    code: i32,
    message: StaticString
}

UnixSocketError.from_errno = (errno: i64) UnixSocketError {
    code = (0 - errno) as i32
    msg = errno ? {
        -2 => "No such file"
        -9 => "Bad file descriptor"
        -13 => "Permission denied"
        -98 => "Address already in use"
        -111 => "Connection refused"
        -107 => "Transport endpoint not connected"
        _ => "Unix socket error"
    }
    return UnixSocketError { code: code, message: msg }
}

// ============================================================================
// Unix Socket Address (struct sockaddr_un layout)
// ============================================================================
// sockaddr_un is 110 bytes:
// - sun_family: u16 (offset 0)
// - sun_path: [108]u8 (offset 2)

UnixAddr: {
    family: u16,
    // Path stored inline (up to 107 chars + null)
    path_data: i64,   // First 8 bytes
    path_data2: i64,
    path_data3: i64,
    path_data4: i64,
    path_data5: i64,
    path_data6: i64,
    path_data7: i64,
    path_data8: i64,
    path_data9: i64,
    path_data10: i64,
    path_data11: i64,
    path_data12: i64,
    path_data13: i32  // Last 4 bytes
}

// Create address from path string
UnixAddr.from_path = (path: String, allocator: Allocator) UnixAddr {
    addr = UnixAddr {
        family: AF_UNIX as u16,
        path_data: 0, path_data2: 0, path_data3: 0, path_data4: 0,
        path_data5: 0, path_data6: 0, path_data7: 0, path_data8: 0,
        path_data9: 0, path_data10: 0, path_data11: 0, path_data12: 0,
        path_data13: 0
    }

    // Copy path into address (at offset 2)
    addr_ptr = compiler.ptr_to_int(&addr.ref()) + 2
    path_len = path.len()
    max_len = path_len < 107 ? { path_len } : { 107 }

    compiler.memcpy(addr_ptr, path.data.addr(), max_len)
    // Null terminate
    compiler.store<u8>(compiler.int_to_ptr(addr_ptr + max_len), 0)

    return addr
}

// ============================================================================
// Low-Level Syscall Wrappers
// ============================================================================

sys_socket = (domain: i32, type_: i32, protocol: i32) i64 {
    return compiler.syscall3(SYS_SOCKET, domain, type_, protocol)
}

sys_bind = (sockfd: i32, addr_ptr: i64, addr_len: i32) i64 {
    return compiler.syscall3(SYS_BIND, sockfd, addr_ptr, addr_len)
}

sys_listen = (sockfd: i32, backlog: i32) i64 {
    return compiler.syscall2(SYS_LISTEN, sockfd, backlog)
}

sys_accept = (sockfd: i32, addr_ptr: i64, addr_len_ptr: i64) i64 {
    return compiler.syscall3(SYS_ACCEPT, sockfd, addr_ptr, addr_len_ptr)
}

sys_connect = (sockfd: i32, addr_ptr: i64, addr_len: i32) i64 {
    return compiler.syscall3(SYS_CONNECT, sockfd, addr_ptr, addr_len)
}

sys_send = (sockfd: i32, buf_ptr: i64, len: i64, flags: i32) i64 {
    return compiler.syscall4(SYS_SENDTO, sockfd, buf_ptr, len, flags)
}

sys_recv = (sockfd: i32, buf_ptr: i64, len: i64, flags: i32) i64 {
    return compiler.syscall4(SYS_RECVFROM, sockfd, buf_ptr, len, flags)
}

sys_socketpair = (domain: i32, type_: i32, protocol: i32, fds_ptr: i64) i64 {
    return compiler.syscall4(SYS_SOCKETPAIR, domain, type_, protocol, fds_ptr)
}

sys_shutdown = (sockfd: i32, how: i32) i64 {
    return compiler.syscall2(SYS_SHUTDOWN, sockfd, how)
}

sys_close = (fd: i32) i64 {
    return compiler.syscall1(SYS_CLOSE, fd)
}

sys_unlink = (path_ptr: i64) i64 {
    return compiler.syscall1(SYS_UNLINK, path_ptr)
}

// ============================================================================
// UnixListener - Server socket for local connections
// ============================================================================

UnixListener: {
    fd: i32,
    path_ptr: i64,   // Path for cleanup on close
    path_len: usize
}

// Bind to a path and create listener
UnixListener.bind = (path: String, allocator: Allocator) Result<UnixListener, UnixSocketError> {
    // Create socket
    fd = sys_socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0)
    fd < 0 ? {
        return Result.Err(UnixSocketError.from_errno(fd))
    }

    // Build address
    addr = UnixAddr.from_path(path, allocator)
    addr_ptr = compiler.ptr_to_int(&addr.ref())

    // Unlink existing socket file (ignore errors)
    path_cstr = allocator.allocate(path.len() + 1)
    compiler.memcpy(path_cstr, path.data.addr(), path.len())
    compiler.store<u8>(compiler.int_to_ptr(path_cstr + path.len()), 0)
    sys_unlink(path_cstr)

    // Bind
    result = sys_bind(fd as i32, addr_ptr, 110)  // sizeof(sockaddr_un)
    result < 0 ? {
        sys_close(fd as i32)
        allocator.deallocate(path_cstr, path.len() + 1)
        return Result.Err(UnixSocketError.from_errno(result))
    }

    return Result.Ok(UnixListener {
        fd: fd as i32,
        path_ptr: path_cstr,
        path_len: path.len()
    })
}

UnixListener.listen = (self: MutPtr<UnixListener>, backlog: i32) Result<(), UnixSocketError> {
    result = sys_listen(self.val.fd, backlog)
    result < 0 ? {
        return Result.Err(UnixSocketError.from_errno(result))
    }
    return Result.Ok(())
}

UnixListener.accept = (self: MutPtr<UnixListener>) Result<UnixStream, UnixSocketError> {
    client_fd = sys_accept(self.val.fd, 0, 0)
    client_fd < 0 ? {
        return Result.Err(UnixSocketError.from_errno(client_fd))
    }
    return Result.Ok(UnixStream { fd: client_fd as i32 })
}

UnixListener.close = (self: MutPtr<UnixListener>, allocator: Allocator) void {
    sys_close(self.val.fd)
    // Remove socket file
    sys_unlink(self.val.path_ptr)
    allocator.deallocate(self.val.path_ptr, self.val.path_len + 1)
}

// ============================================================================
// UnixStream - Connected Unix domain socket
// ============================================================================

UnixStream: {
    fd: i32
}

UnixStream.connect = (path: String, allocator: Allocator) Result<UnixStream, UnixSocketError> {
    // Create socket
    fd = sys_socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0)
    fd < 0 ? {
        return Result.Err(UnixSocketError.from_errno(fd))
    }

    // Build address
    addr = UnixAddr.from_path(path, allocator)
    addr_ptr = compiler.ptr_to_int(&addr.ref())

    // Connect
    result = sys_connect(fd as i32, addr_ptr, 110)
    result < 0 ? {
        sys_close(fd as i32)
        return Result.Err(UnixSocketError.from_errno(result))
    }

    return Result.Ok(UnixStream { fd: fd as i32 })
}

UnixStream.read = (self: MutPtr<UnixStream>, buf: Ptr<u8>, len: i64) Result<i64, UnixSocketError> {
    buf_ptr = compiler.ptr_to_int(buf)
    result = sys_recv(self.val.fd, buf_ptr, len, 0)
    result < 0 ? {
        return Result.Err(UnixSocketError.from_errno(result))
    }
    return Result.Ok(result)
}

UnixStream.write = (self: MutPtr<UnixStream>, buf: Ptr<u8>, len: i64) Result<i64, UnixSocketError> {
    buf_ptr = compiler.ptr_to_int(buf)
    result = sys_send(self.val.fd, buf_ptr, len, MSG_NOSIGNAL)
    result < 0 ? {
        return Result.Err(UnixSocketError.from_errno(result))
    }
    return Result.Ok(result)
}

UnixStream.shutdown = (self: MutPtr<UnixStream>, how: i32) Result<(), UnixSocketError> {
    result = sys_shutdown(self.val.fd, how)
    result < 0 ? {
        return Result.Err(UnixSocketError.from_errno(result))
    }
    return Result.Ok(())
}

UnixStream.close = (self: MutPtr<UnixStream>) void {
    sys_close(self.val.fd)
}

// ============================================================================
// UnixDatagram - Connectionless Unix domain socket
// ============================================================================

UnixDatagram: {
    fd: i32,
    bound_path_ptr: i64,
    bound_path_len: usize
}

UnixDatagram.bind = (path: String, allocator: Allocator) Result<UnixDatagram, UnixSocketError> {
    // Create socket
    fd = sys_socket(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0)
    fd < 0 ? {
        return Result.Err(UnixSocketError.from_errno(fd))
    }

    // Build address
    addr = UnixAddr.from_path(path, allocator)
    addr_ptr = compiler.ptr_to_int(&addr.ref())

    // Unlink existing
    path_cstr = allocator.allocate(path.len() + 1)
    compiler.memcpy(path_cstr, path.data.addr(), path.len())
    compiler.store<u8>(compiler.int_to_ptr(path_cstr + path.len()), 0)
    sys_unlink(path_cstr)

    // Bind
    result = sys_bind(fd as i32, addr_ptr, 110)
    result < 0 ? {
        sys_close(fd as i32)
        allocator.deallocate(path_cstr, path.len() + 1)
        return Result.Err(UnixSocketError.from_errno(result))
    }

    return Result.Ok(UnixDatagram {
        fd: fd as i32,
        bound_path_ptr: path_cstr,
        bound_path_len: path.len()
    })
}

UnixDatagram.unbound = () Result<UnixDatagram, UnixSocketError> {
    fd = sys_socket(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0)
    fd < 0 ? {
        return Result.Err(UnixSocketError.from_errno(fd))
    }
    return Result.Ok(UnixDatagram { fd: fd as i32, bound_path_ptr: 0, bound_path_len: 0 })
}

UnixDatagram.send_to = (self: MutPtr<UnixDatagram>, buf: Ptr<u8>, len: i64, dest: UnixAddr) Result<i64, UnixSocketError> {
    buf_ptr = compiler.ptr_to_int(buf)
    dest_ptr = compiler.ptr_to_int(&dest.ref())
    result = compiler.syscall6(SYS_SENDTO, self.val.fd, buf_ptr, len, 0, dest_ptr, 110)
    result < 0 ? {
        return Result.Err(UnixSocketError.from_errno(result))
    }
    return Result.Ok(result)
}

UnixDatagram.recv = (self: MutPtr<UnixDatagram>, buf: Ptr<u8>, len: i64) Result<i64, UnixSocketError> {
    buf_ptr = compiler.ptr_to_int(buf)
    result = sys_recv(self.val.fd, buf_ptr, len, 0)
    result < 0 ? {
        return Result.Err(UnixSocketError.from_errno(result))
    }
    return Result.Ok(result)
}

UnixDatagram.close = (self: MutPtr<UnixDatagram>, allocator: Allocator) void {
    sys_close(self.val.fd)
    self.val.bound_path_ptr != 0 ? {
        sys_unlink(self.val.bound_path_ptr)
        allocator.deallocate(self.val.bound_path_ptr, self.val.bound_path_len + 1)
    }
}

// ============================================================================
// Socket Pair - Connected pair of Unix sockets
// ============================================================================

SocketPair: {
    fd1: i32,
    fd2: i32
}

// Create a connected pair of stream sockets
SocketPair.stream = () Result<SocketPair, UnixSocketError> {
    fds = [0, 0]
    fds_ptr = compiler.ptr_to_int(&fds.ref())
    result = sys_socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, fds_ptr)
    result < 0 ? {
        return Result.Err(UnixSocketError.from_errno(result))
    }
    return Result.Ok(SocketPair { fd1: fds[0], fd2: fds[1] })
}

// Create a connected pair of datagram sockets
SocketPair.datagram = () Result<SocketPair, UnixSocketError> {
    fds = [0, 0]
    fds_ptr = compiler.ptr_to_int(&fds.ref())
    result = sys_socketpair(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0, fds_ptr)
    result < 0 ? {
        return Result.Err(UnixSocketError.from_errno(result))
    }
    return Result.Ok(SocketPair { fd1: fds[0], fd2: fds[1] })
}

SocketPair.close = (self: MutPtr<SocketPair>) void {
    sys_close(self.val.fd1)
    sys_close(self.val.fd2)
}
