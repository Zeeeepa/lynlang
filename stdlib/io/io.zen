// Zen Standard Library: IO Module (Improved)
// Input/Output operations with proper syntax

// External C functions for IO
printf = (format: RawPtr<i8>, ...) i32 {
    inline.c("""
        return printf(${format.addr}, ...);
    """)
}

puts = (str: RawPtr<i8>) i32 {
    inline.c("""
        return puts(${str.addr});
    """)
}

getchar = () i32 {
    inline.c("""
        return getchar();
    """)
}

fopen = (filename: RawPtr<i8>, mode: RawPtr<i8>) RawPtr<i8> {
    inline.c("""
        return fopen(${filename.addr}, ${mode.addr});
    """)
}

fclose = (file: RawPtr<i8>) i32 {
    inline.c("""
        return fclose(${file.addr});
    """)
}

fread = (buffer: RawPtr<i8>, size: i64, count: i64, file: RawPtr<i8>) i64 {
    inline.c("""
        return fread(${buffer.addr}, ${size}, ${count}, ${file.addr});
    """)
}

fwrite = (buffer: RawPtr<i8>, size: i64, count: i64, file: RawPtr<i8>) i64 {
    inline.c("""
        return fwrite(${buffer.addr}, ${size}, ${count}, ${file.addr});
    """)
}

feof = (file: RawPtr<i8>) i32 {
    inline.c("""
        return feof(${file.addr});
    """)
}

ferror = (file: RawPtr<i8>) i32 {
    inline.c("""
        return ferror(${file.addr});
    """)
}

fflush = (file: RawPtr<i8>) i32 {
    inline.c("""
        return fflush(${file.addr});
    """)
}

{ allocate_raw, deallocate_raw } = import("memory.zen")

// File descriptor constants
STDIN := 0
STDOUT := 1
STDERR := 2

// Buffer sizes
BUFFER_SIZE := 4096
LINE_BUFFER_SIZE := 1024

// File modes
FileMode: .ReadOnly
    | WriteOnly
    | ReadWrite
    | Append
    | CreateNew

// IO Error types
IOError: .FileNotFound
    | PermissionDenied
    | AlreadyExists
    | BrokenPipe
    | UnexpectedEof
    | InvalidInput
    | WriteZero
    | ReadError
    | WriteError
    | Other

// Result type for IO operations
IOResult<T>: Ok(T) | Err(IOError)

// File handle type
File: {
    handle: RawPtr<i8>,
    path: RawPtr<i8>,
    mode: FileMode,
    is_open: bool,
}

// Print string to stdout
print = (message: RawPtr<i8>) void   {
    puts(message)
}

// Print with newline
println = (message: RawPtr<i8>) void   {
    puts(message)
}

// Print formatted integer
print_int = (value: i32) void   {
    format := "%d\n"
    printf(format, value)
}

// Print formatted float
print_float = (value: f64) void   {
    format := "%.6f\n"
    printf(format, value)
}

// Read a single character from stdin
read_char = () i32   {
    return getchar()
}

// Open a file with specified mode
file_open = (path: RawPtr<i8>, mode: FileMode) IOResult<File> {
    // Convert mode to C string
    mode_str ::= "r"  // Default to read
    mode ?
        | ReadOnly { mode_str = "r" }
        | WriteOnly { mode_str = "w" }
        | ReadWrite { mode_str = "r+" }
        | Append { mode_str = "a" }
        | CreateNew { mode_str = "w+" }
    
    handle := fopen(path, mode_str)
    
    // Check if open succeeded
    handle == 0 ?
        | true {
            return Err(.FileNotFound)
        }
        | false {
            file := File {
                handle: handle,
                path: path,
                mode: mode,
                is_open: true,
            }
            return Ok(file)
        }
}

// Close a file
file_close = (file: File) IOResult<bool> {
    file.is_open ?
        | false {
            return Err(.Other)
        }
        | true {}
    
    result := fclose(file.handle)
    result == 0 ?
        | true {
            return Ok(true)
        }
        | false {
            return Err(.Other)
        }
}

// Write bytes to a file
file_write = (file: File, data: RawPtr<i8>, len: i64) IOResult<i64> {
    file.is_open ?
        | false {
            return Err(.Other)
        }
        | true {}
    
    written := fwrite(data, 1, len, file.handle)
    
    written == len ?
        | true {
            return Ok(written)
        }
        | false {
            written == 0 ?
                | true {
                    return Err(.WriteZero)
                }
                | false {
                    return Err(.WriteError)
                }
        }
}

// Read bytes from a file
file_read = (file: File, buffer: RawPtr<i8>, max_len: i64) IOResult<i64> {
    file.is_open ?
        | false {
            return Err(.Other)
        }
        | true {}
    
    bytes_read := fread(buffer, 1, max_len, file.handle)
    
    has_error := ferror(file.handle)
    has_error != 0 ?
        | true {
            return Err(.ReadError)
        }
        | false {
            is_eof := feof(file.handle)
            (is_eof != 0 && bytes_read == 0) ?
                | true {
                    return Err(.UnexpectedEof)
                }
                | false {
                    return Ok(bytes_read)
                }
        }
}

// Flush output stream
flush = (file: File) IOResult<bool> {
    result := fflush(file.handle)
    result == 0 ?
        | true {
            return Ok(true)
        }
        | false {
            return Err(.Other)
        }
}

// Write a string to file
file_write_string = (file: File, str: RawPtr<i8>) IOResult<i64>   {
    // Calculate string length (simplified - would need proper strlen)
    len := 0
    i := 0
    // TODO: Implement proper string length calculation
    
    return file_write(file, str, len)
}

// Create a buffered reader
BufferedReader: {
    file: File,
    buffer: RawPtr<i8>,
    buffer_size: i64,
    buffer_pos: i64,
    buffer_len: i64,
}

// Create new buffered reader
buffered_reader_new = (file: File) BufferedReader   {
    buffer := allocate_raw(BUFFER_SIZE as usize) as RawPtr<i8>
    return BufferedReader {
        file: file,
        buffer: buffer,
        buffer_size: BUFFER_SIZE,
        buffer_pos: 0,
        buffer_len: 0,
    }
}

// Create a buffered writer
BufferedWriter: {
    file: File,
    buffer: RawPtr<i8>,
    buffer_size: i64,
    buffer_pos: i64,
}

// Create new buffered writer
buffered_writer_new = (file: File) BufferedWriter   {
    buffer := allocate_raw(BUFFER_SIZE as usize) as RawPtr<i8>
    return BufferedWriter {
        file: file,
        buffer: buffer,
        buffer_size: BUFFER_SIZE,
        buffer_pos: 0,
    }
}

// Flush buffered writer
buffered_writer_flush = (writer: BufferedWriter) IOResult<bool> {
    writer.buffer_pos > 0 ?
        | true {
            result := file_write(writer.file, writer.buffer, writer.buffer_pos)
            result ?
                | Ok(written) {
                    writer.buffer_pos = 0
                    return Ok(true)
                }
                | Err(e) {
                    return Err(e)
                }
        }
        | false {
            return Ok(true)
        }
}

// Free buffered reader resources
buffered_reader_free = (reader: BufferedReader) void   {
    deallocate_raw(reader.buffer as RawPtr<void>)
}

// Free buffered writer resources  
buffered_writer_free = (writer: BufferedWriter) void   {
    deallocate_raw(writer.buffer as RawPtr<void>)
}

// Standard streams (simplified)
stdout = () File {
    return File {
        handle: 0,  // Would need proper stdout handle
        path: "stdout",
        mode: .WriteOnly,
        is_open: true,
    }
}

stderr = () File {
    return File {
        handle: 0,  // Would need proper stderr handle
        path: "stderr",
        mode: .WriteOnly,
        is_open: true,
    }
}

stdin = () File {
    return File {
        handle: 0,  // Would need proper stdin handle
        path: "stdin",
        mode: .ReadOnly,
        is_open: true,
    }
}

// Export main functions
module.exports = {
    print,
    println,
    print_int,
    print_float,
    read_char,
    file_open,
    file_close,
    file_write,
    file_read,
    file_write_string,
    flush,
    BufferedReader,
    BufferedWriter,
    buffered_reader_new,
    buffered_writer_new,
    buffered_reader_free,
    buffered_writer_free,
    buffered_writer_flush,
    stdout,
    stderr,
    stdin,
    IOResult,
    IOError,
    File,
    FileMode,
}