// Zen Standard Library - IO Module
// Provides input/output functionality for Zen programs

// File descriptor constants
STDIN_FD: i32 = 0
STDOUT_FD: i32 = 1
STDERR_FD: i32 = 2

// System call numbers for x86_64 Linux
SYS_READ: i64 = 0
SYS_WRITE: i64 = 1
SYS_OPEN: i64 = 2
SYS_CLOSE: i64 = 3

// External syscall function (implemented in runtime)
extern syscall = (number: i64, arg1: i64, arg2: i64, arg3: i64) i64

// Write bytes to a file descriptor
write_fd = (fd: i32, data: *u8, len: usize) isize   {
    result := syscall(SYS_WRITE, fd as i64, data as i64, len as i64)
    return result as isize
}

// Read bytes from a file descriptor
read_fd = (fd: i32, buffer: *u8, len: usize) isize   {
    result := syscall(SYS_READ, fd as i64, buffer as i64, len as i64)
    return result as isize
}

// Print a string to stdout
print = (s: string) void   {
    write_fd(STDOUT_FD, s.data, s.len)
}

// Print a string with newline to stdout
println = (s: string) void   {
    print(s)
    print("\n")
}

// Print an error string to stderr
eprint = (s: string) void   {
    write_fd(STDERR_FD, s.data, s.len)
}

// Print an error string with newline to stderr  
eprintln = (s: string) void   {
    eprint(s)
    eprint("\n")
}

// Print an integer
print_int = (n: i32) void   {
    n < 0 ?
        | true { { }
            print("-")
            n = -n
        }
        | false { { }}
    
    n == 0 ?
        | true { { }
            print("0")
            return
        }
        | false { { }}
    
    // Convert to string (reverse order)
    buffer: [32]u8
    i := 0
    
    loop n > 0 {
        digit := (n % 10) as u8
        buffer[i] = digit + 48  // ASCII '0'
        n = n / 10
        i = i + 1
    }
    
    // Print in correct order
    loop i > 0 {
        i = i - 1
        write_fd(STDOUT_FD, &buffer[i], 1)
    }
}

// Print a boolean
print_bool = (b: bool) void   {
    b ?
        | true { print("true") }
        | false { print("false") }
}

// Read a line from stdin
read_line = () string   {
    buffer: [1024]u8
    bytes_read := read_fd(STDIN_FD, &buffer[0], 1024)
    
    bytes_read <= 0 ?
        | true { return "" }
        | false { { }}
    
    // Find newline and trim
    len := bytes_read as usize
    i := 0
    loop i < len {
        buffer[i] == 10 ?  // '\n'
            | true { { }
                len = i
                break
            }
            | false { { }}
        i = i + 1
    }
    
    // Create string from buffer
    return string:from_bytes(&buffer[0], len)
}

// Flush stdout (placeholder - actual implementation needs syscall)
flush = () void   {
    // TODO: Implement flush when fsync syscall is available
}

// File operations
File: {
    fd: i32,
    path: string,
    is_open: bool,
}

// Open a file
open = (path: string, flags: i32) File   {
    fd := syscall(SYS_OPEN, path.data as i64, flags as i64, 0o666) as i32
    return File {
        fd: fd,
        path: path,
        is_open: fd >= 0,
    }
}

// Close a file
close = (file: *File) void   {
    file.is_open ?
        | true { { }
            syscall(SYS_CLOSE, file.fd as i64, 0, 0)
            file.is_open = false
        }
        | false { { }}
}

// Write to a file
write = (file: *File, data: string) isize   {
    !file.is_open ?
        | true { return -1 }
        | false { { }}
    
    return write_fd(file.fd, data.data, data.len)
}

// Read from a file
read = (file: *File, buffer: *u8, len: usize) isize   {
    !file.is_open ?
        | true { return -1 }
        | false { { }}
    
    return read_fd(file.fd, buffer, len)
}

// File open flags
O_RDONLY: i32 = 0
O_WRONLY: i32 = 1
O_RDWR: i32 = 2
O_CREAT: i32 = 0o100
O_TRUNC: i32 = 0o1000
O_APPEND: i32 = 0o2000

// Convenience functions for file operations
read_file = (path: string) string   {
    file := open(path, O_RDONLY)
    !file.is_open ?
        | true { return "" }
        | false { { }}
    
    // Read file contents (simplified - assumes small file)
    buffer: [65536]u8
    bytes_read := read(&file, &buffer[0], 65536)
    close(&file)
    
    bytes_read <= 0 ?
        | true { return "" }
        | false { { }}
    
    return string:from_bytes(&buffer[0], bytes_read as usize)
}

write_file = (path: string, content: string) bool   {
    file := open(path, O_WRONLY | O_CREAT | O_TRUNC)
    !file.is_open ?
        | true { return false }
        | false { { }}
    
    bytes_written := write(&file, content)
    close(&file)
    
    return bytes_written == content.len as isize
}

append_file = (path: string, content: string) bool   {
    file := open(path, O_WRONLY | O_CREAT | O_APPEND)
    !file.is_open ?
        | true { return false }
        | false { { }}
    
    bytes_written := write(&file, content)
    close(&file)
    
    return bytes_written == content.len as isize
}