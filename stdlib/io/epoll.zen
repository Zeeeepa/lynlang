// Zen Standard Library: Epoll I/O Multiplexing (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics

{ compiler } = @std
{ Result } = @std.core.result
{ SYS_EPOLL_CREATE1, SYS_EPOLL_CTL, SYS_EPOLL_WAIT, SYS_CLOSE } = @std.sys.syscall

// Epoll operations
EPOLL_CTL_ADD = 1
EPOLL_CTL_DEL = 2
EPOLL_CTL_MOD = 3

// Epoll events
EPOLLIN = 1
EPOLLOUT = 4
EPOLLERR = 8
EPOLLHUP = 16
EPOLLET = 2147483648

// Flags
EPOLL_CLOEXEC = 524288

EpollError: { code: i32, message: StaticString }

EpollError.from_errno = (errno: i64) EpollError {
    code = (0 - errno) as i32
    return EpollError { code: code, message: "Epoll error" }
}

EpollEvent: { events: u32, data: u64 }

EpollEvent.for_fd = (events: u32, fd: i32) EpollEvent {
    return EpollEvent { events: events, data: fd as u64 }
}

Epoll: { fd: i32 }

Epoll.new = () Result<Epoll, EpollError> {
    result = compiler.syscall1(SYS_EPOLL_CREATE1, EPOLL_CLOEXEC)
    result < 0 ? { return Result.Err(EpollError.from_errno(result)) }
    return Result.Ok(Epoll { fd: result as i32 })
}

Epoll.add = (self: MutPtr<Epoll>, fd: i32, events: u32) Result<(), EpollError> {
    event = EpollEvent.for_fd(events, fd)
    result = compiler.syscall4(SYS_EPOLL_CTL, self.val.fd, EPOLL_CTL_ADD, fd, compiler.ptr_to_int(&event.ref()))
    result < 0 ? { return Result.Err(EpollError.from_errno(result)) }
    return Result.Ok(())
}

Epoll.remove = (self: MutPtr<Epoll>, fd: i32) Result<(), EpollError> {
    result = compiler.syscall4(SYS_EPOLL_CTL, self.val.fd, EPOLL_CTL_DEL, fd, 0)
    result < 0 ? { return Result.Err(EpollError.from_errno(result)) }
    return Result.Ok(())
}

Epoll.wait = (self: MutPtr<Epoll>, events: Ptr<EpollEvent>, max: i32, timeout_ms: i32) Result<i32, EpollError> {
    result = compiler.syscall4(SYS_EPOLL_WAIT, self.val.fd, compiler.ptr_to_int(events), max, timeout_ms)
    result < 0 ? { return Result.Err(EpollError.from_errno(result)) }
    return Result.Ok(result as i32)
}

Epoll.close = (self: MutPtr<Epoll>) void {
    compiler.syscall1(SYS_CLOSE, self.val.fd)
}
