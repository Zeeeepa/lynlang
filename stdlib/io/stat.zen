// Zen Standard Library: File Statistics (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// stat, fstat, lstat for file metadata

{ compiler } = @std
{ Result } = @std.core.result

// ============================================================================
// Syscall Numbers (x86-64)
// ============================================================================

SYS_STAT = 4
SYS_FSTAT = 5
SYS_LSTAT = 6
SYS_FSTATAT = 262
SYS_STATX = 332

// ============================================================================
// Stat Structure (matches Linux struct stat for x86-64)
// ============================================================================
// Total size: 144 bytes

Stat: {
    st_dev: u64,        // Device ID
    st_ino: u64,        // Inode number
    st_nlink: u64,      // Number of hard links
    st_mode: u32,       // File type and mode
    st_uid: u32,        // Owner user ID
    st_gid: u32,        // Owner group ID
    _pad0: u32,         // Padding
    st_rdev: u64,       // Device ID (if special file)
    st_size: i64,       // Total size in bytes
    st_blksize: i64,    // Block size for I/O
    st_blocks: i64,     // Number of 512B blocks
    st_atime: i64,      // Access time (seconds)
    st_atime_nsec: i64, // Access time (nanoseconds)
    st_mtime: i64,      // Modification time (seconds)
    st_mtime_nsec: i64, // Modification time (nanoseconds)
    st_ctime: i64,      // Status change time (seconds)
    st_ctime_nsec: i64  // Status change time (nanoseconds)
}

// ============================================================================
// File Type Constants (from st_mode)
// ============================================================================

S_IFMT   = 61440    // Type mask (0o170000)
S_IFSOCK = 49152    // Socket (0o140000)
S_IFLNK  = 40960    // Symbolic link (0o120000)
S_IFREG  = 32768    // Regular file (0o100000)
S_IFBLK  = 24576    // Block device (0o060000)
S_IFDIR  = 16384    // Directory (0o040000)
S_IFCHR  = 8192     // Character device (0o020000)
S_IFIFO  = 4096     // FIFO/pipe (0o010000)

// ============================================================================
// Permission Constants
// ============================================================================

S_ISUID = 2048      // Set user ID (0o4000)
S_ISGID = 1024      // Set group ID (0o2000)
S_ISVTX = 512       // Sticky bit (0o1000)

S_IRWXU = 448       // Owner RWX (0o700)
S_IRUSR = 256       // Owner read (0o400)
S_IWUSR = 128       // Owner write (0o200)
S_IXUSR = 64        // Owner execute (0o100)

S_IRWXG = 56        // Group RWX (0o070)
S_IRGRP = 32        // Group read (0o040)
S_IWGRP = 16        // Group write (0o020)
S_IXGRP = 8         // Group execute (0o010)

S_IRWXO = 7         // Others RWX (0o007)
S_IROTH = 4         // Others read (0o004)
S_IWOTH = 2         // Others write (0o002)
S_IXOTH = 1         // Others execute (0o001)

// ============================================================================
// Type Check Helpers
// ============================================================================

Stat.is_regular = (self: Stat) bool {
    return (self.st_mode & S_IFMT) == S_IFREG
}

Stat.is_directory = (self: Stat) bool {
    return (self.st_mode & S_IFMT) == S_IFDIR
}

Stat.is_symlink = (self: Stat) bool {
    return (self.st_mode & S_IFMT) == S_IFLNK
}

Stat.is_socket = (self: Stat) bool {
    return (self.st_mode & S_IFMT) == S_IFSOCK
}

Stat.is_fifo = (self: Stat) bool {
    return (self.st_mode & S_IFMT) == S_IFIFO
}

Stat.is_block_device = (self: Stat) bool {
    return (self.st_mode & S_IFMT) == S_IFBLK
}

Stat.is_char_device = (self: Stat) bool {
    return (self.st_mode & S_IFMT) == S_IFCHR
}

// ============================================================================
// Permission Check Helpers
// ============================================================================

Stat.is_readable_by_owner = (self: Stat) bool {
    return (self.st_mode & S_IRUSR) != 0
}

Stat.is_writable_by_owner = (self: Stat) bool {
    return (self.st_mode & S_IWUSR) != 0
}

Stat.is_executable_by_owner = (self: Stat) bool {
    return (self.st_mode & S_IXUSR) != 0
}

Stat.is_setuid = (self: Stat) bool {
    return (self.st_mode & S_ISUID) != 0
}

Stat.is_setgid = (self: Stat) bool {
    return (self.st_mode & S_ISGID) != 0
}

Stat.is_sticky = (self: Stat) bool {
    return (self.st_mode & S_ISVTX) != 0
}

// Get permission bits only (no file type)
Stat.permissions = (self: Stat) u32 {
    return self.st_mode & 4095  // 0o7777
}

// ============================================================================
// Core Stat Functions
// ============================================================================

// Stat a file by path
stat = (path_ptr: i64) Result<Stat, i32> {
    buf = Stat {
        st_dev: 0, st_ino: 0, st_nlink: 0, st_mode: 0,
        st_uid: 0, st_gid: 0, _pad0: 0, st_rdev: 0,
        st_size: 0, st_blksize: 0, st_blocks: 0,
        st_atime: 0, st_atime_nsec: 0,
        st_mtime: 0, st_mtime_nsec: 0,
        st_ctime: 0, st_ctime_nsec: 0
    }

    result = compiler.syscall2(SYS_STAT, path_ptr, compiler.ptr_to_int(&buf.ref() as RawPtr<u8>))
    result < 0 ? { return Result.Err(result as i32) }

    return Result.Ok(buf)
}

// Stat an open file descriptor
fstat = (fd: i32) Result<Stat, i32> {
    buf = Stat {
        st_dev: 0, st_ino: 0, st_nlink: 0, st_mode: 0,
        st_uid: 0, st_gid: 0, _pad0: 0, st_rdev: 0,
        st_size: 0, st_blksize: 0, st_blocks: 0,
        st_atime: 0, st_atime_nsec: 0,
        st_mtime: 0, st_mtime_nsec: 0,
        st_ctime: 0, st_ctime_nsec: 0
    }

    result = compiler.syscall2(SYS_FSTAT, fd, compiler.ptr_to_int(&buf.ref() as RawPtr<u8>))
    result < 0 ? { return Result.Err(result as i32) }

    return Result.Ok(buf)
}

// Stat a symlink (don't follow)
lstat = (path_ptr: i64) Result<Stat, i32> {
    buf = Stat {
        st_dev: 0, st_ino: 0, st_nlink: 0, st_mode: 0,
        st_uid: 0, st_gid: 0, _pad0: 0, st_rdev: 0,
        st_size: 0, st_blksize: 0, st_blocks: 0,
        st_atime: 0, st_atime_nsec: 0,
        st_mtime: 0, st_mtime_nsec: 0,
        st_ctime: 0, st_ctime_nsec: 0
    }

    result = compiler.syscall2(SYS_LSTAT, path_ptr, compiler.ptr_to_int(&buf.ref() as RawPtr<u8>))
    result < 0 ? { return Result.Err(result as i32) }

    return Result.Ok(buf)
}

// ============================================================================
// Convenience Functions
// ============================================================================

// Check if path exists
path_exists = (path_ptr: i64) bool {
    result = stat(path_ptr)
    result ? {
        | Ok(_) { return true }
        | Err(_) { return false }
    }
}

// Check if path is a directory
is_dir = (path_ptr: i64) bool {
    result = stat(path_ptr)
    result ? {
        | Ok(s) { return s.is_directory() }
        | Err(_) { return false }
    }
}

// Check if path is a regular file
is_file = (path_ptr: i64) bool {
    result = stat(path_ptr)
    result ? {
        | Ok(s) { return s.is_regular() }
        | Err(_) { return false }
    }
}

// Get file size
file_size = (path_ptr: i64) Result<i64, i32> {
    result = stat(path_ptr)
    result ? {
        | Ok(s) { return Result.Ok(s.st_size) }
        | Err(e) { return Result.Err(e) }
    }
}

// Get file size from fd
fd_size = (fd: i32) Result<i64, i32> {
    result = fstat(fd)
    result ? {
        | Ok(s) { return Result.Ok(s.st_size) }
        | Err(e) { return Result.Err(e) }
    }
}
