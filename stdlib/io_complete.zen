// Complete IO Module for Zen Standard Library
// Provides input/output functionality

core := @std.core
string := @std.string
fs := @std.fs

// Standard file descriptors
STDIN :: 0
STDOUT :: 1
STDERR :: 2

// IO Result type
IoResult<T> = enum {
    Ok -> value: T,
    Err -> error: IoError,
}

// IO Error types
IoError = enum {
    FileNotFound,
    PermissionDenied,
    AlreadyExists,
    NotFound,
    BrokenPipe,
    WouldBlock,
    InvalidInput,
    InvalidData,
    TimedOut,
    WriteZero,
    Interrupted,
    UnexpectedEof,
    Other -> message: string,
}

// Buffered reader for efficient reading
BufferedReader = struct {
    inner: *File,
    buffer: [8192]u8,
    pos: usize,
    cap: usize,
}

// Buffered writer for efficient writing
BufferedWriter = struct {
    inner: *File,
    buffer: [8192]u8,
    pos: usize,
}

// File handle
File = struct {
    fd: i32,
    path: string,
    mode: FileMode,
}

// File mode flags
FileMode = enum {
    Read,
    Write,
    Append,
    ReadWrite,
}

// Print string to stdout
print = (s: string) void {
    write_str(STDOUT, s)
}

// Print string with newline to stdout
println = (s: string) void {
    print(s)
    print("\n")
}

// Print formatted string (basic implementation)
printf = (format: string, args: ...any) void {
    formatted := format_string(format, args)
    print(formatted)
}

// Print to stderr
eprint = (s: string) void {
    write_str(STDERR, s)
}

// Print to stderr with newline
eprintln = (s: string) void {
    eprint(s)
    eprint("\n")
}

// Read line from stdin
read_line = () IoResult<string> {
    buffer := [1024]u8{}
    bytes_read := read(STDIN, &buffer[0], 1024)
    
    bytes_read < 0 ? {
        return IoResult.Err -> error: IoError.Other -> message: "Read failed"
    } : {}
    
    // Find newline and create string
    i := 0
    loop i < bytes_read {
        buffer[i] == '\n' ? {
            return IoResult.Ok -> value: string.from_bytes(&buffer[0], i)
        } : {}
        i = i + 1
    }
    
    return IoResult.Ok -> value: string.from_bytes(&buffer[0], bytes_read)
}

// Open file
open = (path: string, mode: FileMode) IoResult<File> {
    flags := match mode {
        | FileMode.Read => O_RDONLY
        | FileMode.Write => O_WRONLY | O_CREAT | O_TRUNC
        | FileMode.Append => O_WRONLY | O_CREAT | O_APPEND
        | FileMode.ReadWrite => O_RDWR | O_CREAT
    }
    
    fd := open_syscall(path, flags, 0o644)
    fd < 0 ? {
        return IoResult.Err -> error: IoError.FileNotFound
    } : {
        return IoResult.Ok -> value: File{
            fd: fd,
            path: path,
            mode: mode,
        }
    }
}

// Read from file
file_read = (file: *File, buffer: *u8, size: usize) IoResult<usize> {
    bytes_read := read(file.fd, buffer, size)
    bytes_read < 0 ? {
        return IoResult.Err -> error: IoError.Other -> message: "Read failed"
    } : {
        return IoResult.Ok -> value: bytes_read as usize
    }
}

// Write to file
file_write = (file: *File, data: *u8, size: usize) IoResult<usize> {
    bytes_written := write(file.fd, data, size)
    bytes_written < 0 ? {
        return IoResult.Err -> error: IoError.Other -> message: "Write failed"
    } : {
        return IoResult.Ok -> value: bytes_written as usize
    }
}

// Write string to file
file_write_str = (file: *File, s: string) IoResult<usize> {
    return file_write(file, s.data, s.len)
}

// Close file
file_close = (file: *File) IoResult<void> {
    result := close(file.fd)
    result < 0 ? {
        return IoResult.Err -> error: IoError.Other -> message: "Close failed"
    } : {
        return IoResult.Ok -> value: void
    }
}

// Read entire file to string
read_to_string = (path: string) IoResult<string> {
    file := open(path, FileMode.Read)?
    defer file_close(&file)
    
    // Get file size
    stats := fs.stat(path)?
    buffer := vec.with_capacity<u8>(stats.size)
    
    total_read := 0 as usize
    loop total_read < stats.size {
        bytes_read := file_read(&file, buffer.data + total_read, stats.size - total_read)?
        bytes_read == 0 ? { break } : {}
        total_read = total_read + bytes_read
    }
    
    return IoResult.Ok -> value: string.from_bytes(buffer.data, total_read)
}

// Write string to file
write_to_file = (path: string, content: string) IoResult<void> {
    file := open(path, FileMode.Write)?
    defer file_close(&file)
    
    file_write_str(&file, content)?
    return IoResult.Ok -> value: void
}

// Create buffered reader
buffered_reader = (file: *File) BufferedReader {
    return BufferedReader{
        inner: file,
        buffer: [8192]u8{},
        pos: 0,
        cap: 0,
    }
}

// Read line from buffered reader
read_line_buffered = (reader: *BufferedReader) IoResult<string> {
    line := vec.new<u8>()
    
    loop {
        // Refill buffer if needed
        reader.pos >= reader.cap ? {
            bytes_read := file_read(reader.inner, &reader.buffer[0], 8192)?
            bytes_read == 0 ? {
                line.is_empty() ? {
                    return IoResult.Err -> error: IoError.UnexpectedEof
                } : {
                    return IoResult.Ok -> value: string.from_vec(line)
                }
            } : {}
            reader.pos = 0
            reader.cap = bytes_read
        } : {}
        
        // Look for newline in buffer
        start := reader.pos
        loop reader.pos < reader.cap {
            reader.buffer[reader.pos] == '\n' ? {
                // Found newline, add to line and return
                i := start
                loop i < reader.pos {
                    line.push(reader.buffer[i])
                    i = i + 1
                }
                reader.pos = reader.pos + 1 // Skip newline
                return IoResult.Ok -> value: string.from_vec(line)
            } : {}
            reader.pos = reader.pos + 1
        }
        
        // Add buffer contents to line
        i := start
        loop i < reader.cap {
            line.push(reader.buffer[i])
            i = i + 1
        }
    }
}

// Create buffered writer
buffered_writer = (file: *File) BufferedWriter {
    return BufferedWriter{
        inner: file,
        buffer: [8192]u8{},
        pos: 0,
    }
}

// Write to buffered writer
write_buffered = (writer: *BufferedWriter, data: *u8, size: usize) IoResult<void> {
    remaining := size
    offset := 0 as usize
    
    loop remaining > 0 {
        available := 8192 - writer.pos
        to_write := remaining < available ? remaining : available
        
        // Copy to buffer
        i := 0
        loop i < to_write {
            writer.buffer[writer.pos + i] = data[offset + i]
            i = i + 1
        }
        
        writer.pos = writer.pos + to_write
        offset = offset + to_write
        remaining = remaining - to_write
        
        // Flush if buffer is full
        writer.pos >= 8192 ? {
            flush_buffered(writer)?
        } : {}
    }
    
    return IoResult.Ok -> value: void
}

// Flush buffered writer
flush_buffered = (writer: *BufferedWriter) IoResult<void> {
    writer.pos > 0 ? {
        file_write(writer.inner, &writer.buffer[0], writer.pos)?
        writer.pos = 0
    } : {}
    return IoResult.Ok -> value: void
}

// System call wrappers (would be implemented as FFI in real implementation)
extern "C" {
    read = (fd: i32, buf: *u8, count: usize) i64
    write = (fd: i32, buf: *u8, count: usize) i64
    open_syscall = (path: *char, flags: i32, mode: i32) i32
    close = (fd: i32) i32
}

// Helper to write string to file descriptor
write_str = (fd: i32, s: string) void {
    write(fd, s.data, s.len)
}

// Format string with arguments (simplified)
format_string = (format: string, args: ...any) string {
    result := vec.new<char>()
    i := 0
    arg_index := 0
    
    loop i < format.len {
        format[i] == '{' && i + 1 < format.len && format[i + 1] == '}' ? {
            // Found placeholder
            arg_index < args.len ? {
                // Convert arg to string and append
                arg_str := to_string(args[arg_index])
                j := 0
                loop j < arg_str.len {
                    result.push(arg_str[j])
                    j = j + 1
                }
                arg_index = arg_index + 1
            } : {}
            i = i + 2
        } : {
            result.push(format[i])
            i = i + 1
        }
    }
    
    return string.from_vec(result)
}

// Convert any value to string (simplified)
to_string = (value: any) string {
    // This would use type introspection in real implementation
    return "<value>"
}

// File open flags (POSIX)
O_RDONLY :: 0x0000
O_WRONLY :: 0x0001
O_RDWR :: 0x0002
O_CREAT :: 0x0040
O_TRUNC :: 0x0200
O_APPEND :: 0x0400