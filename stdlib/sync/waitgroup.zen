// Zen Standard Library: WaitGroup (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Wait for a collection of tasks to complete

{ compiler } = @std
{ futex_wait, futex_wake_all } = @std.sync.futex

// ============================================================================
// WaitGroup - Wait for multiple tasks to complete
// ============================================================================
// Similar to Go's sync.WaitGroup - allows waiting for a collection of
// goroutines (or in Zen's case, tasks/threads) to finish.
//
// Usage:
//   wg = WaitGroup.new()
//   wg.add(3)              // Expect 3 tasks
//
//   // Spawn tasks that call wg.done() when complete
//   spawn_task(|| { do_work(); wg.done() })
//   spawn_task(|| { do_work(); wg.done() })
//   spawn_task(|| { do_work(); wg.done() })
//
//   wg.wait()              // Block until all 3 are done

WaitGroup: {
    counter: i64    // Upper 32 bits: counter, Lower 32 bits: waiters
}

WaitGroup.new = () WaitGroup {
    return WaitGroup { counter: 0 }
}

// Add to the WaitGroup counter (can be negative to decrement)
// Must be called before wait() is called
WaitGroup.add = (self: MutPtr<WaitGroup>, delta: i32) void {
    // Add to upper 32 bits
    delta64 = (delta as i64) << 32
    compiler.atomic_add(&self.val.counter.ref() as Ptr<u64>, delta64 as u64)
}

// Mark one task as done (equivalent to add(-1))
WaitGroup.done = (self: MutPtr<WaitGroup>) void {
    // Decrement upper 32 bits
    old = compiler.atomic_sub(&self.val.counter.ref() as Ptr<u64>, (1 as i64 << 32) as u64) as i64

    // Extract counter and waiters
    counter = (old >> 32) as i32 - 1
    waiters = old as i32

    // If counter reaches 0 and there are waiters, wake them
    counter == 0 ? {
        waiters > 0 ? {
            futex_wake_all(&self.val.counter.ref())
        }
    }
}

// Wait until counter reaches zero
WaitGroup.wait = (self: MutPtr<WaitGroup>) void {
    val = compiler.atomic_load(&self.val.counter.ref() as Ptr<u64>) as i64
    counter = (val >> 32) as i32

    // Fast path: already done
    counter == 0 ? { return }

    // Increment waiter count (lower 32 bits)
    compiler.atomic_add(&self.val.counter.ref() as Ptr<u64>, 1)

    // Wait loop
    done = false
    done == false ? {
        val = compiler.atomic_load(&self.val.counter.ref() as Ptr<u64>) as i64
        counter = (val >> 32) as i32

        counter == 0 ? { done = true }
        done == false ? {
            futex_wait(&self.val.counter.ref(), val as i32)
        }
    }

    // Decrement waiter count
    compiler.atomic_sub(&self.val.counter.ref() as Ptr<u64>, 1)
}

// Get current counter value (for debugging)
WaitGroup.counter = (self: Ptr<WaitGroup>) i32 {
    val = compiler.atomic_load(&self.val.counter.ref() as Ptr<u64>) as i64
    return (val >> 32) as i32
}

// Check if all tasks are done
WaitGroup.is_done = (self: Ptr<WaitGroup>) bool {
    return self.counter() == 0
}

// ============================================================================
// Latch - One-shot synchronization barrier
// ============================================================================
// Unlike WaitGroup, a Latch can only count down (never up) and
// once triggered, all future wait() calls return immediately.
//
// Useful for one-time initialization gates.

Latch: {
    count: i32
}

Latch.new = (count: i32) Latch {
    return Latch { count: count }
}

// Count down by one
Latch.count_down = (self: MutPtr<Latch>) void {
    old = compiler.atomic_sub(&self.val.count.ref() as Ptr<u64>, 1) as i32 - 1

    // If we hit zero, wake all waiters
    old == 0 ? {
        futex_wake_all(&self.val.count.ref())
    }
}

// Wait until count reaches zero
Latch.wait = (self: MutPtr<Latch>) void {
    count = compiler.atomic_load(&self.val.count.ref() as Ptr<u64>) as i32

    // Fast path
    count <= 0 ? { return }

    // Wait loop
    count > 0 ? {
        futex_wait(&self.val.count.ref(), count)
        count = compiler.atomic_load(&self.val.count.ref() as Ptr<u64>) as i32
    }
}

// Arrive and wait (combines count_down + wait)
Latch.arrive_and_wait = (self: MutPtr<Latch>) void {
    self.count_down()
    self.wait()
}

// Check if latch has triggered
Latch.is_ready = (self: Ptr<Latch>) bool {
    count = compiler.atomic_load(&self.val.count.ref() as Ptr<u64>) as i32
    return count <= 0
}

// ============================================================================
// CountDownEvent - Generalization of Latch with reset capability
// ============================================================================

CountDownEvent: {
    initial: i32,
    current: i32
}

CountDownEvent.new = (count: i32) CountDownEvent {
    return CountDownEvent { initial: count, current: count }
}

CountDownEvent.signal = (self: MutPtr<CountDownEvent>) void {
    old = compiler.atomic_sub(&self.val.current.ref() as Ptr<u64>, 1) as i32 - 1
    old == 0 ? {
        futex_wake_all(&self.val.current.ref())
    }
}

CountDownEvent.wait = (self: MutPtr<CountDownEvent>) void {
    count = compiler.atomic_load(&self.val.current.ref() as Ptr<u64>) as i32
    count > 0 ? {
        futex_wait(&self.val.current.ref(), count)
    }
}

CountDownEvent.reset = (self: MutPtr<CountDownEvent>) void {
    compiler.atomic_store(&self.val.current.ref() as Ptr<u64>, self.val.initial as u64)
}

CountDownEvent.is_set = (self: Ptr<CountDownEvent>) bool {
    count = compiler.atomic_load(&self.val.current.ref() as Ptr<u64>) as i32
    return count <= 0
}
