// Zen Standard Library: Semaphore (Syscall-based)
// No FFI - uses compiler.syscall* intrinsics
// Counting semaphore for limiting concurrent access

{ compiler } = @std
{ futex_wait, futex_wake_one, futex_wake } = @std.sync.futex

// ============================================================================
// Semaphore - Counting semaphore
// ============================================================================
// A semaphore maintains a count that can be incremented (signal/post) and
// decremented (wait/acquire). When the count is zero, wait blocks until
// another thread signals.
//
// Use cases:
// - Limiting concurrent access to a resource pool
// - Producer/consumer synchronization
// - Signaling between threads

Semaphore: {
    count: i32,    // Available permits
    waiters: i32   // Number of waiting threads (for efficient wakeup)
}

// Create a new semaphore with initial count
Semaphore.new = (initial: i32) Semaphore {
    return Semaphore { count: initial, waiters: 0 }
}

// Create a binary semaphore (mutex-like, 0 or 1)
Semaphore.binary = () Semaphore {
    return Semaphore.new(1)
}

// Acquire a permit (decrement count), blocking if count is zero
Semaphore.acquire = (self: MutPtr<Semaphore>) void {
    // Fast path: try to decrement if count > 0
    count = compiler.atomic_load(&self.val.count.ref() as Ptr<u64>) as i32
    count > 0 ? {
        old = compiler.atomic_cas(&self.val.count.ref() as Ptr<u64>, count, count - 1)
        old == count ? { return }
    }

    // Slow path: need to wait
    self.acquire_slow()
}

// Slow path for acquire - handles contention
Semaphore.acquire_slow = (self: MutPtr<Semaphore>) void {
    acquired = false
    acquired == false ? {
        // Register as waiter
        compiler.atomic_add(&self.val.waiters.ref() as Ptr<u64>, 1)

        // Check count and wait if zero
        count = compiler.atomic_load(&self.val.count.ref() as Ptr<u64>) as i32
        count == 0 ? {
            futex_wait(&self.val.count.ref(), 0)
        }

        // Unregister as waiter
        compiler.atomic_sub(&self.val.waiters.ref() as Ptr<u64>, 1)

        // Try to acquire
        count = compiler.atomic_load(&self.val.count.ref() as Ptr<u64>) as i32
        count > 0 ? {
            old = compiler.atomic_cas(&self.val.count.ref() as Ptr<u64>, count, count - 1)
            old == count ? { acquired = true }
        }
    }
}

// Try to acquire without blocking
// Returns true if permit was acquired, false if count was zero
Semaphore.try_acquire = (self: MutPtr<Semaphore>) bool {
    count = compiler.atomic_load(&self.val.count.ref() as Ptr<u64>) as i32
    count > 0 ? {
        old = compiler.atomic_cas(&self.val.count.ref() as Ptr<u64>, count, count - 1)
        return old == count
    }
    return false
}

// Release a permit (increment count), waking one waiter if any
Semaphore.release = (self: MutPtr<Semaphore>) void {
    // Increment count
    compiler.atomic_add(&self.val.count.ref() as Ptr<u64>, 1)

    // Wake one waiter if there are any
    waiters = compiler.atomic_load(&self.val.waiters.ref() as Ptr<u64>) as i32
    waiters > 0 ? {
        futex_wake_one(&self.val.count.ref())
    }
}

// Release multiple permits at once
Semaphore.release_n = (self: MutPtr<Semaphore>, n: i32) void {
    // Increment count by n
    compiler.atomic_add(&self.val.count.ref() as Ptr<u64>, n)

    // Wake waiters
    waiters = compiler.atomic_load(&self.val.waiters.ref() as Ptr<u64>) as i32
    waiters > 0 ? {
        // Wake up to n waiters
        wake_count = n < waiters ? { n } : { waiters }
        futex_wake(&self.val.count.ref(), wake_count)
    }
}

// Get current count (for debugging/testing)
Semaphore.available = (self: Ptr<Semaphore>) i32 {
    return compiler.atomic_load(&self.val.count.ref() as Ptr<u64>) as i32
}

// ============================================================================
// SemaphoreGuard - RAII-style permit guard
// ============================================================================

SemaphoreGuard: {
    sem: MutPtr<Semaphore>
}

SemaphoreGuard.new = (sem: MutPtr<Semaphore>) SemaphoreGuard {
    sem.acquire()
    return SemaphoreGuard { sem: sem }
}

SemaphoreGuard.release = (self: MutPtr<SemaphoreGuard>) void {
    self.val.sem.release()
}
