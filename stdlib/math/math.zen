// Zen Standard Library: Math Module
// Mathematical functions from libm

// Pi constant
PI = 3.14159265358979323846

// e constant (Euler's number)
E = 2.71828182845904523536

// Trigonometric functions
sin = (x: f64) f64 {
    // Built-in - calls libm sin
    return x
}

cos = (x: f64) f64 {
    // Built-in - calls libm cos
    return x
}

tan = (x: f64) f64 {
    // Built-in - calls libm tan
    return x
}

asin = (x: f64) f64 {
    // Built-in - calls libm asin
    return x
}

acos = (x: f64) f64 {
    // Built-in - calls libm acos
    return x
}

atan = (x: f64) f64 {
    // Built-in - calls libm atan
    return x
}

atan2 = (y: f64, x: f64) f64 {
    // Built-in - calls libm atan2
    return x
}

// Hyperbolic functions
sinh = (x: f64) f64 {
    // Built-in - calls libm sinh
    return x
}

cosh = (x: f64) f64 {
    // Built-in - calls libm cosh
    return x
}

tanh = (x: f64) f64 {
    // Built-in - calls libm tanh
    return x
}

// Exponential and logarithmic functions
exp = (x: f64) f64 {
    // Built-in - calls libm exp
    return x
}

log = (x: f64) f64 {
    // Built-in - calls libm log (natural log)
    return x
}

log10 = (x: f64) f64 {
    // Built-in - calls libm log10
    return x
}

log2 = (x: f64) f64 {
    // Built-in - calls libm log2
    return x
}

// Power functions
pow = (x: f64, y: f64) f64 {
    // Built-in - calls libm pow
    return x
}

sqrt = (x: f64) f64 {
    // Built-in - calls libm sqrt
    return x
}

cbrt = (x: f64) f64 {
    // Built-in - calls libm cbrt
    return x
}

// Rounding and absolute value
floor = (x: f64) f64 {
    // Built-in - calls libm floor
    return x
}

ceil = (x: f64) f64 {
    // Built-in - calls libm ceil
    return x
}

round = (x: f64) f64 {
    // Built-in - calls libm round
    return x
}

trunc = (x: f64) f64 {
    // Built-in - calls libm trunc
    return x
}

fabs = (x: f64) f64 {
    // Built-in - calls libm fabs
    return x
}

// Modulo
fmod = (x: f64, y: f64) f64 {
    // Built-in - calls libm fmod
    return x
}

remainder = (x: f64, y: f64) f64 {
    // Built-in - calls libm remainder
    return x
}

// Min/Max
fmin = (x: f64, y: f64) f64 {
    x < y ?
        | true { x }
        | false { y }
}

fmax = (x: f64, y: f64) f64 {
    x > y ?
        | true { x }
        | false { y }
}

// Copy sign
copysign = (x: f64, y: f64) f64 {
    // Built-in - calls libm copysign
    return x
}

// ============================================================================
// Integer Math Functions
// ============================================================================

// Absolute value for i32
abs = (n: i32) i32 {
    n < 0 ?
        | true { return -n }
        | false { return n }
}

// Absolute value for i64
abs64 = (n: i64) i64 {
    n < 0 ?
        | true { return -n }
        | false { return n }
}

// Factorial (u32 -> u64 to avoid overflow)
factorial = (n: u32) u64 {
    n == 0 ?
        | true { return 1 }
        | false { return cast(n, u64) * factorial(n - 1) }
}

// Check if even
is_even = (n: i32) bool {
    n % 2 == 0
}

// Check if odd
is_odd = (n: i32) bool {
    n % 2 != 0
}

// Max of two i32
max = (a: i32, b: i32) i32 {
    a > b ?
        | true { return a }
        | false { return b }
}

// Min of two i32
min = (a: i32, b: i32) i32 {
    a < b ?
        | true { return a }
        | false { return b }
}

// Clamp value to range
clamp = (n: i32, low: i32, high: i32) i32 {
    n < low ?
        | true { return low }
        | false {
            n > high ?
                | true { return high }
                | false { return n }
        }
}

// ============================================================================
// Integer bounds constants
// Useful for safe conversions and overflow checking
// ============================================================================

// Signed integer bounds
I8_MIN = 0 - 128
I8_MAX = 127
I16_MIN = 0 - 32768
I16_MAX = 32767
I32_MIN = 0 - 2147483648
I32_MAX = 2147483647

// Unsigned integer bounds (as i64 for comparison)
U8_MAX = 255
U16_MAX = 65535
U32_MAX = 4294967295
