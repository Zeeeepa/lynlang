// Zen Standard Library: Queue
// FIFO (First In First Out) data structure

{ compiler } = @std
{ Vec, vec_new, vec_with_capacity, vec_push, vec_pop, vec_len, vec_is_empty, vec_free, vec_get_addr } = @std

// Queue<T> - implemented using Vec<T> internally with head/tail
Queue<T>: {
    data: Vec<T>,
    head: usize,
    tail: usize
}

// Create new empty queue
queue_new<T> = () Queue<T> {
    return Queue<T> {
        data: vec_new(),
        head: 0,
        tail: 0
    }
}

// Create queue with capacity
queue_with_capacity<T> = (capacity: usize) Queue<T> {
    return Queue<T> {
        data: vec_with_capacity(capacity),
        head: 0,
        tail: 0
    }
}

// Get queue size
queue_len<T> = (q: Queue<T>) usize {
    if q.tail >= q.head {
        return q.tail - q.head
    }
    return 0
}

// Check if empty
queue_is_empty<T> = (q: Queue<T>) bool {
    return q.head >= q.tail
}

// Enqueue element
queue_enqueue<T> = (q: *Queue<T>, elem_size: usize, elem_addr: *u8) void {
    vec_push(&q.data, elem_size, elem_addr)
    q.tail = q.tail + 1
}

// Dequeue element (conceptually - just advance head)
queue_dequeue<T> = (q: *Queue<T>) void {
    if q.head < q.tail {
        q.head = q.head + 1
    }
}

// Peek at front without removing
queue_peek_addr<T> = (q: Queue<T>) *u8 {
    if q.head >= q.tail {
        return (0 as *u8)
    }
    return vec_get_addr(q.data, q.head)
}

// Clear queue
queue_clear<T> = (q: *Queue<T>) void {
    q.head = 0
    q.tail = 0
}

// Free queue
queue_free<T> = (q: *Queue<T>, elem_size: usize) void {
    vec_free(&q.data, elem_size)
    q.head = 0
    q.tail = 0
}
