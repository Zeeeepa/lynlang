// Zen Standard Library: Queue
// FIFO (First In First Out) data structure
// Uses compile-time generics with Vec<T>

{ compiler } = @std
{ Ptr, Option } = @std.core
{ Allocator } = @std.memory.allocator

// Queue<T> - implemented using Vec<T> internally with head/tail indices
Queue<T>: {
    data: Vec<T>,
    head: usize,
    tail: usize,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create new empty queue
Queue<T>.new = (allocator: Allocator) Queue<T> {
    return Queue<T> {
        data: Vec<T>.new(allocator),
        head: 0,
        tail: 0,
        allocator: allocator
    }
}

// Create queue with initial capacity
Queue<T>.with_capacity = (allocator: Allocator, capacity: usize) Queue<T> {
    return Queue<T> {
        data: Vec<T>.with_capacity(allocator, capacity),
        head: 0,
        tail: 0,
        allocator: allocator
    }
}

// ============================================================================
// Properties
// ============================================================================

// Get queue size
Queue<T>.len = (self: Queue<T>) usize {
    self.tail >= self.head ?
        | true { return self.tail - self.head }
        | false { return 0 }
}

// Check if empty
Queue<T>.is_empty = (self: Queue<T>) bool {
    return self.head >= self.tail
}

// ============================================================================
// Operations
// ============================================================================

// Enqueue element at the back
Queue<T>.enqueue = (self: MutPtr<Queue<T>>, elem: T) void {
    self.val.data.mut_ref().push(elem)
    self.val.tail = self.val.tail + 1
}

// Dequeue element from front (advances head pointer)
Queue<T>.dequeue = (self: MutPtr<Queue<T>>) void {
    self.val.head < self.val.tail ?
        | true { self.val.head = self.val.head + 1 }
        | false { }
}

// Peek at front element without removing
Queue<T>.peek = (self: Queue<T>) Option<T> {
    self.head >= self.tail ?
        | true { return Option.None }
        | false { return self.data.get(self.head) }
}

// Clear queue (reset indices)
Queue<T>.clear = (self: MutPtr<Queue<T>>) void {
    self.val.head = 0
    self.val.tail = 0
    self.val.data.mut_ref().clear()
}

// ============================================================================
// Memory Management
// ============================================================================

// Free queue memory
Queue<T>.free = (self: MutPtr<Queue<T>>) void {
    self.val.data.mut_ref().free()
    self.val.head = 0
    self.val.tail = 0
}

// ============================================================================
// Iterator Support
// ============================================================================

// QueueIterator - Iterates over queue elements from front to back
QueueIterator<T>: {
    data: Vec<T>,
    index: usize,
    tail: usize
}

// Create an iterator over the queue (front to back)
Queue<T>.iter = (self: Queue<T>) QueueIterator<T> {
    return QueueIterator<T> {
        data: self.data,
        index: self.head,
        tail: self.tail
    }
}

// Get next element from iterator
QueueIterator<T>.next = (self: MutPtr<QueueIterator<T>>) Option<T> {
    self.val.index >= self.val.tail ?
        | true { return Option.None }
        | false {
            elem_opt = self.val.data.get(self.val.index)
            self.val.index = self.val.index + 1
            return elem_opt
        }
}

// Check if iterator has more elements
QueueIterator<T>.has_next = (self: QueueIterator<T>) bool {
    return self.index < self.tail
}
