// Zen Standard Library: Queue
// FIFO (First In First Out) data structure

{ compiler } = @std
{ Vec, vec_new, vec_with_capacity, vec_push, vec_pop, vec_len, vec_is_empty, vec_free, vec_get_addr } = @std

// Queue<T> - implemented using Vec<T> internally with head/tail
Queue<T>: {
    data: Vec<T>,
    head: usize,
    tail: usize
}

// Create new empty queue
queue_new<T> = () Queue<T> {
    return Queue<T> {
        data: vec_new(),
        head: 0,
        tail: 0
    }
}

// Create queue with capacity
queue_with_capacity<T> = (capacity: usize) Queue<T> {
    return Queue<T> {
        data: vec_with_capacity(capacity),
        head: 0,
        tail: 0
    }
}

// Get queue size
queue_len<T> = (q: Queue<T>) usize {
    q.tail >= q.head ?
        | true { return q.tail - q.head }
        | false { return 0 }
}

// Check if empty
queue_is_empty<T> = (q: Queue<T>) bool {
    return q.head >= q.tail
}

// Enqueue element
queue_enqueue<T> = (q: MutPtr<Queue<T>>, elem_size: usize, elem_addr: RawPtr<u8>) void {
    vec_push(q.val.data.mut_ref(), elem_size, elem_addr)
    q.val.tail = q.val.tail + 1
}

// Dequeue element (conceptually - just advance head)
queue_dequeue<T> = (q: MutPtr<Queue<T>>) void {
    q.val.head < q.val.tail ?
        | true { q.val.head = q.val.head + 1 }
        | false { }
}

// Peek at front without removing
queue_peek_addr<T> = (q: Queue<T>) RawPtr<u8> {
    q.head >= q.tail ?
        | true { return compiler.int_to_ptr(0) }
        | false { }
    return vec_get_addr(q.data, q.head)
}

// Clear queue
queue_clear<T> = (q: MutPtr<Queue<T>>) void {
    q.val.head = 0
    q.val.tail = 0
}

// Free queue
queue_free<T> = (q: MutPtr<Queue<T>>, elem_size: usize) void {
    vec_free(q.val.data.mut_ref(), elem_size)
    q.val.head = 0
    q.val.tail = 0
}
