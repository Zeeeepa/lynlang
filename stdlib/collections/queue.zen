// Zen Standard Library: Queue
// FIFO (First In First Out) data structure
// Uses compile-time generics with Vec<T>

{ compiler } = @std
{ Ptr, Option } = @std.core
{ Allocator } = @std.memory.allocator

// Queue<T> - implemented using Vec<T> internally with head/tail indices
Queue<T>: {
    data: Vec<T>,
    head: usize,
    tail: usize,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create new empty queue
Queue<T>.new = (allocator: Allocator) Queue<T> {
    return Queue<T> {
        data: Vec<T>.new(allocator),
        head: 0,
        tail: 0,
        allocator: allocator
    }
}

// Create queue with initial capacity
Queue<T>.with_capacity = (allocator: Allocator, capacity: usize) Queue<T> {
    return Queue<T> {
        data: Vec<T>.with_capacity(allocator, capacity),
        head: 0,
        tail: 0,
        allocator: allocator
    }
}

// ============================================================================
// Properties
// ============================================================================

// Get queue size
Queue<T>.len = (self: Queue<T>) usize {
    self.tail >= self.head ?
        | true { return self.tail - self.head }
        | false { return 0 }
}

// Check if empty
Queue<T>.is_empty = (self: Queue<T>) bool {
    return self.head >= self.tail
}

// ============================================================================
// Operations
// ============================================================================

// Enqueue element at the back
Queue<T>.enqueue = (self: MutPtr<Queue<T>>, elem: T) void {
    self.val.data.mut_ref().push(elem)
    self.val.tail = self.val.tail + 1
}

// Dequeue element from front (advances head pointer)
Queue<T>.dequeue = (self: MutPtr<Queue<T>>) void {
    self.val.head < self.val.tail ?
        | true { self.val.head = self.val.head + 1 }
        | false { }
}

// Peek at front element without removing
Queue<T>.peek = (self: Queue<T>) Option<T> {
    self.head >= self.tail ?
        | true { return Option.None }
        | false { return self.data.get(self.head) }
}

// Clear queue (reset indices)
Queue<T>.clear = (self: MutPtr<Queue<T>>) void {
    self.val.head = 0
    self.val.tail = 0
    self.val.data.mut_ref().clear()
}

// ============================================================================
// Memory Management
// ============================================================================

// Free queue memory
Queue<T>.free = (self: MutPtr<Queue<T>>) void {
    self.val.data.mut_ref().free()
    self.val.head = 0
    self.val.tail = 0
}
