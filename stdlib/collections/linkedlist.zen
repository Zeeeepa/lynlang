// Zen Standard Library: LinkedList<T>
// Doubly-linked list with safe pointers and allocator support

{ compiler } = @std
{ Ptr, Option } = @std.core
{ Allocator } = @std.memory.allocator

// ============================================================================
// Node - Internal linked list node
// ============================================================================

Node<T>: {
    value: T,
    prev: Ptr<Node<T>>,
    next: Ptr<Node<T>>
}

// ============================================================================
// LinkedList<T> - Doubly-linked list
// ============================================================================

LinkedList<T>: {
    head: Ptr<Node<T>>,
    tail: Ptr<Node<T>>,
    len: usize,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create new empty linked list
LinkedList<T>.new = (allocator: Allocator) LinkedList<T> {
    return LinkedList<T> {
        head: Ptr<Node<T>>.none(),
        tail: Ptr<Node<T>>.none(),
        len: 0,
        allocator: allocator
    }
}

// ============================================================================
// Properties
// ============================================================================

// Get current length
LinkedList<T>.len = (self: LinkedList<T>) usize {
    return self.len
}

// Alias for len
LinkedList<T>.size = (self: LinkedList<T>) usize {
    return self.len
}

// Check if empty
LinkedList<T>.is_empty = (self: LinkedList<T>) bool {
    return self.len == 0
}

// ============================================================================
// Read Operations
// ============================================================================

// Get first element
LinkedList<T>.front = (self: LinkedList<T>) Option<T> {
    self.head.is_null() ? {
        return Option.None
    }
    return Option.Some(self.head.val.value)
}

// Get last element
LinkedList<T>.back = (self: LinkedList<T>) Option<T> {
    self.tail.is_null() ? {
        return Option.None
    }
    return Option.Some(self.tail.val.value)
}

// Get element at index (O(n) - walks from closest end)
LinkedList<T>.get = (self: LinkedList<T>, index: usize) Option<T> {
    index >= self.len ? {
        return Option.None
    }

    // Walk from head or tail depending on which is closer
    index < self.len / 2 ? {
        // Walk from head
        current = self.head
        i = 0
        i < index ? {
            current = current.val.next
            i = i + 1
        }
        return Option.Some(current.val.value)
    }

    // Walk from tail
    current = self.tail
    i = self.len - 1
    i > index ? {
        current = current.val.prev
        i = i - 1
    }
    return Option.Some(current.val.value)
}

// Check if list contains value
LinkedList<T>.contains = (self: LinkedList<T>, value: T) bool {
    current = self.head
    !current.is_null() ? {
        current.val.value == value ? {
            return true
        }
        current = current.val.next
    }
    return false
}

// ============================================================================
// Write Operations
// ============================================================================

// Allocate a new node
LinkedList<T>.alloc_node = (self: MutPtr<LinkedList<T>>, value: T) Ptr<Node<T>> {
    node_size = compiler.sizeof<Node<T>>()
    raw_ptr = self.val.allocator.allocate(node_size)
    node_ptr = Ptr<Node<T>>.from_addr(raw_ptr)

    // Initialize node
    node_ptr.mut_ref().val = Node<T> {
        value: value,
        prev: Ptr<Node<T>>.none(),
        next: Ptr<Node<T>>.none()
    }

    return node_ptr
}

// Free a node
LinkedList<T>.free_node = (self: MutPtr<LinkedList<T>>, node: Ptr<Node<T>>) void {
    node_size = compiler.sizeof<Node<T>>()
    raw_ptr = compiler.ptr_to_int(node)
    self.val.allocator.deallocate(raw_ptr, node_size)
}

// Push element to front
LinkedList<T>.push_front = (self: MutPtr<LinkedList<T>>, value: T) void {
    new_node = self.alloc_node(value)

    self.val.head.is_null() ? {
        // Empty list - new node is both head and tail
        self.val.head = new_node
        self.val.tail = new_node
    } : {
        // Link new node to current head
        new_node.mut_ref().val.next = self.val.head
        self.val.head.mut_ref().val.prev = new_node
        self.val.head = new_node
    }

    self.val.len = self.val.len + 1
}

// Push element to back
LinkedList<T>.push_back = (self: MutPtr<LinkedList<T>>, value: T) void {
    new_node = self.alloc_node(value)

    self.val.tail.is_null() ? {
        // Empty list - new node is both head and tail
        self.val.head = new_node
        self.val.tail = new_node
    } : {
        // Link new node to current tail
        new_node.mut_ref().val.prev = self.val.tail
        self.val.tail.mut_ref().val.next = new_node
        self.val.tail = new_node
    }

    self.val.len = self.val.len + 1
}

// Pop element from front
LinkedList<T>.pop_front = (self: MutPtr<LinkedList<T>>) Option<T> {
    self.val.head.is_null() ? {
        return Option.None
    }

    old_head = self.val.head
    value = old_head.val.value

    self.val.head = old_head.val.next
    self.val.head.is_null() ? {
        // List is now empty
        self.val.tail = Ptr<Node<T>>.none()
    } : {
        // Clear prev pointer of new head
        self.val.head.mut_ref().val.prev = Ptr<Node<T>>.none()
    }

    self.free_node(old_head)
    self.val.len = self.val.len - 1

    return Option.Some(value)
}

// Pop element from back
LinkedList<T>.pop_back = (self: MutPtr<LinkedList<T>>) Option<T> {
    self.val.tail.is_null() ? {
        return Option.None
    }

    old_tail = self.val.tail
    value = old_tail.val.value

    self.val.tail = old_tail.val.prev
    self.val.tail.is_null() ? {
        // List is now empty
        self.val.head = Ptr<Node<T>>.none()
    } : {
        // Clear next pointer of new tail
        self.val.tail.mut_ref().val.next = Ptr<Node<T>>.none()
    }

    self.free_node(old_tail)
    self.val.len = self.val.len - 1

    return Option.Some(value)
}

// Insert at index (O(n))
LinkedList<T>.insert = (self: MutPtr<LinkedList<T>>, index: usize, value: T) bool {
    index > self.val.len ? {
        return false
    }

    index == 0 ? {
        self.push_front(value)
        return true
    }

    index == self.val.len ? {
        self.push_back(value)
        return true
    }

    // Find node at index
    current = self.val.head
    i = 0
    i < index ? {
        current = current.val.next
        i = i + 1
    }

    // Insert before current
    new_node = self.alloc_node(value)
    prev_node = current.val.prev

    new_node.mut_ref().val.prev = prev_node
    new_node.mut_ref().val.next = current
    prev_node.mut_ref().val.next = new_node
    current.mut_ref().val.prev = new_node

    self.val.len = self.val.len + 1
    return true
}

// Remove at index (O(n))
LinkedList<T>.remove = (self: MutPtr<LinkedList<T>>, index: usize) Option<T> {
    index >= self.val.len ? {
        return Option.None
    }

    index == 0 ? {
        return self.pop_front()
    }

    index == self.val.len - 1 ? {
        return self.pop_back()
    }

    // Find node at index
    current = self.val.head
    i = 0
    i < index ? {
        current = current.val.next
        i = i + 1
    }

    // Unlink node
    value = current.val.value
    prev_node = current.val.prev
    next_node = current.val.next

    prev_node.mut_ref().val.next = next_node
    next_node.mut_ref().val.prev = prev_node

    self.free_node(current)
    self.val.len = self.val.len - 1

    return Option.Some(value)
}

// Clear all elements
LinkedList<T>.clear = (self: MutPtr<LinkedList<T>>) void {
    !self.val.head.is_null() ? {
        current = self.val.head
        !current.is_null() ? {
            next = current.val.next
            self.free_node(current)
            current = next
        }
    }

    self.val.head = Ptr<Node<T>>.none()
    self.val.tail = Ptr<Node<T>>.none()
    self.val.len = 0
}

// Free all memory
LinkedList<T>.free = (self: MutPtr<LinkedList<T>>) void {
    self.clear()
}

// ============================================================================
// Iterator Support
// ============================================================================

// Iterator state
LinkedListIter<T>: {
    current: Ptr<Node<T>>
}

// Get iterator
LinkedList<T>.iter = (self: LinkedList<T>) LinkedListIter<T> {
    return LinkedListIter<T> {
        current: self.head
    }
}

// Check if iterator has more elements
LinkedListIter<T>.has_next = (self: LinkedListIter<T>) bool {
    return !self.current.is_null()
}

// Get next element
LinkedListIter<T>.next = (self: MutPtr<LinkedListIter<T>>) Option<T> {
    self.val.current.is_null() ? {
        return Option.None
    }

    value = self.val.current.val.value
    self.val.current = self.val.current.val.next
    return Option.Some(value)
}
