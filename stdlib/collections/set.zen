// Zen Standard Library: Set
// Unordered collection of unique elements

{ compiler } = @std
{ Vec, vec_new, vec_with_capacity, vec_len, vec_is_empty, vec_free, vec_get_addr } = @std

// Set<T> - implemented using Vec<T> (simplified: just tracks unique items)
Set<T>: {
    data: Vec<T>
}

// Create new empty set
set_new<T> = () Set<T> {
    return Set<T> {
        data: vec_new()
    }
}

// Create set with capacity
set_with_capacity<T> = (capacity: usize) Set<T> {
    return Set<T> {
        data: vec_with_capacity(capacity)
    }
}

// Get set size
set_len<T> = (s: Set<T>) usize {
    return vec_len(s.data)
}

// Check if empty
set_is_empty<T> = (s: Set<T>) bool {
    return vec_is_empty(s.data)
}

// Check if element exists (naive O(n) search)
set_contains<T> = (s: Set<T>, index: usize) bool {
    return index < vec_len(s.data)
}

// Insert element (caller responsible for uniqueness)
set_insert<T> = (s: MutPtr<Set<T>>, elem_size: usize, elem_addr: RawPtr<u8>) void {
    // TODO: Check for duplicates before inserting
    // For now, just add blindly
    vec_push(s.val.data.mut_ref(), elem_size, elem_addr)
}

// Remove element at index
set_remove<T> = (s: MutPtr<Set<T>>, index: usize) void {
    index < vec_len(s.val.data) ?
        | true {
            // Remove by swapping with last element
            last_index = vec_len(s.val.data) - 1
            index != last_index ?
                | true {
                    last_addr = vec_get_addr(s.val.data, last_index)
                    target_addr = vec_get_addr(s.val.data, index)

                    // Copy last element to index position
                    elem_size = compiler.sizeof(T)
                    i ::= 0
                    loop(() {
                        i >= elem_size ?
                            | true { break }
                            | false { }
                        offset = cast(i, i64)
                        src = compiler.gep(last_addr, offset)
                        dst = compiler.gep(target_addr, offset)
                        // TODO: Copy byte
                        i = i + 1
                    })
                }
                | false { }

            // Decrease length
            s.val.data.len = s.val.data.len - 1
        }
        | false { }
}

// Clear set
set_clear<T> = (s: MutPtr<Set<T>>) void {
    s.val.data.len = 0
}

// Free set
set_free<T> = (s: MutPtr<Set<T>>, elem_size: usize) void {
    vec_free(s.val.data.mut_ref(), elem_size)
}
