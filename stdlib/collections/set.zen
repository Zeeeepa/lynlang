// Zen Standard Library: Set
// Unordered collection of unique elements
// Uses compile-time generics with Vec<T>

{ compiler } = @std
{ Ptr, Option } = @std.core
{ Allocator } = @std.memory.allocator

// Set<T> - implemented using Vec<T> (simplified: linear search)
Set<T>: {
    data: Vec<T>,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create new empty set
Set<T>.new = (allocator: Allocator) Set<T> {
    return Set<T> {
        data: Vec<T>.new(allocator),
        allocator: allocator
    }
}

// Create set with initial capacity
Set<T>.with_capacity = (allocator: Allocator, capacity: usize) Set<T> {
    return Set<T> {
        data: Vec<T>.with_capacity(allocator, capacity),
        allocator: allocator
    }
}

// ============================================================================
// Properties
// ============================================================================

// Get set size
Set<T>.len = (self: Set<T>) usize {
    return self.data.len()
}

// Check if empty
Set<T>.is_empty = (self: Set<T>) bool {
    return self.data.is_empty()
}

// ============================================================================
// Operations
// ============================================================================

// Check if element exists at index (bounds check)
Set<T>.contains_index = (self: Set<T>, index: usize) bool {
    return index < self.data.len()
}

// Insert element (caller responsible for uniqueness)
// TODO: Add proper duplicate checking with equality comparison
Set<T>.insert = (self: MutPtr<Set<T>>, elem: T) void {
    self.val.data.mut_ref().push(elem)
}

// Remove element at index (swap-remove for O(1))
Set<T>.remove_at = (self: MutPtr<Set<T>>, index: usize) void {
    len = self.val.data.len()
    index < len ?
        | true {
            // Swap with last element if not already last
            last_index = len - 1
            index != last_index ?
                | true {
                    // TODO: swap elements when we have proper element access
                }
                | false { }
            // Pop the last element
            self.val.data.mut_ref().pop()
        }
        | false { }
}

// Clear set
Set<T>.clear = (self: MutPtr<Set<T>>) void {
    self.val.data.mut_ref().clear()
}

// ============================================================================
// Memory Management
// ============================================================================

// Free set memory
Set<T>.free = (self: MutPtr<Set<T>>) void {
    self.val.data.mut_ref().free()
}
