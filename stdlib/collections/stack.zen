// Zen Standard Library: Stack
// LIFO (Last In First Out) data structure

{ compiler } = @std
{ Vec, vec_new, vec_with_capacity, vec_push, vec_pop, vec_len, vec_is_empty, vec_free } = @std

// Stack<T> - implemented using Vec<T> internally
Stack<T>: {
    data: Vec<T>
}

// Create new empty stack
stack_new<T> = () Stack<T> {
    return Stack<T> {
        data: vec_new()
    }
}

// Create stack with capacity
stack_with_capacity<T> = (capacity: usize) Stack<T> {
    return Stack<T> {
        data: vec_with_capacity(capacity)
    }
}

// Get stack size
stack_len<T> = (s: Stack<T>) usize {
    return vec_len(s.data)
}

// Check if empty
stack_is_empty<T> = (s: Stack<T>) bool {
    return vec_is_empty(s.data)
}

// Push element onto stack
stack_push<T> = (s: MutPtr<Stack<T>>, elem_size: usize, elem_addr: RawPtr<u8>) void {
    vec_push(s.val.data.mut_ref(), elem_size, elem_addr)
}

// Pop element from stack
stack_pop<T> = (s: MutPtr<Stack<T>>) void {
    vec_pop(s.val.data.mut_ref())
}

// Peek at top without removing
stack_peek_addr<T> = (s: Stack<T>) RawPtr<u8> {
    len = vec_len(s.data)
    len == 0 ?
        | true { return compiler.int_to_ptr(0) }
        | false { }
    return vec_get_addr(s.data, len - 1)
}

// Clear stack
stack_clear<T> = (s: MutPtr<Stack<T>>) void {
    // Use internal vec clear
    s.val.data.len = 0
}

// Free stack
stack_free<T> = (s: MutPtr<Stack<T>>, elem_size: usize) void {
    vec_free(s.val.data.mut_ref(), elem_size)
}
