// Zen Standard Library: HashMap
// Hash-based key-value map
// Uses compile-time generics with Vec<T>

{ compiler } = @std
{ Ptr, Option } = @std.core
{ Allocator } = @std.memory.allocator

// Entry for a single key-value pair
Entry<K, V>: {
    key: K,
    value: V,
    occupied: bool
}

// HashMap<K, V> - simple hash map using linear probing
HashMap<K, V>: {
    entries: Vec<Entry<K, V>>,
    size: usize,
    capacity: usize,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create new empty hashmap
HashMap<K, V>.new = (allocator: Allocator) HashMap<K, V> {
    return HashMap<K, V> {
        entries: Vec<Entry<K, V>>.new(allocator),
        size: 0,
        capacity: 0,
        allocator: allocator
    }
}

// Create hashmap with initial capacity
HashMap<K, V>.with_capacity = (allocator: Allocator, capacity: usize) HashMap<K, V> {
    return HashMap<K, V> {
        entries: Vec<Entry<K, V>>.with_capacity(allocator, capacity),
        size: 0,
        capacity: capacity,
        allocator: allocator
    }
}

// ============================================================================
// Properties
// ============================================================================

// Get number of entries
HashMap<K, V>.len = (self: HashMap<K, V>) usize {
    return self.size
}

// Check if empty
HashMap<K, V>.is_empty = (self: HashMap<K, V>) bool {
    return self.size == 0
}

// ============================================================================
// Hash Function
// ============================================================================

// Simple hash function using FNV-1a algorithm
// For simplicity, we convert the key to bytes and hash them
// This works for primitive types (integers) by treating them as byte sequences
hash<K> = (key: K) u64 {
    // FNV-1a constants
    FNV_OFFSET = 2166136261
    FNV_PRIME = 16777619

    // Get size of the key type
    key_size = compiler.sizeof<K>()

    // Allocate temporary space and store the key
    key_ptr = compiler.raw_allocate(key_size)
    compiler.store<K>(key_ptr, key)

    // Hash each byte using FNV-1a
    // Since Zen doesn't have traditional loops, we'll manually unroll for common sizes
    // This handles keys up to 8 bytes (covers i32, i64, u32, u64, pointers)
    hash_val = FNV_OFFSET

    // Byte 0
    key_size > 0 ?
        | true {
            b = compiler.load<u8>(compiler.gep(key_ptr, 0))
            hash_val = (hash_val ^ b) * FNV_PRIME
        }
        | false { }

    // Byte 1
    key_size > 1 ?
        | true {
            b = compiler.load<u8>(compiler.gep(key_ptr, 1))
            hash_val = (hash_val ^ b) * FNV_PRIME
        }
        | false { }

    // Byte 2
    key_size > 2 ?
        | true {
            b = compiler.load<u8>(compiler.gep(key_ptr, 2))
            hash_val = (hash_val ^ b) * FNV_PRIME
        }
        | false { }

    // Byte 3
    key_size > 3 ?
        | true {
            b = compiler.load<u8>(compiler.gep(key_ptr, 3))
            hash_val = (hash_val ^ b) * FNV_PRIME
        }
        | false { }

    // Byte 4
    key_size > 4 ?
        | true {
            b = compiler.load<u8>(compiler.gep(key_ptr, 4))
            hash_val = (hash_val ^ b) * FNV_PRIME
        }
        | false { }

    // Byte 5
    key_size > 5 ?
        | true {
            b = compiler.load<u8>(compiler.gep(key_ptr, 5))
            hash_val = (hash_val ^ b) * FNV_PRIME
        }
        | false { }

    // Byte 6
    key_size > 6 ?
        | true {
            b = compiler.load<u8>(compiler.gep(key_ptr, 6))
            hash_val = (hash_val ^ b) * FNV_PRIME
        }
        | false { }

    // Byte 7
    key_size > 7 ?
        | true {
            b = compiler.load<u8>(compiler.gep(key_ptr, 7))
            hash_val = (hash_val ^ b) * FNV_PRIME
        }
        | false { }

    // Clean up
    compiler.raw_deallocate(key_ptr, key_size)

    return hash_val
}

// Helper: Check if two keys are equal using memcmp
keys_equal<K> = (key1: K, key2: K) bool {
    key_size = compiler.sizeof<K>()

    // Allocate temp space for both keys
    ptr1 = compiler.raw_allocate(key_size)
    ptr2 = compiler.raw_allocate(key_size)

    compiler.store<K>(ptr1, key1)
    compiler.store<K>(ptr2, key2)

    // Compare memory
    result = compiler.memcmp(ptr1, ptr2, key_size)

    // Clean up
    compiler.raw_deallocate(ptr1, key_size)
    compiler.raw_deallocate(ptr2, key_size)

    return result == 0
}

// Helper: Find slot for key using linear probing (recursive)
find_slot<K, V> = (entries: Vec<Entry<K, V>>, key: K, start_index: usize, probe: usize, capacity: usize) usize {
    probe >= capacity ?
        | true {
            // Failed to find slot (table full) - return start_index
            return start_index
        }
        | false {
            current = (start_index + probe) % capacity
            entry_opt = entries.get(current)

            entry_opt ?
                | Some(entry) {
                    // Found empty slot or matching key
                    !entry.occupied ?
                        | true { return current }
                        | false {
                            keys_equal<K>(entry.key, key) ?
                                | true { return current }
                                | false {
                                    // Continue probing
                                    return find_slot<K, V>(entries, key, start_index, probe + 1, capacity)
                                }
                        }
                }
                | None {
                    // Shouldn't happen, return start_index
                    return start_index
                }
        }
}

// ============================================================================
// Operations
// ============================================================================

// Helper: Initialize empty entries in vector (recursive)
init_entries<K, V> = (vec: MutPtr<Vec<Entry<K, V>>>, count: usize, dummy_key: K, dummy_val: V) void {
    count > 0 ?
        | true {
            empty_entry = Entry<K, V> {
                key: dummy_key,
                value: dummy_val,
                occupied: false
            }
            vec.val.push(empty_entry)
            init_entries<K, V>(vec, count - 1, dummy_key, dummy_val)
        }
        | false { }
}

// Insert key-value pair
HashMap<K, V>.insert = (self: MutPtr<HashMap<K, V>>, key: K, value: V) void {
    // Initialize capacity if empty
    self.val.capacity == 0 ?
        | true {
            self.val.capacity = 16
            // Fill with empty entries
            init_entries<K, V>(self.val.entries.mut_ref(), 16, key, value)
        }
        | false { }

    // Compute hash and find slot using linear probing
    h = hash<K>(key)
    start_index = h % self.val.capacity
    slot_index = find_slot<K, V>(self.val.entries, key, start_index, 0, self.val.capacity)

    // Get pointer to entry at slot_index and update it
    entry_ptr = self.val.entries.val.data.at(slot_index)
    entry_ptr ?
        | Some(_) {
            addr = entry_ptr.addr()

            // Check if this is a new insertion
            existing_opt = self.val.entries.get(slot_index)
            is_new = false
            existing_opt ?
                | Some(existing) {
                    is_new = !existing.occupied
                }
                | None { }

            // Create and store new entry
            new_entry = Entry<K, V> {
                key: key,
                value: value,
                occupied: true
            }
            compiler.store<Entry<K, V>>(addr, new_entry)

            // Increment size if new insertion
            is_new ?
                | true { self.val.size = self.val.size + 1 }
                | false { }
        }
        | None { }
}

// Get value by key
HashMap<K, V>.get = (self: HashMap<K, V>, key: K) Option<V> {
    // Return None if empty
    self.capacity == 0 ?
        | true { return Option.None }
        | false { }

    // Compute hash and find slot
    h = hash<K>(key)
    start_index = h % self.capacity
    slot_index = find_slot<K, V>(self.entries, key, start_index, 0, self.capacity)

    // Check if entry exists and is occupied
    entry_opt = self.entries.get(slot_index)
    entry_opt ?
        | Some(entry) {
            // Return value if occupied and key matches
            entry.occupied ?
                | true {
                    keys_equal<K>(entry.key, key) ?
                        | true { return Option.Some(entry.value) }
                        | false { return Option.None }
                }
                | false { return Option.None }
        }
        | None { return Option.None }
}

// Check if key exists
HashMap<K, V>.contains_key = (self: HashMap<K, V>, key: K) bool {
    // Return false if empty
    self.capacity == 0 ?
        | true { return false }
        | false { }

    // Compute hash and find slot
    h = hash<K>(key)
    start_index = h % self.capacity
    slot_index = find_slot<K, V>(self.entries, key, start_index, 0, self.capacity)

    // Check if entry exists and is occupied
    entry_opt = self.entries.get(slot_index)
    entry_opt ?
        | Some(entry) {
            entry.occupied ?
                | true {
                    return keys_equal<K>(entry.key, key)
                }
                | false { return false }
        }
        | None { return false }
}

// Remove key and return value
HashMap<K, V>.remove = (self: MutPtr<HashMap<K, V>>, key: K) Option<V> {
    // Return None if empty
    self.val.capacity == 0 ?
        | true { return Option.None }
        | false { }

    // Compute hash and find slot
    h = hash<K>(key)
    start_index = h % self.val.capacity
    slot_index = find_slot<K, V>(self.val.entries, key, start_index, 0, self.val.capacity)

    // Check if entry exists and is occupied
    entry_opt = self.val.entries.get(slot_index)
    entry_opt ?
        | Some(entry) {
            entry.occupied ?
                | true {
                    // Check if key matches
                    keys_equal<K>(entry.key, key) ?
                        | true {
                            // Get pointer to entry and mark as unoccupied
                            entry_ptr = self.val.entries.val.data.at(slot_index)
                            entry_ptr ?
                                | Some(_) {
                                    addr = entry_ptr.addr()

                                    // Create empty entry (keeping old key/value for dummy)
                                    empty_entry = Entry<K, V> {
                                        key: entry.key,
                                        value: entry.value,
                                        occupied: false
                                    }
                                    compiler.store<Entry<K, V>>(addr, empty_entry)

                                    // Decrement size
                                    self.val.size = self.val.size - 1

                                    // Return the removed value
                                    return Option.Some(entry.value)
                                }
                                | None { return Option.None }
                        }
                        | false { return Option.None }
                }
                | false { return Option.None }
        }
        | None { return Option.None }
}

// Clear hashmap
HashMap<K, V>.clear = (self: MutPtr<HashMap<K, V>>) void {
    self.val.size = 0
    self.val.entries.mut_ref().clear()
}

// ============================================================================
// Memory Management
// ============================================================================

// Free hashmap memory
HashMap<K, V>.free = (self: MutPtr<HashMap<K, V>>) void {
    self.val.entries.mut_ref().free()
    self.val.size = 0
    self.val.capacity = 0
}
