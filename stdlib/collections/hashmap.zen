// Zen Standard Library: HashMap
// Hash-based key-value map
// Uses compile-time generics with Vec<T>

{ compiler } = @std
{ Ptr, Option } = @std.core
{ Allocator } = @std.memory.allocator

// Entry for a single key-value pair
Entry<K, V>: {
    key: K,
    value: V,
    occupied: bool
}

// HashMap<K, V> - simple hash map using linear probing
HashMap<K, V>: {
    entries: Vec<Entry<K, V>>,
    size: usize,
    capacity: usize,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create new empty hashmap
HashMap<K, V>.new = (allocator: Allocator) HashMap<K, V> {
    return HashMap<K, V> {
        entries: Vec<Entry<K, V>>.new(allocator),
        size: 0,
        capacity: 0,
        allocator: allocator
    }
}

// Create hashmap with initial capacity
HashMap<K, V>.with_capacity = (allocator: Allocator, capacity: usize) HashMap<K, V> {
    return HashMap<K, V> {
        entries: Vec<Entry<K, V>>.with_capacity(allocator, capacity),
        size: 0,
        capacity: capacity,
        allocator: allocator
    }
}

// ============================================================================
// Properties
// ============================================================================

// Get number of entries
HashMap<K, V>.len = (self: HashMap<K, V>) usize {
    return self.size
}

// Check if empty
HashMap<K, V>.is_empty = (self: HashMap<K, V>) bool {
    return self.size == 0
}

// ============================================================================
// Hash Function
// ============================================================================

// Simple hash function (placeholder - returns 0)
// TODO: Implement proper hash function
hash<K> = (key: K) u64 {
    return 0
}

// ============================================================================
// Operations
// ============================================================================

// Insert key-value pair
HashMap<K, V>.insert = (self: MutPtr<HashMap<K, V>>, key: K, value: V) void {
    self.val.capacity == 0 ?
        | true { self.val.capacity = 16 }
        | false { }

    // TODO: Implement hash table insertion with linear probing
    // For now, just track size
    self.val.size = self.val.size + 1
}

// Get value by key
HashMap<K, V>.get = (self: HashMap<K, V>, key: K) Option<V> {
    // TODO: Implement hash table lookup
    return Option.None
}

// Check if key exists
HashMap<K, V>.contains_key = (self: HashMap<K, V>, key: K) bool {
    // TODO: Implement hash table lookup
    return false
}

// Remove key and return value
HashMap<K, V>.remove = (self: MutPtr<HashMap<K, V>>, key: K) Option<V> {
    // TODO: Implement hash table removal
    self.val.size > 0 ?
        | true { self.val.size = self.val.size - 1 }
        | false { }
    return Option.None
}

// Clear hashmap
HashMap<K, V>.clear = (self: MutPtr<HashMap<K, V>>) void {
    self.val.size = 0
    self.val.entries.mut_ref().clear()
}

// ============================================================================
// Memory Management
// ============================================================================

// Free hashmap memory
HashMap<K, V>.free = (self: MutPtr<HashMap<K, V>>) void {
    self.val.entries.mut_ref().free()
    self.val.size = 0
    self.val.capacity = 0
}
