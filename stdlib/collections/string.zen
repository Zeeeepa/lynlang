// Zen Standard Library: String Type
// Dynamic growable UTF-8 string with allocator support

{ compiler } = @std
{ Ptr } = @std.core
{ Allocator } = @std.memory.allocator

// String - dynamic growable text buffer
String: {
    data: Ptr<u8>,
    len: usize,
    capacity: usize,
    allocator: Allocator
}

// ============================================================================
// Constructors
// ============================================================================

// Create a new empty string with allocator
String.new = (allocator: Allocator) String {
    initial_capacity = 16
    raw_ptr = allocator.allocate(initial_capacity)
    data = Ptr<u8>.from_addr(raw_ptr)

    return String {
        data: data,
        len: 0,
        capacity: initial_capacity,
        allocator: allocator
    }
}

// ============================================================================
// Properties
// ============================================================================

// Get string length
String.len = (self: String) usize {
    return self.len
}

// Get string capacity
String.capacity = (self: String) usize {
    return self.capacity
}

// Check if empty
String.is_empty = (self: String) bool {
    return self.len == 0
}

// ============================================================================
// Operations
// ============================================================================

// Push a single byte (auto-grow)
String.push = (self: MutPtr<String>, byte: u8) void {
    // Grow if needed
    self.val.len >= self.val.capacity ?
    | true {
        new_capacity = self.val.capacity * 2
        old_addr = self.val.data.addr()
        old_size = self.val.capacity
        new_addr = self.val.allocator.reallocate(old_addr, old_size, new_capacity)
        self.val.data = Ptr<u8>.from_addr(new_addr)
        self.val.capacity = new_capacity
    }
    | false { }

    // Write byte at end
    raw_addr = self.val.data.addr()
    offset_i64 = self.val.len
    target = compiler.gep(raw_addr, offset_i64)
    compiler.store<u8>(target, byte)

    self.val.len = self.val.len + 1
}

// Get byte at index
String.at = (self: String, index: usize) u8 {
    index >= self.len ?
    | true { return 0 }
    | false {
        raw_addr = self.data.addr()
        offset_i64 = index
        addr = compiler.gep(raw_addr, offset_i64)
        return compiler.load<u8>(addr)
    }
}

// Clear string (keep capacity)
String.clear = (self: MutPtr<String>) void {
    self.val.len = 0
}

// Reserve additional capacity
String.reserve = (self: MutPtr<String>, additional: usize) void {
    needed = self.val.len + additional
    needed > self.val.capacity ?
    | true {
        new_capacity = needed * 2
        old_addr = self.val.data.addr()
        old_size = self.val.capacity
        new_addr = self.val.allocator.reallocate(old_addr, old_size, new_capacity)
        self.val.data = Ptr<u8>.from_addr(new_addr)
        self.val.capacity = new_capacity
    }
    | false { }
}

// ============================================================================
// Memory Management
// ============================================================================

// Deallocate string
String.free = (self: MutPtr<String>) void {
    raw_addr = self.val.data.addr()
    self.val.allocator.deallocate(raw_addr, self.val.capacity)
    self.val.data = Ptr<u8>.none()
    self.val.len = 0
    self.val.capacity = 0
}

// Clone string (requires allocator for new allocation)
String.clone = (self: String, allocator: Allocator) String {
    new_capacity = self.capacity
    raw_ptr = allocator.allocate(new_capacity)
    new_data = Ptr<u8>.from_addr(raw_ptr)

    result = String {
        data: new_data,
        len: self.len,
        capacity: new_capacity,
        allocator: allocator
    }

    // Copy bytes directly
    i = 0
    loop(() {
        i >= self.len ?
        | true { break }
        | false {
            // Read from source
            src_addr = self.data.addr()
            src_offset_i64 = i
            src_ptr = compiler.gep(src_addr, src_offset_i64)
            byte = compiler.load<u8>(src_ptr)

            // Write to destination
            dst_addr = result.data.addr()
            dst_offset_i64 = i
            dst_ptr = compiler.gep(dst_addr, dst_offset_i64)
            compiler.store<u8>(dst_ptr, byte)

            i = i + 1
        }
    })

    return result
}

// ============================================================================
// Factory Methods
// ============================================================================

// Create string from raw pointer and length (takes ownership of memory)
String.from_ptr = (ptr: i64, len: usize, allocator: Allocator) String {
    return String {
        data: Ptr<u8>.from_addr(ptr),
        len: len,
        capacity: len,
        allocator: allocator
    }
}

// Create string by copying from a static string literal
// Note: This requires a pointer to the string data and its length
String.from = (literal: StaticString, allocator: Allocator) String {
    // Get the length of the literal
    len = compiler.strlen(literal)

    // Allocate space for the string
    capacity = len + 1  // Extra space for potential null terminator
    raw_ptr = allocator.allocate(capacity)

    // Copy the literal to the new buffer
    literal_ptr = compiler.static_string_ptr(literal)
    compiler.memcpy(raw_ptr, literal_ptr, len)

    return String {
        data: Ptr<u8>.from_addr(raw_ptr),
        len: len,
        capacity: capacity,
        allocator: allocator
    }
}

// ============================================================================
// Iterator Support
// ============================================================================

{ Option } = @std.core.option

// StringIterator - Iterates over bytes in the string
StringIterator: {
    data: Ptr<u8>,
    index: usize,
    len: usize
}

// Create an iterator over the string bytes
String.iter = (self: String) StringIterator {
    return StringIterator {
        data: self.data,
        index: 0,
        len: self.len
    }
}

// Alias for iter() - iterate over characters (bytes for ASCII)
String.bytes = (self: String) StringIterator {
    return self.iter()
}

// Get next byte from iterator
StringIterator.next = (self: MutPtr<StringIterator>) Option<u8> {
    self.val.index >= self.val.len ?
        | true { return Option.None }
        | false {
            raw_addr = self.val.data.addr()
            offset_i64 = self.val.index
            addr = compiler.gep(raw_addr, offset_i64)
            byte = compiler.load<u8>(addr)
            self.val.index = self.val.index + 1
            return Option.Some(byte)
        }
}

// Check if iterator has more bytes
StringIterator.has_next = (self: StringIterator) bool {
    return self.index < self.len
}

// Peek at next byte without consuming
StringIterator.peek = (self: StringIterator) Option<u8> {
    self.index >= self.len ?
        | true { return Option.None }
        | false {
            raw_addr = self.data.addr()
            offset_i64 = self.index
            addr = compiler.gep(raw_addr, offset_i64)
            byte = compiler.load<u8>(addr)
            return Option.Some(byte)
        }
}

// Skip n bytes
StringIterator.skip = (self: MutPtr<StringIterator>, n: usize) void {
    new_index = self.val.index + n
    new_index > self.val.len ?
        | true { self.val.index = self.val.len }
        | false { self.val.index = new_index }
}

// Get remaining count
StringIterator.remaining = (self: StringIterator) usize {
    return self.len - self.index
}

// ============================================================================
// String Comparison
// ============================================================================

// Compare two strings for equality
String.equals = (self: String, other: String) bool {
    self.len != other.len ?
        | true { return false }
        | false {
            // Compare byte by byte
            i = 0
            loop(() {
                i >= self.len ?
                    | true { return true }
                    | false {
                        a = self.at(i)
                        b = other.at(i)
                        a != b ?
                            | true { return false }
                            | false { i = i + 1 }
                    }
            })
            return true
        }
}

// Check if string starts with prefix
String.starts_with = (self: String, prefix: String) bool {
    prefix.len > self.len ?
        | true { return false }
        | false {
            i = 0
            loop(() {
                i >= prefix.len ?
                    | true { return true }
                    | false {
                        a = self.at(i)
                        b = prefix.at(i)
                        a != b ?
                            | true { return false }
                            | false { i = i + 1 }
                    }
            })
            return true
        }
}

// Check if string ends with suffix
String.ends_with = (self: String, suffix: String) bool {
    suffix.len > self.len ?
        | true { return false }
        | false {
            offset = self.len - suffix.len
            i = 0
            loop(() {
                i >= suffix.len ?
                    | true { return true }
                    | false {
                        a = self.at(offset + i)
                        b = suffix.at(i)
                        a != b ?
                            | true { return false }
                            | false { i = i + 1 }
                    }
            })
            return true
        }
}
