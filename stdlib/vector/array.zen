// Array/Slice operations for Zen
// Provides dynamic array functionality with automatic resizing

build = @std
core := build.import("core")
mem := build.import("mem")
math := build.import("math")

// Dynamic array structure
Array(T: type): {
    data: Ptr<T>,
    len: usize,
    capacity: usize,
}

// Create a new array with initial capacity
new = (T: type, initial_capacity: usize) Array(T) {
    data := initial_capacity > 0 ? 
        | true { mem.alloc(T, initial_capacity) }
        | false { null }
    
    return Array(T){
        data: data,
        len: 0,
        capacity: initial_capacity,
    }
}

// Create array from slice
from_slice = (T: type, slice: []T) Array(T) {
    arr := new(T, slice.len)
    arr.len = slice.len
    mem.copy(arr.data, slice.ptr, slice.len * core.sizeof(T))
    return arr
}

// Push element to array
push = (T: type, arr: Ptr<Array(T)>, value: T) void {
    arr.len >= arr.capacity ? {
        grow(T, arr)
    }
    arr.data[arr.len] = value
    arr.len += 1
}

// Pop element from array
pop = (T: type, arr: Ptr<Array(T)>) Option<T> {
    arr.len == 0 ? {
        return null
    }
    arr.len -= 1
    return arr.data[arr.len]
}

// Get element at index
get = (T: type, arr: Ptr<Array(T)>, index: usize) Option<T> {
    index >= arr.len ? {
        return null
    }
    return arr.data[index]
}

// Set element at index
set = (T: type, arr: Ptr<Array(T)>, index: usize, value: T) bool {
    index >= arr.len ? {
        return false
    }
    arr.data[index] = value
    return true
}

// Insert element at index
insert = (T: type, arr: Ptr<Array(T)>, index: usize, value: T) bool {
    index > arr.len ? {
        return false
    }
    
    arr.len >= arr.capacity ? {
        grow(T, arr)
    }
    
    // Shift elements right
    index < arr.len ? {
        mem.move(
            arr.data + index + 1,
            arr.data + index,
            (arr.len - index) * core.sizeof(T))
        )
    }
    
    arr.data[index] = value
    arr.len += 1
    return true
}

// Remove element at index
remove = (T: type, arr: Ptr<Array(T)>, index: usize) Option<T> {
    index >= arr.len ? {
        return null
    }
    
    value := arr.data[index]
    
    // Shift elements left
    index < arr.len - 1 ? {
        mem.move(
            arr.data + index,
            arr.data + index + 1,
            (arr.len - index - 1) * @sizeof(T)
        )
    }
    
    arr.len -= 1
    return value
}

// Clear array (keep capacity)
clear = (T: type, arr: Ptr<Array(T)>) void {
    arr.len = 0
}

// Resize array to exact size
resize = (T: type, arr: Ptr<Array(T)>, new_size: usize) void {
    new_size > arr.capacity ? {
        reserve(T, arr, new_size)
    }
    arr.len = new_size
}

// Reserve capacity
reserve = (T: type, arr: Ptr<Array(T)>, new_capacity: usize) void {
    new_capacity <= arr.capacity ? {
        return
    }
    
    new_data := mem.alloc(T, new_capacity)
    (arr.data != null and arr.len > 0) ? {
        mem.copy(new_data, arr.data, arr.len * @sizeof(T))
        mem.free(arr.data)
    }
    
    arr.data = new_data
    arr.capacity = new_capacity
}

// Grow array capacity (internal)
grow = (T: type, arr: Ptr<Array(T)>) void {
    new_capacity := arr.capacity == 0 ? {
        8
    } : {
        arr.capacity * 2
    }
    reserve(T, arr, new_capacity)
}

// Shrink to fit
shrink_to_fit = (T: type, arr: Ptr<Array(T)>) void {
    arr.len == arr.capacity ? {
        return
    }
    
    arr.len == 0 ? {
        arr.data != null ? {
            mem.free(arr.data)
        }
        arr.data = null
        arr.capacity = 0
        return
    }
    
    new_data := mem.alloc(T, arr.len)
    mem.copy(new_data, arr.data, arr.len * @sizeof(T))
    mem.free(arr.data)
    arr.data = new_data
    arr.capacity = arr.len
}

// Get slice of array
slice = (T: type, arr: Ptr<Array(T)>, start: usize, end: usize) []T {
    (start > end or end > arr.len) ? {
        return []T{}
    }
    return arr.data[start..end]
}

// Reverse array in place
reverse = (T: type, arr: Ptr<Array(T)>) void {
    arr.len <= 1 ? {
        return
    }
    
    left := 0
    right := arr.len - 1
    
    loop (left < right) {
        temp := arr.data[left]
        arr.data[left] = arr.data[right]
        arr.data[right] = temp
        left += 1
        right -= 1
    }
}

// Find element in array
find = (T: type, arr: Ptr<Array(T)>, value: T) Option<usize> {
    i := 0
    loop (i < arr.len) {
        arr.data[i] == value ? {
            return i
        }
        i += 1
    }
    return null
}

// Check if array contains element
contains = (T: type, arr: Ptr<Array(T)>, value: T) bool {
    return find(T, arr, value) != null
}

// Map function over array
map = (T: type, U: type, arr: Ptr<Array(T)>, f: fn(T) U) Array(U) {
    result := new(U, arr.len)
    result.len = arr.len
    
    i := 0
    loop (i < arr.len) {
        result.data[i] = f(arr.data[i])
        i += 1
    }
    
    return result
}

// Filter array
filter = (T: type, arr: Ptr<Array(T)>, predicate: fn(T) bool) Array(T) {
    result := new(T, arr.len)
    
    i := 0
    loop (i < arr.len) {
        predicate(arr.data[i]) ? {
            push(T, &result, arr.data[i])
        }
        i += 1
    }
    
    return result
}

// Reduce array
reduce = (T: type, U: type, arr: Ptr<Array(T)>, initial: U, f: fn(U, T) U) U {
    result := initial
    i := 0
    loop (i < arr.len) {
        result = f(result, arr.data[i])
        i += 1
    }
    return result
}

// Sort array (quicksort)
sort = (T: type, arr: Ptr<Array(T)>, compare: fn(T, T) i32) void {
    arr.len <= 1 ? {
        return
    }
    quicksort(T, arr.data, 0, arr.len - 1, compare)
}

// Quicksort implementation
quicksort = (T: type, data: Ptr<T>, low: usize, high: usize, compare: fn(T, T) i32) void {
    low >= high ? {
        return
    }
    
    pivot_index := partition(T, data, low, high, compare)
    pivot_index > 0 ? {
        quicksort(T, data, low, pivot_index - 1, compare)
    }
    quicksort(T, data, pivot_index + 1, high, compare)
}

// Partition for quicksort
partition = (T: type, data: Ptr<T>, low: usize, high: usize, compare: fn(T, T) i32) usize {
    pivot := data[high]
    i := low
    
    j := low
    loop (j < high) {
        compare(data[j], pivot) <= 0 ? {
            temp := data[i]
            data[i] = data[j]
            data[j] = temp
            i += 1
        }
        j += 1
    }
    
    temp := data[i]
    data[i] = data[high]
    data[high] = temp
    
    return i
}

// Binary search (array must be sorted)
binary_search = (T: type, arr: Ptr<Array(T)>, value: T, compare: fn(T, T) i32) Option<usize> {
    arr.len == 0 ? {
        return null
    }
    
    left := 0
    right := arr.len - 1
    
    loop (left <= right) {
        mid := left + (right - left) / 2
        cmp := compare(arr.data[mid], value)
        
        cmp == 0 ? {
            return mid
        } : cmp < 0 ? {
            left = mid + 1
        } : {
            mid == 0 ? break
            right = mid - 1
        }
    }
    
    return null
}

// Clone array
clone = (T: type, arr: Ptr<Array(T)>) Array(T) {
    result := new(T, arr.capacity)
    result.len = arr.len
    
    arr.len > 0 ? {
        mem.copy(result.data, arr.data, arr.len * @sizeof(T))
    }
    
    return result
}

// Extend array with another array
extend = (T: type, arr: Ptr<Array(T)>, other: Ptr<Array(T)>) void {
    other.len == 0 ? {
        return
    }
    
    required_capacity := arr.len + other.len
    required_capacity > arr.capacity ? {
        reserve(T, arr, required_capacity)
    }
    
    mem.copy(arr.data + arr.len, other.data, other.len * @sizeof(T))
    arr.len += other.len
}

// Free array memory
free = (T: type, arr: Ptr<Array(T)>) void {
    arr.data != null ? {
        mem.free(arr.data)
    }
    arr.data = null
    arr.len = 0
    arr.capacity = 0
}

// Iterator support
iter = (T: type, arr: Ptr<Array(T)>) ArrayIterator(T) {
    return ArrayIterator(T){
        data: arr.data,
        len: arr.len,
        index: 0,
    }
}

ArrayIterator(T: type): {
    data: Ptr<T>,
    len: usize,
    index: usize,
}

next = (T: type, it: Ptr<ArrayIterator(T)>) Option<T> {
    it.index >= it.len ? {
        return null
    }
    value := it.data[it.index]
    it.index += 1
    return value
}