// Zen Standard Library: Memory Management
// Low-level memory management utilities

// External C functions for memory management
extern malloc = (size: i64) RawPtr<i8>
extern calloc = (num: i64, size: i64) RawPtr<i8>
extern realloc = (ptr: RawPtr<i8>, size: i64) RawPtr<i8>
extern free = (ptr: RawPtr<i8>) void
extern memcpy = (dest: RawPtr<i8>, src: RawPtr<i8>, n: i64) RawPtr<i8>
extern memmove = (dest: RawPtr<i8>, src: RawPtr<i8>, n: i64) RawPtr<i8>
extern memset = (ptr: RawPtr<i8>, value: i32, n: i64) RawPtr<i8>
extern memcmp = (ptr1: RawPtr<i8>, ptr2: RawPtr<i8>, n: i64) i32

// Memory alignment
ALIGNMENT := 8

// Memory statistics tracking
MemoryStats: {
    total_allocated: i64,
    total_freed: i64,
    current_usage: i64,
    peak_usage: i64,
    allocation_count: i64,
    free_count: i64,
}

// Global memory statistics (initialized to zero)
global_stats ::= MemoryStats {
    total_allocated: 0,
    total_freed: 0,
    current_usage: 0,
    peak_usage: 0,
    allocation_count: 0,
    free_count: 0,
}

// Allocate memory with tracking
alloc = (size: i64) RawPtr<i8> {
    ptr = malloc(size)
    ptr != null ?
        | true {
            global_stats.total_allocated ::= global_stats.total_allocated + size
            global_stats.current_usage ::= global_stats.current_usage + size
            global_stats.allocation_count ::= global_stats.allocation_count + 1
            
            global_stats.current_usage > global_stats.peak_usage ?
                | true { global_stats.peak_usage ::= global_stats.current_usage }
                | false { }
        }
        | false { }
    ptr
}

// Allocate zeroed memory
alloc_zeroed = (size: i64) RawPtr<i8> {
    ptr = calloc(1, size)
    ptr != null ?
        | true {
            global_stats.total_allocated ::= global_stats.total_allocated + size
            global_stats.current_usage ::= global_stats.current_usage + size
            global_stats.allocation_count ::= global_stats.allocation_count + 1
            
            global_stats.current_usage > global_stats.peak_usage ?
                | true { global_stats.peak_usage ::= global_stats.current_usage }
                | false { }
        }
        | false { }
    ptr
}

// Reallocate memory
realloc_mem = (ptr: RawPtr<i8>, old_size: i64, new_size: i64) RawPtr<i8> {
    new_ptr = realloc(ptr, new_size)
    new_ptr != null ?
        | true {
            global_stats.total_allocated ::= global_stats.total_allocated + new_size
            global_stats.total_freed ::= global_stats.total_freed + old_size
            global_stats.current_usage ::= global_stats.current_usage + (new_size - old_size)
            
            global_stats.current_usage > global_stats.peak_usage ?
                | true { global_stats.peak_usage ::= global_stats.current_usage }
                | false { }
        }
        | false { }
    new_ptr
}

// Free memory with tracking
dealloc = (ptr: RawPtr<i8>, size: i64) void   {
    ptr != null ?
        | true {
            free(ptr)
            global_stats.total_freed ::= global_stats.total_freed + size
            global_stats.current_usage ::= global_stats.current_usage - size
            global_stats.free_count ::= global_stats.free_count + 1
        }
        | false { }
}

// Copy memory
copy = (dest: RawPtr<i8>, src: RawPtr<i8>, size: i64) void   {
    memcpy(dest, src, size)
}

// Move memory (handles overlapping regions)
move = (dest: RawPtr<i8>, src: RawPtr<i8>, size: i64) void   {
    memmove(dest, src, size)
}

// Set memory to a value
set = (ptr: RawPtr<i8>, value: i8, size: i64) void   {
    memset(ptr, value, size)
}

// Compare memory regions
compare = (ptr1: RawPtr<i8>, ptr2: RawPtr<i8>, size: i64) i32   {
    memcmp(ptr1, ptr2, size)
}

// Zero out memory
zero = (ptr: RawPtr<i8>, size: i64) void   {
    memset(ptr, 0, size)
}

// Check if memory regions are equal
equals = (ptr1: RawPtr<i8>, ptr2: RawPtr<i8>, size: i64) bool   {
    memcmp(ptr1, ptr2, size) == 0
}

// Align size to boundary
align_size = (size: i64, alignment: i64) i64   {
    (size + alignment - 1) & ~(alignment - 1)
}

// Check if pointer is aligned
is_aligned = (ptr: RawPtr<i8>, alignment: i64) bool   {
    (ptr as i64) & (alignment - 1) == 0
}

// Get current memory statistics
get_stats = () MemoryStats   {
    global_stats
}

// Reset memory statistics
reset_stats = () void   {
    global_stats.total_allocated ::= 0
    global_stats.total_freed ::= 0
    global_stats.current_usage ::= 0
    global_stats.peak_usage ::= 0
    global_stats.allocation_count ::= 0
    global_stats.free_count ::= 0
}

// Memory pool for efficient small allocations
MemoryPool: {
    blocks: *RawPtr<i8>,
    block_size: i64,
    block_count: i64,
    free_list: *i64,
    allocated_count: i64,
}

// Create a new memory pool
pool_create = (block_size: i64, block_count: i64) MemoryPool   {
    aligned_size = align_size(block_size, ALIGNMENT)
    total_size = aligned_size * block_count
    
    memory = alloc(total_size)
    blocks = alloc(block_count * 8) as Ptr<RawPtr<i8>>
    
    i ::= 0
    loop(() {
        i >= block_count ?
            | true { break }
            | false { }
        blocks[i] ::= memory + (i * aligned_size)
        i ::= i + 1
    })
    
    MemoryPool {
        blocks: blocks,
        block_size: aligned_size,
        block_count: block_count,
        free_list: null,
        allocated_count: 0,
    }
}

// Allocate from pool
pool_alloc = (pool: &MemoryPool) RawPtr<i8> {
    pool.allocated_count < pool.block_count ?
        | true {
            block = pool.blocks[pool.allocated_count]
            pool.val.allocated_count ::= pool.val.allocated_count + 1
            block
        }
        | false { .None }
}

// Free pool memory
pool_destroy = (pool: &MemoryPool) void   {
    pool.val.blocks != .None ?
        | true {
            dealloc(pool.val.blocks[0], pool.val.block_size * pool.val.block_count)
            dealloc(pool.val.blocks as RawPtr<i8>, pool.val.block_count * 8)
        }
        | false { }
}