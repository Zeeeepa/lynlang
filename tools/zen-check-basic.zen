// Zen Syntax Checker
// A simple tool to check Zen source files for syntax errors

core = @std
io = @std
fs = @std
args = @std
string = @std

// Error types
SyntaxError: {
    line: i32,
    column: i32,
    message: string,
    context: string,
}

// Check result
CheckResult: 
    Success,
    SyntaxErrors(Vec<SyntaxError>),
    FileError(string),

// Token types for basic checking
TokenType: 
    Identifier,
    Number,
    String,
    Operator,
    Symbol,
    Keyword,
    EOF,

// Basic syntax checker
SyntaxChecker: {
    input: string,
    position: i32,
    line: i32,
    column: i32,
    errors: Vec<SyntaxError>,
}

// Create a new syntax checker
new_checker = (input: string) SyntaxChecker   {
    return SyntaxChecker {
        input: input,
        position: 0,
        line: 1,
        column: 1,
        errors: Vec<SyntaxError>.new(),
    }
}

// Add an error
add_error = (checker: &mut SyntaxChecker, message: string) void   {
    error := SyntaxError {
        line: checker.line,
        column: checker.column,
        message: message,
        context: get_line_context(checker.input, checker.line),
    }
    checker.errors.push(error)
}

// Get context for error reporting
get_line_context = (input: string, line_num: i32) string   {
    lines := string.split(input, "\n")
    (line_num > 0 && line_num <= lines.len()) ?
        | true { return lines[line_num - 1] }
        | false { return "" }
}

// Check for balanced braces
check_balanced_braces = (checker: &mut SyntaxChecker) void   {
    brace_count := 0
    paren_count := 0
    bracket_count := 0
    
    i := 0
    loop(() {
        i < checker.input.len() ?
            | false { break }
            | true {
        ch := checker.input[i]
        
        ch ?
            | '{' { brace_count = brace_count + 1 }
            | '}' {
                brace_count = brace_count - 1
                brace_count < 0 ?
                    | true { add_error(checker, "Unexpected closing brace '}'") }
                    | false {}
            }
            | '(' { paren_count = paren_count + 1 }
            | ')' {
                paren_count = paren_count - 1
                paren_count < 0 ?
                    | true { add_error(checker, "Unexpected closing parenthesis ')')") }
                    | false {}
            }
            | '[' { bracket_count = bracket_count + 1 }
            | ']' {
                bracket_count = bracket_count - 1
                bracket_count < 0 ?
                    | true { add_error(checker, "Unexpected closing bracket ']')") }
                    | false {}
            }
            | '\n' {
                checker.line = checker.line + 1
                checker.column = 0
            }
            | _ {}
        }
        
                checker.column = checker.column + 1
                i = i + 1
            }
    })
    
    brace_count > 0 ?
        | true { add_error(checker, "Unclosed brace '{'")") }
        | false {}
    paren_count > 0 ?
        | true { add_error(checker, "Unclosed parenthesis '('")") }
        | false {}
    bracket_count > 0 ?
        | true { add_error(checker, "Unclosed bracket '['")") }
        | false {}
}

// Check for invalid import placement
check_import_placement = (checker: &mut SyntaxChecker) void   {
    lines := string.split(checker.input, "\n")
    in_comptime := false
    brace_depth := 0
    
    i := 0
    loop(() {
        i < lines.len() ?
            | false { break }
            | true {
                line := string.trim(lines[i])
                
                // Check for comptime block start
                (string.starts_with(line, "comptime") && string.contains(line, "{")) ?
                    | true {
                        in_comptime = true
                        brace_depth = 1
                    }
                    | false {}
                
                // Track brace depth in comptime
                in_comptime ?
                    | true {
                        j := 0
                        loop(() {
                            j < line.len() ?
                                | false { break }
                                | true {
                                    line[j] == '{' ?
                                        | true { brace_depth = brace_depth + 1 }
                                        | false {
                                            line[j] == '}' ?
                                                | true {
                                                    brace_depth = brace_depth - 1
                                                    brace_depth == 0 ?
                                                        | true { in_comptime = false }
                                                        | false {}
                                                }
                                                | false {}
                                        }
                                    j = j + 1
                                }
                        })
                    }
                    | false {}
                
                // Check for imports in comptime
                in_comptime ?
                    | true {
                        (string.contains(line, "@std") || string.contains(line, "build.import")) ?
                            | true {
                                checker.line = i + 1
                                add_error(checker, "Import statements are not allowed inside comptime blocks")
                            }
                            | false {}
                    }
                    | false {}
                
                i = i + 1
            }
    })
}

// Main checking function
check_syntax = (input: string) CheckResult   {
    checker := new_checker(input)
    
    // Run various checks
    check_balanced_braces(&mut checker)
    check_import_placement(&mut checker)
    
    // Return result
    checker.errors.is_empty() ?
        | true { return CheckResult.Success }
        | false { return CheckResult.SyntaxErrors(checker.errors) }
}

// Print errors
print_errors = (errors: Vec<SyntaxError>) void   {
    io.print("Syntax errors found:\n\n")
    
    i := 0
    loop(() {
        i < errors.len() ?
            | false { break }
            | true {
                error := errors[i]
                io.print("  Line ")
                io.print_int(error.line)
                io.print(":")
                io.print_int(error.column)
                io.print(" - ")
                io.print(error.message)
                io.print("\n")
                
                error.context != "" ?
                    | true {
                        io.print("    ")
                        io.print(error.context)
                        io.print("\n")
                    }
                    | false {}
                
                i = i + 1
            }
    })
}

// Main entry point
main = (argc: i32, argv: *RawPtr<i8>) i32   {
    argc < 2 ?
        | true {
            io.print("Usage: zen-check <file.zen>\n")
            return 1
        }
        | false {}
    
    // Get filename from args
    filename := string.from_cstr(argv[1])
    
    // Read file
    result := fs.read_file(filename)
    
    result ?
        | Result<string, string>.Ok(content) {
            // Check syntax
            check_result := check_syntax(content)
            
            check_result ?
                | CheckResult.Success {
                    io.print("✓ No syntax errors found in ")
                    io.print(filename)
                    io.print("\n")
                    return 0
                }
                | CheckResult.SyntaxErrors(errors) {
                    io.print("✗ Syntax errors in ")
                    io.print(filename)
                    io.print(":\n")
                    print_errors(errors)
                    return 1
                }
                | CheckResult.FileError(msg) {
                    io.print("File error: ")
                    io.print(msg)
                    io.print("\n")
                    return 1
                }
        }
        | Result<string, string>.Err(error) {
            io.print("Error reading file: ")
            io.print(error)
            io.print("\n")
            return 1
        }
}