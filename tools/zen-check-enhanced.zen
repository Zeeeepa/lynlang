// Enhanced Zen Code Checker
// A comprehensive validation tool for Zen source files with detailed error reporting

io := @std.io
fs := @std.fs
string := @std.string
vec := @std.vec
core := @std.core
path := @std.path

// Error severity levels
Severity = 
    | Error
    | Warning
    | Info

// Diagnostic information
Diagnostic = {
    line: i32,
    column: i32,
    severity: Severity,
    message: string,
    code: string,  // Error code like "E001"
    suggestion: string,  // Optional fix suggestion
}

// Check result
CheckResult = {
    filepath: string,
    diagnostics: Vec<Diagnostic>,
    error_count: i32,
    warning_count: i32,
    info_count: i32,
}

// Token types for basic lexical analysis
TokenType = 
    | Identifier
    | Keyword
    | Operator
    | Number
    | String
    | Comment
    | Whitespace
    | Unknown

// Simple token
Token = {
    type: TokenType,
    value: string,
    line: i32,
    column: i32,
}

// Create a new diagnostic
diagnostic_new = (line: i32, column: i32, severity: Severity, code: string, message: string, suggestion: string) Diagnostic {
    return Diagnostic {
        line: line,
        column: column,
        severity: severity,
        message: message,
        code: code,
        suggestion: suggestion,
    }
}

// Print diagnostic with color
print_diagnostic = (diag: Diagnostic, filepath: string, line_content: string) void {
    // Color codes
    color := ""
    prefix := ""
    
    diag.severity ?
        | Error => {
            color = "\x1b[31m"  // Red
            prefix = "ERROR"
        }
        | Warning => {
            color = "\x1b[33m"  // Yellow
            prefix = "WARNING"
        }
        | Info => {
            color = "\x1b[36m"  // Cyan
            prefix = "INFO"
        }
    
    // Print diagnostic header
    io.print(color)
    io.print("[")
    io.print(diag.code)
    io.print("] ")
    io.print(prefix)
    io.print("\x1b[0m: ")
    io.print(diag.message)
    io.print("\n")
    
    // Print location
    io.print("  --> ")
    io.print(filepath)
    io.print(":")
    io.print(string.from_int(diag.line))
    io.print(":")
    io.print(string.from_int(diag.column))
    io.print("\n")
    
    // Print line with error marker
    io.print("   |\n")
    io.print(string.from_int(diag.line))
    io.print(" | ")
    io.print(line_content)
    io.print("\n")
    io.print("   | ")
    
    // Print caret pointing to error
    i := 0
    loop i < diag.column - 1 {
        io.print(" ")
        i = i + 1
    }
    io.print(color)
    io.print("^")
    io.print("\x1b[0m\n")
    
    // Print suggestion if available
    diag.suggestion != "" ?
        | true => {
            io.print("   = help: ")
            io.print(diag.suggestion)
            io.print("\n")
        }
        | false => {}
    
    io.print("\n")
}

// Check for syntax issues
check_syntax = (lines: Vec<string>, result: *CheckResult) void {
    i := 0
    in_comptime := false
    in_function := false
    brace_depth := 0
    paren_depth := 0
    
    loop i < lines.len() {
        line := lines[i]
        line_num := i + 1
        trimmed := string.trim(line)
        
        // Skip empty lines and comments
        trimmed == "" || string.starts_with(trimmed, "//") ?
            | true => {
                i = i + 1
                continue
            }
            | false => {}
        
        // Check for comptime blocks
        string.contains(line, "comptime") && string.contains(line, "{") ?
            | true => {
                in_comptime = true
                brace_depth = brace_depth + 1
            }
            | false => {}
        
        // Check for imports in comptime
        in_comptime && (string.contains(line, "@std.") || string.contains(line, "@std.compiler.")) ?
            | true => {
                diag := diagnostic_new(
                    line_num, 
                    string.index_of(line, "@") + 1,
                    Severity.Error,
                    "E001",
                    "Imports are not allowed inside comptime blocks",
                    "Move import statement to module level (top of file)"
                )
                result.diagnostics.push(diag)
                result.error_count = result.error_count + 1
            }
            | false => {}
        
        // Check brace matching
        j := 0
        loop j < line.len() {
            c := line[j]
            c == '{' ?
                | true => { brace_depth = brace_depth + 1 }
                | false => {}
            c == '}' ?
                | true => { 
                    brace_depth = brace_depth - 1
                    brace_depth < 0 ?
                        | true => {
                            diag := diagnostic_new(
                                line_num,
                                j + 1,
                                Severity.Error,
                                "E002",
                                "Unmatched closing brace",
                                "Check for missing opening brace"
                            )
                            result.diagnostics.push(diag)
                            result.error_count = result.error_count + 1
                        }
                        | false => {}
                }
                | false => {}
            c == '(' ?
                | true => { paren_depth = paren_depth + 1 }
                | false => {}
            c == ')' ?
                | true => { 
                    paren_depth = paren_depth - 1
                    paren_depth < 0 ?
                        | true => {
                            diag := diagnostic_new(
                                line_num,
                                j + 1,
                                Severity.Error,
                                "E003",
                                "Unmatched closing parenthesis",
                                "Check for missing opening parenthesis"
                            )
                            result.diagnostics.push(diag)
                            result.error_count = result.error_count + 1
                        }
                        | false => {}
                }
                | false => {}
            j = j + 1
        }
        
        // Update comptime state
        in_comptime && brace_depth == 0 ?
            | true => { in_comptime = false }
            | false => {}
        
        // Check for deprecated syntax
        string.contains(line, "build.import(") ?
            | true => {
                diag := diagnostic_new(
                    line_num,
                    string.index_of(line, "build.import") + 1,
                    Severity.Warning,
                    "W001",
                    "Deprecated import syntax",
                    "Use @std.module syntax instead"
                )
                result.diagnostics.push(diag)
                result.warning_count = result.warning_count + 1
            }
            | false => {}
        
        // Check for trailing whitespace
        line.len() > 0 && (line[line.len() - 1] == ' ' || line[line.len() - 1] == '\t') ?
            | true => {
                diag := diagnostic_new(
                    line_num,
                    line.len(),
                    Severity.Info,
                    "I001",
                    "Trailing whitespace",
                    "Remove trailing spaces/tabs"
                )
                result.diagnostics.push(diag)
                result.info_count = result.info_count + 1
            }
            | false => {}
        
        i = i + 1
    }
    
    // Check for unclosed braces/parens at end of file
    brace_depth > 0 ?
        | true => {
            diag := diagnostic_new(
                lines.len(),
                1,
                Severity.Error,
                "E004",
                "Unclosed brace(s) detected",
                "Add " + string.from_int(brace_depth) + " closing brace(s)"
            )
            result.diagnostics.push(diag)
            result.error_count = result.error_count + 1
        }
        | false => {}
    
    paren_depth > 0 ?
        | true => {
            diag := diagnostic_new(
                lines.len(),
                1,
                Severity.Error,
                "E005",
                "Unclosed parenthesis detected",
                "Add " + string.from_int(paren_depth) + " closing parenthesis"
            )
            result.diagnostics.push(diag)
            result.error_count = result.error_count + 1
        }
        | false => {}
}

// Check for style issues
check_style = (lines: Vec<string>, result: *CheckResult) void {
    i := 0
    uses_tabs := false
    uses_spaces := false
    
    loop i < lines.len() {
        line := lines[i]
        line_num := i + 1
        
        // Check indentation consistency
        line.len() > 0 ?
            | true => {
                has_tab := false
                has_space := false
                j := 0
                loop j < line.len() && (line[j] == ' ' || line[j] == '\t') {
                    line[j] == '\t' ?
                        | true => { has_tab = true }
                        | false => { has_space = true }
                    j = j + 1
                }
                
                has_tab ?
                    | true => { uses_tabs = true }
                    | false => {}
                has_space ?
                    | true => { uses_spaces = true }
                    | false => {}
                
                has_tab && has_space ?
                    | true => {
                        diag := diagnostic_new(
                            line_num,
                            1,
                            Severity.Warning,
                            "W002",
                            "Mixed tabs and spaces in indentation",
                            "Use either tabs or spaces consistently"
                        )
                        result.diagnostics.push(diag)
                        result.warning_count = result.warning_count + 1
                    }
                    | false => {}
            }
            | false => {}
        
        // Check line length
        line.len() > 120 ?
            | true => {
                diag := diagnostic_new(
                    line_num,
                    121,
                    Severity.Info,
                    "I002",
                    "Line exceeds 120 characters",
                    "Consider breaking long lines for readability"
                )
                result.diagnostics.push(diag)
                result.info_count = result.info_count + 1
            }
            | false => {}
        
        i = i + 1
    }
    
    // Check overall indentation consistency
    uses_tabs && uses_spaces ?
        | true => {
            diag := diagnostic_new(
                1,
                1,
                Severity.Warning,
                "W003",
                "File uses both tabs and spaces for indentation",
                "Choose one indentation style for the entire file"
            )
            result.diagnostics.push(diag)
            result.warning_count = result.warning_count + 1
        }
        | false => {}
}

// Check a single file
check_file = (filepath: string) CheckResult {
    result := CheckResult {
        filepath: filepath,
        diagnostics: vec.new<Diagnostic>(),
        error_count: 0,
        warning_count: 0,
        info_count: 0,
    }
    
    // Read file
    content_result := fs.read_file(filepath)
    content_result.is_err() ?
        | true => {
            diag := diagnostic_new(
                0,
                0,
                Severity.Error,
                "E000",
                "Could not read file: " + filepath,
                "Check file path and permissions"
            )
            result.diagnostics.push(diag)
            result.error_count = 1
            return result
        }
        | false => {}
    
    content := content_result.unwrap()
    lines := string.split(content, "\n")
    
    // Run checks
    check_syntax(lines, &result)
    check_style(lines, &result)
    
    return result
}

// Print summary
print_summary = (results: Vec<CheckResult>) void {
    total_errors := 0
    total_warnings := 0
    total_infos := 0
    
    i := 0
    loop i < results.len() {
        r := results[i]
        total_errors = total_errors + r.error_count
        total_warnings = total_warnings + r.warning_count
        total_infos = total_infos + r.info_count
        i = i + 1
    }
    
    io.print("\n")
    io.print("=== Summary ===\n")
    
    total_errors == 0 ?
        | true => {
            io.print("\x1b[32m✓ No errors found!\x1b[0m\n")
        }
        | false => {
            io.print("\x1b[31m✗ ")
            io.print(string.from_int(total_errors))
            io.print(" error(s) found\x1b[0m\n")
        }
    
    total_warnings > 0 ?
        | true => {
            io.print("\x1b[33m⚠ ")
            io.print(string.from_int(total_warnings))
            io.print(" warning(s) found\x1b[0m\n")
        }
        | false => {}
    
    total_infos > 0 ?
        | true => {
            io.print("\x1b[36mℹ ")
            io.print(string.from_int(total_infos))
            io.print(" info message(s)\x1b[0m\n")
        }
        | false => {}
}

// Main entry point
main = () i32 {
    io.print("Enhanced Zen Code Checker v0.2.0\n")
    io.print("================================\n\n")
    
    // In a real implementation, parse command-line arguments
    // For now, provide usage information
    io.print("Usage: zen-check-enhanced <file.zen> [<file2.zen> ...]\n\n")
    io.print("Checks for:\n")
    io.print("  Errors:\n")
    io.print("    • E001: Imports in comptime blocks\n")
    io.print("    • E002: Unmatched closing braces\n")
    io.print("    • E003: Unmatched closing parentheses\n")
    io.print("    • E004: Unclosed braces\n")
    io.print("    • E005: Unclosed parentheses\n")
    io.print("  Warnings:\n")
    io.print("    • W001: Deprecated import syntax\n")
    io.print("    • W002: Mixed tabs/spaces in indentation\n")
    io.print("    • W003: Inconsistent indentation style\n")
    io.print("  Info:\n")
    io.print("    • I001: Trailing whitespace\n")
    io.print("    • I002: Line length > 120 characters\n")
    
    return 0
}