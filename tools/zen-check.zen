// Zen Code Checker
// A validation tool for Zen source files

io := @std.io
fs := @std.fs
string := @std.string
vec := @std.vec
core := @std.core

// Check for common issues in Zen source code
check_file = (filepath: string) i32 {
    // Read the file content
    content_result := fs.read_file(filepath)
    content_result.is_err() ?
        | true => {
            io.print("Error: Could not read file: ")
            io.print(filepath)
            io.print("\n")
            return 1
        }
        | false => {}
    
    content := content_result.unwrap()
    errors_found := 0
    warnings_found := 0
    
    // Split content into lines for analysis
    lines := string.split(content, "\n")
    
    i := 0
    in_comptime := false
    comptime_start := 0
    
    loop i < lines.len() {
        line := lines[i]
        line_num := i + 1
        
        // Check for comptime blocks
        string.contains(line, "comptime") && string.contains(line, "{") ?
            | true => {
                in_comptime = true
                comptime_start = line_num
            }
            | false => {}
        
        // Check for imports in comptime blocks
        in_comptime && (string.contains(line, "@std") || string.contains(line, ".import(")) ?
            | true => {
                io.print("\x1b[31m[ERROR]\x1b[0m Line ")
                io.print(string.from_int(line_num))
                io.print(": Imports should not be inside comptime blocks\n")
                errors_found = errors_found + 1
            }
            | false => {}
        
        // Check for closing brace of comptime
        in_comptime && string.contains(line, "}") ?
            | true => {
                in_comptime = false
            }
            | false => {}
        
        // Check for proper import syntax at module level
        in_comptime == false && string.contains(line, "@std") ?
            | true => {
                // Count leading spaces/tabs
                leading_spaces := 0
                j := 0
                loop j < line.len() {
                    c := line[j]
                    (c == ' ' || c == '\t') ?
                        | true => { leading_spaces = leading_spaces + 1 }
                        | false => { break }
                    j = j + 1
                }
                
                leading_spaces > 0 ?
                    | true => {
                        io.print("\x1b[33m[WARNING]\x1b[0m Line ")
                        io.print(string.from_int(line_num))
                        io.print(": Import should be at module level (no indentation)\n")
                        warnings_found = warnings_found + 1
                    }
                    | false => {}
            }
            | false => {}
        
        // Check for tabs vs spaces consistency
        has_tabs := string.contains(line, "\t")
        has_leading_spaces := false
        line.len() >= 4 ?
            | true => {
                has_leading_spaces = line[0] == ' ' && line[1] == ' ' && line[2] == ' ' && line[3] == ' '
            }
            | false => {}
        
        has_tabs && has_leading_spaces ?
            | true => {
                io.print("\x1b[33m[WARNING]\x1b[0m Line ")
                io.print(string.from_int(line_num))
                io.print(": Mixed tabs and spaces for indentation\n")
                warnings_found = warnings_found + 1
            }
            | false => {}
        
        i = i + 1
    }
    
    // Print summary
    errors_found == 0 && warnings_found == 0 ?
        | true => {
            io.print("\x1b[32m✓ No issues found!\x1b[0m\n")
            return 0
        }
        | false => {
            io.print("\nSummary: ")
            io.print(string.from_int(errors_found))
            io.print(" error(s), ")
            io.print(string.from_int(warnings_found))
            io.print(" warning(s)\n")
            
            errors_found > 0 ?
                | true => { return 1 }
                | false => { return 0 }
        }
}

// Main entry point
main = () i32 {
    // Simple argument handling for now
    // In a real implementation, we'd parse command-line arguments properly
    io.print("Zen Code Checker v0.1.0\n")
    io.print("======================\n\n")
    
    // For demonstration, check a sample file
    io.print("Usage: zen-check <file.zen>\n")
    io.print("\nThis tool checks for:\n")
    io.print("  • Imports inside comptime blocks (ERROR)\n")
    io.print("  • Indented imports (WARNING)\n")
    io.print("  • Mixed tabs and spaces (WARNING)\n")
    
    return 0
}