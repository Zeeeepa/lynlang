// Zen Code Checker
// A simple validation tool for Zen source files

io := @std.io
fs := @std.fs
string := @std.string
vec := @std.vec

// Validation result types
ValidationError = {
    line: i32,
    column: i32,
    message: *i8,
    severity: ErrorSeverity,
}

ErrorSeverity = 
    | Error
    | Warning
    | Info

ValidationResult = 
    | Ok
    | Errors(errors: Vec<ValidationError>)

// Check for common issues in Zen source code
check_file = (filepath: *i8) ValidationResult {
    // Read the file content
    content := fs.read_file(filepath)
    if (!content) {
        io.print("Error: Could not read file ")
        io.println(filepath)
        return ValidationResult.Errors(vec.new(ValidationError))
    }
    
    errors := vec.new(ValidationError)
    line_num := 1
    
    // Split content into lines for analysis
    lines := string.split(content, "\n")
    
    for (i := 0; i < lines.len; i += 1) {
        line := lines.data[i]
        
        // Check for comptime import patterns (these are errors)
        if (string.contains(line, "comptime") && string.contains(line, "{")) {
            // Look ahead to see if there's an import in the comptime block
            j := i + 1
            while (j < lines.len && !string.contains(lines.data[j], "}")) {
                next_line := lines.data[j]
                if (string.contains(next_line, "@std") || 
                    string.contains(next_line, "build.import")) {
                    
                    error := ValidationError {
                        line: i + 1,
                        column: 1,
                        message: "Imports should not be inside comptime blocks",
                        severity: ErrorSeverity.Error,
                    }
                    vec.push(ValidationError, &errors, error)
                }
                j += 1
            }
        }
        
        // Check for proper import syntax
        if (string.contains(line, "@std")) {
            // Ensure it's at module level (not indented)
            leading_spaces := 0
            for (k := 0; k < string.len(line); k += 1) {
                if (line[k] != ' ' && line[k] != '\t') break
                leading_spaces += 1
            }
            
            if (leading_spaces > 0) {
                warning := ValidationError {
                    line: i + 1,
                    column: 1,
                    message: "Import should be at module level (no indentation)",
                    severity: ErrorSeverity.Warning,
                }
                vec.push(ValidationError, &errors, warning)
            }
        }
        
        // Check for missing semicolons in statements
        if (string.ends_with(line, ")") && !string.ends_with(line, ";") && 
            !string.ends_with(line, "{") && !string.contains(line, "=>")) {
            info := ValidationError {
                line: i + 1,
                column: string.len(line),
                message: "Statement might be missing semicolon",
                severity: ErrorSeverity.Info,
            }
            vec.push(ValidationError, &errors, info)
        }
        
        // Check for tabs vs spaces consistency
        has_tabs := string.contains(line, "\t")
        has_spaces := string.starts_with(line, "    ")
        if (has_tabs && has_spaces) {
            warning := ValidationError {
                line: i + 1,
                column: 1,
                message: "Mixed tabs and spaces for indentation",
                severity: ErrorSeverity.Warning,
            }
            vec.push(ValidationError, &errors, warning)
        }
    }
    
    // Return result
    errors.len == 0 ?
        | true => return ValidationResult.Ok
        | false => return ValidationResult.Errors(errors)
}

// Print validation errors
print_errors = (errors: Vec<ValidationError>) void {
    for (i := 0; i < errors.len; i += 1) {
        error := errors.data[i]
        
        // Print severity with color codes
        error.severity ?
            | Error => io.print("\x1b[31m[ERROR]\x1b[0m ")
            | Warning => io.print("\x1b[33m[WARNING]\x1b[0m ")
            | Info => io.print("\x1b[36m[INFO]\x1b[0m ")
        
        io.print("Line ")
        io.print_int(error.line)
        io.print(", Column ")
        io.print_int(error.column)
        io.print(": ")
        io.println(error.message)
    }
}

// Main entry point
main = (argc: i32, argv: **i8) i32 {
    if (argc < 2) {
        io.println("Usage: zen-check <file.zen>")
        io.println("Check Zen source files for common issues")
        return 1
    }
    
    filepath := argv[1]
    io.print("Checking file: ")
    io.println(filepath)
    io.println("----------------------------------------")
    
    result := check_file(filepath)
    
    result ?
        | Ok => {
            io.println("\x1b[32mâœ“ No issues found!\x1b[0m")
            return 0
        }
        | Errors(errors) => {
            io.print("Found ")
            io.print_int(errors.len)
            io.println(" issue(s):")
            io.println("")
            print_errors(errors)
            return 1
        }
}