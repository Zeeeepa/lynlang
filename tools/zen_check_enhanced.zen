// Enhanced Zen Syntax Checker
// Provides comprehensive syntax checking and linting

{ io } = @std.io
{ fs } = @std.fs
{ string } = @std.string
{ process } = @std.process

// Import compiler modules
{ lexer } = @std.compiler.lexer
{ parser } = @std.compiler.parser
{ type_checker } = @std.compiler.type_checker

// Check result
CheckResult: {
    file: string,
    errors: []Error,
    warnings: []Warning,
    hints: []Hint,
    stats: FileStats,
}

// Error information
Error: {
    line: u32,
    column: u32,
    message: string,
    code: string,
    severity: Severity,
}

// Warning information
Warning: {
    line: u32,
    column: u32,
    message: string,
    code: string,
    suggestion: Option<string>,
}

// Hint information
Hint: {
    line: u32,
    column: u32,
    message: string,
    suggestion: string,
}

// Severity levels
Severity: 
    Error,
    Warning,
    Info,
    Hint,

// File statistics
FileStats: {
    lines: u32,
    functions: u32,
    structs: u32,
    enums: u32,
    imports: u32,
    comments: u32,
    complexity: u32,
}

// Linter rules
LintRule: 
    UnusedVariable,
    UnusedImport,
    UnusedFunction,
    DeadCode,
    UnreachableCode,
    MissingReturnType,
    InconsistentNaming,
    LongFunction,
    DeepNesting,
    ComptimeImport,
    MutableGlobal,
    ShadowedVariable,
    UnhandledError,
    EmptyBlock,
    DuplicateCase,

// Checker configuration
CheckerConfig: {
    strict: bool,
    max_line_length: u32,
    max_function_length: u32,
    max_complexity: u32,
    max_nesting: u32,
    naming_convention: NamingConvention,
    enabled_rules: []LintRule,
    disabled_rules: []LintRule,
    treat_warnings_as_errors: bool,
}

// Naming conventions
NamingConvention: 
    SnakeCase,
    CamelCase,
    PascalCase,
    Mixed,

// Enhanced syntax checker
SyntaxChecker: {
    config: CheckerConfig,
    results: []CheckResult,
    total_errors: u32,
    total_warnings: u32,
    total_hints: u32,
}

// Create syntax checker
SyntaxChecker.new = (config: CheckerConfig) SyntaxChecker => {
    return SyntaxChecker {
        config: config,
        results: [],
        total_errors: 0,
        total_warnings: 0,
        total_hints: 0,
    }
}

// Check a single file
SyntaxChecker.check_file = (self: &SyntaxChecker, path: string) CheckResult => {
    // Read file
    content := fs.read_file(path) ?
        | .Ok -> c => c
        | .Err -> err => {
            return CheckResult {
                file: path,
                errors: [Error {
                    line: 0,
                    column: 0,
                    message: "Failed to read file: $(err)",
                    code: "E001",
                    severity: .Error,
                }],
                warnings: [],
                hints: [],
                stats: FileStats {},
            }
        }
    
    result := CheckResult {
        file: path,
        errors: [],
        warnings: [],
        hints: [],
        stats: analyze_file_stats(content),
    }
    
    // Lexical analysis
    tokens := lexer.tokenize(content) ?
        | .Ok -> t => t
        | .Err -> err => {
            result.errors.push(Error {
                line: err.line,
                column: err.column,
                message: err.message,
                code: "E002",
                severity: .Error,
            });
            return result
        }
    
    // Check for lexical issues
    check_lexical_issues(&result, tokens, self.config);
    
    // Parse syntax tree
    ast := parser.parse(tokens) ?
        | .Ok -> tree => tree
        | .Err -> err => {
            result.errors.push(Error {
                line: err.line,
                column: err.column,
                message: err.message,
                code: "E003",
                severity: .Error,
            });
            return result
        }
    
    // Syntax checks
    check_syntax_issues(&result, ast, self.config);
    
    // Type checking
    typed_ast := type_checker.check(ast) ?
        | .Ok -> tree => tree
        | .Err -> err => {
            result.errors.push(Error {
                line: err.line,
                column: err.column,
                message: err.message,
                code: "E004",
                severity: .Error,
            });
            return result
        }
    
    // Semantic checks
    check_semantic_issues(&result, typed_ast, self.config);
    
    // Linting
    apply_lint_rules(&result, typed_ast, self.config);
    
    // Style checks
    check_style_issues(&result, content, self.config);
    
    return result
}

// Check lexical issues
check_lexical_issues = (result: &CheckResult, tokens: []Token, config: CheckerConfig) void => {
    // Check for invalid characters
    loop token in tokens {
        token.type == .Invalid ? | true => {
            result.errors.push(Error {
                line: token.line,
                column: token.column,
                message: "Invalid character: '$(token.value)'",
                code: "E100",
                severity: .Error,
            })
        }
    }
    
    // Check line length
    line_num := 1u32;
    line_start := 0;
    
    loop token in tokens {
        token.line > line_num ? | true => {
            line_length := token.position - line_start;
            line_length > config.max_line_length ? | true => {
                result.warnings.push(Warning {
                    line: line_num,
                    column: config.max_line_length,
                    message: "Line exceeds maximum length of $(config.max_line_length)",
                    code: "W101",
                    suggestion: .Some -> "Break long lines for better readability",
                })
            }
            
            line_num = token.line;
            line_start = token.position
        }
    }
}

// Check syntax issues
check_syntax_issues = (result: &CheckResult, ast: AST, config: CheckerConfig) void => {
    // Check for comptime imports (critical issue)
    loop node in ast.nodes {
        node.type == .ComptimeBlock ? | true => {
            check_comptime_imports(result, node)
        }
    }
    
    // Check for unused variables
    scope_analyzer := ScopeAnalyzer.new();
    scope_analyzer.analyze(ast);
    
    loop var in scope_analyzer.unused_variables {
        result.warnings.push(Warning {
            line: var.line,
            column: var.column,
            message: "Unused variable: '$(var.name)'",
            code: "W200",
            suggestion: .Some -> "Remove unused variable or prefix with '_'",
        })
    }
    
    // Check for unreachable code
    loop func in ast.functions {
        check_unreachable_code(result, func)
    }
    
    // Check for missing return statements
    loop func in ast.functions {
        func.return_type != "void" ? | true => {
            has_return := check_has_return(func.body);
            has_return ? | false => {
                result.errors.push(Error {
                    line: func.end_line,
                    column: 0,
                    message: "Function '$(func.name)' missing return statement",
                    code: "E201",
                    severity: .Error,
                })
            }
        }
    }
}

// Check for comptime imports (should not be wrapped in comptime)
check_comptime_imports = (result: &CheckResult, node: ASTNode) void => {
    loop stmt in node.statements {
        stmt.type == .Assignment ? | true => {
            // Check if it's an import
            is_import := stmt.value.type == .ModuleAccess && 
                        (stmt.value.module.starts_with("@std") || 
                         stmt.value.function == "import");
            
            is_import ? | true => {
                result.errors.push(Error {
                    line: stmt.line,
                    column: stmt.column,
                    message: "Imports should not be wrapped in comptime blocks",
                    code: "E300",
                    severity: .Error,
                });
                
                result.hints.push(Hint {
                    line: stmt.line,
                    column: stmt.column,
                    message: "Move import to module level",
                    suggestion: "$(stmt.name) := $(stmt.value)",
                })
            }
        }
    }
}

// Check semantic issues
check_semantic_issues = (result: &CheckResult, ast: TypedAST, config: CheckerConfig) void => {
    // Check for type mismatches
    loop expr in ast.expressions {
        expr.expected_type != expr.actual_type ? | true => {
            result.errors.push(Error {
                line: expr.line,
                column: expr.column,
                message: "Type mismatch: expected '$(expr.expected_type)', got '$(expr.actual_type)'",
                code: "E400",
                severity: .Error,
            })
        }
    }
    
    // Check for unhandled errors
    loop call in ast.function_calls {
        call.returns_result ? | true => {
            call.result_handled ? | false => {
                result.warnings.push(Warning {
                    line: call.line,
                    column: call.column,
                    message: "Unhandled Result type from '$(call.name)'",
                    code: "W401",
                    suggestion: .Some -> "Handle the error with pattern matching or ? operator",
                })
            }
        }
    }
}

// Apply linting rules
apply_lint_rules = (result: &CheckResult, ast: TypedAST, config: CheckerConfig) void => {
    loop rule in config.enabled_rules {
        rule ?
            | .UnusedImport => check_unused_imports(result, ast)
            | .UnusedFunction => check_unused_functions(result, ast)
            | .DeadCode => check_dead_code(result, ast)
            | .LongFunction => check_long_functions(result, ast, config)
            | .DeepNesting => check_deep_nesting(result, ast, config)
            | .MutableGlobal => check_mutable_globals(result, ast)
            | .ShadowedVariable => check_shadowed_variables(result, ast)
            | .EmptyBlock => check_empty_blocks(result, ast)
            | .DuplicateCase => check_duplicate_cases(result, ast)
            | .InconsistentNaming => check_naming_conventions(result, ast, config)
    }
}

// Check style issues
check_style_issues = (result: &CheckResult, content: string, config: CheckerConfig) void => {
    lines := string.split(content, "\n");
    
    i := 0;
    loop i < lines.len {
        line := lines[i];
        line_num := i + 1;
        
        // Check trailing whitespace
        line.ends_with(" ") || line.ends_with("\t") ? | true => {
            result.hints.push(Hint {
                line: line_num,
                column: line.len,
                message: "Trailing whitespace",
                suggestion: "Remove trailing whitespace",
            })
        }
        
        // Check tabs vs spaces
        has_tabs := line.contains("\t");
        has_spaces := line.starts_with(" ");
        
        has_tabs && has_spaces ? | true => {
            result.warnings.push(Warning {
                line: line_num,
                column: 0,
                message: "Mixed tabs and spaces for indentation",
                code: "W500",
                suggestion: .Some -> "Use consistent indentation (prefer spaces)",
            })
        }
        
        i += 1
    }
}

// Check for long functions
check_long_functions = (result: &CheckResult, ast: TypedAST, config: CheckerConfig) void => {
    loop func in ast.functions {
        line_count := func.end_line - func.start_line;
        
        line_count > config.max_function_length ? | true => {
            result.warnings.push(Warning {
                line: func.start_line,
                column: 0,
                message: "Function '$(func.name)' is too long ($(line_count) lines)",
                code: "W600",
                suggestion: .Some -> "Consider breaking into smaller functions",
            })
        }
    }
}

// Check for deep nesting
check_deep_nesting = (result: &CheckResult, ast: TypedAST, config: CheckerConfig) void => {
    loop func in ast.functions {
        max_depth := calculate_nesting_depth(func.body);
        
        max_depth > config.max_nesting ? | true => {
            result.warnings.push(Warning {
                line: func.start_line,
                column: 0,
                message: "Function '$(func.name)' has deep nesting (depth: $(max_depth))",
                code: "W601",
                suggestion: .Some -> "Reduce nesting by extracting functions or early returns",
            })
        }
    }
}

// Analyze file statistics
analyze_file_stats = (content: string) FileStats => {
    lines := string.split(content, "\n");
    
    stats := FileStats {
        lines: lines.len,
        functions: 0,
        structs: 0,
        enums: 0,
        imports: 0,
        comments: 0,
        complexity: 0,
    }
    
    loop line in lines {
        trimmed := string.trim(line);
        
        // Count different elements
        trimmed.starts_with("//") ? | true => stats.comments += 1
        trimmed.contains(" = (") && trimmed.contains(")") ? | true => stats.functions += 1
        trimmed.starts_with("struct ") || trimmed.contains(" = {") ? | true => stats.structs += 1
        trimmed.starts_with("enum ") ? | true => stats.enums += 1
        trimmed.contains(":= @") || trimmed.contains(".import(") ? | true => stats.imports += 1
    }
    
    return stats
}

// Format output with colors
format_output = (result: &CheckResult, use_colors: bool) string => {
    // ANSI color codes
    RED := use_colors ? | true => "\x1b[31m" | false => "";
    YELLOW := use_colors ? | true => "\x1b[33m" | false => "";
    BLUE := use_colors ? | true => "\x1b[34m" | false => "";
    CYAN := use_colors ? | true => "\x1b[36m" | false => "";
    RESET := use_colors ? | true => "\x1b[0m" | false => "";
    BOLD := use_colors ? | true => "\x1b[1m" | false => "";
    
    output := "";
    
    // File header
    output += "$(BOLD)$(result.file)$(RESET)\n";
    
    // Errors
    loop error in result.errors {
        output += "  $(RED)error[$(error.code)]$(RESET): $(error.message)\n";
        output += "    --> $(result.file):$(error.line):$(error.column)\n"
    }
    
    // Warnings
    loop warning in result.warnings {
        output += "  $(YELLOW)warning[$(warning.code)]$(RESET): $(warning.message)\n";
        output += "    --> $(result.file):$(warning.line):$(warning.column)\n";
        
        warning.suggestion ?
            | .Some -> suggestion => {
                output += "    $(CYAN)help$(RESET): $(suggestion)\n"
            }
    }
    
    // Hints
    loop hint in result.hints {
        output += "  $(BLUE)hint$(RESET): $(hint.message)\n";
        output += "    --> $(result.file):$(hint.line):$(hint.column)\n";
        output += "    $(CYAN)suggestion$(RESET): $(hint.suggestion)\n"
    }
    
    // Statistics
    output += "\n";
    output += "  Statistics:\n";
    output += "    Lines: $(result.stats.lines)\n";
    output += "    Functions: $(result.stats.functions)\n";
    output += "    Structs: $(result.stats.structs)\n";
    output += "    Enums: $(result.stats.enums)\n";
    
    return output
}

// Main check function
check = (paths: []string, config: CheckerConfig) i32 => {
    checker := SyntaxChecker.new(config);
    
    // Check each file
    loop path in paths {
        // Expand wildcards
        files := fs.glob(path) ?
            | .Ok -> f => f
            | .Err => [path]
        
        loop file in files {
            file.ends_with(".zen") ? | false => continue
            
            result := checker.check_file(file);
            
            // Update totals
            checker.total_errors += result.errors.len;
            checker.total_warnings += result.warnings.len;
            checker.total_hints += result.hints.len;
            
            // Print result
            has_issues := result.errors.len > 0 || 
                         result.warnings.len > 0 || 
                         result.hints.len > 0;
            
            has_issues ? | true => {
                output := format_output(&result, true);
                io.print(output);
                io.print("\n")
            }
            
            checker.results.push(result)
        }
    }
    
    // Print summary
    io.print("Summary:\n");
    io.print("  Files checked: $(checker.results.len)\n");
    io.print("  Errors: $(checker.total_errors)\n");
    io.print("  Warnings: $(checker.total_warnings)\n");
    io.print("  Hints: $(checker.total_hints)\n");
    
    // Return exit code
    checker.total_errors > 0 ? | true => return 1
    
    config.treat_warnings_as_errors && checker.total_warnings > 0 ? | true => return 1
    
    return 0
}

// Main entry point
main = (args: []string) i32 => {
    // Default configuration
    config := CheckerConfig {
        strict: false,
        max_line_length: 120,
        max_function_length: 50,
        max_complexity: 10,
        max_nesting: 4,
        naming_convention: .SnakeCase,
        enabled_rules: [
            .UnusedVariable,
            .UnusedImport,
            .ComptimeImport,
            .UnhandledError,
            .MissingReturnType,
        ],
        disabled_rules: [],
        treat_warnings_as_errors: false,
    }
    
    // Parse arguments
    files := [];
    i := 1;
    
    loop i < args.len {
        arg := args[i];
        
        arg ?
            | "--strict" => config.strict = true
            | "--werror" => config.treat_warnings_as_errors = true
            | "--max-line-length" => {
                i += 1;
                i < args.len ? | true => {
                    config.max_line_length = string.parse_u32(args[i])?
                }
            }
            | "--help" | "-h" => {
                print_help();
                return 0
            }
            | _ => files.push(arg)
        
        i += 1
    }
    
    files.is_empty() ? | true => {
        io.error("No files specified\n");
        print_usage();
        return 1
    }
    
    return check(files, config)
}

// Print help
print_help = () void => {
    io.print("Zen Syntax Checker\n");
    io.print("==================\n\n");
    io.print("Usage: zen-check [options] <files...>\n\n");
    io.print("Options:\n");
    io.print("  --strict                Enable all checks\n");
    io.print("  --werror                Treat warnings as errors\n");
    io.print("  --max-line-length <n>   Maximum line length (default: 120)\n");
    io.print("  -h, --help              Show this help\n\n");
    io.print("Examples:\n");
    io.print("  zen-check main.zen\n");
    io.print("  zen-check src/*.zen\n");
    io.print("  zen-check --strict --werror src/**/*.zen\n")
}

// Print usage
print_usage = () void => {
    io.print("Usage: zen-check [options] <files...>\n");
    io.print("Try 'zen-check --help' for more information\n")
}