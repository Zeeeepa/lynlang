// Zen Language Syntax Checker
// Simple tool to validate Zen source files

io := @std.io
fs := @std.fs
string := @std.string
vec := @std.vec
process := @std.process
lexer := @compiler.lexer_enhanced
parser := @compiler.parser_enhanced

// Checker result
CheckResult = struct {
    file: string,
    errors: vec.Vec<Error>,
    warnings: vec.Vec<Warning>,
    valid: bool,
}

// Error information
Error = struct {
    line: u32,
    column: u32,
    message: string,
    severity: ErrorSeverity,
}

// Warning information
Warning = struct {
    line: u32,
    column: u32,
    message: string,
}

// Error severity levels
ErrorSeverity = |
    Error,
    Fatal,

// Check a single file
check_file = (path: string) CheckResult {
    result := CheckResult{
        file: path,
        errors: vec.new<Error>(),
        warnings: vec.new<Warning>(),
        valid: true,
    }
    
    // Read file contents
    content := match io.read_to_string(path) {
        | IoResult.Ok -> value => value
        | IoResult.Err -> error => {
            result.errors.push(Error{
                line: 0,
                column: 0,
                message: "Failed to read file: " + path,
                severity: ErrorSeverity.Fatal,
            })
            result.valid = false
            return result
        }
    }
    
    // Tokenize
    lex := lexer.lexer_new(content)
    tokens := lexer.lexer_scan_tokens(&lex)
    
    // Check for lexer errors (invalid tokens)
    i := 0
    loop i < tokens.len {
        match tokens[i].type {
            | lexer.TokenType.Invalid => {
                result.errors.push(Error{
                    line: tokens[i].line,
                    column: tokens[i].column,
                    message: "Invalid token: " + tokens[i].lexeme,
                    severity: ErrorSeverity.Error,
                })
                result.valid = false
            }
            | _ => {}
        }
        i = i + 1
    }
    
    // Parse
    p := parser.parser_new(tokens)
    ast := match parser.parse(&p) {
        | Result.Ok -> nodes => nodes
        | Result.Err -> errors => {
            j := 0
            loop j < errors.len {
                result.errors.push(Error{
                    line: 0,
                    column: 0,
                    message: errors[j],
                    severity: ErrorSeverity.Error,
                })
                j = j + 1
            }
            result.valid = false
            return result
        }
    }
    
    // Perform semantic checks
    check_semantics(&result, ast)
    
    return result
}

// Perform semantic checks on AST
check_semantics = (result: *CheckResult, ast: vec.Vec<*parser.AstNode>) void {
    // Check for imports inside comptime blocks
    check_import_placement(result, ast)
    
    // Check for duplicate declarations
    check_duplicates(result, ast)
    
    // Check for unused variables (warning)
    check_unused(result, ast)
    
    // Check for unreachable code
    check_unreachable(result, ast)
}

// Check that imports are at module level only
check_import_placement = (result: *CheckResult, ast: vec.Vec<*parser.AstNode>) void {
    i := 0
    loop i < ast.len {
        check_import_in_node(result, ast[i], false)
        i = i + 1
    }
}

// Recursively check for imports in wrong places
check_import_in_node = (result: *CheckResult, node: *parser.AstNode, in_comptime: bool) void {
    match node.type {
        | parser.AstNodeType.ComptimeExpr => {
            // Mark that we're inside comptime
            match node.data {
                | parser.AstData.BlockStmt -> statements => {
                    j := 0
                    loop j < statements.len {
                        check_import_in_node(result, statements[j], true)
                        j = j + 1
                    }
                }
                | _ => {}
            }
        }
        | parser.AstNodeType.VariableDecl => {
            match node.data {
                | parser.AstData.VariableDecl -> decl => {
                    // Check if it's an import
                    is_import := false
                    match decl.value.data {
                        | parser.AstData.MemberExpr -> member => {
                            string.starts_with(member.member, "@std") ? {
                                is_import = true
                            } : {}
                        }
                        | _ => {}
                    }
                    
                    is_import && in_comptime ? {
                        result.errors.push(Error{
                            line: node.line,
                            column: node.column,
                            message: "Imports not allowed inside comptime blocks",
                            severity: ErrorSeverity.Error,
                        })
                        result.valid = false
                    } : {}
                }
                | _ => {}
            }
        }
        | _ => {}
    }
}

// Check for duplicate declarations
check_duplicates = (result: *CheckResult, ast: vec.Vec<*parser.AstNode>) void {
    declarations := vec.new<string>()
    
    i := 0
    loop i < ast.len {
        name := get_declaration_name(ast[i])
        !string.is_empty(name) ? {
            // Check if already declared
            j := 0
            loop j < declarations.len {
                string.equals(declarations[j], name) ? {
                    result.errors.push(Error{
                        line: ast[i].line,
                        column: ast[i].column,
                        message: "Duplicate declaration: " + name,
                        severity: ErrorSeverity.Error,
                    })
                    result.valid = false
                    break
                } : {}
                j = j + 1
            }
            declarations.push(name)
        } : {}
        i = i + 1
    }
}

// Get declaration name from node
get_declaration_name = (node: *parser.AstNode) string {
    match node.data {
        | parser.AstData.FunctionDecl -> decl => decl.name
        | parser.AstData.VariableDecl -> decl => decl.name
        | parser.AstData.StructDecl -> decl => decl.name
        | parser.AstData.EnumDecl -> decl => decl.name
        | _ => ""
    }
}

// Check for unused variables (simplified)
check_unused = (result: *CheckResult, ast: vec.Vec<*parser.AstNode>) void {
    // This is a simplified check - real implementation would track usage
    i := 0
    loop i < ast.len {
        match ast[i].data {
            | parser.AstData.VariableDecl -> decl => {
                // Check if variable name starts with underscore (convention for unused)
                !string.starts_with(decl.name, "_") && string.starts_with(decl.name, "unused") ? {
                    result.warnings.push(Warning{
                        line: ast[i].line,
                        column: ast[i].column,
                        message: "Variable '" + decl.name + "' appears to be unused",
                    })
                } : {}
            }
            | _ => {}
        }
        i = i + 1
    }
}

// Check for unreachable code
check_unreachable = (result: *CheckResult, ast: vec.Vec<*parser.AstNode>) void {
    i := 0
    loop i < ast.len {
        check_unreachable_in_node(result, ast[i])
        i = i + 1
    }
}

// Check for unreachable code in a node
check_unreachable_in_node = (result: *CheckResult, node: *parser.AstNode) void {
    match node.data {
        | parser.AstData.BlockStmt -> statements => {
            j := 0
            found_return := false
            loop j < statements.len {
                found_return ? {
                    result.warnings.push(Warning{
                        line: statements[j].line,
                        column: statements[j].column,
                        message: "Unreachable code after return",
                    })
                } : {}
                
                match statements[j].type {
                    | parser.AstNodeType.ReturnStmt => found_return = true
                    | _ => {}
                }
                j = j + 1
            }
        }
        | _ => {}
    }
}

// Print results
print_results = (results: vec.Vec<CheckResult>) void {
    total_errors := 0
    total_warnings := 0
    
    i := 0
    loop i < results.len {
        result := results[i]
        
        io.println("Checking: " + result.file)
        
        // Print errors
        j := 0
        loop j < result.errors.len {
            error := result.errors[j]
            io.eprintln("  ERROR [" + string.from_int(error.line) + ":" + 
                       string.from_int(error.column) + "]: " + error.message)
            j = j + 1
        }
        
        // Print warnings
        k := 0
        loop k < result.warnings.len {
            warning := result.warnings[k]
            io.println("  WARNING [" + string.from_int(warning.line) + ":" + 
                      string.from_int(warning.column) + "]: " + warning.message)
            k = k + 1
        }
        
        result.valid ? {
            io.println("  ✓ Valid")
        } : {
            io.println("  ✗ Invalid")
        }
        
        total_errors = total_errors + result.errors.len
        total_warnings = total_warnings + result.warnings.len
        i = i + 1
    }
    
    io.println("")
    io.println("Summary:")
    io.println("  Files checked: " + string.from_int(results.len))
    io.println("  Errors: " + string.from_int(total_errors))
    io.println("  Warnings: " + string.from_int(total_warnings))
    
    total_errors > 0 ? {
        io.println("  Status: FAILED")
    } : {
        io.println("  Status: PASSED")
    }
}

// Main entry point
main = (args: vec.Vec<string>) i32 {
    args.len < 2 ? {
        io.println("Usage: zen-check <file.zen> [file2.zen ...]")
        return 1
    } : {}
    
    results := vec.new<CheckResult>()
    
    // Check each file
    i := 1
    loop i < args.len {
        results.push(check_file(args[i]))
        i = i + 1
    }
    
    // Print results
    print_results(results)
    
    // Return error code based on results
    i = 0
    loop i < results.len {
        !results[i].valid ? { return 1 } : {}
        i = i + 1
    }
    
    return 0
}