// Zen Language Syntax Checker
// Simple tool to validate Zen source files

io = @std
fs = @std
string = @std
{ Vec, DynVec } = @std
process = @std
{ lexer } = @std
{ parser } = @std

// Checker result
CheckResult: {
    file: string,
    errors: DynVec<Error>,
    warnings: DynVec<Warning>,
    valid: bool,
}

// Error information
Error: {
    line: u32,
    column: u32,
    message: string,
    severity: ErrorSeverity,
}

// Warning information
Warning: {
    line: u32,
    column: u32,
    message: string,
}

// Error severity levels
ErrorSeverity: 
    Error,
    Fatal,

// Check a single file
check_file = (path: string) CheckResult   {
    result := CheckResult{
        file: path,
        errors: DynVec.new<Error>(),
        warnings: DynVec.new<Warning>(),
        valid: true,
    }
    
    // Read file contents
    content := match io.read_to_string(path) {
        | IoResult.Ok(value) => value
        | IoResult.Err(error) => {
            result.errors.push(Error{
                line: 0,
                column: 0,
                message: "Failed to read file: " + path,
                severity: ErrorSeverity.Fatal,
            })
            result.valid = false
            return result
        }
    }
    
    // Tokenize
    lex := lexer.lexer_new(content)
    tokens := lexer.lexer_scan_tokens(&lex)
    
    // Check for lexer errors (invalid tokens)
    i := 0
    loop i < tokens.len {
        tokens[i].type ?
            | lexer.TokenType.Invalid => {
                result.errors.push(Error{
                    line: tokens[i].line,
                    column: tokens[i].column,
                    message: "Invalid token: " + tokens[i].lexeme,
                    severity: ErrorSeverity.Error,
                })
                result.valid = false
            }
            | _ => {}
        }
        i = i + 1
    }
    
    // Parse
    p := parser.parser_new(tokens)
    ast := match parser.parse(&p) {
        | Result.Ok(nodes) => nodes
        | Result.Err(errors) => {
            j := 0
            loop j < errors.len {
                result.errors.push(Error{
                    line: 0,
                    column: 0,
                    message: errors[j],
                    severity: ErrorSeverity.Error,
                })
                j = j + 1
            }
            result.valid = false
            return result
        }
    }
    
    // Perform semantic checks
    check_semantics(&result, ast)
    
    return result
}

// Perform semantic checks on AST
check_semantics = (result: Ptr<CheckResult>, ast: DynVec<Ptr<parser.AstNode>>) void   {
    // Check for imports inside comptime blocks
    check_import_placement(result, ast)
    
    // Check for duplicate declarations
    check_duplicates(result, ast)
    
    // Check for unused variables (warning)
    check_unused(result, ast)
    
    // Check for unreachable code
    check_unreachable(result, ast)
}

// Check that imports are at module level only
check_import_placement = (result: Ptr<CheckResult>, ast: DynVec<Ptr<parser.AstNode>>) void   {
    i := 0
    loop i < ast.len {
        check_import_in_node(result, ast[i], false)
        i = i + 1
    }
}

// Recursively check for imports in wrong places
check_import_in_node = (result: Ptr<CheckResult>, node: Ptr<parser.AstNode>, in_comptime: bool) void   {
    node.type ?
        | parser.AstNodeType.ComptimeExpr => {
            // Mark that we're inside comptime
            node.data ?
                | parser.AstData.BlockStmt(statements) => {
                    j := 0
                    loop j < statements.len {
                        check_import_in_node(result, statements[j], true)
                        j = j + 1
                    }
                }
                | _ => {}
            }
        }
        | parser.AstNodeType.VariableDecl => {
            node.data ?
                | parser.AstData.VariableDecl(decl) => {
                    // Check if it's an import
                    is_import := false
                    decl.value.data ?
                        | parser.AstData.MemberExpr(member) => {
                            string.starts_with(member.member, "@std") ? {
                                is_import = true
                            } : {}
                        }
                        | _ => {}
                    }
                    
                    is_import && in_comptime ? {
                        result.errors.push(Error{
                            line: node.line,
                            column: node.column,
                            message: "Imports not allowed inside comptime blocks",
                            severity: ErrorSeverity.Error,
                        })
                        result.valid = false
                    } : {}
                }
                | _ => {}
            }
        }
        | _ => {}
    }
}

// Check for duplicate declarations
check_duplicates = (result: Ptr<CheckResult>, ast: DynVec<Ptr<parser.AstNode>>) void   {
    declarations := DynVec.new<string>()
    
    i := 0
    loop i < ast.len {
        name := get_declaration_name(ast[i])
        !string.is_empty(name) ? {
            // Check if already declared
            j := 0
            loop j < declarations.len {
                string.equals(declarations[j], name) ? {
                    result.errors.push(Error{
                        line: ast[i].line,
                        column: ast[i].column,
                        message: "Duplicate declaration: " + name,
                        severity: ErrorSeverity.Error,
                    })
                    result.valid = false
                    break
                } : {}
                j = j + 1
            }
            declarations.push(name)
        } : {}
        i = i + 1
    }
}

// Get declaration name from node
get_declaration_name = (node: Ptr<parser.AstNode>) string   {
    node.data ?
        | parser.AstData.FunctionDecl(decl) => decl.name
        | parser.AstData.VariableDecl(decl) => decl.name
        | parser.AstData.StructDecl(decl) => decl.name
        | parser.AstData.EnumDecl(decl) => decl.name
        | _ => ""
    }
}

// Check for unused variables (simplified)
check_unused = (result: Ptr<CheckResult>, ast: DynVec<Ptr<parser.AstNode>>) void   {
    // This is a simplified check - real implementation would track usage
    i := 0
    loop i < ast.len {
        ast[i].data ?
            | parser.AstData.VariableDecl(decl) => {
                // Check if variable name starts with underscore (convention for unused)
                !string.starts_with(decl.name, "_") && string.starts_with(decl.name, "unused") ? {
                    result.warnings.push(Warning{
                        line: ast[i].line,
                        column: ast[i].column,
                        message: "Variable '" + decl.name + "' appears to be unused",
                    })
                } : {}
            }
            | _ => {}
        }
        i = i + 1
    }
}

// Check for unreachable code
check_unreachable = (result: Ptr<CheckResult>, ast: DynVec<Ptr<parser.AstNode>>) void   {
    i := 0
    loop i < ast.len {
        check_unreachable_in_node(result, ast[i])
        i = i + 1
    }
}

// Check for unreachable code in a node
check_unreachable_in_node = (result: Ptr<CheckResult>, node: Ptr<parser.AstNode>) void   {
    node.data ?
        | parser.AstData.BlockStmt(statements) => {
            j := 0
            found_return := false
            loop j < statements.len {
                found_return ? {
                    result.warnings.push(Warning{
                        line: statements[j].line,
                        column: statements[j].column,
                        message: "Unreachable code after return",
                    })
                } : {}
                
                statements[j].type ?
                    | parser.AstNodeType.ReturnStmt => found_return = true
                    | _ => {}
                }
                j = j + 1
            }
        }
        | _ => {}
    }
}

// Print results
print_results = (results: DynVec<CheckResult>) void   {
    total_errors := 0
    total_warnings := 0
    
    i := 0
    loop i < results.len {
        result := results[i]
        
        io.println("Checking: " + result.file)
        
        // Print errors
        j := 0
        loop j < result.errors.len {
            error := result.errors[j]
            io.eprintln("  ERROR [" + string.from_int(error.line) + ":" + 
                       string.from_int(error.column) + "]: " + error.message)
            j = j + 1
        }
        
        // Print warnings
        k := 0
        loop k < result.warnings.len {
            warning := result.warnings[k]
            io.println("  WARNING [" + string.from_int(warning.line) + ":" + 
                      string.from_int(warning.column) + "]: " + warning.message)
            k = k + 1
        }
        
        result.valid ? {
            io.println("  ✓ Valid")
        } : {
            io.println("  ✗ Invalid")
        }
        
        total_errors = total_errors + result.errors.len
        total_warnings = total_warnings + result.warnings.len
        i = i + 1
    }
    
    io.println("")
    io.println("Summary:")
    io.println("  Files checked: " + string.from_int(results.len))
    io.println("  Errors: " + string.from_int(total_errors))
    io.println("  Warnings: " + string.from_int(total_warnings))
    
    total_errors > 0 ? {
        io.println("  Status: FAILED")
    } : {
        io.println("  Status: PASSED")
    }
}

// Main entry point
main = (args: DynVec<string>) i32   {
    args.len < 2 ? {
        io.println("Usage: zen-check <file.zen> [file2.zen ...]")
        return 1
    } : {}
    
    results := DynVec.new<CheckResult>()
    
    // Check each file
    i := 1
    loop i < args.len {
        results.push(check_file(args[i]))
        i = i + 1
    }
    
    // Print results
    print_results(results)
    
    // Return error code based on results
    i = 0
    loop i < results.len {
        !results[i].valid ? { return 1 } : {}
        i = i + 1
    }
    
    return 0
}