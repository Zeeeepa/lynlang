#!/bin/bash
# zen-check - Zen Language Syntax Checker
# A tool to validate Zen source files for correctness

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check if file is provided
if [ $# -eq 0 ]; then
    echo "Usage: zen-check <file.zen> [options]"
    echo ""
    echo "Options:"
    echo "  --verbose    Show detailed validation output"
    echo "  --quiet      Only show errors"
    echo "  --all        Check all .zen files recursively"
    echo ""
    exit 1
fi

# Function to check a single file
check_file() {
    local file=$1
    local verbose=$2
    local quiet=$3
    
    if [ ! -f "$file" ]; then
        echo -e "${RED}Error: File '$file' not found${NC}"
        return 1
    fi
    
    if [ "$quiet" != "true" ]; then
        echo -e "Checking: $file"
    fi
    
    local errors=0
    local warnings=0
    
    # Check 1: Imports should not be in comptime blocks
    if grep -q "comptime\s*{[^}]*@std" "$file" 2>/dev/null; then
        echo -e "${RED}  ✗ Error: Imports found inside comptime block${NC}"
        if [ "$verbose" == "true" ]; then
            grep -n "comptime\s*{[^}]*@std" "$file" | while read -r line; do
                echo "    Line: $line"
            done
        fi
        ((errors++))
    fi
    
    # Check 2: All imports should be at module level
    local import_lines=$(grep -n "^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*\s*:=\s*@std" "$file" 2>/dev/null | cut -d: -f1)
    local main_line=$(grep -n "^main\s*=" "$file" 2>/dev/null | head -1 | cut -d: -f1)
    
    if [ -n "$import_lines" ] && [ -n "$main_line" ]; then
        for line_num in $import_lines; do
            if [ "$line_num" -gt "$main_line" ]; then
                echo -e "${RED}  ✗ Error: Import on line $line_num appears after main function${NC}"
                ((errors++))
            fi
        done
    fi
    
    # Check 3: Verify function syntax
    if grep -q "func\s" "$file" 2>/dev/null; then
        echo -e "${YELLOW}  ⚠ Warning: Old 'func' keyword found, use '=' syntax instead${NC}"
        ((warnings++))
    fi
    
    # Check 4: Verify proper use of comptime (only for metaprogramming)
    local comptime_blocks=$(grep -n "comptime\s*{" "$file" 2>/dev/null)
    if [ -n "$comptime_blocks" ] && [ "$verbose" == "true" ]; then
        echo "  ℹ Comptime blocks found (verify they're for metaprogramming only):"
        echo "$comptime_blocks" | while read -r line; do
            echo "    $line"
        done
    fi
    
    # Check 5: Basic syntax validation
    # Check for unmatched braces
    local open_braces=$(grep -o "{" "$file" 2>/dev/null | wc -l)
    local close_braces=$(grep -o "}" "$file" 2>/dev/null | wc -l)
    
    if [ "$open_braces" -ne "$close_braces" ]; then
        echo -e "${RED}  ✗ Error: Unmatched braces (open: $open_braces, close: $close_braces)${NC}"
        ((errors++))
    fi
    
    # Check 6: Verify pattern matching syntax
    if grep -q "?\s*|.*=>.*|.*=>" "$file" 2>/dev/null; then
        if [ "$verbose" == "true" ]; then
            echo "  ℹ Pattern matching found - verifying syntax..."
        fi
    fi
    
    # Summary for this file
    if [ "$errors" -eq 0 ] && [ "$warnings" -eq 0 ]; then
        if [ "$quiet" != "true" ]; then
            echo -e "${GREEN}  ✓ No issues found${NC}"
        fi
        return 0
    else
        echo -e "  Summary: ${RED}$errors errors${NC}, ${YELLOW}$warnings warnings${NC}"
        return 1
    fi
}

# Parse arguments
VERBOSE=false
QUIET=false
CHECK_ALL=false
FILES=()

for arg in "$@"; do
    case $arg in
        --verbose)
            VERBOSE=true
            ;;
        --quiet)
            QUIET=true
            ;;
        --all)
            CHECK_ALL=true
            ;;
        *)
            FILES+=("$arg")
            ;;
    esac
done

# Main execution
TOTAL_ERRORS=0

if [ "$CHECK_ALL" == "true" ]; then
    echo -e "${GREEN}Checking all .zen files...${NC}"
    echo ""
    
    while IFS= read -r -d '' file; do
        if check_file "$file" "$VERBOSE" "$QUIET"; then
            :
        else
            ((TOTAL_ERRORS++))
        fi
        echo ""
    done < <(find . -name "*.zen" -type f -print0)
    
    echo -e "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    if [ "$TOTAL_ERRORS" -eq 0 ]; then
        echo -e "${GREEN}✓ All files passed validation${NC}"
    else
        echo -e "${RED}✗ $TOTAL_ERRORS file(s) with errors${NC}"
        exit 1
    fi
else
    # Check specific files
    for file in "${FILES[@]}"; do
        if check_file "$file" "$VERBOSE" "$QUIET"; then
            :
        else
            ((TOTAL_ERRORS++))
        fi
    done
    
    if [ ${#FILES[@]} -gt 1 ]; then
        echo ""
        echo -e "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        if [ "$TOTAL_ERRORS" -eq 0 ]; then
            echo -e "${GREEN}✓ All files passed validation${NC}"
        else
            echo -e "${RED}✗ $TOTAL_ERRORS file(s) with errors${NC}"
            exit 1
        fi
    fi
fi

exit $TOTAL_ERRORS