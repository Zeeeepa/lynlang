// Zen Language REPL (Read-Eval-Print Loop)
// Interactive shell for experimenting with Zen code

core := @std.core
io := @std.io
string := @std.string
process := @std.process
lexer := @std.compiler.lexer
parser := @std.compiler.parser
type_checker := @std.compiler.type_checker
interpreter := @std.compiler.interpreter

// REPL state
ReplState := {
    line_number: u32
    history: []string
    variables: Map<string, Value>
    functions: Map<string, Function>
    in_multiline: bool
    multiline_buffer: string
    debug_mode: bool
}

// Create new REPL state
new_repl_state = () ReplState {
    return ReplState{
        line_number: 1,
        history: [],
        variables: Map.new(),
        functions: Map.new(),
        in_multiline: false,
        multiline_buffer: "",
        debug_mode: false
    }
}

// ANSI color codes
RED := "\x1b[31m"
GREEN := "\x1b[32m"
YELLOW := "\x1b[33m"
BLUE := "\x1b[34m"
MAGENTA := "\x1b[35m"
CYAN := "\x1b[36m"
RESET := "\x1b[0m"
BOLD := "\x1b[1m"

// Print colored text
print_colored = (color: string, text: string) void {
    io.print(color + text + RESET)
}

// Print welcome banner
print_banner = () void {
    print_colored(CYAN, "╔═══════════════════════════════════════╗\n")
    print_colored(CYAN, "║      ")
    print_colored(YELLOW + BOLD, "Zen Language REPL v1.0")
    print_colored(CYAN, "       ║\n")
    print_colored(CYAN, "╚═══════════════════════════════════════╝\n")
    io.println("")
    io.println("Type 'help' for commands, 'exit' to quit")
    io.println("")
}

// Print help
print_help = () void {
    print_colored(GREEN + BOLD, "Available Commands:\n")
    io.println("  help          - Show this help message")
    io.println("  exit/quit     - Exit the REPL")
    io.println("  clear         - Clear the screen")
    io.println("  vars          - Show all variables")
    io.println("  funcs         - Show all functions")
    io.println("  debug on/off  - Toggle debug mode")
    io.println("  reset         - Reset REPL state")
    io.println("  history       - Show command history")
    io.println("  save <file>   - Save session to file")
    io.println("  load <file>   - Load and execute file")
    io.println("")
    print_colored(GREEN + BOLD, "Special Keys:\n")
    io.println("  Ctrl+C        - Cancel current input")
    io.println("  Ctrl+D        - Exit REPL")
    io.println("")
    print_colored(GREEN + BOLD, "Multi-line Input:\n")
    io.println("  Use \\ at end of line to continue")
    io.println("  Empty line to execute multi-line input")
}

// Get prompt string
get_prompt = (state: &ReplState) string {
    if (state.in_multiline) {
        return BLUE + "... " + RESET
    }
    return BLUE + "zen[" + string.from_u32(state.line_number) + "]> " + RESET
}

// Check if line continues (ends with backslash)
is_continuation = (line: string) bool {
    trimmed := string.trim(line)
    return string.ends_with(trimmed, "\\")
}

// Remove continuation character
remove_continuation = (line: string) string {
    if (is_continuation(line)) {
        return string.substring(line, 0, line.len - 1)
    }
    return line
}

// Process special commands
process_command = (state: &mut ReplState, input: string) bool {
    parts := string.split(input, " ")
    if (parts.len == 0) return false
    
    command := parts[0]
    
    if (command == "help") {
        print_help()
        return true
    } else if (command == "exit" || command == "quit") {
        print_colored(YELLOW, "Goodbye!\n")
        process.exit(0)
    } else if (command == "clear") {
        io.print("\x1b[2J\x1b[H")  // Clear screen and move cursor to top
        return true
    } else if (command == "vars") {
        if (state.variables.is_empty()) {
            io.println("No variables defined")
        } else {
            print_colored(GREEN + BOLD, "Variables:\n")
            for (entry in state.variables) {
                io.println("  " + entry.key + " = " + value_to_string(entry.value))
            }
        }
        return true
    } else if (command == "funcs") {
        if (state.functions.is_empty()) {
            io.println("No functions defined")
        } else {
            print_colored(GREEN + BOLD, "Functions:\n")
            for (entry in state.functions) {
                io.println("  " + entry.key + entry.value.signature())
            }
        }
        return true
    } else if (command == "debug") {
        if (parts.len > 1) {
            if (parts[1] == "on") {
                state.debug_mode = true
                print_colored(GREEN, "Debug mode enabled\n")
            } else if (parts[1] == "off") {
                state.debug_mode = false
                print_colored(GREEN, "Debug mode disabled\n")
            }
        } else {
            io.println("Debug mode: " + if (state.debug_mode) "on" else "off")
        }
        return true
    } else if (command == "reset") {
        *state = new_repl_state()
        print_colored(GREEN, "REPL state reset\n")
        return true
    } else if (command == "history") {
        if (state.history.is_empty()) {
            io.println("No history")
        } else {
            print_colored(GREEN + BOLD, "History:\n")
            for (i := 0; i < state.history.len; i++) {
                io.println("  " + string.from_u32(i + 1) + ": " + state.history[i])
            }
        }
        return true
    } else if (command == "save" && parts.len > 1) {
        filename := parts[1]
        save_session(state, filename)
        return true
    } else if (command == "load" && parts.len > 1) {
        filename := parts[1]
        load_file(state, filename)
        return true
    }
    
    return false
}

// Evaluate Zen expression
evaluate = (state: &mut ReplState, input: string) void {
    // Add to history
    state.history.append(input)
    
    // Tokenize
    tokens := lexer.tokenize(input)
    if (tokens.is_error()) {
        print_colored(RED, "Lexer error: " + tokens.error() + "\n")
        return
    }
    
    if (state.debug_mode) {
        print_colored(MAGENTA, "Tokens: ")
        io.println(tokens_to_string(tokens.unwrap()))
    }
    
    // Parse
    ast := parser.parse(tokens.unwrap())
    if (ast.is_error()) {
        print_colored(RED, "Parser error: " + ast.error() + "\n")
        return
    }
    
    if (state.debug_mode) {
        print_colored(MAGENTA, "AST: ")
        io.println(ast_to_string(ast.unwrap()))
    }
    
    // Type check
    typed_ast := type_checker.check(ast.unwrap())
    if (typed_ast.is_error()) {
        print_colored(RED, "Type error: " + typed_ast.error() + "\n")
        return
    }
    
    // Interpret
    result := interpreter.evaluate(typed_ast.unwrap(), state.variables, state.functions)
    if (result.is_error()) {
        print_colored(RED, "Runtime error: " + result.error() + "\n")
        return
    }
    
    // Display result
    value := result.unwrap()
    if (!value.is_void()) {
        print_colored(GREEN, "=> ")
        io.println(value_to_string(value))
    }
    
    // Update state based on evaluation
    // (store new variables, functions, etc.)
    update_state(state, typed_ast.unwrap())
}

// Save session to file
save_session = (state: &ReplState, filename: string) void {
    content := string.Builder.new()
    content.append("// Zen REPL session\n")
    content.append("// Generated on " + get_timestamp() + "\n\n")
    
    for (line in state.history) {
        content.append(line)
        content.append("\n")
    }
    
    result := fs.write_file(filename, content.build())
    if (result.is_ok()) {
        print_colored(GREEN, "Session saved to " + filename + "\n")
    } else {
        print_colored(RED, "Error saving session: " + result.error() + "\n")
    }
}

// Load and execute file
load_file = (state: &mut ReplState, filename: string) void {
    content := fs.read_file(filename)
    if (content.is_error()) {
        print_colored(RED, "Error loading file: " + content.error() + "\n")
        return
    }
    
    lines := string.split(content.unwrap(), "\n")
    for (line in lines) {
        // Skip empty lines and comments
        trimmed := string.trim(line)
        if (trimmed.len == 0 || string.starts_with(trimmed, "//")) {
            continue
        }
        
        io.println(get_prompt(state) + line)
        evaluate(state, line)
    }
}

// Main REPL loop
repl_loop = () void {
    state := new_repl_state()
    print_banner()
    
    while (true) {
        // Print prompt
        io.print(get_prompt(&state))
        
        // Read input
        input := io.read_line()
        if (input.is_error()) {
            // Ctrl+D pressed
            print_colored(YELLOW, "\nGoodbye!\n")
            break
        }
        
        line := input.unwrap()
        
        // Handle empty input
        if (string.trim(line).len == 0) {
            if (state.in_multiline) {
                // Execute multi-line buffer
                state.in_multiline = false
                evaluate(&mut state, state.multiline_buffer)
                state.multiline_buffer = ""
                state.line_number += 1
            }
            continue
        }
        
        // Check for continuation
        if (is_continuation(line)) {
            state.in_multiline = true
            state.multiline_buffer += remove_continuation(line) + "\n"
            continue
        }
        
        // Build complete input
        complete_input := if (state.in_multiline) {
            state.multiline_buffer + line
        } else {
            line
        }
        
        // Reset multi-line state
        state.in_multiline = false
        state.multiline_buffer = ""
        
        // Check for special commands
        if (!process_command(&mut state, complete_input)) {
            // Evaluate as Zen code
            evaluate(&mut state, complete_input)
        }
        
        state.line_number += 1
    }
}

// Entry point
main = () i32 {
    // Set up signal handlers for graceful exit
    setup_signal_handlers()
    
    // Run the REPL
    repl_loop()
    
    return 0
}