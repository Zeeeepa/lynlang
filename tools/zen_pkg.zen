// Zen Package Manager (zen-pkg)
// A package manager for Zen written in Zen

// Imports
{ core } = @std.core
{ io } = @std.io
{ fs } = @std.fs
{ net } = @std.network
{ http } = @std.http
{ json } = @std.json
{ process } = @std.process
{ string } = @std.string
{ crypto } = @std.crypto

// Package registry URL
REGISTRY_URL := "https://registry.zenlang.org"
CACHE_DIR := "~/.zen/cache"
PACKAGES_DIR := "~/.zen/packages"

// Package manifest
Package: {
    name: string,
    version: string,
    description: string,
    author: string,
    license: string,
    repository: string,
    keywords: []string,
    dependencies: HashMap<string, VersionReq>,
    dev_dependencies: HashMap<string, VersionReq>,
    files: []string,
    entry_point: string,
}

// Version requirement
VersionReq: 
    Exact -> version: string,
    Range -> min: string, max: string,
    Latest,
    Git -> url: string, ref: string,
    Path -> path: string,

// Package lock entry
LockEntry: {
    name: string,
    version: string,
    checksum: string,
    dependencies: []string,
    source: PackageSource,
}

// Where package came from
PackageSource: 
    Registry,
    Git -> url: string, commit: string,
    Local -> path: string,

// Package manager commands
Command: 
    Init,
    Install,
    Update,
    Remove,
    Search,
    Info,
    Publish,
    List,
    Clean,
    Doctor,

// Initialize a new package
init_package = (name: string, path: string) Result<void, string>   {
    io.print("Initializing new Zen package: $(name)\n");
    
    // Check if directory exists
    fs.exists(path) ? | true => {
        fs.is_empty(path) ? | false =>
            return .Err -> "Directory is not empty"
    } | false => {
        fs.create_dir_all(path) ?
            | .Err -> err => return .Err -> "Failed to create directory: $(err)"
    }
    
    // Create default package manifest
    manifest := Package {
        name: name,
        version: "0.1.0",
        description: "A new Zen package",
        author: get_git_user(),
        license: "MIT",
        repository: "",
        keywords: [],
        dependencies: HashMap.new(),
        dev_dependencies: HashMap.new(),
        files: ["src/**/*.zen"],
        entry_point: "src/main.zen",
    }
    
    // Write zen.toml
    manifest_path := "$(path)/zen.toml";
    write_manifest(manifest_path, manifest) ?
        | .Err -> err => return .Err -> err
    
    // Create project structure
    fs.create_dir("$(path)/src") ?
        | .Err -> err => return .Err -> "Failed to create src directory: $(err)"
    
    fs.create_dir("$(path)/tests") ?
        | .Err -> err => return .Err -> "Failed to create tests directory: $(err)"
    
    // Create main.zen
    main_content := "// $(name) - Main entry point\n\n";
    main_content += "{ io } = @std.io\n\n";
    main_content += "main = () i32 {\n";
    main_content += "    io.print(\"Hello from $(name)!\\n\");\n";
    main_content += "    return 0\n";
    main_content += "}\n";
    
    fs.write_file("$(path)/src/main.zen", main_content) ?
        | .Err -> err => return .Err -> "Failed to create main.zen: $(err)"
    
    // Create .gitignore
    gitignore := "build/\n";
    gitignore += "*.o\n";
    gitignore += "*.so\n";
    gitignore += "*.a\n";
    gitignore += "zen.lock\n";
    gitignore += "node_modules/\n";
    
    fs.write_file("$(path)/.gitignore", gitignore) ?
        | .Err -> err => return .Err -> "Failed to create .gitignore: $(err)"
    
    io.print("Package initialized successfully!\n");
    io.print("  cd $(path)\n");
    io.print("  zen-pkg install\n");
    io.print("  zen-build run\n");
    
    return .Ok
}

// Install dependencies
install_packages = (manifest_path: string) Result<void, string>   {
    io.print("Installing packages...\n");
    
    // Load manifest
    manifest := load_manifest(manifest_path) ?
        | .Ok -> m => m
        | .Err -> err => return .Err -> err
    
    // Resolve dependencies
    resolved := resolve_dependencies(manifest.dependencies) ?
        | .Ok -> deps => deps
        | .Err -> err => return .Err -> "Failed to resolve dependencies: $(err)"
    
    // Download and install each package
    loop entry in resolved {
        install_package(entry) ?
            | .Err -> err => return .Err -> err
    }
    
    // Write lock file
    write_lock_file("zen.lock", resolved) ?
        | .Err -> err => return .Err -> "Failed to write lock file: $(err)"
    
    io.print("Installed $(resolved.len) packages\n");
    return .Ok
}

// Resolve dependency tree
resolve_dependencies = (deps: HashMap<string, VersionReq>) Result<[]LockEntry, string>   {
    resolved := [];
    queue := [];
    seen := HashMap.new<string, string>();
    
    // Add initial dependencies to queue
    loop (name, req) in deps {
        queue.push((name, req))
    }
    
    // Process queue
    loop queue.len > 0 {
        (name, req) := queue.pop();
        
        // Check if already resolved
        seen.contains(name) ? | true => continue
        
        // Fetch package info
        info := fetch_package_info(name, req) ?
            | .Ok -> pkg => pkg
            | .Err -> err => return .Err -> err
        
        // Mark as seen
        seen.set(name, info.version);
        
        // Add to resolved list
        resolved.push(LockEntry {
            name: info.name,
            version: info.version,
            checksum: info.checksum,
            dependencies: info.dependencies.keys(),
            source: .Registry,
        });
        
        // Add dependencies to queue
        loop (dep_name, dep_req) in info.dependencies {
            queue.push((dep_name, dep_req))
        }
    }
    
    return .Ok -> resolved
}

// Fetch package information from registry
fetch_package_info = (name: string, req: VersionReq) Result<PackageInfo, string>   {
    // Determine version to fetch
    version := req ?
        | .Exact -> v => v
        | .Latest => "latest"
        | .Range -> min, max => resolve_version_range(name, min, max)?
        | _ => return .Err -> "Unsupported version requirement"
    
    // Fetch from registry
    url := "$(REGISTRY_URL)/packages/$(name)/$(version)";
    
    response := http.get(url) ?
        | .Ok -> resp => resp
        | .Err -> err => return .Err -> "Failed to fetch package: $(err)"
    
    response.status != 200 ? | true =>
        return .Err -> "Package not found: $(name)@$(version)"
    
    // Parse response
    info := json.parse<PackageInfo>(response.body) ?
        | .Ok -> data => data
        | .Err -> err => return .Err -> "Failed to parse package info: $(err)"
    
    return .Ok -> info
}

// Install a single package
install_package = (entry: LockEntry) Result<void, string>   {
    io.print("  Installing $(entry.name)@$(entry.version)...\n");
    
    package_dir := "$(PACKAGES_DIR)/$(entry.name)/$(entry.version)";
    
    // Check if already installed
    fs.exists(package_dir) ? | true => {
        // Verify checksum
        installed_checksum := calculate_package_checksum(package_dir)?;
        installed_checksum == entry.checksum ? | true => {
            io.print("    Already installed\n");
            return .Ok
        }
    }
    
    // Download package
    archive_path := download_package(entry.name, entry.version) ?
        | .Ok -> path => path
        | .Err -> err => return .Err -> err
    
    // Verify checksum
    checksum := crypto.sha256_file(archive_path) ?
        | .Ok -> hash => hash
        | .Err -> err => return .Err -> "Failed to calculate checksum: $(err)"
    
    checksum != entry.checksum ? | true =>
        return .Err -> "Checksum mismatch for $(entry.name)"
    
    // Extract package
    fs.create_dir_all(package_dir) ?
        | .Err -> err => return .Err -> "Failed to create package dir: $(err)"
    
    extract_archive(archive_path, package_dir) ?
        | .Err -> err => return .Err -> "Failed to extract package: $(err)"
    
    // Clean up archive
    fs.remove(archive_path)?;
    
    io.print("    Installed\n");
    return .Ok
}

// Download package archive
download_package = (name: string, version: string) Result<string, string>   {
    url := "$(REGISTRY_URL)/packages/$(name)/$(version)/download";
    cache_path := "$(CACHE_DIR)/$(name)-$(version).tar.gz";
    
    // Ensure cache directory exists
    fs.create_dir_all(CACHE_DIR) ?
        | .Err -> err => return .Err -> "Failed to create cache dir: $(err)"
    
    // Download file
    http.download(url, cache_path) ?
        | .Err -> err => return .Err -> "Failed to download: $(err)"
    
    return .Ok -> cache_path
}

// Search for packages
search_packages = (query: string) Result<void, string>   {
    io.print("Searching for packages matching '$(query)'...\n\n");
    
    url := "$(REGISTRY_URL)/search?q=$(url_encode(query))";
    
    response := http.get(url) ?
        | .Ok -> resp => resp
        | .Err -> err => return .Err -> "Search failed: $(err)"
    
    results := json.parse<[]SearchResult>(response.body) ?
        | .Ok -> data => data
        | .Err -> err => return .Err -> "Failed to parse results: $(err)"
    
    results.is_empty() ? | true => {
        io.print("No packages found\n");
        return .Ok
    }
    
    // Display results
    loop result in results {
        io.print("$(result.name) ($(result.version)) - $(result.description)\n");
        io.print("  Author: $(result.author)\n");
        io.print("  Downloads: $(result.downloads)\n\n")
    }
    
    io.print("Found $(results.len) packages\n");
    return .Ok
}

// Publish package to registry
publish_package = (manifest_path: string) Result<void, string>   {
    io.print("Publishing package...\n");
    
    // Load manifest
    manifest := load_manifest(manifest_path) ?
        | .Ok -> m => m
        | .Err -> err => return .Err -> err
    
    // Validate package
    validate_package(manifest) ?
        | .Err -> err => return .Err -> "Validation failed: $(err)"
    
    // Create archive
    archive_path := create_package_archive(manifest) ?
        | .Ok -> path => path
        | .Err -> err => return .Err -> err
    
    // Get authentication token
    token := get_auth_token() ?
        | .Ok -> t => t
        | .Err -> err => return .Err -> "Not authenticated. Run 'zen-pkg login'"
    
    // Upload to registry
    url := "$(REGISTRY_URL)/packages/$(manifest.name)/$(manifest.version)";
    
    response := http.put(url, archive_path, [
        ("Authorization", "Bearer $(token)"),
        ("Content-Type", "application/gzip"),
    ]) ?
        | .Ok -> resp => resp
        | .Err -> err => return .Err -> "Upload failed: $(err)"
    
    response.status != 201 ? | true =>
        return .Err -> "Publish failed: $(response.body)"
    
    // Clean up
    fs.remove(archive_path)?;
    
    io.print("Successfully published $(manifest.name)@$(manifest.version)\n");
    return .Ok
}

// List installed packages
list_packages = (global: bool) Result<void, string>   {
    io.print("Installed packages:\n\n");
    
    dir := global ? | true => PACKAGES_DIR | false => "./node_modules";
    
    fs.exists(dir) ? | false => {
        io.print("No packages installed\n");
        return .Ok
    }
    
    packages := fs.list_dirs(dir) ?
        | .Ok -> dirs => dirs
        | .Err -> err => return .Err -> "Failed to list packages: $(err)"
    
    loop package in packages {
        versions := fs.list_dirs("$(dir)/$(package)") ?
            | .Ok -> vers => vers
            | .Err => continue
        
        loop version in versions {
            manifest_path := "$(dir)/$(package)/$(version)/zen.toml";
            manifest := load_manifest(manifest_path) ?
                | .Ok -> m => m
                | .Err => continue
            
            io.print("  $(manifest.name)@$(manifest.version) - $(manifest.description)\n")
        }
    }
    
    return .Ok
}

// Clean package cache
clean_cache = () Result<void, string>   {
    io.print("Cleaning package cache...\n");
    
    fs.exists(CACHE_DIR) ? | false => {
        io.print("Cache is already clean\n");
        return .Ok
    }
    
    size := calculate_dir_size(CACHE_DIR);
    
    fs.remove_dir_all(CACHE_DIR) ?
        | .Err -> err => return .Err -> "Failed to clean cache: $(err)"
    
    io.print("Freed $(format_size(size))\n");
    return .Ok
}

// Check system configuration
doctor = () Result<void, string>   {
    io.print("Checking Zen package manager configuration...\n\n");
    
    errors := 0;
    warnings := 0;
    
    // Check Zen compiler
    io.print("Checking Zen compiler... ");
    process.run(["zenc", "--version"]) ?
        | .Ok -> output => {
            io.print("OK ($(string.trim(output.stdout)))\n")
        }
        | .Err => {
            io.print("ERROR: Zen compiler not found\n");
            errors += 1
        }
    
    // Check network connectivity
    io.print("Checking registry connectivity... ");
    http.get("$(REGISTRY_URL)/health") ?
        | .Ok -> resp => {
            resp.status == 200 ? | true => {
                io.print("OK\n")
            } | false => {
                io.print("WARNING: Registry returned status $(resp.status)\n");
                warnings += 1
            }
        }
        | .Err => {
            io.print("ERROR: Cannot reach registry\n");
            errors += 1
        }
    
    // Check cache directory
    io.print("Checking cache directory... ");
    cache_dir := expand_path(CACHE_DIR);
    fs.is_writable(fs.dirname(cache_dir)) ?
        | true => io.print("OK\n")
        | false => {
            io.print("WARNING: Cache directory not writable\n");
            warnings += 1
        }
    
    // Check packages directory
    io.print("Checking packages directory... ");
    packages_dir := expand_path(PACKAGES_DIR);
    fs.is_writable(fs.dirname(packages_dir)) ?
        | true => io.print("OK\n")
        | false => {
            io.print("WARNING: Packages directory not writable\n");
            warnings += 1
        }
    
    io.print("\n");
    
    errors > 0 ? | true => {
        io.print("Found $(errors) errors and $(warnings) warnings\n");
        return .Err -> "System check failed"
    }
    
    warnings > 0 ? | true => {
        io.print("Found $(warnings) warnings\n");
        io.print("Package manager should work but may have issues\n")
    } | false => {
        io.print("All checks passed! Package manager is ready\n")
    }
    
    return .Ok
}

// Main entry point
main = (args: []string) i32   {
    args.len < 2 ? | true => {
        print_usage();
        return 1
    }
    
    command := args[1];
    
    result := command ?
        | "init" => {
            name := args.len > 2 ? | true => args[2] | false => fs.basename(fs.cwd());
            path := args.len > 3 ? | true => args[3] | false => ".";
            init_package(name, path)
        }
        | "install" | "i" => {
            manifest := args.len > 2 ? | true => args[2] | false => "zen.toml";
            install_packages(manifest)
        }
        | "search" => {
            args.len > 2 ? | true => search_packages(args[2])
                         | false => .Err -> "Search query required"
        }
        | "publish" => {
            manifest := args.len > 2 ? | true => args[2] | false => "zen.toml";
            publish_package(manifest)
        }
        | "list" | "ls" => {
            global := args.len > 2 && args[2] == "--global";
            list_packages(global)
        }
        | "clean" => clean_cache()
        | "doctor" => doctor()
        | "--help" | "-h" => {
            print_help();
            return 0
        }
        | "--version" | "-v" => {
            io.print("zen-pkg version 1.0.0\n");
            return 0
        }
        | _ => .Err -> "Unknown command: $(command)"
    
    result ?
        | .Ok => return 0
        | .Err -> err => {
            io.error("Error: $(err)\n");
            return 1
        }
}

// Print usage
print_usage = () void   {
    io.print("Usage: zen-pkg <command> [options]\n");
    io.print("Run 'zen-pkg --help' for more information\n")
}

// Print help
print_help = () void   {
    io.print("Zen Package Manager\n\n");
    io.print("Usage: zen-pkg <command> [options]\n\n");
    io.print("Commands:\n");
    io.print("  init [name] [path]     Initialize a new package\n");
    io.print("  install, i             Install dependencies\n");
    io.print("  search <query>         Search for packages\n");
    io.print("  publish                Publish package to registry\n");
    io.print("  list, ls [--global]    List installed packages\n");
    io.print("  clean                  Clean package cache\n");
    io.print("  doctor                 Check system configuration\n");
    io.print("  --help, -h             Show help\n");
    io.print("  --version, -v          Show version\n")
}