// Zen Language Server Protocol Implementation
// Provides IDE support for Zen language files

core = @std
io = @std
json = @std
net = @std
fs = @std
lexer = @std
parser = @std

// LSP Message Types
LSPMessage: {
    jsonrpc: string,
    id: Option<i32>,
    method: Option<string>,
    params: Option<json.Value>,
    result: Option<json.Value>,
    error: Option<LSPError>,
}

LSPError: {
    code: i32,
    message: string,
    data: Option<json.Value>,
}

// LSP Server State
LSPServer: {
    documents: HashMap<string, Document>,
    workspace_root: Option<string>,
    capabilities: ServerCapabilities,
}

Document: {
    uri: string,
    content: string,
    version: i32,
    diagnostics: Vec<Diagnostic>,
}

Diagnostic: {
    range: Range,
    severity: i32,
    code: Option<string>,
    source: string,
    message: string,
}

Range: {
    start: Position,
    end: Position,
}

Position: {
    line: i32,
    character: i32,
}

ServerCapabilities: {
    text_document_sync: i32,
    hover_provider: bool,
    completion_provider: bool,
    signature_help_provider: bool,
    definition_provider: bool,
    references_provider: bool,
    document_highlight_provider: bool,
    document_symbol_provider: bool,
    code_action_provider: bool,
    code_lens_provider: bool,
    document_formatting_provider: bool,
    document_range_formatting_provider: bool,
    rename_provider: bool,
}

// Create new LSP server
lsp_server_new = () LSPServer   {
    return LSPServer {
        documents: HashMap:new(),
        workspace_root: None,
        capabilities: ServerCapabilities {
            text_document_sync: 1, // Full sync
            hover_provider: true,
            completion_provider: true,
            signature_help_provider: true,
            definition_provider: true,
            references_provider: true,
            document_highlight_provider: true,
            document_symbol_provider: true,
            code_action_provider: false,
            code_lens_provider: false,
            document_formatting_provider: true,
            document_range_formatting_provider: false,
            rename_provider: true,
        },
    }
}

// Handle LSP request
handle_request = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    msg.method ? 
        | Some(method) => {
            method == "initialize" ?  return handle_initialize(server, msg)
            method == "initialized" ? return None  // No response needed
            method == "textDocument/didOpen" ? return handle_did_open(server, msg)
            method == "textDocument/didChange" ? return handle_did_change(server, msg)
            method == "textDocument/didSave" ? return handle_did_save(server, msg)
            method == "textDocument/didClose" ? return handle_did_close(server, msg)
            method == "textDocument/hover" ? return handle_hover(server, msg)
            method == "textDocument/completion" ? return handle_completion(server, msg)
            method == "textDocument/definition" ? return handle_definition(server, msg)
            method == "textDocument/references" ? return handle_references(server, msg)
            method == "textDocument/formatting" ? return handle_formatting(server, msg)
            method == "shutdown" ? return handle_shutdown(server, msg)
            // Unknown method
            return create_error_response(msg.id, -32601, "Method not found")
        }
        | None return None
}

// Initialize handler
handle_initialize = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    // Extract workspace root from params
    msg.params ?
        | Some(params) => {
            root_uri := json.get_string(params, "rootUri")
            root_uri ?
                | Some(uri) => { server.workspace_root = Some(uri) }
                | None => {}
        }
        | None => {}
    
    // Create initialize response
    result := json.object([
        ("capabilities", json.object([
            ("textDocumentSync", json.number(1)),
            ("hoverProvider", json.bool(true)),
            ("completionProvider", json.object([
                ("resolveProvider", json.bool(false)),
                ("triggerCharacters", json.array([json.string("."), json.string(":")]))
            ])),
            ("signatureHelpProvider", json.object([
                ("triggerCharacters", json.array([json.string("("), json.string(",")]))
            ])),
            ("definitionProvider", json.bool(true)),
            ("referencesProvider", json.bool(true)),
            ("documentHighlightProvider", json.bool(true)),
            ("documentSymbolProvider", json.bool(true)),
            ("documentFormattingProvider", json.bool(true)),
            ("renameProvider", json.bool(true))
        ])),
        ("serverInfo", json.object([
            ("name", json.string("zen-lsp")),
            ("version", json.string("0.1.0"))
        ]))
    ])
    
    return create_response(msg.id, result)
}

// Document open handler
handle_did_open = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    msg.params ?
        | Some(params) => {
            text_document := json.get_object(params, "textDocument")
            text_document ?
                | Some(doc) => {
                    uri := json.get_string(doc, "uri")
                    text := json.get_string(doc, "text")
                    version := json.get_number(doc, "version")
                    
                    uri && text && version ? {
                            document := Document {
                                uri: uri,
                                content: text,
                                version: version as i32,
                                diagnostics: Vec:new(),
                            }
                            
                            // Analyze document
                            analyze_document(server, &document)
                            
                            // Store document
                            server.documents.insert(uri, document)
                        }
                }
                | None => {}
        }
        | None => {}
    
    return Option.None
}

// Document change handler
handle_did_change = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    // Similar to did_open but updates existing document
    return Option.None
}

// Document save handler
handle_did_save = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    // Re-analyze document on save
    return Option.None
}

// Document close handler
handle_did_close = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    msg.params ?
        | Some(params) => {
            text_document := json.get_object(params, "textDocument")
            text_document ?
                | Some(doc) => {
                    uri := json.get_string(doc, "uri")
                    uri ?
                        | Some(u) => { server.documents.remove(u) }
                        | None => {}
                }
                | None => {}
        }
        | None => {}
    
    return None
}

// Hover handler
handle_hover = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    // TODO: Implement hover information
    return create_response(msg.id, json.Null)
}

// Completion handler
handle_completion = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    // TODO: Implement code completion
    completions := json.array([
        create_completion_item("loop", "Keyword", "Loop construct"),
        create_completion_item("break", "Keyword", "Break from loop"),
        create_completion_item("continue", "Keyword", "Continue to next iteration"),
        create_completion_item("return", "Keyword", "Return from function"),
        create_completion_item("comptime", "Keyword", "Compile-time evaluation"),
        create_completion_item("extern", "Keyword", "External declaration"),
    ])
    
    return create_response(msg.id, completions)
}

// Definition handler
handle_definition = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    // TODO: Implement go-to-definition
    return create_response(msg.id, json.Null)
}

// References handler
handle_references = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    // TODO: Implement find references
    return create_response(msg.id, json.Array([]))
}

// Formatting handler
handle_formatting = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    // TODO: Implement code formatting
    return create_response(msg.id, json.Array([]))
}

// Shutdown handler
handle_shutdown = (server: Ptr<LSPServer>, msg: LSPMessage) Option<LSPMessage>   {
    return create_response(msg.id, json.Null)
}

// Analyze document for diagnostics
analyze_document = (server: Ptr<LSPServer>, doc: Ptr<Document>) void   {
    // Create lexer
    lex := lexer.lexer_new(doc.content)
    
    diagnostics := Vec.new()
    
    // Tokenize and check for errors
    loop {
        tok := lexer.lexer_next_token(&lex)
        tok.token_type == lexer.TokenType.Eof ?
            { break }
        
        // Check for lexer errors (simplified)
        // In real implementation, would check for invalid tokens
    }
    
    doc.diagnostics = diagnostics
    
    // Send diagnostics notification
    send_diagnostics(doc.uri, diagnostics)
}

// Send diagnostics notification
send_diagnostics = (uri: string, diagnostics: Vec<Diagnostic>) void   {
    notification := json.object([
        ("jsonrpc", json.string("2.0")),
        ("method", json.string("textDocument/publishDiagnostics")),
        ("params", json.object([
            ("uri", json.string(uri)),
            ("diagnostics", diagnostics_to_json(diagnostics))
        ]))
    ])
    
    send_message(notification)
}

// Convert diagnostics to JSON
diagnostics_to_json = (diagnostics: Vec<Diagnostic>) json.Value {
    items := Vec.new()
    
    i := 0
    loop i < diagnostics.len() {
        diag := diagnostics[i]
        item := json.object([
            ("range", json.object([
                ("start", json.object([
                    ("line", json.number(diag.range.start.line as f64)),
                    ("character", json.number(diag.range.start.character as f64))
                ])),
                ("end", json.object([
                    ("line", json.number(diag.range.end.line as f64)),
                    ("character", json.number(diag.range.end.character as f64))
                ]))
            ])),
            ("severity", json.number(diag.severity as f64)),
            ("source", json.string(diag.source)),
            ("message", json.string(diag.message))
        ])
        items.push(item)
        i = i + 1
    }
    
    return json.array(items)
}

// Create completion item
create_completion_item = (label: string, kind: string, detail: string) json.Value {
    kind_num := kind == "Keyword" ? | true {14} | false {1}
    
    return json.object([
        ("label", json.string(label)),
        ("kind", json.number(kind_num as f64)),
        ("detail", json.string(detail))
    ])
}

// Create response message
create_response = (id: Option<i32>, result: json.Value) Option<LSPMessage>   {
    id ?
        | Some(i) => {
            return Some(LSPMessage {
                jsonrpc: "2.0",
                id: Some(i),
                method: None,
                params: None,
                result: Some(result),
                error: None,
            })
        }
        | None => return None
}

// Create error response
create_error_response = (id: Option<i32>, code: i32, message: string) Option<LSPMessage>   {
    id ?
        | Some(i) => {
            return Some(LSPMessage {
                jsonrpc: "2.0",
                id: Some(i),
                method: None,
                params: None,
                result: None,
                error: Some(LSPError {
                    code: code,
                    message: message,
                    data: None,
                }),
            })
        }
        | None => return None
}

// Read message from stdin
read_message = () Option<LSPMessage>   {
    // Read Content-Length header
    header := io.read_line()
    header.starts_with("Content-Length: ") ? { return None }
    
    length_str := header[16..]
    length := length_str.parse_int()
    
    // Read empty line
    io.read_line()
    
    // Read JSON content
    content := io.read_bytes(length)
    
    // Parse JSON
    msg := json.parse(content)
    msg ?
        | Ok(m) => return parse_lsp_message(m)
        | Err(_) => return None
}

// Parse JSON into LSP message
parse_lsp_message = (value: json.Value) Option<LSPMessage>   {
    // TODO: Implement JSON to LSPMessage conversion
    return None
}

// Send message to stdout
send_message = (msg: json.Value) void   {
    content := json.stringify(msg)
    length := content.len()
    
    io.print("Content-Length: $(length)\r\n\r\n")
    io.print(content)
    io.flush()
}

// Main LSP server loop
main = () void   {
    server := lsp_server_new()
    
    io.print_err("Zen LSP Server starting...\n")
    
    loop {
        msg := read_message()
        msg ?
            | Some(m) => {
                response := handle_request(&server, m)
                response ?
                    | Some(r) => {
                        // Convert response to JSON and send
                        json_msg := lsp_message_to_json(r)
                        send_message(json_msg)
                    }
                    | None => {}
            }
            | None => {
                // Error reading message
                io.print_err("Failed to read message\n")
                break
            }
    }
    
    io.print_err("Zen LSP Server shutting down\n")
}

// Convert LSP message to JSON
lsp_message_to_json = (msg: LSPMessage) json.Value {
    fields := Vec:new()
    fields.push(("jsonrpc", json.string(msg.jsonrpc)))
    
    msg.id ?
        | Some(i) => { fields.push(("id", json.number(i as f64))) }
        | None => {}
    
    msg.method ?
        | Some(m) => { fields.push(("method", json.string(m))) }
        | None => {}
    
    msg.params ?
        | Some(p) => { fields.push(("params", p)) }
        | None => {}
    
    msg.result ?
        | Some(r) => { fields.push(("result", r)) }
        | None => {}
    
    msg.error ?
        | Some(e) => {
            error_obj := json.object([
                ("code", json.number(e.code as f64)),
                ("message", json.string(e.message))
            ])
            fields.push(("error", error_obj))
        }
        | None => {}
    
    return json.object(fields)
}