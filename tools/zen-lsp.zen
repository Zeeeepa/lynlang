// Zen Language Server Protocol Implementation
// Provides IDE support for Zen language files

core := @std.core
build := @std.build
io := build.import("io")
json := build.import("json")
net := build.import("net")
fs := build.import("fs")
lexer := build.import("lexer")
parser := build.import("parser")

// LSP Message Types
LSPMessage = {
    jsonrpc: string,
    id: Option<i32>,
    method: Option<string>,
    params: Option<json.Value>,
    result: Option<json.Value>,
    error: Option<LSPError>,
}

LSPError = {
    code: i32,
    message: string,
    data: Option<json.Value>,
}

// LSP Server State
LSPServer = {
    documents: HashMap<string, Document>,
    workspace_root: Option<string>,
    capabilities: ServerCapabilities,
}

Document = {
    uri: string,
    content: string,
    version: i32,
    diagnostics: Vec<Diagnostic>,
}

Diagnostic = {
    range: Range,
    severity: i32,
    code: Option<string>,
    source: string,
    message: string,
}

Range = {
    start: Position,
    end: Position,
}

Position = {
    line: i32,
    character: i32,
}

ServerCapabilities = {
    text_document_sync: i32,
    hover_provider: bool,
    completion_provider: bool,
    signature_help_provider: bool,
    definition_provider: bool,
    references_provider: bool,
    document_highlight_provider: bool,
    document_symbol_provider: bool,
    code_action_provider: bool,
    code_lens_provider: bool,
    document_formatting_provider: bool,
    document_range_formatting_provider: bool,
    rename_provider: bool,
}

// Create new LSP server
lsp_server_new = () LSPServer {
    return LSPServer {
        documents: HashMap::new(),
        workspace_root: Option::None,
        capabilities: ServerCapabilities {
            text_document_sync: 1, // Full sync
            hover_provider: true,
            completion_provider: true,
            signature_help_provider: true,
            definition_provider: true,
            references_provider: true,
            document_highlight_provider: true,
            document_symbol_provider: true,
            code_action_provider: false,
            code_lens_provider: false,
            document_formatting_provider: true,
            document_range_formatting_provider: false,
            rename_provider: true,
        },
    }
}

// Handle LSP request
handle_request = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    msg.method ? 
        | .Some -> method => {
            method == "initialize" ? 
                | true => return handle_initialize(server, msg)
                | false => {}
            
            method == "initialized" ?
                | true => return Option::None  // No response needed
                | false => {}
            
            method == "textDocument/didOpen" ?
                | true => return handle_did_open(server, msg)
                | false => {}
            
            method == "textDocument/didChange" ?
                | true => return handle_did_change(server, msg)
                | false => {}
            
            method == "textDocument/didSave" ?
                | true => return handle_did_save(server, msg)
                | false => {}
            
            method == "textDocument/didClose" ?
                | true => return handle_did_close(server, msg)
                | false => {}
            
            method == "textDocument/hover" ?
                | true => return handle_hover(server, msg)
                | false => {}
            
            method == "textDocument/completion" ?
                | true => return handle_completion(server, msg)
                | false => {}
            
            method == "textDocument/definition" ?
                | true => return handle_definition(server, msg)
                | false => {}
            
            method == "textDocument/references" ?
                | true => return handle_references(server, msg)
                | false => {}
            
            method == "textDocument/formatting" ?
                | true => return handle_formatting(server, msg)
                | false => {}
            
            method == "shutdown" ?
                | true => return handle_shutdown(server, msg)
                | false => {}
            
            // Unknown method
            return create_error_response(msg.id, -32601, "Method not found")
        }
        | .None => return Option::None
}

// Initialize handler
handle_initialize = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    // Extract workspace root from params
    msg.params ?
        | .Some -> params => {
            root_uri := json.get_string(params, "rootUri")
            root_uri ?
                | .Some -> uri => { server.workspace_root = Option::Some(uri) }
                | .None => {}
        }
        | .None => {}
    
    // Create initialize response
    result := json.object([
        ("capabilities", json.object([
            ("textDocumentSync", json.number(1)),
            ("hoverProvider", json.bool(true)),
            ("completionProvider", json.object([
                ("resolveProvider", json.bool(false)),
                ("triggerCharacters", json.array([json.string("."), json.string(":")]))
            ])),
            ("signatureHelpProvider", json.object([
                ("triggerCharacters", json.array([json.string("("), json.string(",")]))
            ])),
            ("definitionProvider", json.bool(true)),
            ("referencesProvider", json.bool(true)),
            ("documentHighlightProvider", json.bool(true)),
            ("documentSymbolProvider", json.bool(true)),
            ("documentFormattingProvider", json.bool(true)),
            ("renameProvider", json.bool(true))
        ])),
        ("serverInfo", json.object([
            ("name", json.string("zen-lsp")),
            ("version", json.string("0.1.0"))
        ]))
    ])
    
    return create_response(msg.id, result)
}

// Document open handler
handle_did_open = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    msg.params ?
        | .Some -> params => {
            text_document := json.get_object(params, "textDocument")
            text_document ?
                | .Some -> doc => {
                    uri := json.get_string(doc, "uri")
                    text := json.get_string(doc, "text")
                    version := json.get_number(doc, "version")
                    
                    uri && text && version ?
                        | true => {
                            document := Document {
                                uri: uri.unwrap(),
                                content: text.unwrap(),
                                version: version.unwrap() as i32,
                                diagnostics: Vec::new(),
                            }
                            
                            // Analyze document
                            analyze_document(server, &document)
                            
                            // Store document
                            server.documents.insert(uri.unwrap(), document)
                        }
                        | false => {}
                }
                | .None => {}
        }
        | .None => {}
    
    return Option::None
}

// Document change handler
handle_did_change = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    // Similar to did_open but updates existing document
    return Option::None
}

// Document save handler
handle_did_save = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    // Re-analyze document on save
    return Option::None
}

// Document close handler
handle_did_close = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    msg.params ?
        | .Some -> params => {
            text_document := json.get_object(params, "textDocument")
            text_document ?
                | .Some -> doc => {
                    uri := json.get_string(doc, "uri")
                    uri ?
                        | .Some -> u => { server.documents.remove(u) }
                        | .None => {}
                }
                | .None => {}
        }
        | .None => {}
    
    return Option::None
}

// Hover handler
handle_hover = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    // TODO: Implement hover information
    return create_response(msg.id, json.null())
}

// Completion handler
handle_completion = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    // TODO: Implement code completion
    completions := json.array([
        create_completion_item("loop", "Keyword", "Loop construct"),
        create_completion_item("break", "Keyword", "Break from loop"),
        create_completion_item("continue", "Keyword", "Continue to next iteration"),
        create_completion_item("return", "Keyword", "Return from function"),
        create_completion_item("comptime", "Keyword", "Compile-time evaluation"),
        create_completion_item("extern", "Keyword", "External declaration"),
    ])
    
    return create_response(msg.id, completions)
}

// Definition handler
handle_definition = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    // TODO: Implement go-to-definition
    return create_response(msg.id, json.null())
}

// References handler
handle_references = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    // TODO: Implement find references
    return create_response(msg.id, json.array([]))
}

// Formatting handler
handle_formatting = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    // TODO: Implement code formatting
    return create_response(msg.id, json.array([]))
}

// Shutdown handler
handle_shutdown = (server: *LSPServer, msg: LSPMessage) Option<LSPMessage> {
    return create_response(msg.id, json.null())
}

// Analyze document for diagnostics
analyze_document = (server: *LSPServer, doc: *Document) void {
    // Create lexer
    lex := lexer.lexer_new(doc.content)
    
    diagnostics := Vec::new()
    
    // Tokenize and check for errors
    loop {
        tok := lexer.lexer_next_token(&lex)
        tok.token_type == lexer.TokenType::Eof ?
            | true => { break }
            | false => {}
        
        // Check for lexer errors (simplified)
        // In real implementation, would check for invalid tokens
    }
    
    doc.diagnostics = diagnostics
    
    // Send diagnostics notification
    send_diagnostics(doc.uri, diagnostics)
}

// Send diagnostics notification
send_diagnostics = (uri: string, diagnostics: Vec<Diagnostic>) void {
    notification := json.object([
        ("jsonrpc", json.string("2.0")),
        ("method", json.string("textDocument/publishDiagnostics")),
        ("params", json.object([
            ("uri", json.string(uri)),
            ("diagnostics", diagnostics_to_json(diagnostics))
        ]))
    ])
    
    send_message(notification)
}

// Convert diagnostics to JSON
diagnostics_to_json = (diagnostics: Vec<Diagnostic>) json.Value {
    items := Vec::new()
    
    i ::= 0
    loop i < diagnostics.len() {
        diag := diagnostics[i]
        item := json.object([
            ("range", json.object([
                ("start", json.object([
                    ("line", json.number(diag.range.start.line as f64)),
                    ("character", json.number(diag.range.start.character as f64))
                ])),
                ("end", json.object([
                    ("line", json.number(diag.range.end.line as f64)),
                    ("character", json.number(diag.range.end.character as f64))
                ]))
            ])),
            ("severity", json.number(diag.severity as f64)),
            ("source", json.string(diag.source)),
            ("message", json.string(diag.message))
        ])
        items.push(item)
        i = i + 1
    }
    
    return json.array(items)
}

// Create completion item
create_completion_item = (label: string, kind: string, detail: string) json.Value {
    kind_num := kind == "Keyword" ? | true => 14 | false => 1
    
    return json.object([
        ("label", json.string(label)),
        ("kind", json.number(kind_num as f64)),
        ("detail", json.string(detail))
    ])
}

// Create response message
create_response = (id: Option<i32>, result: json.Value) Option<LSPMessage> {
    id ?
        | .Some -> i => {
            return Option::Some(LSPMessage {
                jsonrpc: "2.0",
                id: Option::Some(i),
                method: Option::None,
                params: Option::None,
                result: Option::Some(result),
                error: Option::None,
            })
        }
        | .None => return Option::None
}

// Create error response
create_error_response = (id: Option<i32>, code: i32, message: string) Option<LSPMessage> {
    id ?
        | .Some -> i => {
            return Option::Some(LSPMessage {
                jsonrpc: "2.0",
                id: Option::Some(i),
                method: Option::None,
                params: Option::None,
                result: Option::None,
                error: Option::Some(LSPError {
                    code: code,
                    message: message,
                    data: Option::None,
                }),
            })
        }
        | .None => return Option::None
}

// Read message from stdin
read_message = () Option<LSPMessage> {
    // Read Content-Length header
    header := io.read_line()
    header.starts_with("Content-Length: ") ?
        | false => return Option::None
        | true => {}
    
    length_str := header[16..]
    length := length_str.parse_int()
    
    // Read empty line
    io.read_line()
    
    // Read JSON content
    content := io.read_bytes(length)
    
    // Parse JSON
    msg := json.parse(content)
    msg ?
        | .Ok -> m => return parse_lsp_message(m)
        | .Err -> _ => return Option::None
}

// Parse JSON into LSP message
parse_lsp_message = (value: json.Value) Option<LSPMessage> {
    // TODO: Implement JSON to LSPMessage conversion
    return Option::None
}

// Send message to stdout
send_message = (msg: json.Value) void {
    content := json.stringify(msg)
    length := content.len()
    
    io.print("Content-Length: $(length)\r\n\r\n")
    io.print(content)
    io.flush()
}

// Main LSP server loop
main = () void {
    server := lsp_server_new()
    
    io.print_err("Zen LSP Server starting...\n")
    
    loop {
        msg := read_message()
        msg ?
            | .Some -> m => {
                response := handle_request(&server, m)
                response ?
                    | .Some -> r => {
                        // Convert response to JSON and send
                        json_msg := lsp_message_to_json(r)
                        send_message(json_msg)
                    }
                    | .None => {}
            }
            | .None => {
                // Error reading message
                io.print_err("Failed to read message\n")
                break
            }
    }
    
    io.print_err("Zen LSP Server shutting down\n")
}

// Convert LSP message to JSON
lsp_message_to_json = (msg: LSPMessage) json.Value {
    fields := Vec::new()
    fields.push(("jsonrpc", json.string(msg.jsonrpc)))
    
    msg.id ?
        | .Some -> i => { fields.push(("id", json.number(i as f64))) }
        | .None => {}
    
    msg.method ?
        | .Some -> m => { fields.push(("method", json.string(m))) }
        | .None => {}
    
    msg.params ?
        | .Some -> p => { fields.push(("params", p)) }
        | .None => {}
    
    msg.result ?
        | .Some -> r => { fields.push(("result", r)) }
        | .None => {}
    
    msg.error ?
        | .Some -> e => {
            error_obj := json.object([
                ("code", json.number(e.code as f64)),
                ("message", json.string(e.message))
            ])
            fields.push(("error", error_obj))
        }
        | .None => {}
    
    return json.object(fields)
}