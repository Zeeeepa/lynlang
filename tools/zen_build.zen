// Zen Build System
// A build system for Zen projects written in Zen

// Imports
{ core } = @std.core
{ io } = @std.io
{ fs } = @std.fs
{ process } = @std.process
{ string } = @std.string
{ json } = @std.json
{ hashmap } = @std.hashmap

// Build configuration
BuildConfig: {
    name: string,
    version: string,
    source_dir: string,
    output_dir: string,
    entry_point: string,
    dependencies: []Dependency,
    compiler_flags: []string,
    linker_flags: []string,
    prebuild: []string,
    postbuild: []string,
}

// Dependency specification
Dependency: {
    name: string,
    version: string,
    source: DependencySource,
}

// Where to get dependencies from
DependencySource: 
    Local { path: string },
    Git { url: string, branch: string },
    Registry { package: string },

// Build target
Target: {
    name: string,
    sources: []string,
    output: string,
    type: TargetType,
    dependencies: []string,
}

// Type of build target
TargetType: 
    Executable,
    Library,
    SharedLibrary,
    Test,

// Build result
BuildResult: 
    Success { artifacts: []string },
    Failed { error: string },
    Skipped { reason: string },

// Build system state
BuildSystem: {
    config: BuildConfig,
    targets: HashMap<string, Target>,
    cache: BuildCache,
    verbose: bool,
}

// Build cache for incremental compilation
BuildCache: {
    hashes: HashMap<string, string>,
    timestamps: HashMap<string, i64>,
    artifacts: HashMap<string, []string>,
}

// Load build configuration from zen.toml
load_config = (path: string) Result<BuildConfig, string>   {
    content := fs.read_file(path) ?
        | .Ok -> data => data
        | .Err -> err => return .Err -> "Failed to read config: $(err)"
    
    // Parse TOML (simplified for now, would use proper TOML parser)
    config := parse_build_config(content) ?
        | .Ok -> cfg => cfg
        | .Err -> err => return .Err -> "Failed to parse config: $(err)"
    
    return .Ok -> config
}

// Parse build configuration
parse_build_config = (content: string) Result<BuildConfig, string>   {
    // For now, parse a simplified JSON-like format
    // In a real implementation, this would parse TOML
    
    config := BuildConfig {
        name: "default",
        version: "0.1.0",
        source_dir: "src",
        output_dir: "build",
        entry_point: "main.zen",
        dependencies: [],
        compiler_flags: [],
        linker_flags: [],
        prebuild: [],
        postbuild: [],
    }
    
    // Simple line-based parser
    lines := string.split(content, "\n");
    
    loop line in lines {
        line = string.trim(line);
        line.is_empty() || line.starts_with("#") ? | true => continue
        
        parts := string.split(line, "=");
        parts.len != 2 ? | true => continue
        
        key := string.trim(parts[0]);
        value := string.trim(parts[1]);
        
        key ?
            | "name" => config.name = string.unquote(value)
            | "version" => config.version = string.unquote(value)
            | "source_dir" => config.source_dir = string.unquote(value)
            | "output_dir" => config.output_dir = string.unquote(value)
            | "entry_point" => config.entry_point = string.unquote(value)
    }
    
    return .Ok -> config
}

// Initialize build system
init_build_system = (config: BuildConfig, verbose: bool) BuildSystem   {
    return BuildSystem {
        config: config,
        targets: hashmap.new<string, Target>(),
        cache: BuildCache {
            hashes: hashmap.new<string, string>(),
            timestamps: hashmap.new<string, i64>(),
            artifacts: hashmap.new<string, []string>(),
        },
        verbose: verbose,
    }
}

// Discover targets in the project
discover_targets = (bs: &BuildSystem) Result<void, string>   {
    // Find all .zen files in source directory
    files := fs.walk(bs.config.source_dir, "*.zen") ?
        | .Ok -> list => list
        | .Err -> err => return .Err -> "Failed to scan sources: $(err)"
    
    // Create main executable target
    main_target := Target {
        name: "main",
        sources: files,
        output: "$(bs.config.output_dir)/$(bs.config.name)",
        type: .Executable,
        dependencies: [],
    }
    
    bs.targets.set("main", main_target);
    
    // Find test files
    test_files := files.filter(|f| f.contains("_test.zen"));
    
    test_files.is_empty() ? | false => {
        test_target := Target {
            name: "test",
            sources: test_files,
            output: "$(bs.config.output_dir)/test_runner",
            type: .Test,
            dependencies: [],
        }
        
        bs.targets.set("test", test_target)
    }
    
    return .Ok
}

// Build a specific target
build_target = (bs: &BuildSystem, target_name: string) BuildResult   {
    target := bs.targets.get(target_name) ?
        | .Some -> t => t
        | .None => return .Failed -> error: "Unknown target: $(target_name)"
    
    bs.verbose ? | true => io.print("Building target: $(target.name)\n")
    
    // Check if rebuild is needed
    needs_rebuild := check_needs_rebuild(bs, target);
    
    needs_rebuild ? | false => {
        bs.verbose ? | true => io.print("Target is up to date\n");
        return .Skipped -> reason: "Up to date"
    }
    
    // Create output directory
    fs.create_dir_all(bs.config.output_dir) ?
        | .Err -> err => return .Failed -> error: "Failed to create output dir: $(err)"
    
    // Compile each source file
    objects := [];
    
    loop source in target.sources {
        bs.verbose ? | true => io.print("  Compiling: $(source)\n")
        
        object := compile_file(bs, source) ?
            | .Ok -> obj => obj
            | .Err -> err => return .Failed -> error: err
        
        objects.push(object)
    }
    
    // Link objects into final output
    bs.verbose ? | true => io.print("  Linking: $(target.output)\n")
    
    link_result := link_objects(bs, objects, target.output) ?
        | .Ok => .Success -> artifacts: [target.output]
        | .Err -> err => .Failed -> error: err
    
    // Update cache
    update_cache(bs, target, objects);
    
    return link_result
}

// Check if target needs rebuilding
check_needs_rebuild = (bs: &BuildSystem, target: Target) bool   {
    // Check if output exists
    fs.exists(target.output) ? | false => return true
    
    // Check source file modifications
    loop source in target.sources {
        source_time := fs.get_modified_time(source) ?
            | .Ok -> time => time
            | .Err => return true
        
        cached_time := bs.cache.timestamps.get(source) ?
            | .Some -> time => time
            | .None => return true
        
        source_time > cached_time ? | true => return true
    }
    
    return false
}

// Compile a single file
compile_file = (bs: &BuildSystem, source: string) Result<string, string>   {
    object := string.replace(source, ".zen", ".o");
    object = "$(bs.config.output_dir)/$(fs.basename(object))";
    
    // Build compiler command
    cmd := ["zenc", source, "-o", object, "-c"];
    cmd.extend(bs.config.compiler_flags);
    
    // Run compiler
    result := process.run(cmd) ?
        | .Ok -> output => {
            output.exit_code != 0 ? | true => 
                return .Err -> "Compilation failed:\n$(output.stderr)"
            return .Ok -> object
        }
        | .Err -> err => return .Err -> "Failed to run compiler: $(err)"
}

// Link object files
link_objects = (bs: &BuildSystem, objects: []string, output: string) Result<void, string>   {
    // Build linker command
    cmd := ["zenc", "-o", output];
    cmd.extend(objects);
    cmd.extend(bs.config.linker_flags);
    
    // Run linker
    result := process.run(cmd) ?
        | .Ok -> output => {
            output.exit_code != 0 ? | true =>
                return .Err -> "Linking failed:\n$(output.stderr)"
            return .Ok
        }
        | .Err -> err => return .Err -> "Failed to run linker: $(err)"
}

// Update build cache
update_cache = (bs: &BuildSystem, target: Target, objects: []string) void   {
    // Update timestamps
    loop source in target.sources {
        time := fs.get_modified_time(source) ?
            | .Ok -> t => t
            | .Err => continue
        
        bs.cache.timestamps.set(source, time)
    }
    
    // Store artifacts
    bs.cache.artifacts.set(target.name, objects)
}

// Clean build artifacts
clean = (bs: &BuildSystem) Result<void, string>   {
    io.print("Cleaning build artifacts...\n");
    
    fs.remove_dir_all(bs.config.output_dir) ?
        | .Err -> err => return .Err -> "Failed to clean: $(err)"
    
    // Clear cache
    bs.cache.hashes.clear();
    bs.cache.timestamps.clear();
    bs.cache.artifacts.clear();
    
    io.print("Clean complete\n");
    return .Ok
}

// Run tests
run_tests = (bs: &BuildSystem) Result<void, string>   {
    // Build test target
    result := build_target(bs, "test");
    
    result ?
        | .Success -> artifacts => {
            io.print("Running tests...\n");
            
            // Execute test runner
            test_result := process.run([artifacts[0]]) ?
                | .Ok -> output => {
                    io.print(output.stdout);
                    output.exit_code != 0 ? | true =>
                        return .Err -> "Tests failed"
                    return .Ok
                }
                | .Err -> err => return .Err -> "Failed to run tests: $(err)"
        }
        | .Failed -> error => return .Err -> error
        | .Skipped => {
            io.print("Tests are up to date\n");
            return .Ok
        }
}

// Main build function
build = (args: []string) i32   {
    // Parse arguments
    verbose := false;
    clean_build := false;
    target := "main";
    config_file := "zen.toml";
    
    i := 1;
    loop i < args.len {
        arg := args[i];
        
        arg ?
            | "-v" | "--verbose" => verbose = true
            | "--clean" => clean_build = true
            | "--target" => {
                i += 1;
                i < args.len ? | true => target = args[i]
            }
            | "--config" => {
                i += 1;
                i < args.len ? | true => config_file = args[i]
            }
            | "clean" => {
                clean_build = true;
                target = ""
            }
            | "test" => target = "test"
            | "run" => target = "run"
            | _ => target = arg
        
        i += 1
    }
    
    // Load configuration
    config := load_config(config_file) ?
        | .Ok -> cfg => cfg
        | .Err -> err => {
            io.error("$(err)\n");
            return 1
        }
    
    // Initialize build system
    bs := init_build_system(config, verbose);
    
    // Discover targets
    discover_targets(&bs) ?
        | .Err -> err => {
            io.error("Failed to discover targets: $(err)\n");
            return 1
        }
    
    // Handle clean
    clean_build ? | true => {
        clean(&bs) ?
            | .Err -> err => {
                io.error("$(err)\n");
                return 1
            }
        
        target.is_empty() ? | true => return 0
    }
    
    // Handle different targets
    target ?
        | "test" => {
            run_tests(&bs) ?
                | .Err -> err => {
                    io.error("$(err)\n");
                    return 1
                }
        }
        | "run" => {
            // Build and run
            result := build_target(&bs, "main");
            
            result ?
                | .Success -> artifacts => {
                    io.print("Running $(artifacts[0])...\n");
                    process.exec(artifacts[0], args[2..])
                }
                | .Failed -> error => {
                    io.error("Build failed: $(error)\n");
                    return 1
                }
                | .Skipped => {
                    executable := "$(bs.config.output_dir)/$(bs.config.name)";
                    io.print("Running $(executable)...\n");
                    process.exec(executable, args[2..])
                }
        }
        | _ => {
            // Build specific target
            result := build_target(&bs, target);
            
            result ?
                | .Success => io.print("Build successful!\n")
                | .Failed -> error => {
                    io.error("Build failed: $(error)\n");
                    return 1
                }
                | .Skipped -> reason => io.print("Build skipped: $(reason)\n")
        }
    
    return 0
}

// Entry point
main = (args: []string) i32   {
    return build(args)
}