// Zen Interactive Debugger
// Provides step-through debugging capabilities for Zen programs

core = @std
io = @std
string = @std
{ Vec, DynVec } = @std
hashmap = @std
fs = @std
process = @std
colors = @std

// Debugger state
DebuggerState : 
    | Idle
    | Running
    | Paused
    | Stepping
    | Finished

// Breakpoint information
Breakpoint := {
    id: u32
    file: string
    line: u32
    condition: Option<string>
    hit_count: u32
    enabled: bool
}

// Stack frame
StackFrame := {
    function: string
    file: string
    line: u32
    column: u32
    locals: HashMap<string, Value>
}

// Variable value representation
Value : 
    Null
    Bool(val: bool)
    I8(val: i8)
    I16(val: i16)
    I32(val: i32)
    I64(val: i64)
    U8(val: u8)
    U16(val: u16)
    U32(val: u32)
    U64(val: u64)
    F32(val: f32)
    F64(val: f64)
    String(val: string)
    Pointer(addr: usize)
    Struct(fields: HashMap<string, Value>)
    Array(elements: Vec<Value>)

// Watch expression
WatchExpression := {
    id: u32
    expression: string
    value: Option<Value>
}

// Debugger context
Debugger := {
    state: DebuggerState
    program_path: string
    source_files: HashMap<string, Vec<string>>
    breakpoints: Vec<Breakpoint>
    next_breakpoint_id: u32
    call_stack: Vec<StackFrame>
    current_frame: u32
    watches: Vec<WatchExpression>
    next_watch_id: u32
    step_mode: StepMode
    output_buffer: string
}

// Step modes
StepMode : 
    | None
    | StepOver
    | StepInto
    | StepOut

// Create new debugger instance
new_debugger = (program_path: string) Ptr<Debugger>   {
    dbg := mem.allocate<Debugger>(1)
    dbg.state = DebuggerState.Idle
    dbg.program_path = program_path
    dbg.source_files = hashmap.new<string, Vec<string>>()
    dbg.breakpoints = DynVec.new<Breakpoint>()
    dbg.next_breakpoint_id = 1
    dbg.call_stack = DynVec.new<StackFrame>()
    dbg.current_frame = 0
    dbg.watches = DynVec.new<WatchExpression>()
    dbg.next_watch_id = 1
    dbg.step_mode = StepMode.None
    dbg.output_buffer = string.new()
    return dbg
}

// Load source file
load_source_file = (dbg: Ptr<Debugger>, file_path: string) bool   {
    // Check if already loaded
    hashmap.contains(dbg.source_files, file_path) ? {
        return true
    }
    
    // Read file
    content := fs.read_file(file_path)
    content.is_error() ? {
        io.eprintln(colors.red("Error loading source: ") + content.error())
        return false
    }
    
    // Split into lines
    lines := string.split(content.unwrap(), "\n")
    hashmap.insert(dbg.source_files, file_path, lines)
    return true
}

// Add breakpoint
add_breakpoint = (dbg: Ptr<Debugger>, file: string, line: u32) u32   {
    // Load source file if needed
    !load_source_file(dbg, file) ? {
        return 0
    }
    
    bp := Breakpoint{
        id: dbg.next_breakpoint_id,
        file: file,
        line: line,
        condition: Option.None,
        hit_count: 0,
        enabled: true
    }
    
    DynVec.push(dbg.breakpoints, bp)
    dbg.next_breakpoint_id += 1
    
    io.println(colors.green("Breakpoint ") + string.format("#{} set at {}:{}", 
                                                            bp.id, file, line))
    return bp.id
}

// Remove breakpoint
remove_breakpoint = (dbg: Ptr<Debugger>, id: u32) bool   {
    i := 0
    while (i < dbg.breakpoints.len()) {
        dbg.breakpoints[i].id == id ? {
            DynVec.remove(dbg.breakpoints, i)
            io.println(colors.yellow("Breakpoint ") + string.format("#{} removed", id))
            return true
        }
        i += 1
    }
    return false
}

// Toggle breakpoint
toggle_breakpoint = (dbg: Ptr<Debugger>, id: u32) bool   {
    i := 0
    while (i < dbg.breakpoints.len()) {
        dbg.breakpoints[i].id == id ? {
            dbg.breakpoints[i].enabled = !dbg.breakpoints[i].enabled
            status := if (dbg.breakpoints[i].enabled) "enabled" else "disabled"
            io.println(colors.yellow("Breakpoint ") + 
                      string.format("#{} {}", id, status))
            return true
        }
        i += 1
    }
    return false
}

// List breakpoints
list_breakpoints = (dbg: Ptr<Debugger>) void   {
    dbg.breakpoints.len() == 0 ? {
        io.println("No breakpoints set")
        return
    }
    
    io.println(colors.bold("Breakpoints:"))
    i := 0
    while (i < dbg.breakpoints.len()) {
        bp := dbg.breakpoints[i]
        status := if (bp.enabled) colors.green("[enabled]") else colors.red("[disabled]")
        io.println(string.format("  #{} {} {}:{} (hits: {})",
                                 bp.id, status, bp.file, bp.line, bp.hit_count))
        i += 1
    }
}

// Add watch expression
add_watch = (dbg: Ptr<Debugger>, expression: string) u32   {
    watch := WatchExpression{
        id: dbg.next_watch_id,
        expression: expression,
        value: Option.None
    }
    
    DynVec.push(dbg.watches, watch)
    dbg.next_watch_id += 1
    
    io.println(colors.green("Watch ") + string.format("#{} added: {}", 
                                                      watch.id, expression))
    return watch.id
}

// Remove watch
remove_watch = (dbg: Ptr<Debugger>, id: u32) bool   {
    i := 0
    while (i < dbg.watches.len()) {
        dbg.watches[i].id == id ? {
            DynVec.remove(dbg.watches, i)
            io.println(colors.yellow("Watch ") + string.format("#{} removed", id))
            return true
        }
        i += 1
    }
    return false
}

// List watches
list_watches = (dbg: Ptr<Debugger>) void   {
    dbg.watches.len() == 0 ? {
        io.println("No watches set")
        return
    }
    
    io.println(colors.bold("Watches:"))
    i := 0
    while (i < dbg.watches.len()) {
        watch := dbg.watches[i]
        value_str := match watch.value {
            Option.Some(v) => value_to_string(v)
            Option.None => "<not evaluated>"
        }
        io.println(string.format("  #{} {}: {}", 
                                 watch.id, watch.expression, value_str))
        i += 1
    }
}

// Convert value to string
value_to_string = (val: Value) string   {
    val ?
        Value.Null => "null"
        Value.Bool(v) => if (v) "true" else "false"
        Value.I32(v) => string.format("{}", v)
        Value.I64(v) => string.format("{}", v)
        Value.F32(v) => string.format("{}", v)
        Value.F64(v) => string.format("{}", v)
        Value.String(v) => string.format("\"{}\"", v)
        Value.Pointer(addr) => string.format("0x{:x}", addr)
        Value.Struct(fields) => {
            result := "{ "
            first := true
            hashmap.foreach(fields, (key, value) => {
                if (!first) string.append(result, ", ")
                string.append(result, key)
                string.append(result, ": ")
                string.append(result, value_to_string(value))
                first = false
            })
            string.append(result, " }")
            return result
        }
        Value.Array(elements) => {
            result := "["
            i := 0
            while (i < elements.len()) {
                if (i > 0) string.append(result, ", ")
                string.append(result, value_to_string(elements[i]))
                i += 1
            }
            string.append(result, "]")
            return result
        }
        _ => "<unknown>"
    }
}

// Print call stack
print_call_stack = (dbg: Ptr<Debugger>) void   {
    dbg.call_stack.len() == 0 ? {
        io.println("Call stack is empty")
        return
    }
    
    io.println(colors.bold("Call Stack:"))
    i := 0
    while (i < dbg.call_stack.len()) {
        frame := dbg.call_stack[i]
        marker := if (i == dbg.current_frame) colors.cyan("→ ") else "  "
        io.println(string.format("{}#{} {} at {}:{}:{}", 
                                 marker, i, frame.function, 
                                 frame.file, frame.line, frame.column))
        i += 1
    }
}

// Print local variables
print_locals = (dbg: Ptr<Debugger>) void   {
    dbg.current_frame >= dbg.call_stack.len() ? {
        io.println("No active frame")
        return
    }
    
    frame := dbg.call_stack[dbg.current_frame]
    hashmap.size(frame.locals) == 0 ? {
        io.println("No local variables")
        return
    }
    
    io.println(colors.bold("Local Variables:"))
    hashmap.foreach(frame.locals, (name, value) => {
        io.println(string.format("  {}: {}", name, value_to_string(value)))
    })
}

// Show source context
show_source_context = (dbg: Ptr<Debugger>, file: string, line: u32, context: u32) void   {
    // Get source lines
    lines_opt := hashmap.get(dbg.source_files, file)
    !lines_opt ? {
        !load_source_file(dbg, file) ? {
            return
        }
        lines_opt = hashmap.get(dbg.source_files, file)
    }
    
    lines_opt ?
        Option.Some(lines) => {
            // Calculate range
            start := if (line > context) line - context else 1
            end := if (line + context < lines.len()) line + context else lines.len()
            
            io.println(colors.bold(string.format("{}:", file)))
            
            i := start
            while (i <= end) {
                line_str := if (i < lines.len()) lines[i - 1] else ""
                
                // Check for breakpoint
                has_breakpoint := false
                j := 0
                while (j < dbg.breakpoints.len()) {
                    if (dbg.breakpoints[j].file == file && 
                        dbg.breakpoints[j].line == i &&
                        dbg.breakpoints[j].enabled) {
                        has_breakpoint = true
                        break
                    }
                    j += 1
                }
                
                // Format line
                i == line ? {
                    // Current line
                    io.print(colors.cyan("→ "))
                } else if (has_breakpoint) {
                    // Breakpoint line
                    io.print(colors.red("● "))
                } | false {
                    io.print("  ")
                }
                
                io.print(colors.dim(string.format("{:4} ", i)))
                io.println(line_str)
                
                i += 1
            }
        }
        Option.None => {}
    }
}

// Run program
run_program = (dbg: Ptr<Debugger>) void   {
    dbg.state = DebuggerState.Running
    io.println(colors.green("Running: ") + dbg.program_path)
    
    // TODO: Actually execute the program
    // This would involve:
    // 1. Compiling the program with debug info
    // 2. Setting up process control
    // 3. Handling breakpoints via ptrace or similar
    // 4. Managing execution state
    
    // For now, simulate execution
    simulate_execution(dbg)
}

// Continue execution
continue_execution = (dbg: Ptr<Debugger>) void   {
    dbg.state != DebuggerState.Paused ? {
        io.println(colors.red("Program is not paused"))
        return
    }
    
    dbg.state = DebuggerState.Running
    dbg.step_mode = StepMode.None
    io.println(colors.green("Continuing..."))
    
    // Continue simulation
    simulate_execution(dbg)
}

// Step over
step_over = (dbg: Ptr<Debugger>) void   {
    dbg.state != DebuggerState.Paused ? {
        io.println(colors.red("Program is not paused"))
        return
    }
    
    dbg.state = DebuggerState.Stepping
    dbg.step_mode = StepMode.StepOver
    io.println(colors.yellow("Stepping over..."))
    
    // Simulate step
    simulate_step(dbg)
}

// Step into
step_into = (dbg: Ptr<Debugger>) void   {
    dbg.state != DebuggerState.Paused ? {
        io.println(colors.red("Program is not paused"))
        return
    }
    
    dbg.state = DebuggerState.Stepping
    dbg.step_mode = StepMode.StepInto
    io.println(colors.yellow("Stepping into..."))
    
    // Simulate step
    simulate_step(dbg)
}

// Step out
step_out = (dbg: Ptr<Debugger>) void   {
    dbg.state != DebuggerState.Paused ? {
        io.println(colors.red("Program is not paused"))
        return
    }
    
    dbg.state = DebuggerState.Stepping
    dbg.step_mode = StepMode.StepOut
    io.println(colors.yellow("Stepping out..."))
    
    // Simulate step
    simulate_step(dbg)
}

// Simulate execution (placeholder)
simulate_execution = (dbg: Ptr<Debugger>) void   {
    // This is a simulation for demonstration
    // Real implementation would use ptrace or similar
    
    // Add a fake stack frame
    frame := StackFrame{
        function: "main",
        file: dbg.program_path,
        line: 10,
        column: 1,
        locals: hashmap.new<string, Value>()
    }
    
    // Add some fake locals
    hashmap.insert(frame.locals, "x", Value.I32(42))
    hashmap.insert(frame.locals, "y", Value.F64(3.14))
    hashmap.insert(frame.locals, "name", Value.String("test"))
    
    DynVec.push(dbg.call_stack, frame)
    
    // Simulate hitting a breakpoint
    dbg.state = DebuggerState.Paused
    io.println(colors.yellow("Breakpoint hit at ") + 
              string.format("{}:{}", frame.file, frame.line))
    
    // Show context
    show_source_context(dbg, frame.file, frame.line, 3)
}

// Simulate step (placeholder)
simulate_step = (dbg: Ptr<Debugger>) void   {
    // Update current frame's line
    dbg.current_frame < dbg.call_stack.len() ? {
        dbg.call_stack[dbg.current_frame].line += 1
        
        frame := dbg.call_stack[dbg.current_frame]
        io.println(colors.cyan("Stepped to ") + 
                  string.format("{}:{}", frame.file, frame.line))
        
        // Show context
        show_source_context(dbg, frame.file, frame.line, 3)
    }
    
    dbg.state = DebuggerState.Paused
    dbg.step_mode = StepMode.None
}

// Debugger REPL
debugger_repl = (dbg: Ptr<Debugger>) void   {
    io.println(colors.bold("Zen Debugger v1.0"))
    io.println("Type 'help' for commands")
    io.println("")
    
    running := true
    while (running) {
        // Show prompt based on state
        prompt := match dbg.state {
            DebuggerState.Idle => colors.green("(zen-dbg) ")
            DebuggerState.Paused => colors.yellow("(paused) ")
            DebuggerState.Running => colors.blue("(running) ")
            _ => "(zen-dbg) "
        }
        
        io.print(prompt)
        io.flush()
        
        // Read command
        input := io.readline()
        !input ? {
            break
        }
        
        // Parse and execute command
        parts := string.split(string.trim(input), " ")
        parts.len() == 0 ? {
            continue
        }
        
        cmd := parts[0]
        
        cmd == "help" || cmd == "h" ? {
            print_help()
        } else if (cmd == "quit" || cmd == "q") {
            running = false
        } else if (cmd == "run" || cmd == "r") {
            run_program(dbg)
        } else if (cmd == "continue" || cmd == "c") {
            continue_execution(dbg)
        } else if (cmd == "step" || cmd == "s") {
            step_into(dbg)
        } else if (cmd == "next" || cmd == "n") {
            step_over(dbg)
        } else if (cmd == "finish" || cmd == "f") {
            step_out(dbg)
        } else if (cmd == "break" || cmd == "b") {
            parts.len() >= 2 ? {
                // Parse file:line or just line
                location := parts[1]
                string.contains(location, ":") ? {
                    file_line := string.split(location, ":")
                    file_line.len() == 2 ? {
                        line := string.parse_u32(file_line[1])
                        add_breakpoint(dbg, file_line[0], line)
                    }
                } | false {
                    line := string.parse_u32(location)
                    dbg.current_frame < dbg.call_stack.len() ? {
                        file := dbg.call_stack[dbg.current_frame].file
                        add_breakpoint(dbg, file, line)
                    }
                }
            } | false {
                list_breakpoints(dbg)
            }
        } else if (cmd == "delete" || cmd == "d") {
            parts.len() >= 2 ? {
                id := string.parse_u32(parts[1])
                remove_breakpoint(dbg, id)
            }
        } else if (cmd == "watch" || cmd == "w") {
            parts.len() >= 2 ? {
                expr := string.join(parts[1:], " ")
                add_watch(dbg, expr)
            } | false {
                list_watches(dbg)
            }
        } else if (cmd == "backtrace" || cmd == "bt") {
            print_call_stack(dbg)
        } else if (cmd == "locals" || cmd == "l") {
            print_locals(dbg)
        } else if (cmd == "list") {
            dbg.current_frame < dbg.call_stack.len() ? {
                frame := dbg.call_stack[dbg.current_frame]
                show_source_context(dbg, frame.file, frame.line, 5)
            }
        } else if (cmd == "frame") {
            parts.len() >= 2 ? {
                frame_num := string.parse_u32(parts[1])
                frame_num < dbg.call_stack.len() ? {
                    dbg.current_frame = frame_num
                    frame := dbg.call_stack[frame_num]
                    io.println(string.format("Switched to frame #{}", frame_num))
                    show_source_context(dbg, frame.file, frame.line, 3)
                }
            }
        } | false {
            io.println(colors.red("Unknown command: ") + cmd)
            io.println("Type 'help' for available commands")
        }
    }
    
    io.println("\nGoodbye!")
}

// Print help
print_help = () void   {
    io.println(colors.bold("Debugger Commands:"))
    io.println("  help, h           - Show this help")
    io.println("  quit, q           - Exit debugger")
    io.println("")
    io.println(colors.bold("Execution:"))
    io.println("  run, r            - Run program")
    io.println("  continue, c       - Continue execution")
    io.println("  step, s           - Step into")
    io.println("  next, n           - Step over")
    io.println("  finish, f         - Step out")
    io.println("")
    io.println(colors.bold("Breakpoints:"))
    io.println("  break [file:]line - Set breakpoint")
    io.println("  break             - List breakpoints")
    io.println("  delete <id>       - Delete breakpoint")
    io.println("")
    io.println(colors.bold("Inspection:"))
    io.println("  backtrace, bt     - Show call stack")
    io.println("  locals, l         - Show local variables")
    io.println("  watch <expr>      - Add watch expression")
    io.println("  watch             - List watches")
    io.println("  list              - Show source code")
    io.println("  frame <n>         - Switch to frame n")
}

// Main entry point
main = (args: []string) i32   {
    args.len() < 2 ? {
        io.eprintln("Usage: zen-debug <program.zen>")
        return 1
    }
    
    // Create debugger
    dbg := new_debugger(args[1])
    
    // Start REPL
    debugger_repl(dbg)
    
    return 0
}