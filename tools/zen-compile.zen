// Zen Language - Bootstrap Compiler
// Compiles Zen source code to C for bootstrapping

core := @std.core
io := @std.io
fs := @std.fs
os := @std.os
string := @std.string
path := @std.path
lexer := @std.compiler.lexer
parser := @std.compiler.parser
codegen := @std.compiler.codegen
type_checker := @std.compiler.type_checker

// Compiler options
CompilerOptions := {
    input_file: string
    output_file: string
    emit_c: bool
    emit_llvm: bool
    optimize: bool
    debug: bool
    verbose: bool
}

// Parse command line arguments
parse_args: (args: []string) CompilerOptions  = {
    options := CompilerOptions{
        input_file: "",
        output_file: "",
        emit_c: true,  // Default to C output for bootstrapping
        emit_llvm: false,
        optimize: false,
        debug: false,
        verbose: false
    }
    
    i := 1  // Skip program name
    while (i < args.len) {
        arg := args[i]
        
        if (arg == "-o" || arg == "--output") {
            i = i + 1
            if (i < args.len) {
                options.output_file = args[i]
            }
        } else if (arg == "--emit-c") {
            options.emit_c = true
            options.emit_llvm = false
        } else if (arg == "--emit-llvm") {
            options.emit_llvm = true
            options.emit_c = false
        } else if (arg == "-O" || arg == "--optimize") {
            options.optimize = true
        } else if (arg == "-g" || arg == "--debug") {
            options.debug = true
        } else if (arg == "-v" || arg == "--verbose") {
            options.verbose = true
        } else if (arg == "-h" || arg == "--help") {
            print_usage()
            os.exit(0)
        } else if (!string.starts_with(arg, "-")) {
            options.input_file = arg
        } else {
            io.print("Unknown option: ")
            io.print(arg)
            io.print("\n")
            print_usage()
            os.exit(1)
        }
        
        i = i + 1
    }
    
    // Validate input file
    if (options.input_file == "") {
        io.print("Error: No input file specified\n")
        print_usage()
        os.exit(1)
    }
    
    // Generate default output file if not specified
    if (options.output_file == "") {
        base_name := path.basename(options.input_file)
        if (string.ends_with(base_name, ".zen")) {
            base_name = string.substring(base_name, 0, base_name.len - 4)
        }
        
        if (options.emit_c) {
            options.output_file = base_name ++ ".c"
        } else if (options.emit_llvm) {
            options.output_file = base_name ++ ".ll"
        }
    }
    
    return options
}

// Print usage information
print_usage: () void  = {
    io.print("zen-compile - Zen Language Bootstrap Compiler\n\n")
    io.print("Usage: zen-compile [options] <input-file>\n\n")
    io.print("Options:\n")
    io.print("  -o, --output <file>    Output file name\n")
    io.print("  --emit-c               Emit C code (default)\n")
    io.print("  --emit-llvm           Emit LLVM IR\n")
    io.print("  -O, --optimize        Enable optimizations\n")
    io.print("  -g, --debug          Include debug information\n")
    io.print("  -v, --verbose        Verbose output\n")
    io.print("  -h, --help           Show this help message\n")
}

// Compile a Zen source file
compile_file: (options: &CompilerOptions) bool  = {
    if (options.verbose) {
        io.print("Compiling: ")
        io.print(options.input_file)
        io.print(" -> ")
        io.print(options.output_file)
        io.print("\n")
    }
    
    // Read source file
    source := fs.read_file(options.input_file)
    if (!source) {
        io.print("Error: Could not read file: ")
        io.print(options.input_file)
        io.print("\n")
        return false
    }
    
    // Lexical analysis
    if (options.verbose) {
        io.print("  Lexing...")
    }
    
    lex := lexer.new_lexer(source, options.input_file)
    tokens := lexer.tokenize(&lex)
    
    if (lex.errors.len > 0) {
        io.print("\nLexical errors:\n")
        for (lex.errors) |err| {
            io.print("  ")
            io.print(err)
            io.print("\n")
        }
        return false
    }
    
    if (options.verbose) {
        io.print(" OK (")
        io.print(tokens.len.to_string())
        io.print(" tokens)\n")
    }
    
    // Parsing
    if (options.verbose) {
        io.print("  Parsing...")
    }
    
    p := parser.new_parser(tokens, options.input_file)
    ast := parser.parse(&p)
    
    if (p.errors.len > 0) {
        io.print("\nParse errors:\n")
        for (p.errors) |err| {
            io.print("  ")
            io.print(err)
            io.print("\n")
        }
        return false
    }
    
    if (options.verbose) {
        io.print(" OK (")
        io.print(ast.functions.len.to_string())
        io.print(" functions)\n")
    }
    
    // Type checking
    if (options.verbose) {
        io.print("  Type checking...")
    }
    
    checker := type_checker.new_checker()
    type_errors := type_checker.check(&checker, &ast)
    
    if (type_errors.len > 0) {
        io.print("\nType errors:\n")
        for (type_errors) |err| {
            io.print("  ")
            io.print(err)
            io.print("\n")
        }
        return false
    }
    
    if (options.verbose) {
        io.print(" OK\n")
    }
    
    // Code generation
    if (options.verbose) {
        io.print("  Generating code...")
    }
    
    output_code := ""
    
    if (options.emit_c) {
        gen := codegen.new_codegen()
        output_code = codegen.generate_c(&gen, &ast)
    } else if (options.emit_llvm) {
        io.print("\nError: LLVM backend not yet implemented\n")
        return false
    }
    
    if (options.verbose) {
        io.print(" OK\n")
    }
    
    // Write output file
    if (options.verbose) {
        io.print("  Writing output...")
    }
    
    if (!fs.write_file(options.output_file, output_code)) {
        io.print("\nError: Could not write output file: ")
        io.print(options.output_file)
        io.print("\n")
        return false
    }
    
    if (options.verbose) {
        io.print(" OK\n")
    }
    
    // If emitting C, optionally compile to executable
    if (options.emit_c && !string.ends_with(options.output_file, ".c")) {
        if (options.verbose) {
            io.print("  Compiling C code...")
        }
        
        cc_cmd := "cc "
        if (options.optimize) cc_cmd = cc_cmd ++ "-O2 "
        if (options.debug) cc_cmd = cc_cmd ++ "-g "
        cc_cmd = cc_cmd ++ "-o " ++ options.output_file ++ " "
        cc_cmd = cc_cmd ++ options.output_file ++ ".c"
        
        result := os.system(cc_cmd)
        if (result != 0) {
            io.print("\nError: C compilation failed\n")
            return false
        }
        
        if (options.verbose) {
            io.print(" OK\n")
        }
    }
    
    if (options.verbose) {
        io.print("Compilation successful!\n")
    }
    
    return true
}

// Main entry point
main: (args: []string) i32  = {
    io.print("zen-compile v0.1.0 - Zen Language Bootstrap Compiler\n")
    
    // Parse command line arguments
    options := parse_args(args)
    
    // Compile the file
    if (!compile_file(&options)) {
        return 1
    }
    
    return 0
}