// Basic Zen Language Server
// Minimal LSP implementation for syntax checking and diagnostics

// Standard library imports
build = @std
core = @std
io := build.import("io")
string := build.import("string")
{ Vec, DynVec } = @std
json := build.import("json")

// JSON-RPC message structure
JsonRpcMessage: {
    jsonrpc: string,
    id: Option<i32>,
    method: Option<string>,
    params: Option<json.Value>,
    result: Option<json.Value>,
    error: Option<JsonRpcError>,
}

JsonRpcError: {
    code: i32,
    message: string,
    data: Option<json.Value>,
}

// LSP Message types
InitializeParams: {
    processId: Option<i32>,
    rootUri: Option<string>,
    capabilities: json.Value,
}

InitializeResult: {
    capabilities: ServerCapabilities,
}

ServerCapabilities: {
    textDocumentSync: i32,  // 1 = full sync
    diagnosticProvider: bool,
    hoverProvider: bool,
    completionProvider: Option<CompletionOptions>,
}

CompletionOptions: {
    triggerCharacters: Vec<string>,
    resolveProvider: bool,
}

// Text document types
TextDocumentItem: {
    uri: string,
    languageId: string,
    version: i32,
    text: string,
}

TextDocumentIdentifier: {
    uri: string,
}

VersionedTextDocumentIdentifier: {
    uri: string,
    version: i32,
}

// Diagnostic types
Diagnostic: {
    range: Range,
    severity: i32,  // 1=Error, 2=Warning, 3=Info, 4=Hint
    code: Option<string>,
    source: string,
    message: string,
}

Range: {
    start: Position,
    end: Position,
}

Position: {
    line: i32,
    character: i32,
}

// Simple document store
Document: {
    uri: string,
    version: i32,
    content: string,
    diagnostics: Vec<Diagnostic>,
}

// Language Server State
LanguageServer: {
    initialized: bool,
    root_uri: Option<string>,
    documents: Vec<Document>,
}

// Create a new language server
new_server = () LanguageServer   {
    return LanguageServer{
        initialized: false,
        root_uri: Option<string>.None,
        documents: Vec<Document>.new(),
    }
}

// Handle initialize request
handle_initialize = (server: *LanguageServer, params: InitializeParams) InitializeResult   {
    server.initialized = true
    server.root_uri = params.rootUri
    
    capabilities := ServerCapabilities{
        textDocumentSync: 1,  // Full document sync
        diagnosticProvider: true,
        hoverProvider: false,  // Basic server doesn't provide hover
        completionProvider: Option<CompletionOptions>.None,
    }
    
    return InitializeResult{
        capabilities: capabilities,
    }
}

// Handle text document open
handle_did_open = (server: *LanguageServer, uri: string, version: i32, text: string) void   {
    doc := Document{
        uri: uri,
        version: version,
        content: text,
        diagnostics: Vec<Diagnostic>.new(),
    }
    
    // Check syntax and generate diagnostics
    check_document(&doc)
    
    // Store document
    server.documents.push(doc)
    
    // Send diagnostics
    publish_diagnostics(uri, doc.diagnostics)
}

// Handle text document change
handle_did_change = (server: *LanguageServer, uri: string, version: i32, text: string) void   {
    // Find and update document
    i := 0
    loop i < server.documents.len() {
        server.documents[i].uri == uri ? {
                server.documents[i].version = version
                server.documents[i].content = text
                server.documents[i].diagnostics.clear()
                
                // Re-check document
                check_document(&server.documents[i])
                
                // Send updated diagnostics
                publish_diagnostics(uri, server.documents[i].diagnostics)
                return
            }
        i = i + 1
    }
}

// Check document for errors
check_document = (doc: *Document) void   {
    // Basic syntax checks
    diagnostics := Vec<Diagnostic>.new()
    
    // Check for common issues
    lines := string.split(doc.content, "\n")
    line_num := 0
    
    loop line_num < lines.len() {
        line := lines[line_num]
        
        // Check for old-style comptime imports
        string.contains(line, "comptime") && string.contains(line, "@std") ?
            {
                diag := Diagnostic{
                    range: Range{
                        start: Position{line = line_num, character = 0},
                        end: Position{line = line_num, character = line.len()},
                    },
                    severity: 1,  // Error
                    code: Option<string>.Some("import-in-comptime"),
                    source: "zen-lsp",
                    message: "Imports should not be wrapped in comptime blocks",
                }
                diagnostics.push(diag)
            }
        
        // Check for missing semicolons (simplified)
        needs_semicolon := false
        !(string.ends_with(line, "}") || string.ends_with(line, "{")) ?
            {
                // Check if line looks like a statement
                string.contains(line, "=") && !string.contains(line, "=>") ?
                    {
                        !string.ends_with(string.trim(line), ";") ? {
                                diag := Diagnostic{
                                    range: Range{
                                        start: Position{line = line_num, character = line.len()},
                                        end: Position{line = line_num, character = line.len()},
                                    },
                                    severity: 2,  // Warning
                                    code: Option<string>.Some("missing-semicolon"),
                                    source: "zen-lsp",
                                    message: "Statement may be missing semicolon",
                                }
                                diagnostics.push(diag)
                            }
                    }
            }
        
        // Check for tabs vs spaces
        string.starts_with(line, "\t") ?
            {
                diag := Diagnostic{
                    range: Range{
                        start: Position{line = line_num, character = 0},
                        end: Position{line = line_num, character = 1},
                    },
                    severity: 3,  // Info
                    code: Option<string>.Some("tabs-vs-spaces"),
                    source: "zen-lsp",
                    message: "Consider using spaces instead of tabs",
                }
                diagnostics.push(diag)
            }
        
        line_num = line_num + 1
    }
    
    doc.diagnostics = diagnostics
}

// Publish diagnostics notification
publish_diagnostics = (uri: string, diagnostics: Vec<Diagnostic>) void   {
    notification := JsonRpcMessage{
        jsonrpc: "2.0",
        id: Option<i32>.None,
        method: Option<string>.Some("textDocument/publishDiagnostics"),
        params: Option<json.Value>.Some(json.object({
            "uri": json.string(uri),
            "diagnostics": diagnostics_to_json(diagnostics),
        })),
        result: Option<json.Value>.None,
        error: Option<JsonRpcError>.None,
    }
    
    send_message(notification)
}

// Convert diagnostics to JSON
diagnostics_to_json = (diagnostics: Vec<Diagnostic>) json.Value {
    items := Vec<json.Value>.new()
    
    i := 0
    loop i < diagnostics.len() {
        diag := diagnostics[i]
        item := json.object({
            "range": json.object({
                "start": json.object({
                    "line": json.number(diag.range.start.line),
                    "character": json.number(diag.range.start.character),
                }),
                "end": json.object({
                    "line": json.number(diag.range.end.line),
                    "character": json.number(diag.range.end.character),
                }),
            }),
            "severity": json.number(diag.severity),
            "source": json.string(diag.source),
            "message": json.string(diag.message),
        })
        
    // Add optional code
    diag.code ?
        | Some(code) => {
            item.set("code", json.string(code))
        }
        | None => {}
    }
    
    items.push(item)
    i = i + 1
    
    return json.array(items)
}

// Read message from stdin
read_message = () Option<JsonRpcMessage>   {
    // Read Content-Length header
    header := io.read_line()
    !string.starts_with(header, "Content-Length:") ? { return Option<JsonRpcMessage>.None }
    
    // Parse content length
    length_str := string.trim(string.substring(header, 15, header.len()))
    content_length := string.parse_int(length_str)
    
    // Read empty line
    io.read_line()
    
    // Read content
    content := io.read_bytes(content_length)
    
    // Parse JSON
    json_value := json.parse(content)
    
    // Convert to message
    return parse_json_rpc_message(json_value)
}

// Send message to stdout
send_message = (msg: JsonRpcMessage) void   {
    // Convert to JSON
    json_str := message_to_json(msg)
    
    // Send with Content-Length header
    io.print("Content-Length: " + string.from_int(json_str.len()) + "\r\n")
    io.print("\r\n")
    io.print(json_str)
    io.flush()
}

// Main server loop
run_server = () void   {
    server := new_server()
    
    io.log("Zen Language Server starting...")
    
    loop true {
        // Read next message
        msg =  read_message() ?
            | Some(message) => {
                // Handle message based on method
                message.method ?
                    | Some(method) => {
                        handle_method(&server, method, message)
                    }
                    | None => {
                        // Response to a request we made (shouldn't happen in basic server)
                        io.log("Unexpected response received")
                    }
            }
            | None => {
                io.log("Failed to read message")
                break
            }
    
    io.log("Zen Language Server shutting down...")
}

// Handle specific method
handle_method = (server: *LanguageServer, method: string, msg: JsonRpcMessage) void   {
    method == "initialize" ? {
            // Parse params and handle initialize
            params := parse_initialize_params(msg.params)
            result := handle_initialize(server, params)
            
            // Send response
            response := JsonRpcMessage{
                jsonrpc: "2.0",
                id: msg.id,
                method: Option<string>.None,
                params: Option<json.Value>.None,
                result: Option<json.Value>.Some(initialize_result_to_json(result)),
                error: Option<JsonRpcError>.None,
            }
            send_message(response)
        }
    }
    
    method == "initialized" ? {
            io.log("Server initialized successfully")
        }
    
    method == "textDocument/didOpen" ? {
            // Parse params
            params := msg.params
            params ?
                | Some(p) => {
                    doc := p.get("textDocument")
                    uri := doc.get("uri").as_string()
                    version := doc.get("version").as_int()
                    text := doc.get("text").as_string()
                    handle_did_open(server, uri, version, text)
                }
            }
        }
    
    method == "textDocument/didChange" ? {
            // Parse params
            params := msg.params
            params ?
                | Some(p) => {
                    doc := p.get("textDocument")
                    uri := doc.get("uri").as_string()
                    version := doc.get("version").as_int()
                    changes := p.get("contentChanges")
                    // For simplicity, assume full document sync
                    text := changes[0].get("text").as_string()
                    handle_did_change(server, uri, version, text)
                }
                | None => {}
            }
    
    method == "shutdown" ? {
            // Prepare for shutdown
            io.log("Shutdown requested")
            
            // Send response
            response := JsonRpcMessage{
                jsonrpc: "2.0",
                id: msg.id,
                method: Option<string>.None,
                params: Option<json.Value>.None,
                result: Option<json.Value>.Some(json.null()),
                error: Option<JsonRpcError>.None,
            }
            send_message(response)
        }
    
    method == "exit" ?
        {
            io.log("Exit requested")
            // Exit the server
            core.exit(0)
        }
}

// Entry point
main = () i32   {
    run_server()
    return 0
}