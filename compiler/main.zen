// Zen Language Self-Hosted Compiler
// Main entry point for the self-hosted compiler

{ core } = @std.core
{ io } = @std.io
{ fs } = @std.fs
{ string } = @std.string
{ process } = @std.process
{ lexer } = @std.compiler.lexer
{ parser } = @std.compiler.parser
{ c_backend } = @std.compiler.c_backend
{ llvm_backend } = @std.compiler.llvm_backend
{ type_checker } = @std.compiler.type_checker

// Compiler options
CompilerOptions := {
    input_file: string,
    output_file: string,
    backend: string,  // "c", "llvm", "wasm"
    optimize: bool,
    debug: bool,
    verbose: bool,
}

// Parse command line arguments
parse_args = (args: [string]) CompilerOptions   {
    opts := CompilerOptions{
        input_file: "",
        output_file: "",
        backend: "c",
        optimize: false,
        debug: false,
        verbose: false,
    }
    
    i := 1
    loop i < args.len() {
        arg := args[i]
        
        if (arg == "-o") && ((i + 1) < args.len()) {
            opts.output_file = args[i + 1]
            i = i + 2
        } else if arg == "--backend" && i + 1 < args.len() {
            opts.backend = args[i + 1]
            i = i + 2
        } else if arg == "--optimize" {
            opts.optimize = true
            i = i + 1
        } else if arg == "--debug" {
            opts.debug = true
            i = i + 1
        } else if arg == "--verbose" || arg == "-v" {
            opts.verbose = true
            i = i + 1
        } else if arg == "--help" || arg == "-h" {
            print_help()
            process.exit(0)
        } else if !string.starts_with(arg, "-") {
            opts.input_file = arg
            i = i + 1
        } else {
            io.eprintln("Unknown option: " + arg)
            process.exit(1)
        }
    }
    
    // Validate options
    (opts.input_file == "") ?
        | true {
            io.eprintln("Error: No input file specified")
            print_help()
            process.exit(1)
        }
        | false { }
    
    // Default output file
    (opts.output_file == "") ?
        | true {
            (opts.backend == "c") ?
                | true {
                    opts.output_file = string.replace(opts.input_file, ".zen", ".c")
                }
                | false {
                    opts.output_file = string.replace(opts.input_file, ".zen", ".out")
                }
        }
        | false { }
    
    return opts
}

// Print help message
print_help = () void {
    io.println("Zen Language Compiler")
    io.println("Usage: zen-compile [options] <input.zen>")
    io.println("")
    io.println("Options:")
    io.println("  -o <file>           Output file name")
    io.println("  --backend <type>    Backend: c, llvm, wasm (default: c)")
    io.println("  --optimize          Enable optimizations")
    io.println("  --debug             Include debug information")
    io.println("  --verbose, -v       Verbose output")
    io.println("  --help, -h          Show this help message")
}

// Compile a Zen file
compile_file = (opts: CompilerOptions) i32 {
    opts.verbose ?
        | true {
            io.println("Compiling: " + opts.input_file)
            io.println("Output: " + opts.output_file)
            io.println("Backend: " + opts.backend)
        }
        | false { }
    
    // Read input file
    source := fs.read_file(opts.input_file)
    source.is_error() ?
        | true {
            io.eprintln("Error reading file: " + source.error())
            return 1
        }
        | false { }
    
    // Lexical analysis
    opts.verbose ? | true { io.println("Phase 1: Lexical analysis...") } | false { }
    tokens := lexer.tokenize(source.unwrap())
    tokens.is_error() ?
        | true {
            io.eprintln("Lexer error: " + tokens.error())
            return 1
        }
        | false { }
    
    // Parsing
    opts.verbose ? | true { io.println("Phase 2: Parsing...") } | false { }
    ast := parser.parse(tokens.unwrap())
    ast.is_error() ?
        | true {
            io.eprintln("Parser error: " + ast.error())
            return 1
        }
        | false { }
    
    // Type checking
    opts.verbose ? | true { io.println("Phase 3: Type checking...") } | false { }
    typed_ast := type_checker.check(ast.unwrap())
    typed_ast.is_error() ?
        | true {
            io.eprintln("Type error: " + typed_ast.error())
            return 1
        }
        | false { }
    
    // Code generation
    opts.verbose ? | true { io.println("Phase 4: Code generation...") } | false { }
    output := generate_code(typed_ast.unwrap(), opts)
    output.is_error() ?
        | true {
            io.eprintln("Codegen error: " + output.error())
            return 1
        }
        | false { }
    
    // Write output
    opts.verbose ? | true { io.println("Writing output...") } | false { }
    result := fs.write_file(opts.output_file, output.unwrap())
    result.is_error() ?
        | true {
            io.eprintln("Error writing output: " + result.error())
            return 1
        }
        | false { }
    
    opts.verbose ?
        | true {
            io.println("Compilation successful!")
        }
        | false { }
    
    return 0
}

// Generate code based on backend
generate_code = (ast: ASTNode, opts: CompilerOptions) Result<string> {
    (opts.backend == "c") ?
        | true {
            backend := c_backend.new_c_backend()
            return backend.generate(ast, opts.debug)
        }
        | false {
            (opts.backend == "llvm") ?
                | true {
                    // Generate LLVM IR
                    module_name := string.basename(opts.input_file)
                    llvm_ir := llvm_backend.generate_llvm_from_ast(ast, module_name)
                    return Result.ok(llvm_ir)
                }
                | false {
                    (opts.backend == "wasm") ?
                        | true {
                            return Result.error("WASM backend not yet implemented")
                        }
                        | false {
                            return Result.error("Unknown backend: " + opts.backend)
                        }
                }
        }
}

// Main entry point
main = (args: [string]) i32 {
    // Parse command line arguments
    opts := parse_args(args)
    
    // Compile the file
    return compile_file(opts)
}