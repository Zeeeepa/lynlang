// Zen Language Self-Hosted Compiler
// Main entry point for the self-hosted compiler

{ core } = @std.core
{ io } = @std.io
{ fs } = @std.fs
{ string } = @std.string
{ process } = @std.process
{ lexer } = @std.compiler.lexer
{ parser } = @std.compiler.parser
{ c_backend } = @std.compiler.c_backend
{ llvm_backend } = @std.compiler.llvm_backend
{ type_checker } = @std.compiler.type_checker

// Compiler options
CompilerOptions := {
    input_file: string,
    output_file: string,
    backend: string,  // "c", "llvm", "wasm"
    optimize: bool,
    debug: bool,
    verbose: bool,
}

// Parse command line arguments
parse_args = (args: [string]) CompilerOptions   {
    opts := CompilerOptions{
        input_file: "",
        output_file: "",
        backend: "c",
        optimize: false,
        debug: false,
        verbose: false,
    }
    
    i := 1
    loop i < args.len() {
        arg := args[i]
        
        if (arg == "-o") && ((i + 1) < args.len()) {
            opts.output_file = args[i + 1]
            i = i + 2
        } else if arg == "--backend" && i + 1 < args.len() {
            opts.backend = args[i + 1]
            i = i + 2
        } else if arg == "--optimize" {
            opts.optimize = true
            i = i + 1
        } else if arg == "--debug" {
            opts.debug = true
            i = i + 1
        } else if arg == "--verbose" || arg == "-v" {
            opts.verbose = true
            i = i + 1
        } else if arg == "--help" || arg == "-h" {
            print_help()
            process.exit(0)
        } else if !string.starts_with(arg, "-") {
            opts.input_file = arg
            i = i + 1
        } else {
            io.eprintln("Unknown option: " + arg)
            process.exit(1)
        }
    }
    
    // Validate options
    if opts.input_file == "") {
        io.eprintln("Error: No input file specified")
        print_help()
        process.exit(1)
    }
    
    // Default output file
    if opts.output_file == "") {
        if opts.backend == "c") {
            opts.output_file = string.replace(opts.input_file, ".zen", ".c")
        } else {
            opts.output_file = string.replace(opts.input_file, ".zen", ".out")
        }
    }
    
    return opts
}

// Print help message
print_help = () void   {
    io.println("Zen Language Compiler")
    io.println("Usage: zen-compile [options] <input.zen>")
    io.println("")
    io.println("Options:")
    io.println("  -o <file>           Output file name")
    io.println("  --backend <type>    Backend: c, llvm, wasm (default: c)")
    io.println("  --optimize          Enable optimizations")
    io.println("  --debug             Include debug information")
    io.println("  --verbose, -v       Verbose output")
    io.println("  --help, -h          Show this help message")
}

// Compile a Zen file
compile_file = (opts: CompilerOptions) i32   {
    if opts.verbose {
        io.println("Compiling: " + opts.input_file)
        io.println("Output: " + opts.output_file)
        io.println("Backend: " + opts.backend)
    }
    
    // Read input file
    source := fs.read_file(opts.input_file)
    if source.is_error() {
        io.eprintln("Error reading file: " + source.error())
        return 1
    }
    
    // Lexical analysis
    if opts.verbose { io.println("Phase 1: Lexical analysis...") }
    tokens := lexer.tokenize(source.unwrap())
    if tokens.is_error() {
        io.eprintln("Lexer error: " + tokens.error())
        return 1
    }
    
    // Parsing
    if opts.verbose { io.println("Phase 2: Parsing...") }
    ast := parser.parse(tokens.unwrap())
    if ast.is_error() {
        io.eprintln("Parser error: " + ast.error())
        return 1
    }
    
    // Type checking
    if opts.verbose { io.println("Phase 3: Type checking...") }
    typed_ast := type_checker.check(ast.unwrap())
    if typed_ast.is_error() {
        io.eprintln("Type error: " + typed_ast.error())
        return 1
    }
    
    // Code generation
    if opts.verbose { io.println("Phase 4: Code generation...") }
    output := generate_code(typed_ast.unwrap(), opts)
    if output.is_error() {
        io.eprintln("Codegen error: " + output.error())
        return 1
    }
    
    // Write output
    if opts.verbose { io.println("Writing output...") }
    result := fs.write_file(opts.output_file, output.unwrap())
    if result.is_error() {
        io.eprintln("Error writing output: " + result.error())
        return 1
    }
    
    if opts.verbose {
        io.println("Compilation successful!")
    }
    
    return 0
}

// Generate code based on backend
generate_code = (ast: ASTNode, opts: CompilerOptions) Result<string>   {
    if opts.backend == "c") {
        backend := c_backend.new_c_backend()
        return backend.generate(ast, opts.debug)
    } else if opts.backend == "llvm") {
        // Generate LLVM IR
        module_name := string.basename(opts.input_file)
        llvm_ir := llvm_backend.generate_llvm_from_ast(ast, module_name)
        return Result.ok(llvm_ir)
    } else if opts.backend == "wasm") {
        return Result.error("WASM backend not yet implemented")
    } else {
        return Result.error("Unknown backend: " + opts.backend)
    }
}

// Main entry point
main = (args: [string]) i32   {
    // Parse command line arguments
    opts := parse_args(args)
    
    // Compile the file
    return compile_file(opts)
}