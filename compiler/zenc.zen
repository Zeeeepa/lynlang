// Zen Compiler - Bootstrap Implementation
// Main compiler driver that coordinates all compilation phases

core = @std
io = @std
fs = @std
string = @std
{ Vec, DynVec } = @std
args = @std
log = @std
time = @std

// Import compiler modules
lexer = @std
parser = @std
type_checker = @std
codegen = @std
codegen_llvm = @std

// Compiler configuration
CompilerConfig: {
    input_file: string,
    output_file: Option<string>,
    output_type: OutputType,
    optimization_level: u8,
    debug_info: bool,
    verbose: bool,
    emit_llvm: bool,
    check_only: bool,
    dump_ast: bool,
    dump_ir: bool,
}

// Output types
OutputType: 
    Executable,
    ObjectFile,
    Assembly,
    LLVMIR,

// Compilation result
CompileResult: 
    Success,
    LexerError(string),
    ParserError(string),
    TypeCheckError(string),
    CodeGenError(string),
    FileError(string),

// Create default configuration
default_config = () CompilerConfig   {
    return CompilerConfig{
        input_file: "",
        output_file: Option<string>.None,
        output_type: OutputType.Executable,
        optimization_level: 2,
        debug_info: false,
        verbose: false,
        emit_llvm: false,
        check_only: false,
        dump_ast: false,
        dump_ir: false,
    }
}

// Parse command line arguments
parse_args = (argv: DynVec<string>) Result<CompilerConfig, string>   {
    parser := args.new_parser("zenc", "The Zen compiler")
    
    // Add flags
    args.add_flag(&mut parser, args.flag_short('h', "help", "Show help message"))
    args.add_flag(&mut parser, args.flag_short('v', "version", "Show version"))
    args.add_flag(&mut parser, args.flag_short('V', "verbose", "Verbose output"))
    args.add_flag(&mut parser, args.flag_value('o', "output", "FILE", "Output file"))
    args.add_flag(&mut parser, args.flag_value('O', "opt", "LEVEL", "Optimization level (0-3)"))
    args.add_flag(&mut parser, args.flag_short('g', "debug", "Generate debug info"))
    args.add_flag(&mut parser, args.flag_long("emit-llvm", "Emit LLVM IR"))
    args.add_flag(&mut parser, args.flag_long("check", "Type check only"))
    args.add_flag(&mut parser, args.flag_long("dump-ast", "Dump AST"))
    args.add_flag(&mut parser, args.flag_long("dump-ir", "Dump IR"))
    args.add_flag(&mut parser, args.flag_value('t', "type", "TYPE", "Output type (exe|obj|asm|llvm)"))
    
    // Add positional argument for input file
    args.add_positional(&mut parser, "input", "Input Zen source file", true)
    
    // Parse arguments
    result := args.parse(&parser, argv)
    
    result ?
        | Result<args.ParsedArgs, string>.Ok(parsed) {
            // Check for help
            args.has_flag(&parsed, "help") ? {
                io.print(args.help_text(&parser))
                core.exit(0)
            } : {}
            
            // Check for version
            args.has_flag(&parsed, "version") ? {
                io.print("zenc version 0.1.0 (self-hosted)\n")
                core.exit(0)
            } : {}
            
            // Build configuration
            config := default_config()
            
            // Get input file
            DynVec.len(parsed.positional) > 0 ? {
                config.input_file = DynVec.get(parsed.positional, 0)
            } : {
                return Result<CompilerConfig, string>.Err("No input file specified")
            }
            
            // Get output file
            args.get_flag(&parsed, "output") ?
                | Option<string>.Some(out) {
                    config.output_file = Option<string>.Some(out)
                }
                | Option<string>.None {}
            }
            
            // Get optimization level
            args.get_flag(&parsed, "opt") ?
                | Option<string>.Some(level) {
                    config.optimization_level = string.parse_u8(level)
                }
                | Option<string>.None {}
            }
            
            // Get output type
            args.get_flag(&parsed, "type") ?
                | Option<string>.Some(t) {
                    t == "exe" ? { config.output_type = OutputType.Executable } :
                    t == "obj" ? { config.output_type = OutputType.ObjectFile } :
                    t == "asm" ? { config.output_type = OutputType.Assembly } :
                    t == "llvm" ? { config.output_type = OutputType.LLVMIR } :
                    { return Result<CompilerConfig, string>.Err("Invalid output type: " + t) }
                }
                | Option<string>.None {}
            }
            
            // Set boolean flags
            config.verbose = args.has_flag(&parsed, "verbose")
            config.debug_info = args.has_flag(&parsed, "debug")
            config.emit_llvm = args.has_flag(&parsed, "emit-llvm")
            config.check_only = args.has_flag(&parsed, "check")
            config.dump_ast = args.has_flag(&parsed, "dump-ast")
            config.dump_ir = args.has_flag(&parsed, "dump-ir")
            
            return Result<CompilerConfig, string>.Ok(config)
        }
        | Result<args.ParsedArgs, string>.Err(e) {
            return Result<CompilerConfig, string>.Err(e)
        }
    }
}

// Read source file
read_source = (path: string) Result<string, string>   {
    config.verbose ? {
        log.info("Reading source file: " + path)
    } : {}
    
    exists := fs.exists(path)
    !exists ? {
        return Result<string, string>.Err("File not found: " + path)
    } : {}
    
    content := fs.read_file(path)
    content ?
        | Result<string, string>.Ok(src) {
            return Result<string, string>.Ok(src)
        }
        | Result<string, string>.Err(e) {
            return Result<string, string>.Err("Failed to read file: " + e)
        }
    }
}

// Compile source code
compile = (config: &CompilerConfig, source: string) CompileResult   {
    timer := time.start_timer()
    
    config.verbose ? {
        log.info("Starting compilation...")
    } : {}
    
    // Phase 1: Lexical Analysis
    config.verbose ? {
        log.info("Phase 1: Lexical analysis...")
    } : {}
    
    tokens := lexer.tokenize(source)
    tokens ?
        | Result<DynVec<lexer.Token>, string>.Err(e) {
            return CompileResult.LexerError(e)
        }
        | Result<DynVec<lexer.Token>, string>.Ok(toks) {
            config.verbose ? {
                log.info("  Lexed " + int_to_string(DynVec.len(toks)) + " tokens")
            } : {}
        }
    }
    
    // Phase 2: Parsing
    config.verbose ? {
        log.info("Phase 2: Parsing...")
    } : {}
    
    ast := parser.parse(tokens.unwrap())
    ast ?
        | Result<parser.AstNode, string>.Err(e) {
            return CompileResult.ParserError(e)
        }
        | Result<parser.AstNode, string>.Ok(tree) {
            config.verbose ? {
                log.info("  Parse successful")
            } : {}
            
            config.dump_ast ? {
                io.print("\n=== AST ===\n")
                io.print(parser.ast_to_string(tree))
                io.print("\n")
            } : {}
        }
    }
    
    // Phase 3: Type Checking
    config.verbose ? {
        log.info("Phase 3: Type checking...")
    } : {}
    
    typed_ast := type_checker.check(ast.unwrap())
    typed_ast ?
        | Result<type_checker.TypedAst, string>.Err(e) {
            return CompileResult.TypeCheckError(e)
        }
        | Result<type_checker.TypedAst, string>.Ok(checked) {
            config.verbose ? {
                log.info("  Type check successful")
            } : {}
        }
    }
    
    // If check-only mode, stop here
    config.check_only ? {
        elapsed := time.stop_timer(&mut timer)
        config.verbose ? {
            log.info("Compilation time: " + time.format_duration(elapsed))
        } : {}
        return CompileResult.Success
    } : {}
    
    // Phase 4: Code Generation
    config.verbose ? {
        log.info("Phase 4: Code generation...")
    } : {}
    
    config.emit_llvm || config.output_type == OutputType.LLVMIR ? {
        // Generate LLVM IR
        module_name := get_module_name(config.input_file)
        gen := codegen_llvm.new_codegen(module_name)
        codegen_llvm.gen_module(&mut gen, typed_ast.unwrap().nodes)
        
        config.dump_ir || config.emit_llvm ? {
            io.print("\n=== LLVM IR ===\n")
            io.print(gen.output)
            io.print("\n")
        } : {}
        
        // Write LLVM IR to file if requested
        config.output_file ?
            | Option<string>.Some(out) {
                write_result := fs.write_file(out, gen.output)
                write_result ?
                    | Result<(), string>.Err(e) {
                        return CompileResult.FileError("Failed to write output: " + e)
                    }
                    | Result<(), string>.Ok(_) {
                        config.verbose ? {
                            log.info("Wrote LLVM IR to: " + out)
                        } : {}
                    }
                }
            }
            | Option<string>.None {}
        }
    } : {
        // Generate native code (would use LLVM backend)
        code := codegen.generate(typed_ast.unwrap())
        code ?
            | Result<string, string>.Err(e) {
                return CompileResult.CodeGenError(e)
            }
            | Result<string, string>.Ok(output) {
                config.verbose ? {
                    log.info("  Code generation successful")
                } : {}
                
                // Write output
                config.output_file ?
                    | Option<string>.Some(out) {
                        write_result := fs.write_file(out, output)
                        write_result ?
                            | Result<(), string>.Err(e) {
                                return CompileResult.FileError("Failed to write output: " + e)
                            }
                            | Result<(), string>.Ok(_) {
                                config.verbose ? {
                                    log.info("Wrote output to: " + out)
                                } : {}
                            }
                        }
                    }
                    | Option<string>.None {
                        // Default output file
                        default_out := get_default_output(config)
                        write_result := fs.write_file(default_out, output)
                        write_result ?
                            | Result<(), string>.Err(e) {
                                return CompileResult.FileError("Failed to write output: " + e)
                            }
                            | Result<(), string>.Ok(_) {
                                config.verbose ? {
                                    log.info("Wrote output to: " + default_out)
                                } : {}
                            }
                        }
                    }
                }
            }
        }
    }
    
    elapsed := time.stop_timer(&mut timer)
    config.verbose ? {
        log.info("Compilation successful!")
        log.info("Total time: " + time.format_duration(elapsed))
    } : {}
    
    return CompileResult.Success
}

// Get module name from file path
get_module_name = (path: string) string   {
    // Extract filename without extension
    last_slash := string.last_index_of(path, "/")
    filename := last_slash >= 0 ? {
        string.substring(path, last_slash + 1, string.len(path))
    } : {
        path
    }
    
    dot_pos := string.index_of(filename, ".")
    dot_pos >= 0 ? {
        return string.substring(filename, 0, dot_pos)
    } : {
        return filename
    }
}

// Get default output filename
get_default_output = (config: &CompilerConfig) string   {
    base_name := get_module_name(config.input_file)
    
    config.output_type ?
        | OutputType.Executable { return base_name }
        | OutputType.ObjectFile { return base_name + ".o" }
        | OutputType.Assembly { return base_name + ".s" }
        | OutputType.LLVMIR { return base_name + ".ll" }
    }
}

// Helper function
int_to_string = (n: i32) string   {
    n == 0 ? { return "0" } : {}
    n < 0 ? { return "-" + int_to_string(-n) } : {}
    n < 10 ? { return "" + (n + 48) as u8 } : {
        return int_to_string(n / 10) + int_to_string(n % 10)
    }
}

// Main entry point
main = (argc: i32, argv: DynVec<string>) i32   {
    // Configure logging
    log.set_level(log.LogLevel.Info)
    
    // Parse command line arguments
    config_result := parse_args(argv)
    
    config_result ?
        | Result<CompilerConfig, string>.Err(e) {
            log.error("Error: " + e)
            io.print("\nUse --help for usage information\n")
            return 1
        }
        | Result<CompilerConfig, string>.Ok(config) {
            // Set verbose logging if requested
            config.verbose ? {
                log.set_level(log.LogLevel.Debug)
            } : {}
            
            // Read source file
            source_result := read_source(config.input_file)
            
            source_result ?
                | Result<string, string>.Err(e) {
                    log.error(e)
                    return 1
                }
                | Result<string, string>.Ok(source) {
                    // Compile the source
                    result := compile(&config, source)
                    
                    result ?
                        | CompileResult.Success {
                            !config.verbose ? {
                                log.info("Compilation successful")
                            } : {}
                            return 0
                        }
                        | CompileResult.LexerError(e) {
                            log.error("Lexer error: " + e)
                            return 1
                        }
                        | CompileResult.ParserError(e) {
                            log.error("Parser error: " + e)
                            return 1
                        }
                        | CompileResult.TypeCheckError(e) {
                            log.error("Type error: " + e)
                            return 1
                        }
                        | CompileResult.CodeGenError(e) {
                            log.error("Code generation error: " + e)
                            return 1
                        }
                        | CompileResult.FileError(e) {
                            log.error("File error: " + e)
                            return 1
                        }
                    }
                }
            }
        }
    }
}