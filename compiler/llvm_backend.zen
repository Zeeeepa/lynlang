// Zen Language LLVM Backend
// Generates LLVM IR for high-performance compilation

core := @std.core
vec := @std.vec
string := @std.string
io := @std.io
mem := @std.mem
ast := @std.ast

// LLVM IR Builder context
LLVMContext := {
    module_name: string
    target_triple: string
    data_layout: string
    globals: Vec<LLVMGlobal>
    functions: Vec<LLVMFunction>
    types: Vec<LLVMType>
    current_block: Option<LLVMBlock>
    next_reg: u32
    string_constants: Vec<StringConstant>
}

// LLVM types
LLVMType := |
    Void
    I1
    I8
    I16
    I32
    I64
    F32
    F64
    Ptr(inner: Ptr<LLVMType>)
    Array(element: Ptr<LLVMType>, size: u64)
    Struct(fields: Vec<LLVMType>)
    Function(ret: Ptr<LLVMType>, params: Vec<LLVMType>)

// LLVM value representation
LLVMValue := |
    Register(id: u32)
    Constant(val: LLVMConstant)
    Global(name: string)
    Argument(index: u32)

// LLVM constants
LLVMConstant := |
    I1(val: bool)
    I8(val: i8)
    I16(val: i16)
    I32(val: i32)
    I64(val: i64)
    F32(val: f32)
    F64(val: f64)
    String(id: u32)
    Null
    Undef

// String constant tracking
StringConstant := {
    id: u32
    value: string
    global_name: string
}

// LLVM global variable
LLVMGlobal := {
    name: string
    type_: LLVMType
    initializer: Option<LLVMConstant>
    is_constant: bool
    linkage: string
}

// LLVM function
LLVMFunction := {
    name: string
    return_type: LLVMType
    params: Vec<LLVMParam>
    blocks: Vec<LLVMBlock>
    is_declaration: bool
    linkage: string
    attributes: Vec<string>
}

// Function parameter
LLVMParam := {
    name: string
    type_: LLVMType
}

// Basic block
LLVMBlock := {
    label: string
    instructions: Vec<LLVMInstruction>
    terminator: Option<LLVMTerminator>
}

// LLVM instructions
LLVMInstruction := |
    // Memory operations
    Alloca(dest: u32, type_: LLVMType, align: Option<u32>)
    Load(dest: u32, type_: LLVMType, ptr: LLVMValue, align: Option<u32>)
    Store(value: LLVMValue, ptr: LLVMValue, align: Option<u32>)
    
    // Arithmetic operations
    Add(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    Sub(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    Mul(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    SDiv(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    UDiv(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    SRem(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    URem(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    
    // Floating point operations
    FAdd(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    FSub(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    FMul(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    FDiv(dest: u32, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    
    // Comparison operations
    ICmp(dest: u32, cond: string, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    FCmp(dest: u32, cond: string, type_: LLVMType, lhs: LLVMValue, rhs: LLVMValue)
    
    // Conversion operations
    Trunc(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    ZExt(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    SExt(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    FPTrunc(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    FPExt(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    FPToUI(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    FPToSI(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    UIToFP(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    SIToFP(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    PtrToInt(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    IntToPtr(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    Bitcast(dest: u32, value: LLVMValue, from: LLVMType, to: LLVMType)
    
    // Other operations
    Call(dest: Option<u32>, func: string, ret_type: LLVMType, args: Vec<(LLVMType, LLVMValue)>)
    GetElementPtr(dest: u32, type_: LLVMType, ptr: LLVMValue, indices: Vec<LLVMValue>)
    Phi(dest: u32, type_: LLVMType, incoming: Vec<(LLVMValue, string)>)
    Select(dest: u32, cond: LLVMValue, true_val: LLVMValue, false_val: LLVMValue, type_: LLVMType)

// Block terminators
LLVMTerminator := |
    Ret(value: Option<LLVMValue>, type_: LLVMType)
    Br(target: string)
    CondBr(cond: LLVMValue, true_target: string, false_target: string)
    Switch(value: LLVMValue, default: string, cases: Vec<(LLVMConstant, string)>)
    Unreachable

// Create new LLVM context
new_context = (module_name: string) LLVMContext {
    return LLVMContext{
        module_name: module_name,
        target_triple: "x86_64-unknown-linux-gnu",
        data_layout: "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
        globals: vec.new<LLVMGlobal>(),
        functions: vec.new<LLVMFunction>(),
        types: vec.new<LLVMType>(),
        current_block: Option<LLVMBlock>.None,
        next_reg: 0,
        string_constants: vec.new<StringConstant>()
    }
}

// Get next register ID
next_register = (ctx: Ptr<LLVMContext>) u32 {
    reg := ctx.next_reg
    ctx.next_reg += 1
    return reg
}

// Convert Zen type to LLVM type
zen_type_to_llvm = (zen_type: Ptr<ast.AstType>) LLVMType {
    match zen_type {
        ast.AstType.Basic(name) => {
            if (string.equals(name, "void")) return LLVMType.Void
            if (string.equals(name, "bool")) return LLVMType.I1
            if (string.equals(name, "i8")) return LLVMType.I8
            if (string.equals(name, "i16")) return LLVMType.I16
            if (string.equals(name, "i32")) return LLVMType.I32
            if (string.equals(name, "i64")) return LLVMType.I64
            if (string.equals(name, "f32")) return LLVMType.F32
            if (string.equals(name, "f64")) return LLVMType.F64
            if (string.equals(name, "u8")) return LLVMType.I8
            if (string.equals(name, "u16")) return LLVMType.I16
            if (string.equals(name, "u32")) return LLVMType.I32
            if (string.equals(name, "u64")) return LLVMType.I64
            return LLVMType.I32  // Default
        }
        ast.AstType.Pointer(inner) => {
            inner_type := zen_type_to_llvm(inner)
            return LLVMType.Ptr(mem.alloc<LLVMType>(inner_type))
        }
        ast.AstType.Array(elem, size) => {
            elem_type := zen_type_to_llvm(elem)
            return LLVMType.Array(mem.alloc<LLVMType>(elem_type), size)
        }
        _ => LLVMType.I32  // Default for unhandled types
    }
}

// Add string constant
add_string_constant = (ctx: Ptr<LLVMContext>, value: string) u32 {
    id := ctx.string_constants.len()
    global_name := string.format("@.str.{}", id)
    
    constant := StringConstant{
        id: id,
        value: value,
        global_name: global_name
    }
    
    vec.push(ctx.string_constants, constant)
    return id
}

// Generate LLVM IR for expression
generate_expression = (ctx: Ptr<LLVMContext>, expr: Ptr<ast.AstExpr>) LLVMValue {
    match expr {
        ast.AstExpr.IntLiteral(val) => {
            return LLVMValue.Constant(LLVMConstant.I32(val))
        }
        ast.AstExpr.FloatLiteral(val) => {
            return LLVMValue.Constant(LLVMConstant.F64(val))
        }
        ast.AstExpr.BoolLiteral(val) => {
            return LLVMValue.Constant(LLVMConstant.I1(val))
        }
        ast.AstExpr.StringLiteral(val) => {
            id := add_string_constant(ctx, val)
            return LLVMValue.Constant(LLVMConstant.String(id))
        }
        ast.AstExpr.Identifier(name) => {
            // Look up variable/function
            return LLVMValue.Global(name)
        }
        ast.AstExpr.Binary(op, lhs, rhs) => {
            lhs_val := generate_expression(ctx, lhs)
            rhs_val := generate_expression(ctx, rhs)
            dest := next_register(ctx)
            
            // Generate appropriate instruction based on operator
            instruction := match op {
                "+" => LLVMInstruction.Add(dest, LLVMType.I32, lhs_val, rhs_val)
                "-" => LLVMInstruction.Sub(dest, LLVMType.I32, lhs_val, rhs_val)
                "*" => LLVMInstruction.Mul(dest, LLVMType.I32, lhs_val, rhs_val)
                "/" => LLVMInstruction.SDiv(dest, LLVMType.I32, lhs_val, rhs_val)
                _ => LLVMInstruction.Add(dest, LLVMType.I32, lhs_val, rhs_val)
            }
            
            // Add instruction to current block
            if (ctx.current_block) {
                match ctx.current_block {
                    Option.Some(block) => vec.push(block.instructions, instruction)
                    _ => {}
                }
            }
            
            return LLVMValue.Register(dest)
        }
        _ => LLVMValue.Constant(LLVMConstant.I32(0))  // Default
    }
}

// Generate LLVM IR for statement
generate_statement = (ctx: Ptr<LLVMContext>, stmt: Ptr<ast.AstStmt>) void {
    match stmt {
        ast.AstStmt.Expression(expr) => {
            generate_expression(ctx, expr)
        }
        ast.AstStmt.Return(expr) => {
            if (expr) {
                val := generate_expression(ctx, expr)
                terminator := LLVMTerminator.Ret(Option.Some(val), LLVMType.I32)
                
                if (ctx.current_block) {
                    match ctx.current_block {
                        Option.Some(block) => block.terminator = Option.Some(terminator)
                        _ => {}
                    }
                }
            } else {
                terminator := LLVMTerminator.Ret(Option.None, LLVMType.Void)
                
                if (ctx.current_block) {
                    match ctx.current_block {
                        Option.Some(block) => block.terminator = Option.Some(terminator)
                        _ => {}
                    }
                }
            }
        }
        _ => {}
    }
}

// Generate LLVM IR for function
generate_function = (ctx: Ptr<LLVMContext>, func: Ptr<ast.AstFunction>) void {
    // Convert parameters
    params := vec.new<LLVMParam>()
    for (i := 0; i < func.params.len(); i += 1) {
        param := func.params[i]
        llvm_type := zen_type_to_llvm(param.type_)
        llvm_param := LLVMParam{
            name: param.name,
            type_: llvm_type
        }
        vec.push(params, llvm_param)
    }
    
    // Convert return type
    ret_type := zen_type_to_llvm(func.return_type)
    
    // Create entry block
    entry_block := LLVMBlock{
        label: "entry",
        instructions: vec.new<LLVMInstruction>(),
        terminator: Option.None
    }
    
    // Create function
    llvm_func := LLVMFunction{
        name: func.name,
        return_type: ret_type,
        params: params,
        blocks: vec.new<LLVMBlock>(),
        is_declaration: false,
        linkage: "define",
        attributes: vec.new<string>()
    }
    
    vec.push(llvm_func.blocks, entry_block)
    ctx.current_block = Option.Some(llvm_func.blocks[0])
    
    // Generate body
    for (i := 0; i < func.body.len(); i += 1) {
        generate_statement(ctx, func.body[i])
    }
    
    // Add default return if needed
    if (ctx.current_block) {
        match ctx.current_block {
            Option.Some(block) => {
                if (!block.terminator) {
                    block.terminator = Option.Some(LLVMTerminator.Ret(Option.None, LLVMType.Void))
                }
            }
            _ => {}
        }
    }
    
    vec.push(ctx.functions, llvm_func)
    ctx.current_block = Option.None
}

// Emit LLVM IR to string
emit_type = (type_: LLVMType) string {
    match type_ {
        LLVMType.Void => "void"
        LLVMType.I1 => "i1"
        LLVMType.I8 => "i8"
        LLVMType.I16 => "i16"
        LLVMType.I32 => "i32"
        LLVMType.I64 => "i64"
        LLVMType.F32 => "float"
        LLVMType.F64 => "double"
        LLVMType.Ptr(inner) => {
            inner_str := emit_type(*inner)
            return string.format("{}*", inner_str)
        }
        LLVMType.Array(elem, size) => {
            elem_str := emit_type(*elem)
            return string.format("[{} x {}]", size, elem_str)
        }
        _ => "i32"
    }
}

// Emit value
emit_value = (val: LLVMValue) string {
    match val {
        LLVMValue.Register(id) => string.format("%{}", id)
        LLVMValue.Global(name) => string.format("@{}", name)
        LLVMValue.Argument(idx) => string.format("%{}", idx)
        LLVMValue.Constant(c) => {
            match c {
                LLVMConstant.I32(v) => string.format("{}", v)
                LLVMConstant.I64(v) => string.format("{}", v)
                LLVMConstant.F32(v) => string.format("{}", v)
                LLVMConstant.F64(v) => string.format("{}", v)
                LLVMConstant.I1(v) => if (v) "true" else "false"
                LLVMConstant.String(id) => string.format("@.str.{}", id)
                LLVMConstant.Null => "null"
                LLVMConstant.Undef => "undef"
                _ => "0"
            }
        }
    }
}

// Emit instruction
emit_instruction = (inst: LLVMInstruction, out: Ptr<string>) void {
    match inst {
        LLVMInstruction.Add(dest, type_, lhs, rhs) => {
            type_str := emit_type(type_)
            lhs_str := emit_value(lhs)
            rhs_str := emit_value(rhs)
            string.append(out, string.format("  %{} = add {} {}, {}\n", dest, type_str, lhs_str, rhs_str))
        }
        LLVMInstruction.Sub(dest, type_, lhs, rhs) => {
            type_str := emit_type(type_)
            lhs_str := emit_value(lhs)
            rhs_str := emit_value(rhs)
            string.append(out, string.format("  %{} = sub {} {}, {}\n", dest, type_str, lhs_str, rhs_str))
        }
        LLVMInstruction.Mul(dest, type_, lhs, rhs) => {
            type_str := emit_type(type_)
            lhs_str := emit_value(lhs)
            rhs_str := emit_value(rhs)
            string.append(out, string.format("  %{} = mul {} {}, {}\n", dest, type_str, lhs_str, rhs_str))
        }
        LLVMInstruction.Call(dest, func, ret_type, args) => {
            ret_str := emit_type(ret_type)
            
            if (dest) {
                match dest {
                    Option.Some(d) => {
                        string.append(out, string.format("  %{} = call {} @{}(", d, ret_str, func))
                    }
                    _ => {
                        string.append(out, string.format("  call {} @{}(", ret_str, func))
                    }
                }
            } else {
                string.append(out, string.format("  call {} @{}(", ret_str, func))
            }
            
            for (i := 0; i < args.len(); i += 1) {
                if (i > 0) string.append(out, ", ")
                arg := args[i]
                type_str := emit_type(arg.0)
                val_str := emit_value(arg.1)
                string.append(out, string.format("{} {}", type_str, val_str))
            }
            
            string.append(out, ")\n")
        }
        _ => {}
    }
}

// Emit terminator
emit_terminator = (term: LLVMTerminator, out: Ptr<string>) void {
    match term {
        LLVMTerminator.Ret(val, type_) => {
            if (val) {
                match val {
                    Option.Some(v) => {
                        type_str := emit_type(type_)
                        val_str := emit_value(v)
                        string.append(out, string.format("  ret {} {}\n", type_str, val_str))
                    }
                    _ => string.append(out, "  ret void\n")
                }
            } else {
                string.append(out, "  ret void\n")
            }
        }
        LLVMTerminator.Br(target) => {
            string.append(out, string.format("  br label %{}\n", target))
        }
        LLVMTerminator.CondBr(cond, true_target, false_target) => {
            cond_str := emit_value(cond)
            string.append(out, string.format("  br i1 {}, label %{}, label %{}\n", 
                                            cond_str, true_target, false_target))
        }
        _ => {}
    }
}

// Generate complete LLVM IR module
generate_module = (ctx: Ptr<LLVMContext>) string {
    output := string.new()
    
    // Module header
    string.append(output, "; ModuleID = '")
    string.append(output, ctx.module_name)
    string.append(output, "'\n")
    string.append(output, "source_filename = \"")
    string.append(output, ctx.module_name)
    string.append(output, "\"\n")
    string.append(output, "target datalayout = \"")
    string.append(output, ctx.data_layout)
    string.append(output, "\"\n")
    string.append(output, "target triple = \"")
    string.append(output, ctx.target_triple)
    string.append(output, "\"\n\n")
    
    // String constants
    for (i := 0; i < ctx.string_constants.len(); i += 1) {
        constant := ctx.string_constants[i]
        len := string.length(constant.value) + 1  // +1 for null terminator
        string.append(output, string.format("{} = private unnamed_addr constant [{} x i8] c\"{}\\00\"\n",
                                           constant.global_name, len, constant.value))
    }
    
    if (ctx.string_constants.len() > 0) {
        string.append(output, "\n")
    }
    
    // Global variables
    for (i := 0; i < ctx.globals.len(); i += 1) {
        global := ctx.globals[i]
        type_str := emit_type(global.type_)
        
        string.append(output, "@")
        string.append(output, global.name)
        string.append(output, " = ")
        string.append(output, global.linkage)
        string.append(output, " ")
        
        if (global.is_constant) {
            string.append(output, "constant ")
        } else {
            string.append(output, "global ")
        }
        
        string.append(output, type_str)
        
        if (global.initializer) {
            match global.initializer {
                Option.Some(init) => {
                    string.append(output, " ")
                    string.append(output, emit_value(LLVMValue.Constant(init)))
                }
                _ => string.append(output, " zeroinitializer")
            }
        } else {
            string.append(output, " zeroinitializer")
        }
        
        string.append(output, "\n")
    }
    
    if (ctx.globals.len() > 0) {
        string.append(output, "\n")
    }
    
    // External declarations
    string.append(output, "; External declarations\n")
    string.append(output, "declare i32 @printf(i8*, ...)\n")
    string.append(output, "declare i8* @malloc(i64)\n")
    string.append(output, "declare void @free(i8*)\n")
    string.append(output, "declare void @exit(i32)\n\n")
    
    // Functions
    for (i := 0; i < ctx.functions.len(); i += 1) {
        func := ctx.functions[i]
        
        // Function signature
        string.append(output, func.linkage)
        string.append(output, " ")
        string.append(output, emit_type(func.return_type))
        string.append(output, " @")
        string.append(output, func.name)
        string.append(output, "(")
        
        for (j := 0; j < func.params.len(); j += 1) {
            if (j > 0) string.append(output, ", ")
            param := func.params[j]
            string.append(output, emit_type(param.type_))
            string.append(output, " %")
            string.append(output, param.name)
        }
        
        string.append(output, ")")
        
        // Function attributes
        for (j := 0; j < func.attributes.len(); j += 1) {
            string.append(output, " ")
            string.append(output, func.attributes[j])
        }
        
        if (func.is_declaration) {
            string.append(output, "\n")
        } else {
            string.append(output, " {\n")
            
            // Function body
            for (j := 0; j < func.blocks.len(); j += 1) {
                block := func.blocks[j]
                
                // Block label
                if (j > 0) {
                    string.append(output, block.label)
                    string.append(output, ":\n")
                }
                
                // Instructions
                for (k := 0; k < block.instructions.len(); k += 1) {
                    emit_instruction(block.instructions[k], output)
                }
                
                // Terminator
                if (block.terminator) {
                    match block.terminator {
                        Option.Some(term) => emit_terminator(term, output)
                        _ => {}
                    }
                }
            }
            
            string.append(output, "}\n")
        }
        
        string.append(output, "\n")
    }
    
    return output
}

// Generate LLVM IR from AST
generate_llvm_from_ast = (ast: Ptr<ast.AstProgram>, module_name: string) string {
    ctx := new_context(module_name)
    
    // Process all top-level declarations
    for (i := 0; i < ast.declarations.len(); i += 1) {
        decl := ast.declarations[i]
        
        match decl {
            ast.AstDecl.Function(func) => {
                generate_function(ctx, func)
            }
            ast.AstDecl.Global(name, type_, init) => {
                llvm_type := zen_type_to_llvm(type_)
                
                global := LLVMGlobal{
                    name: name,
                    type_: llvm_type,
                    initializer: Option.None,
                    is_constant: false,
                    linkage: "global"
                }
                
                vec.push(ctx.globals, global)
            }
            _ => {}
        }
    }
    
    return generate_module(ctx)
}

// Write LLVM IR to file
write_llvm_ir = (ir: string, output_path: string) bool {
    file := io.open(output_path, "w")
    if (!file) {
        io.print("Error: Could not open output file\n")
        return false
    }
    
    io.write(file, ir)
    io.close(file)
    return true
}

// Compile LLVM IR to native code using llc
compile_to_native = (ir_path: string, output_path: string, opt_level: string) bool {
    // Use llc to compile LLVM IR to assembly
    asm_path := string.replace(output_path, ".o", ".s")
    llc_cmd := string.format("llc -{} -filetype=asm {} -o {}", opt_level, ir_path, asm_path)
    
    if (!io.system(llc_cmd)) {
        io.print("Error: Failed to compile LLVM IR to assembly\n")
        return false
    }
    
    // Use system assembler to create object file
    as_cmd := string.format("as {} -o {}", asm_path, output_path)
    
    if (!io.system(as_cmd)) {
        io.print("Error: Failed to assemble object file\n")
        return false
    }
    
    return true
}

// Link object files to create executable
link_executable = (obj_files: Vec<string>, output_path: string) bool {
    // Build linker command
    ld_cmd := string.format("cc -o {} ", output_path)
    
    for (i := 0; i < obj_files.len(); i += 1) {
        string.append(ld_cmd, obj_files[i])
        string.append(ld_cmd, " ")
    }
    
    // Add standard libraries
    string.append(ld_cmd, "-lm -lc")
    
    return io.system(ld_cmd)
}