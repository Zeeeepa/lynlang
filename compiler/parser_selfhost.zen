// Self-hosted Zen Parser
// Parses tokenized Zen source code into an AST

// Import standard modules
core := @std.core
build := @std.build

// AST Node Types
AstNodeType: Program
    | FunctionDecl
    | VariableDecl
    | StructDecl
    | EnumDecl
    | Statement
    | Expression
    | Type
    | Pattern
    | Import

// Expression types
ExprType: Literal
    | Identifier
    | BinaryOp
    | UnaryOp
    | Call
    | FieldAccess
    | Index
    | Match
    | If
    | Block
    | Lambda
    | Struct
    | Array

// Statement types
StmtType: Expression
    | Return
    | Break
    | Continue
    | Loop
    | Assignment
    | Declaration

// Type kinds
TypeKind: Basic      // i32, f64, bool, etc
    | Pointer
    | Array
    | Slice
    | Function
    | Struct
    | Enum
    | Generic

// Basic AST nodes
AstNode: {
    type_: AstNodeType,
    line: i32,
    column: i32,
}

// Program node - root of AST
ProgramNode: {
    base: AstNode,
    imports: [ImportNode; 100],  // Fixed size array for now
    declarations: [DeclNode; 100],  // Fixed size array for now
    import_count: i32,
    decl_count: i32,
}

// Import node
ImportNode: {
    base: AstNode,
    alias: *i8,
    module_path: *i8,
}

// Declaration node
DeclNode: {
    base: AstNode,
    name: *i8,
    exported: bool,
}

// Function declaration
FunctionDecl: {
    decl: DeclNode,
    params: [ParamNode; 10],  // Fixed size array
    param_count: i32,
    return_type: TypeNode,
    body: BlockExpr,
    is_generic: bool,
}

// Parameter node
ParamNode: {
    name: *i8,
    type_: TypeNode,
    is_comptime: bool,
}

// Variable declaration
VariableDecl: {
    decl: DeclNode,
    type_: TypeNode,
    initializer: ExprNode,
    is_mutable: bool,
}

// Struct declaration
StructDecl: {
    decl: DeclNode,
    fields: [FieldNode; 20],  // Fixed size array
    field_count: i32,
    generics: [*i8; 10],  // Fixed size array
    generic_count: i32,
}

// Field node
FieldNode: {
    name: *i8,
    type_: TypeNode,
    default_value: ExprNode,
}

// Enum declaration
EnumDecl: {
    decl: DeclNode,
    variants: [VariantNode; 20],  // Fixed size array
    variant_count: i32,
    generics: [*i8; 10],  // Fixed size array
    generic_count: i32,
}

// Variant node
VariantNode: {
    name: *i8,
    fields: [FieldNode; 10],  // Fixed size array
    field_count: i32,
}

// Type node
TypeNode: {
    base: AstNode,
    kind: TypeKind,
    name: *i8,
}

// Expression node
ExprNode: {
    base: AstNode,
    expr_type: ExprType,
}

// Literal expression
LiteralExpr: {
    expr: ExprNode,
    value: *i8,
    literal_type: TypeNode,
}

// Binary operation
BinaryExpr: {
    expr: ExprNode,
    left: ExprNode,
    right: ExprNode,
    operator: *i8,
}

// Unary operation
UnaryExpr: {
    expr: ExprNode,
    operand: ExprNode,
    operator: *i8,
}

// Function call
CallExpr: {
    expr: ExprNode,
    function: ExprNode,
    arguments: [ExprNode; 20],  // Fixed size array
    arg_count: i32,
}

// Field access
FieldAccessExpr: {
    expr: ExprNode,
    object: ExprNode,
    field: *i8,
}

// If expression
IfExpr: {
    expr: ExprNode,
    condition: ExprNode,
    then_branch: ExprNode,
    else_branch: ExprNode,
}

// Block expression
BlockExpr: {
    expr: ExprNode,
    statements: [StmtNode; 50],  // Fixed size array
    stmt_count: i32,
    result_expr: ExprNode,
}

// Match expression
MatchExpr: {
    expr: ExprNode,
    scrutinee: ExprNode,
    arms: [MatchArm; 20],  // Fixed size array
    arm_count: i32,
}

// Match arm
MatchArm: {
    pattern: PatternNode,
    guard: ExprNode,
    body: ExprNode,
}

// Pattern node
PatternNode: {
    base: AstNode,
    pattern_type: PatternType,
}

// Pattern types
PatternType: Wildcard
    | Literal
    | Identifier
    | Struct
    | Enum
    | Range
    | Or

// Statement node
StmtNode: {
    base: AstNode,
    stmt_type: StmtType,
}

// Parser state
Parser: {
    tokens: [Token; 1000],  // Fixed size array
    current: i32,
    token_count: i32,
}

// Token (from lexer)
Token: {
    type_: i32,  // TokenType
    value: *i8,
    line: i32,
    column: i32,
}

// Create a new parser
parser_new: (tokens: [Token; 1000], count: i32) Parser  = {
    return Parser {
        tokens: tokens,
        current: 0,
        token_count: count,
    }
}

// Check if at end of tokens
is_at_end: (parser: Parser) bool  = {
    return parser.current >= parser.token_count
}

// Get current token
current_token: (parser: Parser) Token  = {
    parser.current < parser.token_count ?
        | true => return parser.tokens[parser.current]
        | false => {
            // Return EOF token
            return Token {
                type_: 0,  // EOF
                value: 0,
                line: 0,
                column: 0,
            }
        }
}

// Advance to next token
advance: (parser: *Parser) Token  = {
    current := current_token(*parser)
    parser.current = parser.current + 1
    return current
}

// Peek at next token
peek: (parser: Parser) Token  = {
    next_pos := parser.current + 1
    next_pos < parser.token_count ?
        | true => return parser.tokens[next_pos]
        | false => {
            return Token {
                type_: 0,  // EOF
                value: 0,
                line: 0,
                column: 0,
            }
        }
}

// Check if current token matches type
check: (parser: Parser, type_: i32) bool  = {
    is_at_end(parser) ?
        | true => return false
        | false => return current_token(parser).type_ == type_
}

// Consume token of expected type
consume: (parser: *Parser, type_: i32, message: *i8) Token  = {
    check(*parser, type_) ?
        | true => return advance(parser)
        | false => {
            // Error: expected token not found
            // In real implementation, would report error
            return current_token(*parser)
        }
}

// Parse program (entry point)
parse_program: (parser: *Parser) ProgramNode  = {
    program := ProgramNode {
        base: AstNode {
            type_: AstNodeType:Program,
            line: 1,
            column: 1,
        },
        imports: [ImportNode; 100]{},
        declarations: [DeclNode; 100]{},
        import_count: 0,
        decl_count: 0,
    }
    
    // Parse imports and declarations
    loop {
        is_at_end(*parser) ?
            | true => break
            | false => {
                // Check for import
                current := current_token(*parser)
                
                // Simple import detection (would need proper implementation)
                // For now, just consume tokens
                advance(parser)
            }
    }
    
    return program
}

// Parse import statement
parse_import: (parser: *Parser) ImportNode  = {
    // alias := @std.module or alias := build.import("module")
    
    import := ImportNode {
        base: AstNode {
            type_: AstNodeType:Import,
            line: current_token(*parser).line,
            column: current_token(*parser).column,
        },
        alias: 0,
        module_path: 0,
    }
    
    // Parse alias
    alias_token := consume(parser, 1, "Expected identifier")  // Identifier type
    import.alias = alias_token.value
    
    // Consume :=
    consume(parser, 2, "Expected :=")  // ColonEqual type
    
    // Parse module path
    // Could be @std.module or build.import("module")
    // Simplified for now
    
    return import
}

// Parse function declaration
parse_function: (parser: *Parser) FunctionDecl  = {
    func := FunctionDecl {
        decl: DeclNode {
            base: AstNode {
                type_: AstNodeType:FunctionDecl,
                line: current_token(*parser).line,
                column: current_token(*parser).column,
            },
            name: 0,
            exported: false,
        },
        params: [ParamNode; 10]{},
        param_count: 0,
        return_type: TypeNode{},
        body: BlockExpr{},
        is_generic: false,
    }
    
    // Parse function name
    name_token := consume(parser, 1, "Expected function name")  // Identifier
    func.decl.name = name_token.value
    
    // Parse = or generic params
    current := current_token(*parser)
    
    // Parse parameter list and body
    // Simplified for now
    
    return func
}

// Parse expression
parse_expression: (parser: *Parser) ExprNode  = {
    // Start with primary expression
    return parse_primary(parser)
}

// Parse primary expression
parse_primary: (parser: *Parser) ExprNode  = {
    current := current_token(*parser)
    
    // Check for literals
    // Simplified - would need full implementation
    
    expr := ExprNode {
        base: AstNode {
            type_: AstNodeType:Expression,
            line: current.line,
            column: current.column,
        },
        expr_type: ExprType:Literal,
    }
    
    advance(parser)
    return expr
}

// Parse type
parse_type: (parser: *Parser) TypeNode  = {
    type_node := TypeNode {
        base: AstNode {
            type_: AstNodeType:Type,
            line: current_token(*parser).line,
            column: current_token(*parser).column,
        },
        kind: TypeKind:Basic,
        name: 0,
    }
    
    // Parse type name
    // Simplified for now
    
    return type_node
}

// Export public functions
export {
    AstNodeType,
    ExprType,
    StmtType,
    TypeKind,
    PatternType,
    AstNode,
    ProgramNode,
    ImportNode,
    DeclNode,
    FunctionDecl,
    VariableDecl,
    StructDecl,
    EnumDecl,
    TypeNode,
    ExprNode,
    StmtNode,
    PatternNode,
    Parser,
    parser_new,
    parse_program,
    parse_import,
    parse_function,
    parse_expression,
    parse_type,
}