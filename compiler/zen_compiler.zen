// Zen Self-Hosted Compiler
// Main entry point for the Zen compiler written in Zen

// Imports - using correct syntax without comptime
core = @std.core
io = @std.io
fs = @std.fs
process = @std.process
string = @std.string

// Import compiler modules
lexer = @std.lexer
parser = @std.parser
type_checker = @std.type_checker
codegen = @std.codegen
llvm_backend = @std.llvm_backend

// Compiler version
VERSION := "1.0.0"

// Compilation options
CompilerOptions: {
    input_file: string,
    output_file: string,
    emit_type: EmitType,
    optimize: bool,
    debug: bool,
    verbose: bool,
    target: string,
    stdlib_path: string,
}

// What kind of output to emit
EmitType: 
    Binary,
    LLVM_IR,
    AST,
    C_Code,

// Compilation result
CompilationResult: 
    Success,
    LexerError -> msg: string,
    ParserError -> msg: string,
    TypeError -> msg: string,
    CodegenError -> msg: string,
    IOError -> msg: string,

// Main compiler driver
compile = (options: CompilerOptions) CompilationResult   {
    options.verbose ? | true {
        io.print("Zen Compiler v$(VERSION)\n");
        io.print("Compiling: $(options.input_file)\n");
    }
    
    // Read source file
    source := fs.read_file(options.input_file) ? 
        | .Ok -> content { content }
        | .Err -> err { return .IOError -> msg: "Failed to read file: $(err)" }
    
    // Lexical analysis
    options.verbose ? | true { io.print("Lexing...\n") }
    tokens := lexer.tokenize(source) ?
        | .Ok -> toks { toks }
        | .Err -> err { return .LexerError -> msg: err }
    
    // Parsing
    options.verbose ? | true { io.print("Parsing...\n") }
    ast := parser.parse(tokens) ?
        | .Ok -> tree { tree }
        | .Err -> err { return .ParserError -> msg: err }
    
    // Early exit if just dumping AST
    options.emit_type ? | .AST {
        dump_ast(ast, options.output_file);
        return .Success
    }
    
    // Type checking
    options.verbose ? | true { io.print("Type checking...\n") }
    typed_ast := type_checker.check(ast) ?
        | .Ok -> tree { tree }
        | .Err -> err { return .TypeError -> msg: err }
    
    // Code generation
    options.verbose ? | true { io.print("Generating code...\n") }
    
    result := options.emit_type ?
        | .C_Code {
            code := codegen.generate_c(typed_ast);
            fs.write_file(options.output_file, code) ?
                | .Ok { .Success }
                | .Err -> err { .IOError -> msg: "Failed to write output: $(err)" }
        }
        | .LLVM_IR {
            ir := llvm_backend.generate_ir(typed_ast);
            fs.write_file(options.output_file, ir) ?
                | .Ok { .Success }
                | .Err -> err { .IOError -> msg: "Failed to write output: $(err)" }
        }
        | .Binary {
            // Generate LLVM IR then compile to binary
            ir := llvm_backend.generate_ir(typed_ast);
            llvm_backend.compile_to_binary(ir, options) ?
                | .Ok { .Success }
                | .Err -> err { .CodegenError -> msg: err }
        }
    
    options.verbose ? | true { io.print("Compilation successful!\n") }
    
    return result
}

// AST dumper for debugging
dump_ast = (ast: AST, output_file: string) void   {
    json := ast.to_json();
    fs.write_file(output_file, json) ?
        | .Err -> err { io.error("Failed to write AST: $(err)\n") }
}

// Parse command line arguments
parse_args = (args: []string) Result<CompilerOptions, string>   {
    args.len < 2 ? | true { return .Err -> "Usage: zenc <input.zen> [options]" }
    
    options := CompilerOptions {
        input_file: args[1],
        output_file: "a.out",
        emit_type: .Binary,
        optimize: false,
        debug: false,
        verbose: false,
        target: "native",
        stdlib_path: "/usr/local/lib/zen/stdlib",
    }
    
    i := 2;
    loop i < args.len {
        arg := args[i];
        
        arg ?
            | "-o" | "--output" {
                i += 1;
                i >= args.len ? | true { return .Err -> "Expected output file after -o" }
                options.output_file = args[i]
            }
            | "--emit-llvm" { options.emit_type = .LLVM_IR }
            | "--emit-c" { options.emit_type = .C_Code }
            | "--emit-ast" { options.emit_type = .AST }
            | "-O" | "--optimize" { options.optimize = true }
            | "-g" | "--debug" { options.debug = true }
            | "-v" | "--verbose" { options.verbose = true }
            | "--target" {
                i += 1;
                i >= args.len ? | true { return .Err -> "Expected target after --target" }
                options.target = args[i]
            }
            | "--stdlib" {
                i += 1;
                i >= args.len ? | true { return .Err -> "Expected path after --stdlib" }
                options.stdlib_path = args[i]
            }
            | "-h" | "--help" {
                print_help();
                process.exit(0)
            }
            | _ { return .Err -> "Unknown option: $(arg)" }
        
        i += 1
    }
    
    return .Ok -> options
}

// Print help message
print_help = () void   {
    io.print("Zen Compiler v$(VERSION)\n");
    io.print("Usage: zenc <input.zen> [options]\n\n");
    io.print("Options:\n");
    io.print("  -o, --output <file>    Output file (default: a.out)\n");
    io.print("  --emit-llvm            Emit LLVM IR instead of binary\n");
    io.print("  --emit-c               Emit C code instead of binary\n");
    io.print("  --emit-ast             Emit AST as JSON\n");
    io.print("  -O, --optimize         Enable optimizations\n");
    io.print("  -g, --debug            Include debug information\n");
    io.print("  -v, --verbose          Verbose output\n");
    io.print("  --target <target>      Target architecture\n");
    io.print("  --stdlib <path>        Path to standard library\n");
    io.print("  -h, --help             Show this help message\n")
}

// Main entry point
main = (args: []string) i32   {
    // Parse command line arguments
    options := parse_args(args) ?
        | .Ok -> opts { opts }
        | .Err -> msg {
            io.error("$(msg)\n");
            return 1
        }
    
    // Run the compiler
    result := compile(options);
    
    result ?
        | .Success { return 0 }
        | .LexerError -> msg { io.error("Lexer error: $(msg)\n") }
        | .ParserError -> msg { io.error("Parser error: $(msg)\n") }
        | .TypeError -> msg { io.error("Type error: $(msg)\n") }
        | .CodegenError -> msg { io.error("Codegen error: $(msg)\n") }
        | .IOError -> msg { io.error("I/O error: $(msg)\n") }
    
    return 1
}