// Self-hosted Zen Compiler Error Handling
// Enhanced error reporting with detailed diagnostics
// Compliant with Language Spec v1.1.0

// Option and Result types
Option<T>:
    Some(value: T)
    | None

// Import collections
{ Vec, DynVec } = @std

Ptr<T> = {
    value: T,
    address: usize,
}

// Source location information
SourceLocation: {
    file: string,
    line: u32,
    column: u32,
    offset: u32,
}

// Error severity levels
ErrorSeverity: Error
    | Warning
    | Info
    | Hint

// Error categories
ErrorCategory: Syntax
    | Type
    | Semantic
    | Import
    | Comptime
    | Internal

// Diagnostic information
Diagnostic: {
    severity: ErrorSeverity,
    category: ErrorCategory,
    message: string,
    location: SourceLocation,
    notes: DynVec<string>,
    suggestion: Option<string>,
    code_snippet: Option<string>,
}

// Error context for better reporting
ErrorContext: {
    source_file: string,
    source_content: string,
    diagnostics: DynVec<Diagnostic>,
    error_count: u32,
    warning_count: u32,
}

// Create a new error context
create_context = (file: string, content: string) ErrorContext {
    ErrorContext {
        source_file: file,
        source_content: content,
        diagnostics: DynVec.new(),
        error_count: 0,
        warning_count: 0,
    }
}

// Add a diagnostic to the context
add_diagnostic = (ctx: Ptr<ErrorContext>, diag: Diagnostic) void {
    ctx.val.diagnostics.push(diag)
    
    diag.severity ?
        | Error { ctx.val.error_count = ctx.val.error_count + 1 }
        | Warning { ctx.val.warning_count = ctx.val.warning_count + 1 }
        | _ {}
}

// Create a syntax error
syntax_error = (message: string, loc: SourceLocation) Diagnostic {
    Diagnostic {
        severity: ErrorSeverity.Error,
        category: ErrorCategory.Syntax,
        message: message,
        location: loc,
        notes: DynVec.new(),
        suggestion: None,
        code_snippet: None,
    }
}

// Create a type error
type_error = (message: string, loc: SourceLocation) Diagnostic {
    Diagnostic {
        severity: ErrorSeverity.Error,
        category: ErrorCategory.Type,
        message: message,
        location: loc,
        notes: DynVec.new(),
        suggestion: None,
        code_snippet: None,
    }
}

// Create an import error
import_error = (message: string, loc: SourceLocation) Diagnostic {
    Diagnostic {
        severity: ErrorSeverity.Error,
        category: ErrorCategory.Import,
        message: message,
        location: loc,
        notes: DynVec.new(),
        suggestion: None,
        code_snippet: None,
    }
}

// Create a warning
warning = (message: string, loc: SourceLocation) Diagnostic {
    Diagnostic {
        severity: ErrorSeverity.Warning,
        category: ErrorCategory.Semantic,
        message: message,
        location: loc,
        notes: DynVec.new(),
        suggestion: None,
        code_snippet: None,
    }
}

// Add a note to a diagnostic
add_note = (diag: Ptr<Diagnostic>, note: string) void {
    diag.val.notes.push(note)
}

// Add a suggestion to a diagnostic
add_suggestion = (diag: Ptr<Diagnostic>, suggestion: string) void {
    diag.val.suggestion = Some(suggestion)
}

// Extract code snippet around error location
extract_snippet = (content: string, loc: SourceLocation) string {
    lines := split_lines(content)
    
    (loc.line == 0 || loc.line > lines.len()) ?
        | true { "" }
        | false {
            line_idx := loc.line - 1
            line := lines[line_idx]
            
            // Create snippet with error marker
            line_num_str := format_u32(loc.line)
            snippet := concat(line_num_str, ": ")
            snippet = concat(snippet, line)
            snippet = concat(snippet, "\n")
            
            // Add pointer to error column
            prefix_len := string_len(line_num_str) + 2
            spaces := repeat_char(' ', loc.column + prefix_len - 1)
            snippet = concat(snippet, spaces)
            concat(snippet, "^")
        }
}

// Format severity for display
format_severity = (severity: ErrorSeverity) string {
    severity ?
        | Error { "error" }
        | Warning { "warning" }
        | Info { "info" }
        | Hint { "hint" }
}

// Format category for display
format_category = (category: ErrorCategory) string {
    category ?
        | Syntax { "syntax" }
        | Type { "type" }
        | Semantic { "semantic" }
        | Import { "import" }
        | Comptime { "comptime" }
        | Internal { "internal" }
}

// Format a diagnostic for display
format_diagnostic = (diag: Diagnostic) string {
    // Format: file:line:column: severity[category]: message
    result := concat(diag.location.file, ":")
    result = concat(result, format_u32(diag.location.line))
    result = concat(result, ":")
    result = concat(result, format_u32(diag.location.column))
    result = concat(result, ": ")
    result = concat(result, format_severity(diag.severity))
    result = concat(result, "[")
    result = concat(result, format_category(diag.category))
    result = concat(result, "]: ")
    result = concat(result, diag.message)
    
    // Add code snippet if available
    diag.code_snippet ?
        | Some(snippet) {
            result = concat(result, "\n")
            result = concat(result, snippet)
        }
        | None {}
    
    // Add notes
    (diag.notes.len() > 0) ?
        | true {
            (0..diag.notes.len()).loop((i) {
                result = concat(result, "\n  note: ")
                result = concat(result, diag.notes[i])
            })
        }
        | false {}
    
    // Add suggestion
    diag.suggestion ?
        | Some(sugg) {
            result = concat(result, "\n  suggestion: ")
            result = concat(result, sugg)
        }
        | None {}
    
    result
}

// Print all diagnostics in context
print_diagnostics = (ctx: ErrorContext) void {
    (ctx.diagnostics.len() == 0) ?
        | true {}
        | false {
            (0..ctx.diagnostics.len()).loop((i) {
                formatted := format_diagnostic(ctx.diagnostics[i])
                print_line(formatted)
            })
            
            // Print summary
            summary := concat("Summary: ", format_u32(ctx.error_count))
            summary = concat(summary, " error(s), ")
            summary = concat(summary, format_u32(ctx.warning_count))
            summary = concat(summary, " warning(s)")
            print_line(summary)
        }
}

// Check if compilation should stop
should_stop_compilation = (ctx: ErrorContext) bool   {
    ctx.error_count > 0
}

// Helper functions (would be imported from string module in real implementation)
split_lines = (s: string) DynVec<string> {
    intrinsic("string_split_lines", s)
}

concat = (a: string, b: string) string {
    intrinsic("string_concat", a, b)
}

format_u32 = (n: u32) string {
    intrinsic("format_u32", n)
}

string_len = (s: string) u32 {
    intrinsic("string_len", s)
}

repeat_char = (c: u8, count: u32) string {
    intrinsic("repeat_char", c, count)
}

print_line = (s: string) void {
    intrinsic("print_line", s)
}

// Vec implementation helpers
// Helper functions for DynVec
DynVec.new<T> = () DynVec<T> {
    intrinsic("vec_new")
}

DynVec.push<T> = (self: Ptr<DynVec<T>>, item: T) void {
    intrinsic("vec_push", self, item)
}

DynVec.len<T> = (self: DynVec<T>) usize {
    self.len
}