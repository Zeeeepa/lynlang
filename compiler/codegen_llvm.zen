// Zen Language - LLVM Code Generator Module
// Generates LLVM IR from Zen AST

{ core, io }= @std
string = @std
{ Vec, DynVec } = @std
parser = @std

// Import AST types from parser
AstNode := parser.AstNode
Type := parser.Type
BinaryOperator := parser.BinaryOperator
UnaryOperator := parser.UnaryOperator

// LLVM IR Builder Context
CodeGen: {
    // Module information
    module_name: string,
    
    // Current state
    current_function: Option<string>,
    current_block: Option<string>,
    
    // Register allocation
    next_register: u32,
    
    // Symbol tables
    globals: DynVec<GlobalVar>,
    functions: DynVec<Function>,
    locals: DynVec<LocalVar>,
    string_constants: DynVec<StringConstant>,
    
    // Output buffer
    output: string,
    
    // Indentation for readability
    indent_level: u32,
}

// Global variable info
GlobalVar: {
    name: string,
    llvm_type: string,
    initializer: Option<string>,
    is_constant: bool,
}

// Function info
Function: {
    name: string,
    return_type: string,
    params: DynVec<(string, string)>,  // (name, type)
    is_declaration: bool,
}

// Local variable info
LocalVar: {
    name: string,
    llvm_type: string,
    register: u32,
}

// String constant info
StringConstant: {
    id: u32,
    value: string,
    global_name: string,
}

// Create new code generator
new_codegen = (module_name: string) CodeGen   {
    return CodeGen{
        module_name: module_name,
        current_function: Option<string>.None,
        current_block: Option<string>.None,
        next_register: 0,
        globals: vec_new<GlobalVar>(),
        functions: vec_new<Function>(),
        locals: vec_new<LocalVar>(),
        string_constants: vec_new<StringConstant>(),
        output: "",
        indent_level: 0,
    }
}

// Allocate new register
alloc_register = (gen: MutPtr<CodeGen>) u32   {
    reg := gen.next_register
    gen.next_register = gen.next_register + 1
    return reg
}

// Emit LLVM IR line
emit = (gen: MutPtr<CodeGen>, line: string)  {
    i := 0
    loop i < gen.indent_level {
        gen.output = gen.output + "  "
        i = i + 1
    }
    gen.output = gen.output + line + "\n"
}

// Convert Zen type to LLVM type
zen_type_to_llvm = (t: Type) string   {
     t ?
        | Type.Named(name) {
            name == "i8" ? { return "i8" } :
            name == "i16" ? { return "i16" } :
            name == "i32" ? { return "i32" } :
            name == "i64" ? { return "i64" } :
            name == "u8" ? { return "i8" } :
            name == "u16" ? { return "i16" } :
            name == "u32" ? { return "i32" } :
            name == "u64" ? { return "i64" } :
            name == "f32" ? { return "float" } :
            name == "f64" ? { return "double" } :
            name == "bool" ? { return "i1" } :
            name == "void" ? { return "void" } :
            name == "string" ? { return "i8*" } :
            { return name }
        }
        | Type.Pointer(inner, _) {
            inner_type := zen_type_to_llvm(*inner)
            return inner_type + "*"
        }
        | Type.Array(elem, size) {
            elem_type := zen_type_to_llvm(*elem)
            size ?
                | Option<u32>.Some(s) { return "[" + u32_to_string(s) + " x " + elem_type + "]" }
                | Option<u32>.None { return elem_type + "*" }
            }
        }
        | Type.Function(params, ret) {
            ret_type := zen_type_to_llvm(*ret)
            // Function pointer type
            return ret_type + " (...)*"
        }
        | _  () {return "i32" }
}

// Generate code for binary operation
gen_binary_op = (gen: MutPtr<CodeGen>, op: BinaryOperator, left_reg: u32, right_reg: u32, ty: string) u32   {
    result_reg := alloc_register(gen)
    
    op_instr := match op {
        | BinaryOperator.Add { ty == "float" || ty == "double" ? "fadd" : "add" }
        | BinaryOperator.Sub { ty == "float" || ty == "double" ? "fsub" : "sub" }
        | BinaryOperator.Mul { ty == "float" || ty == "double" ? "fmul" : "mul" }
        | BinaryOperator.Div { ty == "float" || ty == "double" ? "fdiv" : "sdiv" }
        | BinaryOperator.Mod { "srem" }
        | BinaryOperator.Equal { ty == "float" || ty == "double" ? "fcmp oeq" : "icmp eq" }
        | BinaryOperator.NotEqual { ty == "float" || ty == "double" ? "fcmp one" : "icmp ne" }
        | BinaryOperator.Less { ty == "float" || ty == "double" ? "fcmp olt" : "icmp slt" }
        | BinaryOperator.Greater { ty == "float" || ty == "double" ? "fcmp ogt" : "icmp sgt" }
        | BinaryOperator.LessEqual { ty == "float" || ty == "double" ? "fcmp ole" : "icmp sle" }
        | BinaryOperator.GreaterEqual { ty == "float" || ty == "double" ? "fcmp oge" : "icmp sge" }
        | BinaryOperator.LogicalAnd { "and" }
        | BinaryOperator.LogicalOr { "or" }
        | BinaryOperator.BitwiseAnd { "and" }
        | BinaryOperator.BitwiseOr { "or" }
        | BinaryOperator.BitwiseXor { "xor" }
        | BinaryOperator.LeftShift { "shl" }
        | BinaryOperator.RightShift { "ashr" }
        | _ { "add"  // Default }
    }
    
    emit(gen, "  %" + u32_to_string(result_reg) + " = " + op_instr + " " + ty + " %" + 
         u32_to_string(left_reg) + ", %" + u32_to_string(right_reg))
    
    return result_reg
}

// Generate code for expression
gen_expression = (gen: MutPtr<CodeGen>, expr: AstNode) u32   {
    expr ?
        | AstNode.IntLit(val) {
            reg := alloc_register(gen)
            emit(gen, "  %" + u32_to_string(reg) + " = add i32 0, " + i64_to_string(val))
            return reg
        }
        | AstNode.FloatLit(val) {
            reg := alloc_register(gen)
            emit(gen, "  %" + u32_to_string(reg) + " = fadd double 0.0, " + f64_to_string(val))
            return reg
        }
        | AstNode.BoolLit(val) {
            reg := alloc_register(gen)
            val_str := val ? "1" : "0"
            emit(gen, "  %" + u32_to_string(reg) + " = add i1 0, " + val_str)
            return reg
        }
        | AstNode.StringLit(val) {
            // Add string constant
            str_id := vec_len(gen.string_constants)
            str_name := "@.str." + u32_to_string(str_id)
            
            const := StringConstant{
                id: str_id,
                value: val,
                global_name: str_name,
            }
            vec_push(gen.string_constants, const)
            
            // Return pointer to string constant
            reg := alloc_register(gen)
            emit(gen, "  %" + u32_to_string(reg) + " = getelementptr [" + 
                 u32_to_string(string_len(val) + 1) + " x i8], [" +
                 u32_to_string(string_len(val) + 1) + " x i8]* " + str_name + ", i32 0, i32 0")
            return reg
        }
        | AstNode.Ident(name) { 
            // Load variable
            var := find_variable(gen, name)
            var ?
                | Option<LocalVar>.Some(v) {
                    reg := alloc_register(gen)
                    emit(gen, "  %" + u32_to_string(reg) + " = load " + v.llvm_type + 
                         ", " + v.llvm_type + "* %" + u32_to_string(v.register))
                    return reg
                }
                | Option<LocalVar>.None {
                    // Variable not found, return dummy register
                    return 0
                }
            }
        }
        | AstNode.BinaryOp(op, left, right) {
            left_reg := gen_expression(gen, *left)
            right_reg := gen_expression(gen, *right)
            // For now, assume i32 type
            return gen_binary_op(gen, op, left_reg, right_reg, "i32")
        }
        | _ {
            // Unsupported expression, return dummy register
            return 0
        }
    }
}

// Find variable in symbol table
find_variable = (gen: Ptr<CodeGen>, name: string) Option<LocalVar>   {
    i := 0
    loop i < vec_len(gen.locals) {
        var := vec_get(gen.locals, i)
        var.name == name ? {
            return Option<LocalVar>.Some(var)
        } : {}
        i = i + 1
    }
    return Option<LocalVar>.None
}

// Generate code for statement
gen_statement = (gen: MutPtr<CodeGen>, stmt: AstNode)  {
    stmt ?
        | AstNode.VarDecl(name, ty, init) {
            // Allocate local variable
            llvm_ty := zen_type_to_llvm(ty)
            var_reg := alloc_register(gen)
            emit(gen, "  %" + u32_to_string(var_reg) + " = alloca " + llvm_ty)
            
            // Store initial value if present
            init ?
                | Option<AstNode>.Some(expr) {
                    val_reg := gen_expression(gen, expr)
                    emit(gen, "  store " + llvm_ty + " %" + u32_to_string(val_reg) + 
                         ", " + llvm_ty + "* %" + u32_to_string(var_reg))
                }
                | Option<AstNode>.None {}
            }
            
            // Add to locals table
            var := LocalVar{
                name: name,
                llvm_type: llvm_ty,
                register: var_reg,
            }
            vec_push(gen.locals, var)
        }
        | AstNode.Return(expr) {
            expr ?
                | Option<AstNode>.Some(e) {
                    val_reg := gen_expression(gen, e)
                    emit(gen, "  ret i32 %" + u32_to_string(val_reg))
                }
                | Option<AstNode>.None {
                    emit(gen, "  ret void")
                }
            }
        }
        | AstNode.Expression(expr) {
            // Generate expression (result discarded)
            gen_expression(gen, expr)
        }
        | AstNode.Block(stmts) {
            // Generate each statement in block
            i := 0
            loop i < vec_len(stmts) {
                gen_statement(gen, vec_get(stmts, i))
                i = i + 1
            }
        }
        | _ {}
    }
}

// Generate function definition
gen_function = (gen: MutPtr<CodeGen>, func: AstNode)  {
    func ?
        | AstNode.FnDecl(name, params, ret_ty, body) {
            // Clear locals for new function
            gen.locals = vec_new<LocalVar>()
            gen.next_register = 0
            
            // Generate function signature
            ret_type := zen_type_to_llvm(ret_ty)
            emit(gen, "")
            emit(gen, "define " + ret_type + " @" + name + "(")
            
            // Generate parameters
            i := 0
            loop i < vec_len(params) {
                param := vec_get(params, i)
                param_type := zen_type_to_llvm(param.ty)
                emit(gen, "  " + param_type + " %" + param.name)
                i < vec_len(params) - 1 ? {
                    emit(gen, ",")
                } : {}
                
                // Add parameter to locals
                var := LocalVar{
                    name: param.name,
                    llvm_type: param_type,
                    register: i,
                }
                vec_push(gen.locals, var)
                
                i = i + 1
            }
            
            emit(gen, ") {")
            emit(gen, "entry:")
            gen.indent_level = 1
            
            // Generate function body
            body ?
                | Option<AstNode>.Some(b) {
                    gen_statement(gen, b)
                }
                | Option<AstNode>.None {}
            }
            
            // Add implicit return if needed
            ret_type == "void" ? {
                emit(gen, "  ret void")
            } : {}
            
            gen.indent_level = 0
            emit(gen, "}")
        }
        | _ {}
    }
}

// Helper functions (improved implementations)
u32_to_string = (n: u32) string   {
    n == 0 ? { return "0" } : {}
    
    // Simple implementation for now
    // In real implementation, would use proper conversion
    n < 10 ? { return "" + (n + 48) } : 
    n < 100 ? { return u32_to_string(n / 10) + u32_to_string(n % 10) } :
    n < 1000 ? { return u32_to_string(n / 100) + u32_to_string((n / 10) % 10) + u32_to_string(n % 10) } :
    { return "999" }  // Truncate for now
}

i64_to_string = (n: i64) string   {
    n < 0 ? { return "-" + i64_to_string(-n) } : {}
    n == 0 ? { return "0" } : {}
    
    // Convert positive number
    n < 10 ? { return "" + (n + 48) } :
    { return i64_to_string(n / 10) + i64_to_string(n % 10) }
}

f64_to_string = (n: f64) string   {
    // Simple implementation - just return fixed strings for now
    n == 0.0 ? { return "0.0" } :
    n == 1.0 ? { return "1.0" } :
    { return "0.0" }  // Default
}

string_len = (s: string) u32   {
    // Count characters until null terminator
    len := 0
    i := 0
    loop s[i] != 0 {
        len = len + 1
        i = i + 1
    }
    return len
}

// Use DynVec.len instead

// Use DynVec.get instead

// Use DynVec.push instead

// Use DynVec.new instead

// Generate complete module
gen_module = (gen: MutPtr<CodeGen>, ast: DynVec<AstNode>)  {
    // Generate module header
    emit(gen, "; ModuleID = '" + gen.module_name + "'")
    emit(gen, "source_filename = \"" + gen.module_name + ".zen\"")
    emit(gen, "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"")
    emit(gen, "target triple = \"x86_64-unknown-linux-gnu\"")
    emit(gen, "")
    
    // Generate external function declarations
    emit(gen, "; External function declarations")
    emit(gen, "declare i32 @printf(i8*, ...)")
    emit(gen, "declare i8* @malloc(i64)")
    emit(gen, "declare void @free(i8*)")
    emit(gen, "declare void @exit(i32)")
    emit(gen, "")
    
    // Process all top-level declarations
    i := 0
    loop (i < vec_len(ast)) {
        node := vec_get(ast, i)
        node ?
            | AstNode.FnDecl(_, _, _, _) {
                gen_function(gen, node)
            }
            | AstNode.GlobalVar(name, ty, init) {
                // Generate global variable
                llvm_ty := zen_type_to_llvm(ty)
                init_val := match init {
                    | Option<AstNode>.Some(e) { "0"  // TODO: evaluate constant }
                    | Option<AstNode>.None { "zeroinitializer" }
                }
                emit(gen, "@" + name + " = global " + llvm_ty + " " + init_val)
            }
            | _ {}
        }
        i = i + 1
    }
    
    // Generate string constants
    vec_len(gen.string_constants) > 0 ? {
        emit(gen, "")
        emit(gen, "; String constants")
        i = 0
        loop i < vec_len(gen.string_constants) {
            str_const := vec_get(gen.string_constants, i)
            len := string_len(str_const.value) + 1
            emit(gen, str_const.global_name + " = private unnamed_addr constant [" +
                 u32_to_string(len) + " x i8] c\"" + str_const.value + "\\00\"")
            i = i + 1
        }
    }
}

// Main entry point for testing
main = () i32   {
    io.print("Zen LLVM Code Generator\n")
    io.print("=======================\n\n")
    
    gen := new_codegen("test_module")
    
    // Create sample AST for testing
    test_ast := vec_new<AstNode>()
    
    // Add a simple main function to test AST
    main_body := AstNode.Block(vec_new<AstNode>())
    main_func := AstNode.FnDecl("main", vec_new<Param>(), Type.Named("i32"), Option<AstNode>.Some(main_body))
    vec_push(test_ast, main_func)
    
    // Generate LLVM IR for the module
    gen_module(MutPtr<CodeGen>(gen), test_ast)
    
    // Output the generated LLVM IR
    io.print("Generated LLVM IR:\n")
    io.print("------------------\n")
    io.print(gen.output)
    
    return 0
}