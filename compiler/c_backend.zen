// Zen Language - C Backend Code Generator
// Generates compilable C code from Zen AST

core = @std
io = @std
string = @std
fs = @std
parser = @std

// C type mapping
map_zen_type_to_c = (zen_type: string) string {
    zen_type ?
        | "i8" { return "int8_t" }
        | "i16" { return "int16_t" }
        | "i32" { return "int32_t" }
        | "i64" { return "int64_t" }
        | "u8" { return "uint8_t" }
        | "u16" { return "uint16_t" }
        | "u32" { return "uint32_t" }
        | "u64" { return "uint64_t" }
        | "f32" { return "float" }
        | "f64" { return "double" }
        | "bool" { return "bool" }
        | "void" { return "void" }
        | "string" { return "char*" }
        | _ { return zen_type }  // For custom types
}

// C Backend Context
CBackend := {
    output: string.Builder
    indent: u32
    in_main: bool
    temp_var_counter: u32
    includes_written: bool
}

// Create new C backend
new_c_backend = () CBackend {
    return CBackend{
        output: string.Builder.new(),
        indent: 0,
        in_main: false,
        temp_var_counter: 0,
        includes_written: false
    }
}

// Write indentation
write_indent = (c: MutPtr<CBackend>) void {
    i := 0
    loop(() {
        (i < c.val.indent) ?
            | true {
                c.val.output.append("    ")
                i = i + 1
            }
            | false {
                break
            }
    })
}

// Write standard C includes
write_includes = (c: MutPtr<CBackend>) void {
    c.val.includes_written ? | true { return } | false { }
    
    c.val.output.append("#include <stdio.h>\n")
    c.val.output.append("#include <stdlib.h>\n")
    c.val.output.append("#include <stdint.h>\n")
    c.val.output.append("#include <stdbool.h>\n")
    c.val.output.append("#include <string.h>\n\n")
    
    // Add Zen runtime helpers
    c.val.output.append("// Zen runtime helpers\n")
    c.val.output.append("typedef struct { char* data; size_t len; } zen_string;\n")
    c.val.output.append("typedef struct { void* data; size_t len; size_t cap; } zen_slice;\n\n")
    
    c.val.includes_written = true
}

// Generate expression
generate_expr = (c: MutPtr<CBackend>, expr: Ptr<parser.Expression>) void {
    expr.val.kind ?
        | .IntLiteral {
            c.val.output.append(expr.val.value)
        }
        | .FloatLiteral {
            c.val.output.append(expr.val.value)
        }
        | .StringLiteral {
            c.val.output.append("\"")
            c.val.output.append(expr.val.value)
            c.val.output.append("\"")
        }
        | .BoolLiteral {
            (expr.val.value == "true") ?
                | true {
                    c.val.output.append("true")
                }
                | false {
                    c.val.output.append("false")
                }
        }
        | .Identifier {
            c.val.output.append(expr.val.value)
        }
        | .BinaryOp {
            c.val.output.append("(")
            generate_expr(c, expr.val.left)
            c.val.output.append(" ")
            c.val.output.append(expr.val.op)
            c.val.output.append(" ")
            generate_expr(c, expr.val.right)
            c.val.output.append(")")
        }
        | .UnaryOp {
            c.val.output.append(expr.val.op)
            c.val.output.append("(")
            generate_expr(c, expr.val.operand)
            c.val.output.append(")")
        }
        | .FunctionCall {
            // Special case for print functions
            (expr.val.name == "io.print" || expr.val.name == "print") ?
                | true {
                    c.val.output.append("printf")
                }
                | false {
                    c.val.output.append(expr.val.name)
                }
            c.val.output.append("(")
            i := 0
            loop(() {
                (i < expr.val.args.len) ?
                    | true {
                        (i > 0) ? | true { c.val.output.append(", ") } | false { }
                        generate_expr(c, expr.val.args[i].ref())
                        i = i + 1
                    }
                    | false {
                        break
                    }
            })
            c.val.output.append(")")
        }
        .ArrayLiteral {
            c.output.append("{")
            i := 0
            loop i < expr.elements.len {
                if (i > 0) c.output.append(", ")
                generate_expr(c, &expr.elements[i])
                i = i + 1
            }
            c.output.append("}")
        }
        .StructLiteral {
            c.output.append("{")
            i := 0
            loop i < expr.fields.len {
                (i > 0) ? { c.output.append(", ") } 
                c.output.append(".")
                c.output.append(expr.fields[i].name)
                c.output.append(" = ")
                generate_expr(c, &expr.fields[i].value)
                i = i + 1
            }
            c.output.append("}")
        }
        | _ {
            c.output.append("/* TODO: expr kind ")
            c.output.append(expr.kind)
            c.output.append(" */")
        }
}

// Generate statement
generate_stmt = (c: &CBackend, stmt: &parser.Statement) void   {
    write_indent(c)
    
    (stmt.kind) ?
        .VarDecl => {
            c_type := map_zen_type_to_c(stmt.var_type)
            c.output.append(c_type)
            c.output.append(" ")
            c.output.append(stmt.name)
            stmt.value != null ? {
                c.output.append(" = ")
                generate_expr(c, stmt.value)
            }
            c.output.append(";\n")
        }
        .Assignment => {
            c.output.append(stmt.name)
            c.output.append(" = ")
            generate_expr(c, stmt.value)
            c.output.append(";\n")
        }
        .FunctionCall => {
            generate_expr(c, stmt.expr)
            c.output.append(";\n")
        }
        .Return => {
            c.output.append("return")
            stmt.value != null ? {
                c.output.append(" ")
                generate_expr(c, stmt.value)
            }
            c.output.append(";\n")
        }
        .If => {
            c.output.append("if (")
            generate_expr(c, stmt.condition)
            c.output.append(") {\n")
            c.indent = c.indent + 1
            generate_block(c, stmt.then_block)
            c.indent = c.indent - 1
            write_indent(c)
            c.output.append("}")
            stmt.else_block != null ? {
                c.output.append(" else {\n")
                c.indent = c.indent + 1
                generate_block(c, stmt.else_block)
                c.indent = c.indent - 1
                write_indent(c)
                c.output.append("}")
            }
            c.output.append("\n")
        }
        .Block => {
            c.output.append("{\n")
            c.indent = c.indent + 1
            generate_block(c, stmt.statements)
            c.indent = c.indent - 1
            write_indent(c)
            c.output.append("}\n")
        }
        | _ {
            c.output.append("/* TODO: stmt kind ")
            c.output.append(stmt.kind)
            c.output.append(" */\n")
        }
    }
}

// Generate block of statements
generate_block = (c: &CBackend, stmts: [parser.Statement]) void   {
    i := 0
    loop i < stmts.len {
        generate_stmt(c, &stmts[i])
        i = i + 1
    }
}

// Generate function
generate_function = (c: &CBackend, func: &parser.Function) void   {
    // Skip if it's a Zen builtin that we handle specially
    func.name == "main" ? {
        c.in_main = true
    }
    
    // Generate function signature
    return_type := map_zen_type_to_c(func.return_type)
    c.output.append(return_type)
    c.output.append(" ")
    c.output.append(func.name)
    c.output.append("(")
    
    // Generate parameters
    i := 0
    loop i < func.params.len {
        (i > 0) ? { c.output.append(", ") } | false { }
        param_type := map_zen_type_to_c(func.params[i].type)
        c.output.append(param_type)
        c.output.append(" ")
        c.output.append(func.params[i].name)
        i = i + 1
    }
    
    func.params.len == 0 ? {
        c.output.append("void")
    }
    
    c.output.append(") {\n")
    c.indent = 1
    
    // Generate function body
    generate_block(c, func.body)
    
    // Add default return for void functions
    func.return_type == "void" ? {
    func.return_type == "void" ? {
        write_indent(c)
        c.output.append("return;\n")
    }
    func.return_type == "void" ? {
        write_indent(c)
        c.output.append("return;\n")
    }
    
    c.indent = 0
    c.output.append("}\n\n")
    
    func.name == "main" ? {
        c.in_main = false
    }
}

// Generate struct definition
generate_struct = (c: &CBackend, s: &parser.Struct) void   {
    c.output.append("typedef struct ")
    c.output.append(s.name)
    c.output.append(" {\n")
    
    c.indent = 1
    i := 0
    loop i < s.fields.len {
        write_indent(c)
        field_type := map_zen_type_to_c(s.fields[i].type)
        c.output.append(field_type)
        c.output.append(" ")
        c.output.append(s.fields[i].name)
        c.output.append(";\n")
        i = i + 1
    }
    
    c.indent = 0
    c.output.append("} ")
    c.output.append(s.name)
    c.output.append(";\n\n")
}

// Generate enum definition
generate_enum = (c: &CBackend, e: &parser.Enum) void   {
    c.output.append("typedef enum {\n")
    c.indent = 1
    
    i := 0
    loop i < e.values.len {
        write_indent(c)
        c.output.append(e.name)
        c.output.append("_")
        c.output.append(e.values[i])
        (i < e.values.len - 1) ? {
            c.output.append(",")
        }
        c.output.append("\n")
        i = i + 1
    }
    
    c.indent = 0
    c.output.append("} ")
    c.output.append(e.name)
    c.output.append(";\n\n")
}

// Main generation function
generate_c_from_ast = (ast: &parser.AST) string   {
    backend := new_c_backend()
    
    // Write includes
    write_includes(&backend)
    
    // Forward declare all structs and enums
    backend.output.append("// Type declarations\n")
    for (ast.structs) |s| {
        backend.output.append("typedef struct ")
        backend.output.append(s.name)
        backend.output.append(" ")
        backend.output.append(s.name)
        backend.output.append(";\n")
    }
    backend.output.append("\n")
    
    // Generate structs
    ast.structs.len > 0 ? {
        backend.output.append("// Struct definitions\n")
        for (ast.structs) |s| {
            generate_struct(&backend, &s)
        }
    }
    
    // Generate enums
    ast.enums.len > 0 ? {
        backend.output.append("// Enum definitions\n")
        for (ast.enums) |e| {
            generate_enum(&backend, &e)
        }
    }
    
    // Forward declare functions
    backend.output.append("// Function declarations\n")
    for (ast.functions) |func| {
        func.name != "main" ? {
            return_type := map_zen_type_to_c(func.return_type)
            backend.output.append(return_type)
            backend.output.append(" ")
            backend.output.append(func.name)
            backend.output.append("(")
            
            i := 0
            loop i < func.params.len {
                (i > 0) ? { backend.output.append(", ") } | false { }
                param_type := map_zen_type_to_c(func.params[i].type)
                backend.output.append(param_type)
                backend.output.append(" ")
                backend.output.append(func.params[i].name)
                i = i + 1
            }
            
            func.params.len == 0 ? {
                backend.output.append("void")
            }
            backend.output.append(");\n")
        }
    }
    backend.output.append("\n")
    
    // Generate function implementations
    backend.output.append("// Function implementations\n")
    ast.functions.loop((func) {
        generate_function(&backend, &func)
    })
    
    return backend.output.to_string()
}

// Export the main function
export { generate_c_from_ast, map_zen_type_to_c }