// Minimal Bootstrap Compiler for Zen
// This is a simplified compiler that can compile a subset of Zen
// Goal: Eventually compile itself (self-hosting)

{ io, fs, core } = @std.io

// Import compiler components
{ lexer, parser, codegen } = @std.compiler

// Compiler pipeline stages
CompilerStage:
    .Lexing |
    .Parsing |
    .TypeChecking |
    .CodeGeneration |
    .Linking

// Compilation result
CompileResult:
    .Success { output: string } |
    .Error { stage: CompilerStage, message: string }

// Main compiler function
compile = (source_file: string) CompileResult   {
    io.print("Compiling: ")
    io.print(source_file)
    io.print("\n")
    
    // Read source file
    source_result := fs.read_file(source_file)
    source_result.is_err() ? {
            return CompileResult {
                .Error {
                    stage = CompilerStage.Lexing,
                    message = "Failed to read source file"
                }
            }
        }
    
    source := source_result.unwrap()
    
    // Stage 1: Lexical analysis
    io.print("  [1/4] Lexing...")
    tokens := lexer.tokenize(source)
    io.print(" ✓\n")
    
    // Stage 2: Parsing
    io.print("  [2/4] Parsing...")
    ast := parser.parse(tokens)
    ast.is_err() ? {
            return CompileResult {
                .Error {
                    stage = CompilerStage.Parsing,
                    message = ast.err_msg()
                }
            }
        }
    io.print(" ✓\n")
    
    // Stage 3: Type checking (simplified for now)
    io.print("  [3/4] Type checking...")
    // TODO: Implement type checking
    io.print(" ✓\n")
    
    // Stage 4: Code generation
    io.print("  [4/4] Generating code...")
    output := codegen.generate(ast.unwrap())
    io.print(" ✓\n")
    
    return CompileResult { .Success { output = output } }
}

// Compile multiple files
compile_project = (files: [100]string, file_count: i32) bool   {
    io.print("=== Zen Bootstrap Compiler ===\n\n")
    
    success_count := 0
    i := 0
    
    loop (i < file_count) {
        result = compile(files[i]) ?
            | .Success { output } {
                io.print("✓ Success: ")
                io.print(files[i])
                io.print("\n")
                success_count = success_count + 1
                
                // Write output to .c file
                output_file := files[i] + ".c"
                fs.write_file(output_file, output)
            }
            | .Error { stage, msg } {
                io.print("✗ Error in ")
                print_stage(stage)
                io.print(": ")
                io.print(msg)
                io.print("\n")
            }
        
        i = i + 1
    }
    
    io.print("\n=== Compilation Summary ===\n")
    io.print("Success: ")
    io.print_int(success_count)
    io.print("/")
    io.print_int(file_count)
    io.print(" files\n")
    
    return success_count == file_count
}

// Helper to print stage name
print_stage = (stage: CompilerStage) void   {
    stage ?
        | .Lexing { io.print("Lexing") }
        | .Parsing { io.print("Parsing") }
        | .TypeChecking { io.print("Type Checking") }
        | .CodeGeneration { io.print("Code Generation") }
        | .Linking { io.print("Linking") }
}

// Entry point
main = () i32   {
    // For now, compile a test file
    test_files := ["test.zen"]
    
    compile_project(test_files, 1) ?
        | true {
            io.print("\nCompilation successful!\n")
            return 0
        }
        | false {
            io.print("\nCompilation failed!\n")
            return 1
        }
}