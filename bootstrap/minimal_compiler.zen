// Minimal Bootstrap Compiler for Zen
// This is a simplified compiler that can compile a subset of Zen
// Goal: Eventually compile itself (self-hosting)

io := @std.io
fs := @std.fs
core := @std.core

// Import compiler components
lexer := @std.compiler.lexer
parser := @std.compiler.parser
codegen := @std.compiler.codegen

// Compiler pipeline stages
CompilerStage = 
    | Lexing
    | Parsing  
    | TypeChecking
    | CodeGeneration
    | Linking

// Compilation result
CompileResult = 
    | Success(output: string)
    | Error(stage: CompilerStage, message: string)

// Main compiler function
compile = (source_file: string) CompileResult {
    io.print("Compiling: ")
    io.print(source_file)
    io.print("\n")
    
    // Read source file
    source_result := fs.read_file(source_file)
    source_result.is_err() ?
        | true => {
            return CompileResult.Error(
                CompilerStage.Lexing,
                "Failed to read source file"
            )
        }
        | false => {}
    
    source := source_result.unwrap()
    
    // Stage 1: Lexical analysis
    io.print("  [1/4] Lexing...")
    tokens := lexer.tokenize(source)
    io.print(" ✓\n")
    
    // Stage 2: Parsing
    io.print("  [2/4] Parsing...")
    ast := parser.parse(tokens)
    ast.is_err() ?
        | true => {
            return CompileResult.Error(
                CompilerStage.Parsing,
                ast.err_msg()
            )
        }
        | false => {}
    io.print(" ✓\n")
    
    // Stage 3: Type checking (simplified for now)
    io.print("  [3/4] Type checking...")
    // TODO: Implement type checking
    io.print(" ✓\n")
    
    // Stage 4: Code generation
    io.print("  [4/4] Generating code...")
    output := codegen.generate(ast.unwrap())
    io.print(" ✓\n")
    
    return CompileResult.Success(output)
}

// Compile multiple files
compile_project = (files: [100]string, file_count: i32) bool {
    io.print("=== Zen Bootstrap Compiler ===\n\n")
    
    success_count := 0
    i := 0
    
    loop i < file_count {
        result := compile(files[i])
        result ?
            | CompileResult.Success(output) => {
                io.print("✓ Success: ")
                io.print(files[i])
                io.print("\n")
                success_count = success_count + 1
                
                // Write output to .c file
                output_file := files[i] + ".c"
                fs.write_file(output_file, output)
            }
            | CompileResult.Error(stage, msg) => {
                io.print("✗ Error in ")
                print_stage(stage)
                io.print(": ")
                io.print(msg)
                io.print("\n")
            }
        
        i = i + 1
    }
    
    io.print("\n=== Compilation Summary ===\n")
    io.print("Success: ")
    io.print_int(success_count)
    io.print("/")
    io.print_int(file_count)
    io.print(" files\n")
    
    return success_count == file_count
}

// Helper to print stage name
print_stage = (stage: CompilerStage) void {
    stage ?
        | CompilerStage.Lexing => io.print("Lexing")
        | CompilerStage.Parsing => io.print("Parsing")
        | CompilerStage.TypeChecking => io.print("Type Checking")
        | CompilerStage.CodeGeneration => io.print("Code Generation")
        | CompilerStage.Linking => io.print("Linking")
}

// Entry point
main = () i32 {
    // For now, compile a test file
    test_files := ["test.zen"]
    
    compile_project(test_files, 1) ?
        | true => {
            io.print("\nCompilation successful!\n")
            return 0
        }
        | false => {
            io.print("\nCompilation failed!\n")
            return 1
        }
}