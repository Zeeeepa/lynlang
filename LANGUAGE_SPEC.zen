// ============================================================================
// ZEN LANGUAGE SPECIFICATION
// ============================================================================
//
// REJECTED KEYWORDS (not in Zen):
//   `if/else/while/for/match/switch/async/await/impl/trait/class/interface/null`
//
// CORE PRINCIPLES:
// - Only TWO @ symbols: `@std` (standard library) and `@this` (current scope)
// - Pattern matching with `?` operator replaces if/else/match/switch
// - UFC (Uniform Function Call) - any function can be called as method
// - Allocators determine sync/async behavior (no function coloring)
// - Explicit pointer types: `Ptr<>`, `MutPtr<>`, `RawPtr<>` (no `*` or `&`)
// - No null/nil - only `Option<T>` with `.Some(T)` and `.None`
// - No unions, no tuples - only structs and enums
// - Type casting with `cast(value, Type)` function (no `as` keyword)
//
// ASSIGNMENT OPERATORS:
//   `=`   immutable binding
//   `::=` mutable binding
//   `:=`  constant with inferred type
//   `:`   type annotation
//
// ERROR HANDLING:
// - Result<T, E> for fallible operations
// - `.raise()` for error propagation (not exceptions)
//
// LOOPS:
// - `loop()` for infinite loops
// - `.loop()` for collection iteration
// - `(0..10)` range syntax
//
// METAPROGRAMMING (First-Class, No Special Syntax):
// - `meta` is a regular module imported from `@std`
// - Traits via `.implements()` and `.requires()`
// - Auto-derive via `.derive()`
// - Compile-time execution is IMPLICIT (compiler infers when possible)
// - Reflection via `meta.type_info()` - regular function, not @ builtin
// - Static assertions via `meta.static_assert()` - regular function
// - NO `@meta.*` syntax - metaprogramming uses regular function calls

// ============================================================================
// build.zen
// ============================================================================

{ Build, FFI } := @std

builder = (b :: Build) void {
    builder = b.builder()
    
    // Check command line flags for conditional compilation
    is_release = b.args.contains("--release")
    
    // Conditional compilation based on flags
    is_release ?
        | true {
            b.optimization(.O3)  // Maximum optimization
            b.strip_symbols(true)  // Remove debug symbols
        }
        | false {
            b.optimization(.O0)  // No optimization for debug
            b.debug_info(true)  // Include debug info
        }
    
    // Output target selection - compile to different backends
    b.target ?
        | C { b.emit_c("output.c") }  // Transpile to C
        | LLVM { b.emit_llvm_ir("output.ll") }  // LLVM IR
        | Native { b.emit_native() }  // Direct to machine code

    // Create SDL2 game executable
    builder.add_executable("sdl2-game", "src/main.zen")
        .add_library("game-engine", "src/game.zen")
        .add_test("game-tests", "src/test.zen")

    // SDL2 FFI bindings
    // TODO: Support anonymous struct literals with type inference
    // For now, comment out as FFI.Library type doesn't exist yet
    sdl2_library :: FFI.Library = {
        name: "SDL2",
    }

    // Pattern matching for OS-specific paths
    // TODO: Uncomment when sdl2_library is defined
    std.os ? 
        | Linux {
            sdl2_library.path = "/usr/lib/x86_64-linux-gnu/libSDL2.so"
        }
        | Macos {
            sdl2_library.path = "/usr/local/lib/libSDL2.dylib"
        }
        | Windows {
            sdl2_library.path = "SDL2.dll"
        }
        | _ {
            sdl2_library.path = "SDL2.dll"
        }

    build.add_dependency("sdl2-game", sdl2_library)

    // External dependencies from GitHub
    // TODO: Support anonymous struct literals
    builder
        .add_dependency({
            name: "ecs",
            source: Git {
                url: "github.com/zenlang/zen-ecs",
                branch: "main"
            }
        })   
}

// ============================================================================
// src/main.zen
// ============================================================================

// ============================================================================
// IMPORTS - only @std and @this are special @ symbols
// ============================================================================

// Core utilities
{ io, math } = @std
{ String, StringBuilder } = @std

// Memory management
{ GPA, AsyncPool, Allocator } = @std

// Collections
{ Vec, DynVec } = @std

// Concurrency
{ Actor, Channel, Mutex, AtomicU32 } = @std

// Metaprogramming - regular module, not special syntax!
// This gives you: type_info, static_assert, derive traits, comptime utilities
{ meta } = @std

// Low-level operations
{ inline, simd } = @std

// External packages
sdl2 = @std.import("sdl2")
ecs = @std.import("ecs")


// No null! Only Option types
Option<T>:
    Some: T,
    None

// Result type for error handling
Result<T, E>:
    Ok: T,
    Err: E


// Simple struct
Point: {
    x:: f64, // mutable field
    y:: f64 = 0 // with default value
}


// Trait definition - methods that types can implement
Geometric: {
    area: (self) f64,
    perimeter: (self) f64,
}


Circle: {
    center: Point,
    radius: f64,
}

// Implement trait for type using .implements()
Circle.implements(Geometric, {
    area = (self) f64 {
        return math.pi * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * math.pi * self.radius
    },
})


Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

Rectangle.implements(Geometric, {
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return width * height
    },
    perimeter = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return 2.0 * (width + height)
    },
})


// Enum type (sum type)
Shape:
    Circle,
    Rectangle
// Enforce all Shape variants must implement Geometric
Shape.requires(Geometric)


// UFC overloading based on enum variants
GameEntity:
    Player,
    Enemy,
    Powerup

// Overload functions for each variant
get_health = (e: GameEntity.Player) u32 { return 100 }
get_health = (e: GameEntity.Enemy) u32 { return 50 }
get_health = (e: GameEntity.Powerup) u32 { return 0 }

get_speed = (e: GameEntity.Player) f64 { return 5.0 }
get_speed = (e: GameEntity.Enemy) f64 { return 3.0 }
get_speed = (e: GameEntity.Powerup) f64 { return 0.0 }


// Generic function with constraints
print_area<T: Geometric>(shape: T) void {
    io.println("Area: ${shape.area()}")
}

// Generic container with multiple constraints
Container<T: Geometric + Serializable>: {
    items: DynVec<T>,
    
    add: (item: T) void,
    total_area: () f64,
}


// Parse shape from string - demonstrates Result type
parse_radius = (s: string) Result<f64, string> {
    s.to_f64() ?
        | Some(val) { return Ok(val) }
        | None { return Err("Invalid radius") }
}

// Error propagation with .raise()
load_config = (path: string) Result<Config, Error> {
    file = File.open(path).raise()  // If Err, returns early with that error
    contents = file.read_all().raise()
    config = json.parse(contents).raise()
    return Ok(config)
}


// Multisync function - sync or async based on allocator!
fetch_game_data = (url: string, alloc: Allocator) Result<Data, Error> {
    client = HttpClient(alloc)
    @this.defer(client.deinit())
    
    // This blocks or doesn't based on allocator!
    response = client.get(url)
    response ?
        | Ok(data) { return Ok(parse_data(data)) }
        | Err(e) { return Err(e) }
}


// Actor for lazy/streaming iteration
create_fibonacci = () Actor {
    outer = 100  // Will be captured automatically
    return Actor((receiver) {  // Compiler detects this closure needs capture
        a ::= 0  // ::= for mutable
        b ::= 1
        loop(() {
            receiver.send(a + outer)  // Can access outer - auto-captured
            temp = a + b
            a = b
            b = temp
        })
    })
}


// ============================================================================
// METAPROGRAMMING - Using the meta module (regular functions, no @ syntax!)
// ============================================================================

// Type reflection - meta.type_info() is a regular function
inspect_type = (T: type) void {
    info = meta.type_info(T)  // Regular function call, not @typeInfo
    info.kind ?
        | Struct(s) {
            io.println("Struct: ${s.name}")
            s.fields.loop((f) {
                io.println("  Field: ${f.name}: ${f.type}")
            })
        }
        | Enum(e) {
            io.println("Enum: ${e.name}")
            e.variants.loop((v) {
                io.println("  Variant: ${v.name}")
            })
        }
        | Function(f) {
            io.println("Function: ${f.name}")
            f.params.loop((p) {
                io.println("  Param ${p.name}: ${p.type}, mut: ${p.is_mut}")
            })
            io.println("  Returns: ${f.return_type}")
        }
        | TypeDef(t) {
            io.println("TypeDef: ${t.name}")
            t.methods.loop((m) {
                io.println("  Method: ${m.name}")
            })
        }
}

// Static assertions - regular function, evaluated at compile time
meta.static_assert(sizeof(Point) == 16, "Point must be 16 bytes")

// Compile-time AST modification - regular function, no @ syntax
// The compiler knows this runs at comptime because it operates on types/AST
meta.transform(parse_radius, (original) {
    new_body = original.body.prepend(
        meta.ast.call("io.println", ["Parsing radius from: ${s}"])
    )
    return original.with_body(new_body)
})

// Auto-derive common traits - method call syntax, not @derive
Point.derive(meta.Debug)       // Auto-generate debug printing
Point.derive(meta.Clone)       // Auto-generate cloning
Point.derive(meta.Eq)          // Auto-generate equality comparison
Point.derive(meta.Serialize)   // Auto-generate serialization

// Or derive multiple at once
Circle.derive(meta.Debug, meta.Clone, meta.Eq)


// Inline C/LLVM for low-level control
fast_memcpy = (dst: RawPtr<u8>, src: RawPtr<u8>, len: usize) void {
    inline.c("""
        memcpy(${dst.addr}, ${src.addr}, ${len});
    """)
}

// SIMD operations
vector_add = (a: Vec<f32, 8>, b: Vec<f32, 8>) Vec<f32, 8> {
    return simd.add(a, b)
}


// ============================================================================
// IMPLICIT COMPILE-TIME EVALUATION
// ============================================================================
// No special `comptime` keyword needed! The compiler automatically evaluates
// expressions at compile time when all inputs are known at compile time.

// This function can run at either compile-time OR runtime
factorial = (n: u64) u64 {
    n == 0 ?
        | true { return 1 }
        | false { return n * factorial(n - 1) }
}

// Compiler evaluates at compile time - result baked into binary
FACTORIAL_10 = factorial(10)  // Computed at compile time: 3628800

// Compiler evaluates at runtime - input not known until execution
compute_factorial = (user_input: u64) u64 {
    return factorial(user_input)  // Computed at runtime
}

// Lookup tables - computed at compile time, embedded in binary
SINE_TABLE = (0..360).map((deg) {
    rad = cast(deg, f64) * math.pi / 180.0
    return math.sin(rad)
})

// Compile-time string processing
GREETING = "Hello, " + "World!"  // Concatenated at compile time

// Type-based compile-time decisions using pattern matching
Storage<T> = meta.type_info(T).size <= 8 ?
    | true { Inline: T }           // Small types stored inline
    | false { Heap: Ptr<T> }       // Large types stored on heap


// ============================================================================
// MAIN FUNCTION
// ============================================================================

main = () void {

    x: i32 // forward declaration must be declared in the same scope 
    x = 10
    y = 10    // Immutable assignment 
    z : i32 = 20 // Immutable assignment with type
    w :: i32 // mutable forward declaration must be declared in the same scope
    w = 20
    v ::= 30 // Mutable assignment
    u :: i32 = 40 // mutable assignment with type

    // Sync allocator - everything blocks
    sync_alloc = GPA.init()
    @this.defer(sync_alloc.deinit())
    
    // Async allocator - everything is non-blocking
    async_alloc = AsyncPool.init()
    @this.defer(async_alloc.deinit())
    
    // Mixed type vector - can hold multiple variant types!
    entities = DynVec<GameEntity.Player, GameEntity.Enemy>(sync_alloc)
    @this.defer(entities.deinit())
    
    entities.push(GameEntity.Player)
    entities.push(GameEntity.Enemy)
    entities.push(GameEntity.Player)
    
    // Loop over mixed types with pattern matching
    entities.loop((entity) {
        entity ?
            | Player { 
                io.println("Player health: ${entity.get_health()}")
                io.println("Player speed: ${entity.get_speed()}")
            }
            | Enemy { 
                io.println("Enemy health: ${entity.get_health()}")
                io.println("Enemy speed: ${entity.get_speed()}")
            }
    })
    
    // Another example with inline types
    mixed_items = DynVec<Circle, Rectangle>(sync_alloc)
    @this.defer(mixed_items.deinit())
    
    mixed_items.push(Circle { center: Point { x: 0, y: 0 }, radius: 5 })
    mixed_items.push(Rectangle { top_left: Point { x: 0, y: 0 }, bottom_right: Point { x: 10, y: 10 } })
    
    // Pattern match directly on the type variants
    mixed_items.loop((item) {
        item ?
            | Circle { io.println("Circle area: ${item.area()}") }
            | Rectangle { io.println("Rectangle area: ${item.area()}") }
    })
    
    // Boolean pattern matching - no ternary
    is_ready = true
    is_ready ? { 
        io.println("Starting game!") 
    }
    
    // For if-else, use full pattern match
    has_data = false
    has_data ?
        | true { process_data() }
        | false { io.println("Waiting for data...") }
    
    // Explicit pointer types - no * or &
    circle = Circle { center: Point { x: 100, y: 100 }, radius: 50 }
    circle_ptr: Ptr<Circle> = circle.ref()
    circle_mut: MutPtr<Circle> = circle.mut_ref()
    
    io.println("Circle area: ${circle_ptr.val.area()}")  // .val to dereference
    circle_mut.val.radius = 75
    io.println("New area: ${circle_mut.val.area()}")
    io.println("Address: ${circle_ptr.addr}")
    
    // Static sized vector
    shapes = Vec<Shape, 100>()
    shapes.push(Circle { center: Point { x: 0, y: 0 }, radius: 10 })
    
    // Dynamic vector with allocator
    dynamic_shapes = DynVec<Shape>(sync_alloc.allocator())
    @this.defer(dynamic_shapes.deinit())
    
    dynamic_shapes.push(Rectangle { 
        top_left: Point { x: 0, y: 0 },
        bottom_right: Point { x: 50, y: 50 }
    })
    
    // String building
    sb = StringBuilder(sync_alloc)
    @this.defer(sb.deinit())
    sb.append("Hello")
      .append(" ")
      .append("World")
      .append_line("!")
    built_string = sb.build()
    io.println(built_string)
    
    // Concurrency primitives
    message_chan = Channel<string>(10)  // Buffered channel
    @this.defer(message_chan.close())
    
    // Spawn actor to send messages
    sender = Actor(() {
        (0..5).loop((i) {  // Range syntax!
            message_chan.send("Message ${i}")
        })
    }).spawn()
    
    // Receive messages
    loop(() {
        message_chan.receive() ?
            | Some(msg) { io.println("Received: ${msg}") }
            | None { break }
    })
    
    // Mutex for shared state
    counter_mutex = Mutex<u32>(0)
    @this.defer(counter_mutex.deinit())
    
    counter_mutex.lock() ?
        | Ok(val) {
            val = val + 1
            counter_mutex.unlock()
        }
        | Err(e) { io.println("Lock failed: ${e}") }
    
    // Atomic operations
    atomic_counter = AtomicU32(0)
    atomic_counter.fetch_add(1)
    current = atomic_counter.load()
    io.println("Atomic counter: ${current}")
    
    // Range iterations
    (0..10).loop((i) {
        io.println("Count: ${i}")
    })
    
    // Step ranges
    (0..100).step(10).loop((i) {
        io.println("Step: ${i}")  // 0, 10, 20, ...
    })
    
    // UFC - collection.loop()
    total_area ::= 0.0
    dynamic_shapes.loop((shape) {
        total_area = total_area + shape.area()
    })
    
    // Loop with index
    dynamic_shapes.loop((shape, i) {
        io.println("Shape ${i}: ${shape.area()}")
    })
    
    // Infinite loop
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter > 10 ?
            | true { break }
            | false { io.println("Count: ${counter}") }
    })
    
    // Option handling - no null!
    maybe_radius: Option<f64> = Some(5.5)
    maybe_radius ?
        | Some(r) {
            circle = Circle {
                center: Point { x: 100.0, y: 100.0 },
                radius: r,
            }
            io.println("Created circle with area: ${circle.area()}")
        }
        | None {
            io.println("No radius provided")
        }
    
    // Reflection at runtime
    inspect_type(Circle)
    inspect_type(Shape)
    
    io.println("Total area: ${total_area}")

    // SDL2 integration
    sdl2.init()
    window = sdl2.create_window("SDL2 Game", 100, 100, 640, 480)
    @this.defer(window.destroy())

    sdl2.delay(1000)
    sdl2.quit()
}


// Module exports - simple record syntax
module.exports = {
    Shape: Shape,
    Circle: Circle,
    Rectangle: Rectangle,
    Geometric: Geometric,
    GameEntity: GameEntity,
    get_health: get_health,
    get_speed: get_speed,
    parse_radius: parse_radius,
    create_fibonacci: create_fibonacci,
}

// Imports in other files would look like:
// Circle2D = module.import("shapes2d").Circle
// Rectangle2D = module.import("shapes2d").Rectangle
//
// Or grab the whole module:
// shapes = module.import("shapes2d")
// my_circle = shapes.Circle { ... }


// ============================================================================
// @std.meta MODULE REFERENCE
// ============================================================================
// The meta module provides metaprogramming capabilities as REGULAR FUNCTIONS.
// No special @ syntax needed - metaprogramming is first-class in Zen.
//
// DESIGN PRINCIPLE:
//   "Everything that can be expressed as a regular function, should be."
//   The only @ symbols in Zen are @std and @this - nothing else.

// ----------------------------------------------------------------------------
// TYPE INTROSPECTION
// ----------------------------------------------------------------------------

// meta.type_info(T) -> TypeInfo
// Returns detailed information about any type
TypeInfo: {
    name: String,
    size: usize,
    alignment: usize,
    kind: TypeKind,
}

TypeKind:
    Struct: { fields: []FieldInfo },
    Enum: { variants: []VariantInfo },
    Function: { params: []ParamInfo, return_type: type },
    Primitive: { name: String },
    Pointer: { pointee: type, mutability: Mutability },
    Array: { element: type, length: usize },
    Generic: { base: type, args: []type }

// meta.fields(T) -> []FieldInfo
// Shorthand for getting struct fields

// meta.variants(T) -> []VariantInfo
// Shorthand for getting enum variants

// meta.sizeof(T) -> usize
// Returns size of type in bytes (also available as `sizeof(T)`)

// meta.alignof(T) -> usize
// Returns alignment of type in bytes

// ----------------------------------------------------------------------------
// STATIC ASSERTIONS
// ----------------------------------------------------------------------------

// meta.static_assert(condition, message)
// Compile-time assertion - fails compilation if condition is false
// Example: meta.static_assert(sizeof(Packet) == 64, "wrong size")

// ----------------------------------------------------------------------------
// AUTO-DERIVE TRAITS
// ----------------------------------------------------------------------------

// Type.derive(Trait) or Type.derive(Trait1, Trait2, ...)
// Auto-generates trait implementations

// Available derive traits:
meta.Debug      // Generate debug string representation
meta.Clone      // Generate deep copy functionality
meta.Eq         // Generate equality comparison (==, !=)
meta.Ord        // Generate ordering comparison (<, >, <=, >=)
meta.Hash       // Generate hash function
meta.Default    // Generate default constructor
meta.Serialize  // Generate serialization to bytes/JSON
meta.Deserialize // Generate deserialization from bytes/JSON

// Example:
// Person.derive(meta.Debug, meta.Clone, meta.Eq)

// ----------------------------------------------------------------------------
// AST MANIPULATION
// ----------------------------------------------------------------------------

// meta.ast.call(fn_name, args) -> ASTNode
// Creates a function call AST node

// meta.ast.literal(value) -> ASTNode
// Creates a literal value AST node

// meta.ast.block(statements) -> ASTNode
// Creates a block of statements

// meta.transform(target, transformer_fn)
// Transforms a function/type at compile time
// Example:
// meta.transform(my_function, (ast) {
//     return ast.body.prepend(logging_statement)
// })

// ----------------------------------------------------------------------------
// SOURCE LOCATION
// ----------------------------------------------------------------------------

// meta.file() -> String
// Returns current source file path

// meta.line() -> u32
// Returns current line number

// meta.column() -> u32
// Returns current column number

// meta.function_name() -> String
// Returns name of enclosing function

// meta.caller() -> SourceLocation
// Returns location of caller (for logging/debugging)

// ----------------------------------------------------------------------------
// CONDITIONAL COMPILATION
// ----------------------------------------------------------------------------

// Use pattern matching on compile-time values - no special syntax!
//
// target.os ?
//     | Linux { ... }
//     | Macos { ... }
//     | Windows { ... }
//
// target.arch ?
//     | X86_64 { ... }
//     | Arm64 { ... }
//     | Wasm { ... }
//
// The compiler eliminates unreachable branches at compile time.

// ----------------------------------------------------------------------------
// EMBED FILES
// ----------------------------------------------------------------------------

// meta.embed_file(path) -> []u8
// Embeds file contents as byte array at compile time
// Example: SHADER_SOURCE = meta.embed_file("shaders/vertex.glsl")

// meta.embed_string(path) -> String
// Embeds file contents as string at compile time

// ----------------------------------------------------------------------------
// CODE GENERATION
// ----------------------------------------------------------------------------

// meta.generate_struct(name, fields) -> type
// Dynamically generate a struct type at compile time

// meta.generate_enum(name, variants) -> type
// Dynamically generate an enum type at compile time

// Example: Generate struct from JSON schema
// UserType = meta.generate_struct("User", json.parse(meta.embed_file("schema.json")))


// ============================================================================
// WHY NO @ BUILTINS?
// ============================================================================
//
// Many languages use @ or # for metaprogramming:
//   Zig:  @typeInfo(), @compileLog(), @embedFile()
//   Rust: #[derive(...)], #[cfg(...)]
//
// This creates a "two-class citizen" problem:
//   - Regular code follows one set of rules
//   - Meta code follows different rules
//   - They don't compose the same way
//   - You're learning two languages
//
// Zen's approach:
//   - meta is just a module like io or math
//   - meta functions are regular functions
//   - Compile-time evaluation is IMPLICIT (compiler figures it out)
//   - Everything composes uniformly
//   - One language, one set of rules
//
// The ONLY @ symbols in Zen:
//   @std  - Access the standard library namespace
//   @this - Access the current scope (for defer, etc.)
//
// These are namespace/scope access, NOT metaprogramming escape hatches.