Test run started at Sun Aug 31 01:24:37 UTC 2025
warning: unused import: `FloatValue`
   --> src/codegen/llvm/expressions.rs:526:41
    |
526 |         use inkwell::values::{IntValue, FloatValue, PointerValue};
    |                                         ^^^^^^^^^^
    |
    = note: `#[warn(unused_imports)]` on by default

warning: use of deprecated method `inkwell::types::IntType::<'ctx>::ptr_type`: Starting from version 15.0, LLVM doesn't differentiate between pointer types. Use Context::ptr_type instead.
   --> src/codegen/llvm/functions.rs:445:54
    |
445 |             let i8_ptr_type = self.context.i8_type().ptr_type(inkwell::AddressSpace::default());
    |                                                      ^^^^^^^^
    |
    = note: `#[warn(deprecated)]` on by default

warning: use of deprecated method `inkwell::types::IntType::<'ctx>::ptr_type`: Starting from version 15.0, LLVM doesn't differentiate between pointer types. Use Context::ptr_type instead.
   --> src/codegen/llvm/functions.rs:476:54
    |
476 |             let i8_ptr_type = self.context.i8_type().ptr_type(inkwell::AddressSpace::default());
    |                                                      ^^^^^^^^

warning: use of deprecated method `inkwell::types::FunctionType::<'ctx>::ptr_type`: Starting from version 15.0, LLVM doesn't differentiate between pointer types. Use Context::ptr_type instead.
   --> src/codegen/llvm/types.rs:113:46
    |
113 |                 Ok(Type::Basic(function_type.ptr_type(AddressSpace::default()).into()))
    |                                              ^^^^^^^^

warning: unused variable: `target_llvm_type`
   --> src/codegen/llvm/expressions.rs:530:13
    |
530 |         let target_llvm_type = self.to_llvm_type(target_type)?;
    |             ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_target_llvm_type`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `call`
   --> src/codegen/llvm/functions.rs:454:13
    |
454 |         let call = self.builder.build_call(
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_call`

warning: unused variable: `call`
   --> src/codegen/llvm/functions.rs:485:13
    |
485 |         let call = self.builder.build_call(
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_call`

warning: unused variable: `expected`
  --> src/codegen/llvm/statements.rs:21:33
   |
21 |                     if let Some(expected) = expected_ret_type {
   |                                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected`

warning: unused variable: `actual_type`
  --> src/codegen/llvm/statements.rs:22:29
   |
22 |                         let actual_type = value.get_type();
   |                             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_actual_type`

warning: variable does not need to be mutable
  --> src/parser/expressions.rs:92:13
   |
92 |         let mut expr = self.parse_primary_expression()?;
   |             ----^^^^
   |             |
   |             help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `saved_pos`
   --> src/parser/expressions.rs:200:25
    |
200 |                     let saved_pos = self.current_span.start;
    |                         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_saved_pos`

warning: unreachable pattern
   --> src/typechecker/mod.rs:518:13
    |
518 |             _ => Ok(AstType::Void), // Default for unhandled cases
    |             ^ no value can reach this
    |
note: multiple earlier patterns match some of the same values
   --> src/typechecker/mod.rs:518:13
    |
294 |             Expression::Integer32(_) => Ok(AstType::I32),
    |             ------------------------ matches some of the same values
295 |             Expression::Integer64(_) => Ok(AstType::I64),
    |             ------------------------ matches some of the same values
296 |             Expression::Float32(_) => Ok(AstType::F32),
    |             ---------------------- matches some of the same values
297 |             Expression::Float64(_) => Ok(AstType::F64),
    |             ---------------------- matches some of the same values
...
518 |             _ => Ok(AstType::Void), // Default for unhandled cases
    |             ^ ...and 31 other patterns collectively make this unreachable
    = note: `#[warn(unreachable_patterns)]` on by default

warning: `zen` (lib) generated 12 warnings (run `cargo fix --lib -p zen` to apply 2 suggestions)
warning: variants `Function`, `Struct`, `Enum`, `Option`, `Result`, and `Range` are never constructed
  --> src/ast.rs:27:5
   |
7  | pub enum AstType {
   |          ------- variants in this enum
...
27 |     Function {
   |     ^^^^^^^^
...
35 |     Struct {
   |     ^^^^^^
...
39 |     Enum {
   |     ^^^^
...
45 |     Option(Box<AstType>), // Option<T>
   |     ^^^^^^
46 |     Result {
   |     ^^^^^^
...
50 |     Range {
   |     ^^^^^
   |
   = note: `AstType` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: variant `StringConcat` is never constructed
  --> src/ast.rs:87:5
   |
75 | pub enum BinaryOperator {
   |          -------------- variant in this enum
...
87 |     StringConcat,
   |     ^^^^^^^^^^^^
   |
   = note: `BinaryOperator` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: multiple variants are never constructed
   --> src/ast.rs:94:5
    |
93  | pub enum Expression {
    |          ---------- variants in this enum
94  |     Integer8(i8),
    |     ^^^^^^^^
95  |     Integer16(i16),
    |     ^^^^^^^^^
...
98  |     Unsigned8(u8),
    |     ^^^^^^^^^
99  |     Unsigned16(u16),
    |     ^^^^^^^^^^
100 |     Unsigned32(u32),
    |     ^^^^^^^^^^
101 |     Unsigned64(u64),
    |     ^^^^^^^^^^
102 |     Float32(f32),
    |     ^^^^^^^
...
121 |     AddressOf(Box<Expression>),
    |     ^^^^^^^^^
122 |     Dereference(Box<Expression>),
    |     ^^^^^^^^^^^
123 |     PointerOffset {
    |     ^^^^^^^^^^^^^
...
131 |     StructField {
    |     ^^^^^^^^^^^
...
150 |     StringLength(Box<Expression>),
    |     ^^^^^^^^^^^^
...
164 |     PatternMatch {
    |     ^^^^^^^^^^^^
...
169 |     StdModule(String),
    |     ^^^^^^^^^
170 |     // Generic module reference
171 |     Module(String),
    |     ^^^^^^
...
175 |     Return(Box<Expression>),
    |     ^^^^^^
    |
    = note: `Expression` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: variants `Range` and `Binding` are never constructed
   --> src/ast.rs:218:5
    |
204 | pub enum Pattern {
    |          ------- variants in this enum
...
218 |     Range {
    |     ^^^^^
...
223 |     Binding {
    |     ^^^^^^^
    |
    = note: `Pattern` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: variant `ModuleImport` is never constructed
   --> src/ast.rs:263:5
    |
230 | pub enum Statement {
    |          --------- variant in this enum
...
263 |     ModuleImport {
    |     ^^^^^^^^^^^^
    |
    = note: `Statement` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: associated items `from_functions` and `functions` are never used
   --> src/ast.rs:394:12
    |
393 | impl Program {
    | ------------ associated items in this implementation
394 |     pub fn from_functions(functions: Vec<Function>) -> Self {
    |            ^^^^^^^^^^^^^^
...
400 |     pub fn functions(&self) -> impl Iterator<Item = &Function> {
    |            ^^^^^^^^^

warning: enum `Type` is never used
  --> src/codegen/llvm/mod.rs:29:10
   |
29 | pub enum Type<'ctx> {
   |          ^^^^
   |
   = note: `Type` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: method `into_basic_type` is never used
  --> src/codegen/llvm/mod.rs:38:12
   |
37 | impl<'ctx> Type<'ctx> {
   | --------------------- method in this implementation
38 |     pub fn into_basic_type(self) -> Result<BasicTypeEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^

warning: struct `StructTypeInfo` is never constructed
  --> src/codegen/llvm/mod.rs:51:12
   |
51 | pub struct StructTypeInfo<'ctx> {
   |            ^^^^^^^^^^^^^^
   |
   = note: `StructTypeInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: struct `LLVMCompiler` is never constructed
  --> src/codegen/llvm/mod.rs:56:12
   |
56 | pub struct LLVMCompiler<'ctx> {
   |            ^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/codegen/llvm/mod.rs:72:12
    |
71  | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- associated items in this implementation
72  |     pub fn new(context: &'ctx Context) -> Self {
    |            ^^^
...
104 |     pub fn get_type(&self, name: &str) -> Result<BasicTypeEnum<'ctx>, CompileError> {
    |            ^^^^^^^^
...
113 |     pub fn declare_variable(&mut self, name: &str, _ty: AstType, ptr: PointerValue<'ctx>) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^
...
122 |     pub fn get_variable(&self, name: &str) -> Result<(PointerValue<'ctx>, AstType), CompileError> {
    |            ^^^^^^^^^^^^
...
137 |     pub fn compile_program(&mut self, program: &ast::Program) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^
...
209 |     pub fn register_struct_type(&mut self, struct_def: &ast::StructDefinition) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^
...
266 |     pub fn register_enum_type(&mut self, enum_def: &ast::EnumDefinition) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^
...
293 |     pub fn cast_value_to_type(&self, value: BasicValueEnum<'ctx>, target_type: BasicTypeEnum<'ctx>) -> Result<BasicValueEnum<'ctx>, Compi...
    |            ^^^^^^^^^^^^^^^^^^

warning: struct `BehaviorCodegen` is never constructed
 --> src/codegen/llvm/behaviors.rs:9:12
  |
9 | pub struct BehaviorCodegen<'ctx> {
  |            ^^^^^^^^^^^^^^^

warning: associated items `new`, `generate_vtable`, `register_method`, and `resolve_method` are never used
  --> src/codegen/llvm/behaviors.rs:17:12
   |
16 | impl<'ctx> BehaviorCodegen<'ctx> {
   | -------------------------------- associated items in this implementation
17 |     pub fn new() -> Self {
   |            ^^^
...
25 |     pub fn generate_vtable(
   |            ^^^^^^^^^^^^^^^
...
65 |     pub fn register_method(
   |            ^^^^^^^^^^^^^^^
...
78 |     pub fn resolve_method(
   |            ^^^^^^^^^^^^^^

warning: methods `compile_impl_block`, `compile_method_call`, and `infer_type_name` are never used
   --> src/codegen/llvm/behaviors.rs:89:12
    |
87  | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
88  |     /// Compile an impl block
89  |     pub fn compile_impl_block(&mut self, impl_block: &ImplBlock) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^
...
201 |     pub fn compile_method_call(
    |            ^^^^^^^^^^^^^^^^^^^
...
253 |     fn infer_type_name(&self, expr: &Expression) -> Result<String, CompileError> {
    |        ^^^^^^^^^^^^^^^

warning: multiple methods are never used
   --> src/codegen/llvm/binary_ops.rs:9:12
    |
8   | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
9   |     pub fn compile_binary_operation(
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
...
36  |     fn compile_add(
    |        ^^^^^^^^^^^
...
82  |     fn compile_subtract(
    |        ^^^^^^^^^^^^^^^^
...
110 |     fn compile_multiply(
    |        ^^^^^^^^^^^^^^^^
...
138 |     fn compile_divide(
    |        ^^^^^^^^^^^^^^
...
166 |     fn compile_equals(
    |        ^^^^^^^^^^^^^^
...
229 |     fn compile_not_equals(
    |        ^^^^^^^^^^^^^^^^^^
...
292 |     fn compile_less_than(
    |        ^^^^^^^^^^^^^^^^^
...
326 |     fn compile_greater_than(
    |        ^^^^^^^^^^^^^^^^^^^^
...
356 |     fn compile_less_than_equals(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^
...
386 |     fn compile_greater_than_equals(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
416 |     fn compile_string_concat(
    |        ^^^^^^^^^^^^^^^^^^^^^
...
570 |     fn compile_modulo(
    |        ^^^^^^^^^^^^^^
...
591 |     fn compile_and(
    |        ^^^^^^^^^^^
...
612 |     fn compile_or(
    |        ^^^^^^^^^^

warning: method `compile_conditional` is never used
 --> src/codegen/llvm/control_flow.rs:7:12
  |
6 | impl<'ctx> LLVMCompiler<'ctx> {
  | ----------------------------- method in this implementation
7 |     pub fn compile_conditional(&mut self, scrutinee: &Expression, arms: &[(Expression, Expression)]) -> Result<BasicValueEnum<'ctx>, Comp...
  |            ^^^^^^^^^^^^^^^^^^^

warning: multiple methods are never used
   --> src/codegen/llvm/expressions.rs:7:12
    |
6   | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
7   |     pub fn compile_expression(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^
...
135 |     fn compile_conditional_expression(&mut self, scrutinee: &Expression, arms: &[crate::ast::ConditionalArm]) -> Result<BasicValueEnum<'c...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
244 |     fn compile_array_literal(&mut self, elements: &[Expression]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
280 |     fn compile_array_index(&mut self, array: &Expression, index: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^
...
293 |     pub fn compile_array_index_address(&mut self, array: &Expression, index: &Expression) -> Result<PointerValue<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
318 |     fn compile_enum_variant(&mut self, enum_name: &str, variant: &str, payload: &Option<Box<Expression>>) -> Result<BasicValueEnum<'ctx>,...
    |        ^^^^^^^^^^^^^^^^^^^^
...
372 |     fn compile_member_access(&mut self, object: &Expression, member: &str) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
377 |     fn compile_comptime_expression(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
394 |     fn compile_pattern_match(&mut self, scrutinee: &Expression, arms: &[crate::ast::PatternArm]) -> Result<BasicValueEnum<'ctx>, CompileE...
    |        ^^^^^^^^^^^^^^^^^^^^^
...
503 |     fn compile_range_expression(&mut self, start: &Expression, end: &Expression, inclusive: bool) -> Result<BasicValueEnum<'ctx>, Compile...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^
...
525 |     fn compile_type_cast(&mut self, expr: &Expression, target_type: &crate::ast::AstType) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^

warning: multiple methods are never used
   --> src/codegen/llvm/functions.rs:12:12
    |
10  | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
11  |     /// Declares an external function (C FFI)
12  |     pub fn declare_external_function(&mut self, ext_func: &ast::ExternalFunction) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
...
73  |     pub fn declare_function(&mut self, function: &ast::Function) -> Result<FunctionValue<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^
...
153 |     pub fn compile_function_body(&mut self, function: &ast::Function) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^
...
265 |     pub fn define_and_compile_function(&mut self, function: &ast::Function) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
270 |     pub fn compile_function_call(&mut self, name: &str, args: &[ast::Expression]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^
...
434 |     fn compile_io_print(&mut self, args: &[ast::Expression]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^
...
465 |     fn compile_io_println(&mut self, args: &[ast::Expression]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^

warning: methods `compile_integer_literal`, `compile_float_literal`, `compile_string_literal`, `compile_identifier`, and `compile_string_interpolation` are never used
  --> src/codegen/llvm/literals.rs:8:12
   |
6  | impl<'ctx> LLVMCompiler<'ctx> {
   | ----------------------------- methods in this implementation
7  |     // Expression compilation methods for literals
8  |     pub fn compile_integer_literal(&self, value: i64) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^
...
12 |     pub fn compile_float_literal(&self, value: f64) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^
...
16 |     pub fn compile_string_literal(&mut self, val: &str) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^^
...
25 |     pub fn compile_identifier(&mut self, name: &str) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^
...
81 |     pub fn compile_string_interpolation(&mut self, parts: &[crate::ast::StringPart]) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: methods `compile_pattern_test`, `values_equal`, `apply_pattern_bindings`, and `restore_variables` are never used
   --> src/codegen/llvm/patterns.rs:9:12
    |
8   | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
9   |     pub fn compile_pattern_test(
    |            ^^^^^^^^^^^^^^^^^^^^
...
279 |     fn values_equal(
    |        ^^^^^^^^^^^^
...
314 |     pub fn apply_pattern_bindings(
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
354 |     pub fn restore_variables(
    |            ^^^^^^^^^^^^^^^^^

warning: methods `compile_address_of`, `compile_dereference`, and `compile_pointer_offset` are never used
  --> src/codegen/llvm/pointers.rs:10:12
   |
9  | impl<'ctx> LLVMCompiler<'ctx> {
   | ----------------------------- methods in this implementation
10 |     pub fn compile_address_of(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^
...
33 |     pub fn compile_dereference(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^
...
91 |     pub fn compile_pointer_offset(&mut self, pointer: &Expression, offset: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^^

warning: method `compile_statement` is never used
  --> src/codegen/llvm/statements.rs:10:12
   |
9  | impl<'ctx> LLVMCompiler<'ctx> {
   | ----------------------------- method in this implementation
10 |     pub fn compile_statement(&mut self, statement: &Statement) -> Result<(), CompileError> {
   |            ^^^^^^^^^^^^^^^^^

warning: method `compile_string_length` is never used
 --> src/codegen/llvm/strings.rs:7:12
  |
6 | impl<'ctx> LLVMCompiler<'ctx> {
  | ----------------------------- method in this implementation
7 |     pub fn compile_string_length(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
  |            ^^^^^^^^^^^^^^^^^^^^^

warning: struct `StructTypeInfo` is never constructed
  --> src/codegen/llvm/structs.rs:12:12
   |
12 | pub struct StructTypeInfo<'ctx> {
   |            ^^^^^^^^^^^^^^
   |
   = note: `StructTypeInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `compile_struct_literal`, `compile_struct_field`, `compile_struct_field_from_value`, `infer_struct_type_from_value`, and `compile_struct_field_assignment` are never used
   --> src/codegen/llvm/structs.rs:21:12
    |
20  | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
21  |     pub fn compile_struct_literal(&mut self, name: &str, fields: &[(String, Expression)]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
69  |     pub fn compile_struct_field(&mut self, struct_: &Expression, field: &str) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^
...
273 |     fn compile_struct_field_from_value(&mut self, _struct_val: BasicValueEnum<'ctx>, _field: &str, original_expr: &Expression) -> Result<...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
284 |     pub fn infer_struct_type_from_value(&mut self, _val: &BasicValueEnum<'ctx>, expr: &Expression) -> Result<String, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
366 |     pub fn compile_struct_field_assignment(&mut self, struct_alloca: inkwell::values::PointerValue<'ctx>, field_name: &str, value: BasicV...
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: struct `EnumInfo` is never constructed
  --> src/codegen/llvm/symbols.rs:10:12
   |
10 | pub struct EnumInfo<'ctx> {
   |            ^^^^^^^^
   |
   = note: `EnumInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: enum `Symbol` is never used
  --> src/codegen/llvm/symbols.rs:21:10
   |
21 | pub enum Symbol<'ctx> {
   |          ^^^^^^
   |
   = note: `Symbol` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: struct `Scope` is never constructed
  --> src/codegen/llvm/symbols.rs:43:12
   |
43 | pub struct Scope<'ctx> {
   |            ^^^^^
   |
   = note: `Scope` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: struct `SymbolTable` is never constructed
  --> src/codegen/llvm/symbols.rs:50:12
   |
50 | pub struct SymbolTable<'ctx> {
   |            ^^^^^^^^^^^
   |
   = note: `SymbolTable` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: multiple associated items are never used
   --> src/codegen/llvm/symbols.rs:57:12
    |
55  | impl<'ctx> SymbolTable<'ctx> {
    | ---------------------------- associated items in this implementation
56  |     /// Create a new symbol table with a global scope
57  |     pub fn new() -> Self {
    |            ^^^
...
70  |     pub fn enter_scope(&mut self) {
    |            ^^^^^^^^^^^
...
81  |     pub fn exit_scope(&mut self) -> Option<()> {
    |            ^^^^^^^^^^
...
91  |     pub fn insert<S: Into<String>>(&mut self, name: S, symbol: Symbol<'ctx>) -> Option<Symbol<'ctx>> {
    |            ^^^^^^
...
96  |     pub fn lookup(&self, name: &str) -> Option<&Symbol<'ctx>> {
    |            ^^^^^^
...
111 |     pub fn get_mut(&mut self, name: &str) -> Option<&mut Symbol<'ctx>> {
    |            ^^^^^^^
...
116 |     pub fn exists_in_current_scope(&self, name: &str) -> bool {
    |            ^^^^^^^^^^^^^^^^^^^^^^^
...
121 |     pub fn depth(&self) -> usize {
    |            ^^^^^

warning: methods `to_llvm_type` and `expect_basic_type` are never used
   --> src/codegen/llvm/types.rs:10:12
    |
9   | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
10  |     pub fn to_llvm_type(&mut self, type_: &AstType) -> Result<Type<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^
...
173 |     pub fn expect_basic_type<'a>(&self, t: Type<'a>) -> Result<BasicTypeEnum<'a>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^

warning: struct `Compiler` is never constructed
  --> src/compiler.rs:14:12
   |
14 | pub struct Compiler<'ctx> {
   |            ^^^^^^^^

warning: multiple associated items are never used
   --> src/compiler.rs:19:12
    |
18  | impl<'ctx> Compiler<'ctx> {
    | ------------------------- associated items in this implementation
19  |     pub fn new(context: &'ctx Context) -> Self {
    |            ^^^
...
25  |     pub fn compile_llvm(&self, program: &Program) -> Result<String> {
    |            ^^^^^^^^^^^^
...
50  |     pub fn get_module(&self, program: &Program) -> Result<Module<'ctx>> {
    |            ^^^^^^^^^^
...
75  |     fn process_imports(&self, program: &Program) -> Result<Program> {
    |        ^^^^^^^^^^^^^^^
...
110 |     fn execute_comptime(&self, program: Program) -> Result<Program> {
    |        ^^^^^^^^^^^^^^^^
...
138 |     fn process_declaration_comptime(&self, decl: Declaration, interpreter: &mut ComptimeInterpreter) -> Result<Declaration> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
159 |     fn process_statements_comptime(&self, statements: Vec<crate::ast::Statement>, interpreter: &mut ComptimeInterpreter) -> Result<Vec<cr...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
170 |     fn process_statement_comptime(&self, stmt: crate::ast::Statement, interpreter: &mut ComptimeInterpreter) -> Result<crate::ast::Statem...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
225 |     fn process_expression_comptime(&self, expr: crate::ast::Expression, interpreter: &mut ComptimeInterpreter) -> Result<crate::ast::Expr...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: enum `ComptimeValue` is never used
  --> src/comptime/mod.rs:12:10
   |
12 | pub enum ComptimeValue {
   |          ^^^^^^^^^^^^^
   |
   = note: `ComptimeValue` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `to_expression` and `get_type` are never used
  --> src/comptime/mod.rs:52:12
   |
50 | impl ComptimeValue {
   | ------------------ methods in this implementation
51 |     /// Convert a compile-time value to an AST expression
52 |     pub fn to_expression(&self) -> Result<Expression> {
   |            ^^^^^^^^^^^^^
...
79 |     pub fn get_type(&self) -> AstType {
   |            ^^^^^^^^

warning: struct `Environment` is never constructed
   --> src/comptime/mod.rs:126:12
    |
126 | pub struct Environment {
    |            ^^^^^^^^^^^
    |
    = note: `Environment` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: associated items `new`, `with_parent`, `define`, `get`, and `set` are never used
   --> src/comptime/mod.rs:132:12
    |
131 | impl Environment {
    | ---------------- associated items in this implementation
132 |     pub fn new() -> Self {
    |            ^^^
...
139 |     pub fn with_parent(parent: Environment) -> Self {
    |            ^^^^^^^^^^^
...
146 |     pub fn define(&self, name: String, value: ComptimeValue) {
    |            ^^^^^^
...
150 |     pub fn get(&self, name: &str) -> Option<ComptimeValue> {
    |            ^^^
...
155 |     pub fn set(&self, name: &str, value: ComptimeValue) -> Result<()> {
    |            ^^^

warning: struct `ComptimeInterpreter` is never constructed
   --> src/comptime/mod.rs:170:12
    |
170 | pub struct ComptimeInterpreter {
    |            ^^^^^^^^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/comptime/mod.rs:179:12
    |
178 | impl ComptimeInterpreter {
    | ------------------------ associated items in this implementation
179 |     pub fn new() -> Self {
    |            ^^^
...
192 |     pub fn set_variable(&mut self, name: String, value: ComptimeValue) {
    |            ^^^^^^^^^^^^
...
196 |     pub fn get_variable(&self, name: &str) -> Option<ComptimeValue> {
    |            ^^^^^^^^^^^^
...
200 |     fn init_builtins(&mut self) {
    |        ^^^^^^^^^^^^^
...
295 |     pub fn execute_comptime_block(&mut self, statements: &[Statement]) -> Result<()> {
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
303 |     pub fn execute_statement(&mut self, stmt: &Statement) -> Result<Option<ComptimeValue>> {
    |            ^^^^^^^^^^^^^^^^^
...
342 |     pub fn evaluate_expression(&mut self, expr: &Expression) -> Result<ComptimeValue> {
    |            ^^^^^^^^^^^^^^^^^^^
...
420 |     fn evaluate_binary_op(
    |        ^^^^^^^^^^^^^^^^^^
...
482 |     fn evaluate_function_call(&mut self, name: &str, args: &[Expression]) -> Result<ComptimeValue> {
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
562 |     fn evaluate_member_access(&mut self, object: ComptimeValue, member: &str) -> Result<ComptimeValue> {
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
577 |     pub fn get_generated_declarations(&self) -> Vec<Declaration> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
582 |     pub fn generate_code(&mut self, value: ComptimeValue) -> Result<Expression> {
    |            ^^^^^^^^^^^^^

warning: multiple variants are never constructed
  --> src/error.rs:16:5
   |
14 | pub enum CompileError {
   |          ------------ variants in this enum
15 |     SyntaxError(String, Option<Span>),
16 |     UndeclaredVariable(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^
17 |     UndeclaredFunction(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^
18 |     TypeMismatch {
   |     ^^^^^^^^^^^^
...
23 |     InvalidLoopCondition(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^^^
24 |     MissingReturnStatement(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^^^^^
25 |     InternalError(String, Option<Span>),
26 |     UnsupportedFeature(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^
27 |     TypeError(String, Option<Span>),
   |     ^^^^^^^^^
28 |     FileNotFound(String, Option<String>),
   |     ^^^^^^^^^^^^
29 |     ParseError(String, Option<Span>),
   |     ^^^^^^^^^^
30 |     ComptimeError(String),
   |     ^^^^^^^^^^^^^
   |
   = note: `CompileError` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: method `next_token` is never used
  --> src/lexer.rs:81:12
   |
47 | impl<'a> Lexer<'a> {
   | ------------------ method in this implementation
...
81 |     pub fn next_token(&mut self) -> Token {
   |            ^^^^^^^^^^

warning: associated function `new` is never used
  --> src/lsp/mod.rs:19:12
   |
18 | impl ZenServer {
   | -------------- associated function in this implementation
19 |     pub fn new(client: Client) -> Self {
   |            ^^^

warning: function `run_lsp_server` is never used
   --> src/lsp/mod.rs:232:14
    |
232 | pub async fn run_lsp_server() {
    |              ^^^^^^^^^^^^^^

warning: struct `ModuleSystem` is never constructed
  --> src/module_system/mod.rs:10:12
   |
10 | pub struct ModuleSystem {
   |            ^^^^^^^^^^^^

warning: associated items `new`, `add_search_path`, `load_module`, `resolve_module_path`, `get_modules`, and `merge_programs` are never used
   --> src/module_system/mod.rs:20:12
    |
19  | impl ModuleSystem {
    | ----------------- associated items in this implementation
20  |     pub fn new() -> Self {
    |            ^^^
...
43  |     pub fn add_search_path(&mut self, path: PathBuf) {
    |            ^^^^^^^^^^^^^^^
...
48  |     pub fn load_module(&mut self, module_path: &str) -> Result<&Program, CompileError> {
    |            ^^^^^^^^^^^
...
92  |     fn resolve_module_path(&self, module_path: &str) -> Result<PathBuf, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^
...
117 |     pub fn get_modules(&self) -> &HashMap<String, Program> {
    |            ^^^^^^^^^^^
...
122 |     pub fn merge_programs(&self, main_program: Program) -> Program {
    |            ^^^^^^^^^^^^^^

warning: struct `ModuleResolver` is never constructed
 --> src/module_system/resolver.rs:5:12
  |
5 | pub struct ModuleResolver {
  |            ^^^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/module_system/resolver.rs:13:12
    |
12  | impl ModuleResolver {
    | ------------------- associated items in this implementation
13  |     pub fn new() -> Self {
    |            ^^^
...
21  |     pub fn add_import(&mut self, alias: String, module_path: String) {
    |            ^^^^^^^^^^
...
26  |     pub fn add_exports(&mut self, module_path: String, symbols: HashSet<String>) {
    |            ^^^^^^^^^^^
...
31  |     pub fn resolve_qualified_name(&self, name: &str) -> Option<(String, String)> {
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
44  |     pub fn is_exported(&self, module_path: &str, symbol: &str) -> bool {
    |            ^^^^^^^^^^^
...
52  |     pub fn extract_exports(program: &Program) -> HashSet<String> {
    |            ^^^^^^^^^^^^^^^
...
78  |     pub fn resolve_program(&self, program: &mut Program) -> Result<(), String> {
    |            ^^^^^^^^^^^^^^^
...
89  |     fn resolve_function(&self, func: &mut Function) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^
...
97  |     fn resolve_statement(&self, stmt: &mut Statement) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^
...
121 |     fn resolve_expression(&self, expr: &mut Expression) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^

warning: methods `debug_current_token` and `debug_peek_token` are never used
  --> src/parser/core.rs:33:12
   |
12 | impl<'a> Parser<'a> {
   | ------------------- methods in this implementation
...
33 |     pub fn debug_current_token(&self) -> &Token {
   |            ^^^^^^^^^^^^^^^^^^^
...
37 |     pub fn debug_peek_token(&self) -> &Token {
   |            ^^^^^^^^^^^^^^^^

warning: method `parse_method` is never used
   --> src/parser/structs.rs:147:8
    |
6   | impl<'a> Parser<'a> {
    | ------------------- method in this implementation
...
147 |     fn parse_method(&mut self) -> Result<Function> {
    |        ^^^^^^^^^^^^

warning: method `parse_binding_pattern` is never used
   --> src/parser/patterns.rs:230:12
    |
6   | impl<'a> Parser<'a> {
    | ------------------- method in this implementation
...
230 |     pub fn parse_binding_pattern(&mut self) -> Result<Pattern> {
    |            ^^^^^^^^^^^^^^^^^^^^^

warning: methods `parse_comptime_block`, `parse_comptime_expression`, and `parse_comptime` are never used
  --> src/parser/comptime.rs:8:12
   |
6  | impl<'a> Parser<'a> {
   | ------------------- methods in this implementation
7  |     /// Parse a comptime block: comptime { ... }
8  |     pub fn parse_comptime_block(&mut self) -> Result<Statement> {
   |            ^^^^^^^^^^^^^^^^^^^^
...
46 |     pub fn parse_comptime_expression(&mut self) -> Result<Expression> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^
...
53 |     pub fn parse_comptime(&mut self) -> Result<Statement> {
   |            ^^^^^^^^^^^^^^

warning: struct `StdNamespace` is never constructed
  --> src/stdlib/mod.rs:15:12
   |
15 | pub struct StdNamespace {
   |            ^^^^^^^^^^^^

warning: enum `StdModule` is never used
  --> src/stdlib/mod.rs:19:10
   |
19 | pub enum StdModule {
   |          ^^^^^^^^^

warning: associated items `new`, `get_module`, `is_std_reference`, and `resolve_std_access` are never used
  --> src/stdlib/mod.rs:30:12
   |
29 | impl StdNamespace {
   | ----------------- associated items in this implementation
30 |     pub fn new() -> Self {
   |            ^^^
...
44 |     pub fn get_module(&self, name: &str) -> Option<&StdModule> {
   |            ^^^^^^^^^^
...
49 |     pub fn is_std_reference(name: &str) -> bool {
   |            ^^^^^^^^^^^^^^^^
...
54 |     pub fn resolve_std_access(module_name: &str) -> Option<Expression> {
   |            ^^^^^^^^^^^^^^^^^^

warning: methods `name`, `get_function`, and `get_type` are never used
  --> src/stdlib/mod.rs:91:8
   |
90 | pub trait StdModuleTrait {
   |           -------------- methods in this trait
91 |     fn name(&self) -> &str;
   |        ^^^^
92 |     fn get_function(&self, name: &str) -> Option<StdFunction>;
   |        ^^^^^^^^^^^^
93 |     fn get_type(&self, name: &str) -> Option<AstType>;
   |        ^^^^^^^^

warning: fields `name`, `params`, `return_type`, and `is_builtin` are never read
   --> src/stdlib/mod.rs:98:9
    |
97  | pub struct StdFunction {
    |            ----------- fields in this struct
98  |     pub name: String,
    |         ^^^^
99  |     pub params: Vec<(String, AstType)>,
    |         ^^^^^^
100 |     pub return_type: AstType,
    |         ^^^^^^^^^^^
101 |     pub is_builtin: bool,
    |         ^^^^^^^^^^
    |
    = note: `StdFunction` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: associated function `new` is never used
  --> src/stdlib/core.rs:12:12
   |
11 | impl CoreModule {
   | --------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: associated function `new` is never used
  --> src/stdlib/build.rs:12:12
   |
11 | impl BuildModule {
   | ---------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: function `create_result_type` is never used
 --> src/stdlib/result.rs:4:8
  |
4 | pub fn create_result_type() -> AstType {
  |        ^^^^^^^^^^^^^^^^^^

warning: function `create_option_type` is never used
  --> src/stdlib/result.rs:27:8
   |
27 | pub fn create_option_type() -> AstType {
   |        ^^^^^^^^^^^^^^^^^^

warning: function `ok_value` is never used
  --> src/stdlib/result.rs:47:8
   |
47 | pub fn ok_value(value: Expression) -> Expression {
   |        ^^^^^^^^

warning: function `err_value` is never used
  --> src/stdlib/result.rs:56:8
   |
56 | pub fn err_value(error: Expression) -> Expression {
   |        ^^^^^^^^^

warning: function `some_value` is never used
  --> src/stdlib/result.rs:65:8
   |
65 | pub fn some_value(value: Expression) -> Expression {
   |        ^^^^^^^^^^

warning: function `none_value` is never used
  --> src/stdlib/result.rs:74:8
   |
74 | pub fn none_value() -> Expression {
   |        ^^^^^^^^^^

warning: function `ok_pattern` is never used
  --> src/stdlib/result.rs:83:8
   |
83 | pub fn ok_pattern(binding: Option<String>) -> Pattern {
   |        ^^^^^^^^^^

warning: function `err_pattern` is never used
  --> src/stdlib/result.rs:92:8
   |
92 | pub fn err_pattern(binding: Option<String>) -> Pattern {
   |        ^^^^^^^^^^^

warning: function `some_pattern` is never used
   --> src/stdlib/result.rs:101:8
    |
101 | pub fn some_pattern(binding: Option<String>) -> Pattern {
    |        ^^^^^^^^^^^^

warning: function `none_pattern` is never used
   --> src/stdlib/result.rs:110:8
    |
110 | pub fn none_pattern() -> Pattern {
    |        ^^^^^^^^^^^^

warning: associated items `new`, `get_function`, and `list_functions` are never used
   --> src/stdlib/io.rs:11:12
    |
10  | impl IOModule {
    | ------------- associated items in this implementation
11  |     pub fn new() -> Self {
    |            ^^^
...
155 |     pub fn get_function(&self, name: &str) -> Option<&StdFunction> {
    |            ^^^^^^^^^^^^
...
160 |     pub fn list_functions(&self) -> Vec<String> {
    |            ^^^^^^^^^^^^^^

warning: function `create_net_module` is never used
 --> src/stdlib/net.rs:8:8
  |
8 | pub fn create_net_module() -> Vec<Declaration> {
  |        ^^^^^^^^^^^^^^^^^

warning: function `create_socket_externals` is never used
  --> src/stdlib/net.rs:29:4
   |
29 | fn create_socket_externals() -> Vec<Declaration> {
   |    ^^^^^^^^^^^^^^^^^^^^^^^

warning: function `create_socket_types` is never used
   --> src/stdlib/net.rs:163:4
    |
163 | fn create_socket_types() -> Vec<Declaration> {
    |    ^^^^^^^^^^^^^^^^^^^

warning: function `create_tcp_functions` is never used
   --> src/stdlib/net.rs:260:4
    |
260 | fn create_tcp_functions() -> Vec<Declaration> {
    |    ^^^^^^^^^^^^^^^^^^^^

warning: function `create_udp_functions` is never used
   --> src/stdlib/net.rs:412:4
    |
412 | fn create_udp_functions() -> Vec<Declaration> {
    |    ^^^^^^^^^^^^^^^^^^^^

warning: function `create_helper_functions` is never used
   --> src/stdlib/net.rs:517:4
    |
517 | fn create_helper_functions() -> Vec<Declaration> {
    |    ^^^^^^^^^^^^^^^^^^^^^^^

warning: associated function `new` is never used
  --> src/stdlib/math.rs:12:12
   |
11 | impl MathModule {
   | --------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: associated function `new` is never used
  --> src/stdlib/string.rs:12:12
   |
11 | impl StringModule {
   | ----------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: associated function `new` is never used
  --> src/stdlib/vec.rs:12:12
   |
11 | impl VecModule {
   | -------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: associated function `new` is never used
  --> src/stdlib/fs.rs:12:12
   |
11 | impl FsModule {
   | ------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: struct `TypeChecker` is never constructed
  --> src/typechecker/mod.rs:12:12
   |
12 | pub struct TypeChecker {
   |            ^^^^^^^^^^^

warning: struct `FunctionSignature` is never constructed
  --> src/typechecker/mod.rs:28:12
   |
28 | pub struct FunctionSignature {
   |            ^^^^^^^^^^^^^^^^^
   |
   = note: `FunctionSignature` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `StructInfo` is never constructed
  --> src/typechecker/mod.rs:35:12
   |
35 | pub struct StructInfo {
   |            ^^^^^^^^^^
   |
   = note: `StructInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `EnumInfo` is never constructed
  --> src/typechecker/mod.rs:40:12
   |
40 | pub struct EnumInfo {
   |            ^^^^^^^^
   |
   = note: `EnumInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: multiple associated items are never used
   --> src/typechecker/mod.rs:45:12
    |
44  | impl TypeChecker {
    | ---------------- associated items in this implementation
45  |     pub fn new() -> Self {
    |            ^^^
...
56  |     pub fn check_program(&mut self, program: &Program) -> Result<()> {
    |            ^^^^^^^^^^^^^
...
70  |     fn collect_declaration_types(&mut self, declaration: &Declaration) -> Result<()> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^
...
143 |     fn check_declaration(&mut self, declaration: &Declaration) -> Result<()> {
    |        ^^^^^^^^^^^^^^^^^
...
171 |     fn check_function(&mut self, function: &Function) -> Result<()> {
    |        ^^^^^^^^^^^^^^
...
188 |     fn check_statement(&mut self, statement: &Statement) -> Result<()> {
    |        ^^^^^^^^^^^^^^^
...
292 |     fn infer_expression_type(&self, expr: &Expression) -> Result<AstType> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
522 |     fn types_compatible(&self, expected: &AstType, actual: &AstType) -> bool {
    |        ^^^^^^^^^^^^^^^^
...
526 |     fn enter_scope(&mut self) {
    |        ^^^^^^^^^^^
...
530 |     fn exit_scope(&mut self) {
    |        ^^^^^^^^^^
...
534 |     fn declare_variable(&mut self, name: &str, type_: AstType) -> Result<()> {
    |        ^^^^^^^^^^^^^^^^
...
549 |     fn get_variable_type(&self, name: &str) -> Result<AstType> {
    |        ^^^^^^^^^^^^^^^^^

warning: multiple methods are never used
  --> src/typechecker/types.rs:6:12
   |
4  | impl AstType {
   | ------------ methods in this implementation
5  |     /// Check if this type is numeric (integer or float)
6  |     pub fn is_numeric(&self) -> bool {
   |            ^^^^^^^^^^
...
23 |     pub fn is_integer(&self) -> bool {
   |            ^^^^^^^^^^
...
38 |     pub fn is_float(&self) -> bool {
   |            ^^^^^^^^
...
43 |     pub fn is_signed_integer(&self) -> bool {
   |            ^^^^^^^^^^^^^^^^^
...
51 |     pub fn is_unsigned_integer(&self) -> bool {
   |            ^^^^^^^^^^^^^^^^^^^
...
59 |     pub fn bit_size(&self) -> Option<usize> {
   |            ^^^^^^^^
...
71 |     pub fn default_value(&self) -> String {
   |            ^^^^^^^^^^^^^

warning: function `infer_binary_op_type` is never used
 --> src/typechecker/inference.rs:7:8
  |
7 | pub fn infer_binary_op_type(
  |        ^^^^^^^^^^^^^^^^^^^^

warning: function `infer_member_type` is never used
  --> src/typechecker/inference.rs:75:8
   |
75 | pub fn infer_member_type(
   |        ^^^^^^^^^^^^^^^^^

warning: function `promote_numeric_types` is never used
   --> src/typechecker/inference.rs:132:4
    |
132 | fn promote_numeric_types(left: &AstType, right: &AstType) -> Result<AstType> {
    |    ^^^^^^^^^^^^^^^^^^^^^

warning: function `types_comparable` is never used
   --> src/typechecker/inference.rs:186:4
    |
186 | fn types_comparable(left: &AstType, right: &AstType) -> bool {
    |    ^^^^^^^^^^^^^^^^

warning: function `types_compatible` is never used
 --> src/typechecker/validation.rs:4:8
  |
4 | pub fn types_compatible(expected: &AstType, actual: &AstType) -> bool {
  |        ^^^^^^^^^^^^^^^^

warning: function `can_implicitly_convert` is never used
  --> src/typechecker/validation.rs:88:8
   |
88 | pub fn can_implicitly_convert(from: &AstType, to: &AstType) -> bool {
   |        ^^^^^^^^^^^^^^^^^^^^^^

warning: function `requires_initialization` is never used
   --> src/typechecker/validation.rs:122:8
    |
122 | pub fn requires_initialization(type_: &AstType) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^^^^

warning: function `is_valid_condition_type` is never used
   --> src/typechecker/validation.rs:134:8
    |
134 | pub fn is_valid_condition_type(type_: &AstType) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^^^^

warning: function `can_be_indexed` is never used
   --> src/typechecker/validation.rs:141:8
    |
141 | pub fn can_be_indexed(type_: &AstType) -> Option<AstType> {
    |        ^^^^^^^^^^^^^^

warning: function `can_be_dereferenced` is never used
   --> src/typechecker/validation.rs:152:8
    |
152 | pub fn can_be_dereferenced(type_: &AstType) -> Option<AstType> {
    |        ^^^^^^^^^^^^^^^^^^^

warning: struct `BehaviorResolver` is never constructed
 --> src/typechecker/behaviors.rs:6:12
  |
6 | pub struct BehaviorResolver {
  |            ^^^^^^^^^^^^^^^^

warning: struct `BehaviorInfo` is never constructed
  --> src/typechecker/behaviors.rs:16:12
   |
16 | pub struct BehaviorInfo {
   |            ^^^^^^^^^^^^
   |
   = note: `BehaviorInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `BehaviorMethodInfo` is never constructed
  --> src/typechecker/behaviors.rs:23:12
   |
23 | pub struct BehaviorMethodInfo {
   |            ^^^^^^^^^^^^^^^^^^
   |
   = note: `BehaviorMethodInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `ImplInfo` is never constructed
  --> src/typechecker/behaviors.rs:31:12
   |
31 | pub struct ImplInfo {
   |            ^^^^^^^^
   |
   = note: `ImplInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `MethodInfo` is never constructed
  --> src/typechecker/behaviors.rs:39:12
   |
39 | pub struct MethodInfo {
   |            ^^^^^^^^^^
   |
   = note: `MethodInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: multiple associated items are never used
   --> src/typechecker/behaviors.rs:46:12
    |
45  | impl BehaviorResolver {
    | --------------------- associated items in this implementation
46  |     pub fn new() -> Self {
    |            ^^^
...
55  |     pub fn register_behavior(&mut self, behavior: &BehaviorDefinition) -> Result<()> {
    |            ^^^^^^^^^^^^^^^^^
...
87  |     pub fn register_impl(&mut self, impl_block: &ImplBlock) -> Result<()> {
    |            ^^^^^^^^^^^^^
...
148 |     pub fn type_implements(&self, type_name: &str, behavior_name: &str) -> bool {
    |            ^^^^^^^^^^^^^^^
...
153 |     pub fn get_impl(&self, type_name: &str, behavior_name: &str) -> Option<&ImplInfo> {
    |            ^^^^^^^^
...
158 |     pub fn resolve_method(
    |            ^^^^^^^^^^^^^^
...
183 |     pub fn verify_impl(&self, impl_block: &ImplBlock) -> Result<()> {
    |            ^^^^^^^^^^^
...
219 |     pub fn get_implemented_behaviors(&self, type_name: &str) -> Vec<String> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: associated items `new`, `add`, `get`, and `apply` are never used
  --> src/type_system/mod.rs:25:12
   |
24 | impl TypeSubstitution {
   | --------------------- associated items in this implementation
25 |     pub fn new() -> Self {
   |            ^^^
...
31 |     pub fn add(&mut self, param: String, concrete: AstType) {
   |            ^^^
...
35 |     pub fn get(&self, param: &str) -> Option<&AstType> {
   |            ^^^
...
39 |     pub fn apply(&self, ast_type: &AstType) -> AstType {
   |            ^^^^^

warning: struct `TypeConstraint` is never constructed
  --> src/type_system/mod.rs:83:12
   |
83 | pub struct TypeConstraint {
   |            ^^^^^^^^^^^^^^
   |
   = note: `TypeConstraint` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: function `is_generic_type` is never used
  --> src/type_system/mod.rs:88:8
   |
88 | pub fn is_generic_type(ast_type: &AstType) -> bool {
   |        ^^^^^^^^^^^^^^^

warning: function `extract_type_parameters` is never used
   --> src/type_system/mod.rs:101:8
    |
101 | pub fn extract_type_parameters(ast_type: &AstType) -> Vec<String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^

warning: function `extract_type_params_recursive` is never used
   --> src/type_system/mod.rs:107:4
    |
107 | fn extract_type_params_recursive(ast_type: &AstType, params: &mut Vec<String>) {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: struct `TypeInstantiator` is never constructed
 --> src/type_system/instantiation.rs:4:12
  |
4 | pub struct TypeInstantiator<'a> {
  |            ^^^^^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/type_system/instantiation.rs:9:12
    |
8   | impl<'a> TypeInstantiator<'a> {
    | ----------------------------- associated items in this implementation
9   |     pub fn new(env: &'a mut TypeEnvironment) -> Self {
    |            ^^^
...
13  |     pub fn instantiate_function(
    |            ^^^^^^^^^^^^^^^^^^^^
...
46  |     pub fn instantiate_struct(
    |            ^^^^^^^^^^^^^^^^^^
...
83  |     pub fn instantiate_enum(
    |            ^^^^^^^^^^^^^^^^
...
118 |     fn instantiate_method(
    |        ^^^^^^^^^^^^^^^^^^
...
141 |     fn instantiate_statements(
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
151 |     fn instantiate_statement(
    |        ^^^^^^^^^^^^^^^^^^^^^
...
188 |     fn instantiate_expression(&mut self, expr: &Expression, substitution: &TypeSubstitution) -> Expression {
    |        ^^^^^^^^^^^^^^^^^^^^^^

warning: function `generate_instantiated_name` is never used
   --> src/type_system/instantiation.rs:239:4
    |
239 | fn generate_instantiated_name(base_name: &str, type_args: &[AstType]) -> String {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `type_to_string` is never used
   --> src/type_system/instantiation.rs:248:4
    |
248 | fn type_to_string(ast_type: &AstType) -> String {
    |    ^^^^^^^^^^^^^^

warning: struct `TypeEnvironment` is never constructed
 --> src/type_system/environment.rs:6:12
  |
6 | pub struct TypeEnvironment {
  |            ^^^^^^^^^^^^^^^
  |
  = note: `TypeEnvironment` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: struct `TypeScope` is never constructed
  --> src/type_system/environment.rs:16:8
   |
16 | struct TypeScope {
   |        ^^^^^^^^^

warning: multiple associated items are never used
   --> src/type_system/environment.rs:22:12
    |
21  | impl TypeEnvironment {
    | -------------------- associated items in this implementation
22  |     pub fn new() -> Self {
    |            ^^^
...
36  |     pub fn register_generic_function(&mut self, func: Function) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
...
42  |     pub fn register_generic_struct(&mut self, struct_def: StructDefinition) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^
...
48  |     pub fn register_generic_enum(&mut self, enum_def: EnumDefinition) {
    |            ^^^^^^^^^^^^^^^^^^^^^
...
54  |     pub fn push_scope(&mut self, type_params: Vec<TypeParameter>) {
    |            ^^^^^^^^^^
...
61  |     pub fn pop_scope(&mut self) {
    |            ^^^^^^^^^
...
67  |     pub fn add_substitution(&mut self, param: String, concrete: AstType) {
    |            ^^^^^^^^^^^^^^^^
...
73  |     pub fn resolve_type(&self, ast_type: &AstType) -> AstType {
    |            ^^^^^^^^^^^^
...
83  |     pub fn get_generic_function(&self, name: &str) -> Option<&Function> {
    |            ^^^^^^^^^^^^^^^^^^^^
...
87  |     pub fn get_generic_struct(&self, name: &str) -> Option<&StructDefinition> {
    |            ^^^^^^^^^^^^^^^^^^
...
91  |     pub fn get_generic_enum(&self, name: &str) -> Option<&EnumDefinition> {
    |            ^^^^^^^^^^^^^^^^
...
95  |     pub fn record_instantiation(&mut self, base_name: String, type_args: Vec<AstType>, specialized: AstType) {
    |            ^^^^^^^^^^^^^^^^^^^^
...
108 |     pub fn get_instantiation(&self, base_name: &str, type_args: &[AstType]) -> Option<&AstType> {
    |            ^^^^^^^^^^^^^^^^^
...
116 |     pub fn is_type_parameter(&self, name: &str) -> bool {
    |            ^^^^^^^^^^^^^^^^^
...
122 |     pub fn validate_type_args(&self, expected: &[TypeParameter], provided: &[AstType]) -> Result<(), String> {
    |            ^^^^^^^^^^^^^^^^^^

warning: struct `Monomorphizer` is never constructed
 --> src/type_system/monomorphization.rs:6:12
  |
6 | pub struct Monomorphizer {
  |            ^^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/type_system/monomorphization.rs:15:12
    |
14  | impl Monomorphizer {
    | ------------------ associated items in this implementation
15  |     pub fn new() -> Self {
    |            ^^^
...
25  |     pub fn monomorphize_program(&mut self, program: &Program) -> Result<Program, String> {
    |            ^^^^^^^^^^^^^^^^^^^^
...
86  |     fn collect_instantiations_from_declaration(&mut self, decl: &Declaration) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
105 |     fn collect_instantiations_from_function(&mut self, func: &Function) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
112 |     fn collect_instantiations_from_statement(&mut self, stmt: &crate::ast::Statement) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
146 |     fn collect_instantiations_from_expression(&mut self, expr: &Expression) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
223 |     fn collect_instantiations_from_type(&mut self, ast_type: &AstType) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
256 |     fn infer_type_arguments(&self, generic_func: &Function, args: &[Expression]) -> Result<Vec<AstType>, String> {
    |        ^^^^^^^^^^^^^^^^^^^^
...
287 |     fn type_uses_parameter(&self, ast_type: &AstType, param_name: &str) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^
...
298 |     fn infer_expression_type(&self, expr: &Expression) -> Result<AstType, String> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
315 |     fn transform_declarations(&mut self, declarations: Vec<Declaration>) -> Result<Vec<Declaration>, String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
331 |     fn transform_function(&mut self, mut func: Function) -> Result<Function, String> {
    |        ^^^^^^^^^^^^^^^^^^
...
336 |     fn transform_statements(&mut self, statements: Vec<crate::ast::Statement>) -> Result<Vec<crate::ast::Statement>, String> {
    |        ^^^^^^^^^^^^^^^^^^^^
...
346 |     fn transform_statement(&mut self, stmt: crate::ast::Statement) -> Result<crate::ast::Statement, String> {
    |        ^^^^^^^^^^^^^^^^^^^
...
378 |     fn transform_expression(&mut self, expr: Expression) -> Result<Expression, String> {
    |        ^^^^^^^^^^^^^^^^^^^^

warning: function `generate_instantiated_name` is never used
   --> src/type_system/monomorphization.rs:475:4
    |
475 | fn generate_instantiated_name(base_name: &str, type_args: &[AstType]) -> String {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `type_to_string` is never used
   --> src/type_system/monomorphization.rs:484:4
    |
484 | fn type_to_string(ast_type: &AstType) -> String {
    |    ^^^^^^^^^^^^^^

warning: function `extract_generic_struct_types` is never used
   --> src/type_system/monomorphization.rs:503:4
    |
503 | fn extract_generic_struct_types(name: &str) -> Option<Vec<AstType>> {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `extract_base_name` is never used
   --> src/type_system/monomorphization.rs:512:4
    |
512 | fn extract_base_name(name: &str) -> String {
    |    ^^^^^^^^^^^^^^^^^

warning: `zen` (bin "zen") generated 131 warnings (12 duplicates)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
warning: unused import: `FloatValue`
   --> src/codegen/llvm/expressions.rs:526:41
    |
526 |         use inkwell::values::{IntValue, FloatValue, PointerValue};
    |                                         ^^^^^^^^^^
    |
    = note: `#[warn(unused_imports)]` on by default

warning: use of deprecated method `inkwell::types::IntType::<'ctx>::ptr_type`: Starting from version 15.0, LLVM doesn't differentiate between pointer types. Use Context::ptr_type instead.
   --> src/codegen/llvm/functions.rs:445:54
    |
445 |             let i8_ptr_type = self.context.i8_type().ptr_type(inkwell::AddressSpace::default());
    |                                                      ^^^^^^^^
    |
    = note: `#[warn(deprecated)]` on by default

warning: use of deprecated method `inkwell::types::IntType::<'ctx>::ptr_type`: Starting from version 15.0, LLVM doesn't differentiate between pointer types. Use Context::ptr_type instead.
   --> src/codegen/llvm/functions.rs:476:54
    |
476 |             let i8_ptr_type = self.context.i8_type().ptr_type(inkwell::AddressSpace::default());
    |                                                      ^^^^^^^^

warning: use of deprecated method `inkwell::types::FunctionType::<'ctx>::ptr_type`: Starting from version 15.0, LLVM doesn't differentiate between pointer types. Use Context::ptr_type instead.
   --> src/codegen/llvm/types.rs:113:46
    |
113 |                 Ok(Type::Basic(function_type.ptr_type(AddressSpace::default()).into()))
    |                                              ^^^^^^^^

warning: unused variable: `target_llvm_type`
   --> src/codegen/llvm/expressions.rs:530:13
    |
530 |         let target_llvm_type = self.to_llvm_type(target_type)?;
    |             ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_target_llvm_type`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `call`
   --> src/codegen/llvm/functions.rs:454:13
    |
454 |         let call = self.builder.build_call(
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_call`

warning: unused variable: `call`
   --> src/codegen/llvm/functions.rs:485:13
    |
485 |         let call = self.builder.build_call(
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_call`

warning: unused variable: `expected`
  --> src/codegen/llvm/statements.rs:21:33
   |
21 |                     if let Some(expected) = expected_ret_type {
   |                                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected`

warning: unused variable: `actual_type`
  --> src/codegen/llvm/statements.rs:22:29
   |
22 |                         let actual_type = value.get_type();
   |                             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_actual_type`

warning: variable does not need to be mutable
  --> src/parser/expressions.rs:92:13
   |
92 |         let mut expr = self.parse_primary_expression()?;
   |             ----^^^^
   |             |
   |             help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `saved_pos`
   --> src/parser/expressions.rs:200:25
    |
200 |                     let saved_pos = self.current_span.start;
    |                         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_saved_pos`

warning: unreachable pattern
   --> src/typechecker/mod.rs:518:13
    |
518 |             _ => Ok(AstType::Void), // Default for unhandled cases
    |             ^ no value can reach this
    |
note: multiple earlier patterns match some of the same values
   --> src/typechecker/mod.rs:518:13
    |
294 |             Expression::Integer32(_) => Ok(AstType::I32),
    |             ------------------------ matches some of the same values
295 |             Expression::Integer64(_) => Ok(AstType::I64),
    |             ------------------------ matches some of the same values
296 |             Expression::Float32(_) => Ok(AstType::F32),
    |             ---------------------- matches some of the same values
297 |             Expression::Float64(_) => Ok(AstType::F64),
    |             ---------------------- matches some of the same values
...
518 |             _ => Ok(AstType::Void), // Default for unhandled cases
    |             ^ ...and 31 other patterns collectively make this unreachable
    = note: `#[warn(unreachable_patterns)]` on by default

warning: variants `Function`, `Struct`, `Enum`, `Option`, `Result`, and `Range` are never constructed
  --> src/ast.rs:27:5
   |
7  | pub enum AstType {
   |          ------- variants in this enum
...
27 |     Function {
   |     ^^^^^^^^
...
35 |     Struct {
   |     ^^^^^^
...
39 |     Enum {
   |     ^^^^
...
45 |     Option(Box<AstType>), // Option<T>
   |     ^^^^^^
46 |     Result {
   |     ^^^^^^
...
50 |     Range {
   |     ^^^^^
   |
   = note: `AstType` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: variant `StringConcat` is never constructed
  --> src/ast.rs:87:5
   |
75 | pub enum BinaryOperator {
   |          -------------- variant in this enum
...
87 |     StringConcat,
   |     ^^^^^^^^^^^^
   |
   = note: `BinaryOperator` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: multiple variants are never constructed
   --> src/ast.rs:94:5
    |
93  | pub enum Expression {
    |          ---------- variants in this enum
94  |     Integer8(i8),
    |     ^^^^^^^^
95  |     Integer16(i16),
    |     ^^^^^^^^^
...
98  |     Unsigned8(u8),
    |     ^^^^^^^^^
99  |     Unsigned16(u16),
    |     ^^^^^^^^^^
100 |     Unsigned32(u32),
    |     ^^^^^^^^^^
101 |     Unsigned64(u64),
    |     ^^^^^^^^^^
102 |     Float32(f32),
    |     ^^^^^^^
...
121 |     AddressOf(Box<Expression>),
    |     ^^^^^^^^^
122 |     Dereference(Box<Expression>),
    |     ^^^^^^^^^^^
123 |     PointerOffset {
    |     ^^^^^^^^^^^^^
...
131 |     StructField {
    |     ^^^^^^^^^^^
...
150 |     StringLength(Box<Expression>),
    |     ^^^^^^^^^^^^
...
164 |     PatternMatch {
    |     ^^^^^^^^^^^^
...
169 |     StdModule(String),
    |     ^^^^^^^^^
170 |     // Generic module reference
171 |     Module(String),
    |     ^^^^^^
...
175 |     Return(Box<Expression>),
    |     ^^^^^^
    |
    = note: `Expression` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: variants `Range` and `Binding` are never constructed
   --> src/ast.rs:218:5
    |
204 | pub enum Pattern {
    |          ------- variants in this enum
...
218 |     Range {
    |     ^^^^^
...
223 |     Binding {
    |     ^^^^^^^
    |
    = note: `Pattern` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: variant `ModuleImport` is never constructed
   --> src/ast.rs:263:5
    |
230 | pub enum Statement {
    |          --------- variant in this enum
...
263 |     ModuleImport {
    |     ^^^^^^^^^^^^
    |
    = note: `Statement` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: associated items `from_functions` and `functions` are never used
   --> src/ast.rs:394:12
    |
393 | impl Program {
    | ------------ associated items in this implementation
394 |     pub fn from_functions(functions: Vec<Function>) -> Self {
    |            ^^^^^^^^^^^^^^
...
400 |     pub fn functions(&self) -> impl Iterator<Item = &Function> {
    |            ^^^^^^^^^

warning: enum `Type` is never used
  --> src/codegen/llvm/mod.rs:29:10
   |
29 | pub enum Type<'ctx> {
   |          ^^^^
   |
   = note: `Type` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: method `into_basic_type` is never used
  --> src/codegen/llvm/mod.rs:38:12
   |
37 | impl<'ctx> Type<'ctx> {
   | --------------------- method in this implementation
38 |     pub fn into_basic_type(self) -> Result<BasicTypeEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^

warning: struct `StructTypeInfo` is never constructed
  --> src/codegen/llvm/mod.rs:51:12
   |
51 | pub struct StructTypeInfo<'ctx> {
   |            ^^^^^^^^^^^^^^
   |
   = note: `StructTypeInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: struct `LLVMCompiler` is never constructed
  --> src/codegen/llvm/mod.rs:56:12
   |
56 | pub struct LLVMCompiler<'ctx> {
   |            ^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/codegen/llvm/mod.rs:72:12
    |
71  | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- associated items in this implementation
72  |     pub fn new(context: &'ctx Context) -> Self {
    |            ^^^
...
104 |     pub fn get_type(&self, name: &str) -> Result<BasicTypeEnum<'ctx>, CompileError> {
    |            ^^^^^^^^
...
113 |     pub fn declare_variable(&mut self, name: &str, _ty: AstType, ptr: PointerValue<'ctx>) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^
...
122 |     pub fn get_variable(&self, name: &str) -> Result<(PointerValue<'ctx>, AstType), CompileError> {
    |            ^^^^^^^^^^^^
...
137 |     pub fn compile_program(&mut self, program: &ast::Program) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^
...
209 |     pub fn register_struct_type(&mut self, struct_def: &ast::StructDefinition) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^
...
266 |     pub fn register_enum_type(&mut self, enum_def: &ast::EnumDefinition) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^
...
293 |     pub fn cast_value_to_type(&self, value: BasicValueEnum<'ctx>, target_type: BasicTypeEnum<'ctx>) -> Result<BasicValueEnum<'ctx>, Compi...
    |            ^^^^^^^^^^^^^^^^^^

warning: struct `BehaviorCodegen` is never constructed
 --> src/codegen/llvm/behaviors.rs:9:12
  |
9 | pub struct BehaviorCodegen<'ctx> {
  |            ^^^^^^^^^^^^^^^

warning: associated items `new`, `generate_vtable`, `register_method`, and `resolve_method` are never used
  --> src/codegen/llvm/behaviors.rs:17:12
   |
16 | impl<'ctx> BehaviorCodegen<'ctx> {
   | -------------------------------- associated items in this implementation
17 |     pub fn new() -> Self {
   |            ^^^
...
25 |     pub fn generate_vtable(
   |            ^^^^^^^^^^^^^^^
...
65 |     pub fn register_method(
   |            ^^^^^^^^^^^^^^^
...
78 |     pub fn resolve_method(
   |            ^^^^^^^^^^^^^^

warning: methods `compile_impl_block`, `compile_method_call`, and `infer_type_name` are never used
   --> src/codegen/llvm/behaviors.rs:89:12
    |
87  | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
88  |     /// Compile an impl block
89  |     pub fn compile_impl_block(&mut self, impl_block: &ImplBlock) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^
...
201 |     pub fn compile_method_call(
    |            ^^^^^^^^^^^^^^^^^^^
...
253 |     fn infer_type_name(&self, expr: &Expression) -> Result<String, CompileError> {
    |        ^^^^^^^^^^^^^^^

warning: multiple methods are never used
   --> src/codegen/llvm/binary_ops.rs:9:12
    |
8   | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
9   |     pub fn compile_binary_operation(
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
...
36  |     fn compile_add(
    |        ^^^^^^^^^^^
...
82  |     fn compile_subtract(
    |        ^^^^^^^^^^^^^^^^
...
110 |     fn compile_multiply(
    |        ^^^^^^^^^^^^^^^^
...
138 |     fn compile_divide(
    |        ^^^^^^^^^^^^^^
...
166 |     fn compile_equals(
    |        ^^^^^^^^^^^^^^
...
229 |     fn compile_not_equals(
    |        ^^^^^^^^^^^^^^^^^^
...
292 |     fn compile_less_than(
    |        ^^^^^^^^^^^^^^^^^
...
326 |     fn compile_greater_than(
    |        ^^^^^^^^^^^^^^^^^^^^
...
356 |     fn compile_less_than_equals(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^
...
386 |     fn compile_greater_than_equals(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
416 |     fn compile_string_concat(
    |        ^^^^^^^^^^^^^^^^^^^^^
...
570 |     fn compile_modulo(
    |        ^^^^^^^^^^^^^^
...
591 |     fn compile_and(
    |        ^^^^^^^^^^^
...
612 |     fn compile_or(
    |        ^^^^^^^^^^

warning: method `compile_conditional` is never used
 --> src/codegen/llvm/control_flow.rs:7:12
  |
6 | impl<'ctx> LLVMCompiler<'ctx> {
  | ----------------------------- method in this implementation
7 |     pub fn compile_conditional(&mut self, scrutinee: &Expression, arms: &[(Expression, Expression)]) -> Result<BasicValueEnum<'ctx>, Comp...
  |            ^^^^^^^^^^^^^^^^^^^

warning: multiple methods are never used
   --> src/codegen/llvm/expressions.rs:7:12
    |
6   | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
7   |     pub fn compile_expression(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^
...
135 |     fn compile_conditional_expression(&mut self, scrutinee: &Expression, arms: &[crate::ast::ConditionalArm]) -> Result<BasicValueEnum<'c...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
244 |     fn compile_array_literal(&mut self, elements: &[Expression]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
280 |     fn compile_array_index(&mut self, array: &Expression, index: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^
...
293 |     pub fn compile_array_index_address(&mut self, array: &Expression, index: &Expression) -> Result<PointerValue<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
318 |     fn compile_enum_variant(&mut self, enum_name: &str, variant: &str, payload: &Option<Box<Expression>>) -> Result<BasicValueEnum<'ctx>,...
    |        ^^^^^^^^^^^^^^^^^^^^
...
372 |     fn compile_member_access(&mut self, object: &Expression, member: &str) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
377 |     fn compile_comptime_expression(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
394 |     fn compile_pattern_match(&mut self, scrutinee: &Expression, arms: &[crate::ast::PatternArm]) -> Result<BasicValueEnum<'ctx>, CompileE...
    |        ^^^^^^^^^^^^^^^^^^^^^
...
503 |     fn compile_range_expression(&mut self, start: &Expression, end: &Expression, inclusive: bool) -> Result<BasicValueEnum<'ctx>, Compile...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^
...
525 |     fn compile_type_cast(&mut self, expr: &Expression, target_type: &crate::ast::AstType) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^

warning: multiple methods are never used
   --> src/codegen/llvm/functions.rs:12:12
    |
10  | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
11  |     /// Declares an external function (C FFI)
12  |     pub fn declare_external_function(&mut self, ext_func: &ast::ExternalFunction) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
...
73  |     pub fn declare_function(&mut self, function: &ast::Function) -> Result<FunctionValue<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^
...
153 |     pub fn compile_function_body(&mut self, function: &ast::Function) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^
...
265 |     pub fn define_and_compile_function(&mut self, function: &ast::Function) -> Result<(), CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
270 |     pub fn compile_function_call(&mut self, name: &str, args: &[ast::Expression]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^
...
434 |     fn compile_io_print(&mut self, args: &[ast::Expression]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^
...
465 |     fn compile_io_println(&mut self, args: &[ast::Expression]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^

warning: methods `compile_integer_literal`, `compile_float_literal`, `compile_string_literal`, `compile_identifier`, and `compile_string_interpolation` are never used
  --> src/codegen/llvm/literals.rs:8:12
   |
6  | impl<'ctx> LLVMCompiler<'ctx> {
   | ----------------------------- methods in this implementation
7  |     // Expression compilation methods for literals
8  |     pub fn compile_integer_literal(&self, value: i64) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^
...
12 |     pub fn compile_float_literal(&self, value: f64) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^
...
16 |     pub fn compile_string_literal(&mut self, val: &str) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^^
...
25 |     pub fn compile_identifier(&mut self, name: &str) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^
...
81 |     pub fn compile_string_interpolation(&mut self, parts: &[crate::ast::StringPart]) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: methods `compile_pattern_test`, `values_equal`, `apply_pattern_bindings`, and `restore_variables` are never used
   --> src/codegen/llvm/patterns.rs:9:12
    |
8   | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
9   |     pub fn compile_pattern_test(
    |            ^^^^^^^^^^^^^^^^^^^^
...
279 |     fn values_equal(
    |        ^^^^^^^^^^^^
...
314 |     pub fn apply_pattern_bindings(
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
354 |     pub fn restore_variables(
    |            ^^^^^^^^^^^^^^^^^

warning: methods `compile_address_of`, `compile_dereference`, and `compile_pointer_offset` are never used
  --> src/codegen/llvm/pointers.rs:10:12
   |
9  | impl<'ctx> LLVMCompiler<'ctx> {
   | ----------------------------- methods in this implementation
10 |     pub fn compile_address_of(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^
...
33 |     pub fn compile_dereference(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^
...
91 |     pub fn compile_pointer_offset(&mut self, pointer: &Expression, offset: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
   |            ^^^^^^^^^^^^^^^^^^^^^^

warning: method `compile_statement` is never used
  --> src/codegen/llvm/statements.rs:10:12
   |
9  | impl<'ctx> LLVMCompiler<'ctx> {
   | ----------------------------- method in this implementation
10 |     pub fn compile_statement(&mut self, statement: &Statement) -> Result<(), CompileError> {
   |            ^^^^^^^^^^^^^^^^^

warning: method `compile_string_length` is never used
 --> src/codegen/llvm/strings.rs:7:12
  |
6 | impl<'ctx> LLVMCompiler<'ctx> {
  | ----------------------------- method in this implementation
7 |     pub fn compile_string_length(&mut self, expr: &Expression) -> Result<BasicValueEnum<'ctx>, CompileError> {
  |            ^^^^^^^^^^^^^^^^^^^^^

warning: struct `StructTypeInfo` is never constructed
  --> src/codegen/llvm/structs.rs:12:12
   |
12 | pub struct StructTypeInfo<'ctx> {
   |            ^^^^^^^^^^^^^^
   |
   = note: `StructTypeInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `compile_struct_literal`, `compile_struct_field`, `compile_struct_field_from_value`, `infer_struct_type_from_value`, and `compile_struct_field_assignment` are never used
   --> src/codegen/llvm/structs.rs:21:12
    |
20  | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
21  |     pub fn compile_struct_literal(&mut self, name: &str, fields: &[(String, Expression)]) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
69  |     pub fn compile_struct_field(&mut self, struct_: &Expression, field: &str) -> Result<BasicValueEnum<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^
...
273 |     fn compile_struct_field_from_value(&mut self, _struct_val: BasicValueEnum<'ctx>, _field: &str, original_expr: &Expression) -> Result<...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
284 |     pub fn infer_struct_type_from_value(&mut self, _val: &BasicValueEnum<'ctx>, expr: &Expression) -> Result<String, CompileError> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
366 |     pub fn compile_struct_field_assignment(&mut self, struct_alloca: inkwell::values::PointerValue<'ctx>, field_name: &str, value: BasicV...
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: struct `EnumInfo` is never constructed
  --> src/codegen/llvm/symbols.rs:10:12
   |
10 | pub struct EnumInfo<'ctx> {
   |            ^^^^^^^^
   |
   = note: `EnumInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: enum `Symbol` is never used
  --> src/codegen/llvm/symbols.rs:21:10
   |
21 | pub enum Symbol<'ctx> {
   |          ^^^^^^
   |
   = note: `Symbol` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: struct `Scope` is never constructed
  --> src/codegen/llvm/symbols.rs:43:12
   |
43 | pub struct Scope<'ctx> {
   |            ^^^^^
   |
   = note: `Scope` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: struct `SymbolTable` is never constructed
  --> src/codegen/llvm/symbols.rs:50:12
   |
50 | pub struct SymbolTable<'ctx> {
   |            ^^^^^^^^^^^
   |
   = note: `SymbolTable` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: multiple associated items are never used
   --> src/codegen/llvm/symbols.rs:57:12
    |
55  | impl<'ctx> SymbolTable<'ctx> {
    | ---------------------------- associated items in this implementation
56  |     /// Create a new symbol table with a global scope
57  |     pub fn new() -> Self {
    |            ^^^
...
70  |     pub fn enter_scope(&mut self) {
    |            ^^^^^^^^^^^
...
81  |     pub fn exit_scope(&mut self) -> Option<()> {
    |            ^^^^^^^^^^
...
91  |     pub fn insert<S: Into<String>>(&mut self, name: S, symbol: Symbol<'ctx>) -> Option<Symbol<'ctx>> {
    |            ^^^^^^
...
96  |     pub fn lookup(&self, name: &str) -> Option<&Symbol<'ctx>> {
    |            ^^^^^^
...
111 |     pub fn get_mut(&mut self, name: &str) -> Option<&mut Symbol<'ctx>> {
    |            ^^^^^^^
...
116 |     pub fn exists_in_current_scope(&self, name: &str) -> bool {
    |            ^^^^^^^^^^^^^^^^^^^^^^^
...
121 |     pub fn depth(&self) -> usize {
    |            ^^^^^

warning: methods `to_llvm_type` and `expect_basic_type` are never used
   --> src/codegen/llvm/types.rs:10:12
    |
9   | impl<'ctx> LLVMCompiler<'ctx> {
    | ----------------------------- methods in this implementation
10  |     pub fn to_llvm_type(&mut self, type_: &AstType) -> Result<Type<'ctx>, CompileError> {
    |            ^^^^^^^^^^^^
...
173 |     pub fn expect_basic_type<'a>(&self, t: Type<'a>) -> Result<BasicTypeEnum<'a>, CompileError> {
    |            ^^^^^^^^^^^^^^^^^

warning: struct `Compiler` is never constructed
  --> src/compiler.rs:14:12
   |
14 | pub struct Compiler<'ctx> {
   |            ^^^^^^^^

warning: multiple associated items are never used
   --> src/compiler.rs:19:12
    |
18  | impl<'ctx> Compiler<'ctx> {
    | ------------------------- associated items in this implementation
19  |     pub fn new(context: &'ctx Context) -> Self {
    |            ^^^
...
25  |     pub fn compile_llvm(&self, program: &Program) -> Result<String> {
    |            ^^^^^^^^^^^^
...
50  |     pub fn get_module(&self, program: &Program) -> Result<Module<'ctx>> {
    |            ^^^^^^^^^^
...
75  |     fn process_imports(&self, program: &Program) -> Result<Program> {
    |        ^^^^^^^^^^^^^^^
...
110 |     fn execute_comptime(&self, program: Program) -> Result<Program> {
    |        ^^^^^^^^^^^^^^^^
...
138 |     fn process_declaration_comptime(&self, decl: Declaration, interpreter: &mut ComptimeInterpreter) -> Result<Declaration> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
159 |     fn process_statements_comptime(&self, statements: Vec<crate::ast::Statement>, interpreter: &mut ComptimeInterpreter) -> Result<Vec<cr...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
170 |     fn process_statement_comptime(&self, stmt: crate::ast::Statement, interpreter: &mut ComptimeInterpreter) -> Result<crate::ast::Statem...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
225 |     fn process_expression_comptime(&self, expr: crate::ast::Expression, interpreter: &mut ComptimeInterpreter) -> Result<crate::ast::Expr...
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: enum `ComptimeValue` is never used
  --> src/comptime/mod.rs:12:10
   |
12 | pub enum ComptimeValue {
   |          ^^^^^^^^^^^^^
   |
   = note: `ComptimeValue` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `to_expression` and `get_type` are never used
  --> src/comptime/mod.rs:52:12
   |
50 | impl ComptimeValue {
   | ------------------ methods in this implementation
51 |     /// Convert a compile-time value to an AST expression
52 |     pub fn to_expression(&self) -> Result<Expression> {
   |            ^^^^^^^^^^^^^
...
79 |     pub fn get_type(&self) -> AstType {
   |            ^^^^^^^^

warning: struct `Environment` is never constructed
   --> src/comptime/mod.rs:126:12
    |
126 | pub struct Environment {
    |            ^^^^^^^^^^^
    |
    = note: `Environment` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: associated items `new`, `with_parent`, `define`, `get`, and `set` are never used
   --> src/comptime/mod.rs:132:12
    |
131 | impl Environment {
    | ---------------- associated items in this implementation
132 |     pub fn new() -> Self {
    |            ^^^
...
139 |     pub fn with_parent(parent: Environment) -> Self {
    |            ^^^^^^^^^^^
...
146 |     pub fn define(&self, name: String, value: ComptimeValue) {
    |            ^^^^^^
...
150 |     pub fn get(&self, name: &str) -> Option<ComptimeValue> {
    |            ^^^
...
155 |     pub fn set(&self, name: &str, value: ComptimeValue) -> Result<()> {
    |            ^^^

warning: struct `ComptimeInterpreter` is never constructed
   --> src/comptime/mod.rs:170:12
    |
170 | pub struct ComptimeInterpreter {
    |            ^^^^^^^^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/comptime/mod.rs:179:12
    |
178 | impl ComptimeInterpreter {
    | ------------------------ associated items in this implementation
179 |     pub fn new() -> Self {
    |            ^^^
...
192 |     pub fn set_variable(&mut self, name: String, value: ComptimeValue) {
    |            ^^^^^^^^^^^^
...
196 |     pub fn get_variable(&self, name: &str) -> Option<ComptimeValue> {
    |            ^^^^^^^^^^^^
...
200 |     fn init_builtins(&mut self) {
    |        ^^^^^^^^^^^^^
...
295 |     pub fn execute_comptime_block(&mut self, statements: &[Statement]) -> Result<()> {
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
303 |     pub fn execute_statement(&mut self, stmt: &Statement) -> Result<Option<ComptimeValue>> {
    |            ^^^^^^^^^^^^^^^^^
...
342 |     pub fn evaluate_expression(&mut self, expr: &Expression) -> Result<ComptimeValue> {
    |            ^^^^^^^^^^^^^^^^^^^
...
420 |     fn evaluate_binary_op(
    |        ^^^^^^^^^^^^^^^^^^
...
482 |     fn evaluate_function_call(&mut self, name: &str, args: &[Expression]) -> Result<ComptimeValue> {
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
562 |     fn evaluate_member_access(&mut self, object: ComptimeValue, member: &str) -> Result<ComptimeValue> {
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
577 |     pub fn get_generated_declarations(&self) -> Vec<Declaration> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
582 |     pub fn generate_code(&mut self, value: ComptimeValue) -> Result<Expression> {
    |            ^^^^^^^^^^^^^

warning: multiple variants are never constructed
  --> src/error.rs:16:5
   |
14 | pub enum CompileError {
   |          ------------ variants in this enum
15 |     SyntaxError(String, Option<Span>),
16 |     UndeclaredVariable(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^
17 |     UndeclaredFunction(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^
18 |     TypeMismatch {
   |     ^^^^^^^^^^^^
...
23 |     InvalidLoopCondition(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^^^
24 |     MissingReturnStatement(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^^^^^
25 |     InternalError(String, Option<Span>),
26 |     UnsupportedFeature(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^
27 |     TypeError(String, Option<Span>),
   |     ^^^^^^^^^
28 |     FileNotFound(String, Option<String>),
   |     ^^^^^^^^^^^^
29 |     ParseError(String, Option<Span>),
   |     ^^^^^^^^^^
30 |     ComptimeError(String),
   |     ^^^^^^^^^^^^^
   |
   = note: `CompileError` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: method `next_token` is never used
  --> src/lexer.rs:81:12
   |
47 | impl<'a> Lexer<'a> {
   | ------------------ method in this implementation
...
81 |     pub fn next_token(&mut self) -> Token {
   |            ^^^^^^^^^^

warning: associated function `new` is never used
  --> src/lsp/mod.rs:19:12
   |
18 | impl ZenServer {
   | -------------- associated function in this implementation
19 |     pub fn new(client: Client) -> Self {
   |            ^^^

warning: function `run_lsp_server` is never used
   --> src/lsp/mod.rs:232:14
    |
232 | pub async fn run_lsp_server() {
    |              ^^^^^^^^^^^^^^

warning: struct `ModuleSystem` is never constructed
  --> src/module_system/mod.rs:10:12
   |
10 | pub struct ModuleSystem {
   |            ^^^^^^^^^^^^

warning: associated items `new`, `add_search_path`, `load_module`, `resolve_module_path`, `get_modules`, and `merge_programs` are never used
   --> src/module_system/mod.rs:20:12
    |
19  | impl ModuleSystem {
    | ----------------- associated items in this implementation
20  |     pub fn new() -> Self {
    |            ^^^
...
43  |     pub fn add_search_path(&mut self, path: PathBuf) {
    |            ^^^^^^^^^^^^^^^
...
48  |     pub fn load_module(&mut self, module_path: &str) -> Result<&Program, CompileError> {
    |            ^^^^^^^^^^^
...
92  |     fn resolve_module_path(&self, module_path: &str) -> Result<PathBuf, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^
...
117 |     pub fn get_modules(&self) -> &HashMap<String, Program> {
    |            ^^^^^^^^^^^
...
122 |     pub fn merge_programs(&self, main_program: Program) -> Program {
    |            ^^^^^^^^^^^^^^

warning: struct `ModuleResolver` is never constructed
 --> src/module_system/resolver.rs:5:12
  |
5 | pub struct ModuleResolver {
  |            ^^^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/module_system/resolver.rs:13:12
    |
12  | impl ModuleResolver {
    | ------------------- associated items in this implementation
13  |     pub fn new() -> Self {
    |            ^^^
...
21  |     pub fn add_import(&mut self, alias: String, module_path: String) {
    |            ^^^^^^^^^^
...
26  |     pub fn add_exports(&mut self, module_path: String, symbols: HashSet<String>) {
    |            ^^^^^^^^^^^
...
31  |     pub fn resolve_qualified_name(&self, name: &str) -> Option<(String, String)> {
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
44  |     pub fn is_exported(&self, module_path: &str, symbol: &str) -> bool {
    |            ^^^^^^^^^^^
...
52  |     pub fn extract_exports(program: &Program) -> HashSet<String> {
    |            ^^^^^^^^^^^^^^^
...
78  |     pub fn resolve_program(&self, program: &mut Program) -> Result<(), String> {
    |            ^^^^^^^^^^^^^^^
...
89  |     fn resolve_function(&self, func: &mut Function) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^
...
97  |     fn resolve_statement(&self, stmt: &mut Statement) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^
...
121 |     fn resolve_expression(&self, expr: &mut Expression) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^

warning: methods `debug_current_token` and `debug_peek_token` are never used
  --> src/parser/core.rs:33:12
   |
12 | impl<'a> Parser<'a> {
   | ------------------- methods in this implementation
...
33 |     pub fn debug_current_token(&self) -> &Token {
   |            ^^^^^^^^^^^^^^^^^^^
...
37 |     pub fn debug_peek_token(&self) -> &Token {
   |            ^^^^^^^^^^^^^^^^

warning: method `parse_method` is never used
   --> src/parser/structs.rs:147:8
    |
6   | impl<'a> Parser<'a> {
    | ------------------- method in this implementation
...
147 |     fn parse_method(&mut self) -> Result<Function> {
    |        ^^^^^^^^^^^^

warning: method `parse_binding_pattern` is never used
   --> src/parser/patterns.rs:230:12
    |
6   | impl<'a> Parser<'a> {
    | ------------------- method in this implementation
...
230 |     pub fn parse_binding_pattern(&mut self) -> Result<Pattern> {
    |            ^^^^^^^^^^^^^^^^^^^^^

warning: methods `parse_comptime_block`, `parse_comptime_expression`, and `parse_comptime` are never used
  --> src/parser/comptime.rs:8:12
   |
6  | impl<'a> Parser<'a> {
   | ------------------- methods in this implementation
7  |     /// Parse a comptime block: comptime { ... }
8  |     pub fn parse_comptime_block(&mut self) -> Result<Statement> {
   |            ^^^^^^^^^^^^^^^^^^^^
...
46 |     pub fn parse_comptime_expression(&mut self) -> Result<Expression> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^
...
53 |     pub fn parse_comptime(&mut self) -> Result<Statement> {
   |            ^^^^^^^^^^^^^^

warning: struct `StdNamespace` is never constructed
  --> src/stdlib/mod.rs:15:12
   |
15 | pub struct StdNamespace {
   |            ^^^^^^^^^^^^

warning: enum `StdModule` is never used
  --> src/stdlib/mod.rs:19:10
   |
19 | pub enum StdModule {
   |          ^^^^^^^^^

warning: associated items `new`, `get_module`, `is_std_reference`, and `resolve_std_access` are never used
  --> src/stdlib/mod.rs:30:12
   |
29 | impl StdNamespace {
   | ----------------- associated items in this implementation
30 |     pub fn new() -> Self {
   |            ^^^
...
44 |     pub fn get_module(&self, name: &str) -> Option<&StdModule> {
   |            ^^^^^^^^^^
...
49 |     pub fn is_std_reference(name: &str) -> bool {
   |            ^^^^^^^^^^^^^^^^
...
54 |     pub fn resolve_std_access(module_name: &str) -> Option<Expression> {
   |            ^^^^^^^^^^^^^^^^^^

warning: methods `name`, `get_function`, and `get_type` are never used
  --> src/stdlib/mod.rs:91:8
   |
90 | pub trait StdModuleTrait {
   |           -------------- methods in this trait
91 |     fn name(&self) -> &str;
   |        ^^^^
92 |     fn get_function(&self, name: &str) -> Option<StdFunction>;
   |        ^^^^^^^^^^^^
93 |     fn get_type(&self, name: &str) -> Option<AstType>;
   |        ^^^^^^^^

warning: fields `name`, `params`, `return_type`, and `is_builtin` are never read
   --> src/stdlib/mod.rs:98:9
    |
97  | pub struct StdFunction {
    |            ----------- fields in this struct
98  |     pub name: String,
    |         ^^^^
99  |     pub params: Vec<(String, AstType)>,
    |         ^^^^^^
100 |     pub return_type: AstType,
    |         ^^^^^^^^^^^
101 |     pub is_builtin: bool,
    |         ^^^^^^^^^^
    |
    = note: `StdFunction` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: associated function `new` is never used
  --> src/stdlib/core.rs:12:12
   |
11 | impl CoreModule {
   | --------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: associated function `new` is never used
  --> src/stdlib/build.rs:12:12
   |
11 | impl BuildModule {
   | ---------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: function `create_result_type` is never used
 --> src/stdlib/result.rs:4:8
  |
4 | pub fn create_result_type() -> AstType {
  |        ^^^^^^^^^^^^^^^^^^

warning: function `create_option_type` is never used
  --> src/stdlib/result.rs:27:8
   |
27 | pub fn create_option_type() -> AstType {
   |        ^^^^^^^^^^^^^^^^^^

warning: function `ok_value` is never used
  --> src/stdlib/result.rs:47:8
   |
47 | pub fn ok_value(value: Expression) -> Expression {
   |        ^^^^^^^^

warning: function `err_value` is never used
  --> src/stdlib/result.rs:56:8
   |
56 | pub fn err_value(error: Expression) -> Expression {
   |        ^^^^^^^^^

warning: function `some_value` is never used
  --> src/stdlib/result.rs:65:8
   |
65 | pub fn some_value(value: Expression) -> Expression {
   |        ^^^^^^^^^^

warning: function `none_value` is never used
  --> src/stdlib/result.rs:74:8
   |
74 | pub fn none_value() -> Expression {
   |        ^^^^^^^^^^

warning: function `ok_pattern` is never used
  --> src/stdlib/result.rs:83:8
   |
83 | pub fn ok_pattern(binding: Option<String>) -> Pattern {
   |        ^^^^^^^^^^

warning: function `err_pattern` is never used
  --> src/stdlib/result.rs:92:8
   |
92 | pub fn err_pattern(binding: Option<String>) -> Pattern {
   |        ^^^^^^^^^^^

warning: function `some_pattern` is never used
   --> src/stdlib/result.rs:101:8
    |
101 | pub fn some_pattern(binding: Option<String>) -> Pattern {
    |        ^^^^^^^^^^^^

warning: function `none_pattern` is never used
   --> src/stdlib/result.rs:110:8
    |
110 | pub fn none_pattern() -> Pattern {
    |        ^^^^^^^^^^^^

warning: associated items `new`, `get_function`, and `list_functions` are never used
   --> src/stdlib/io.rs:11:12
    |
10  | impl IOModule {
    | ------------- associated items in this implementation
11  |     pub fn new() -> Self {
    |            ^^^
...
155 |     pub fn get_function(&self, name: &str) -> Option<&StdFunction> {
    |            ^^^^^^^^^^^^
...
160 |     pub fn list_functions(&self) -> Vec<String> {
    |            ^^^^^^^^^^^^^^

warning: function `create_net_module` is never used
 --> src/stdlib/net.rs:8:8
  |
8 | pub fn create_net_module() -> Vec<Declaration> {
  |        ^^^^^^^^^^^^^^^^^

warning: function `create_socket_externals` is never used
  --> src/stdlib/net.rs:29:4
   |
29 | fn create_socket_externals() -> Vec<Declaration> {
   |    ^^^^^^^^^^^^^^^^^^^^^^^

warning: function `create_socket_types` is never used
   --> src/stdlib/net.rs:163:4
    |
163 | fn create_socket_types() -> Vec<Declaration> {
    |    ^^^^^^^^^^^^^^^^^^^

warning: function `create_tcp_functions` is never used
   --> src/stdlib/net.rs:260:4
    |
260 | fn create_tcp_functions() -> Vec<Declaration> {
    |    ^^^^^^^^^^^^^^^^^^^^

warning: function `create_udp_functions` is never used
   --> src/stdlib/net.rs:412:4
    |
412 | fn create_udp_functions() -> Vec<Declaration> {
    |    ^^^^^^^^^^^^^^^^^^^^

warning: function `create_helper_functions` is never used
   --> src/stdlib/net.rs:517:4
    |
517 | fn create_helper_functions() -> Vec<Declaration> {
    |    ^^^^^^^^^^^^^^^^^^^^^^^

warning: associated function `new` is never used
  --> src/stdlib/math.rs:12:12
   |
11 | impl MathModule {
   | --------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: associated function `new` is never used
  --> src/stdlib/string.rs:12:12
   |
11 | impl StringModule {
   | ----------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: associated function `new` is never used
  --> src/stdlib/vec.rs:12:12
   |
11 | impl VecModule {
   | -------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: associated function `new` is never used
  --> src/stdlib/fs.rs:12:12
   |
11 | impl FsModule {
   | ------------- associated function in this implementation
12 |     pub fn new() -> Self {
   |            ^^^

warning: struct `TypeChecker` is never constructed
  --> src/typechecker/mod.rs:12:12
   |
12 | pub struct TypeChecker {
   |            ^^^^^^^^^^^

warning: struct `FunctionSignature` is never constructed
  --> src/typechecker/mod.rs:28:12
   |
28 | pub struct FunctionSignature {
   |            ^^^^^^^^^^^^^^^^^
   |
   = note: `FunctionSignature` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `StructInfo` is never constructed
  --> src/typechecker/mod.rs:35:12
   |
35 | pub struct StructInfo {
   |            ^^^^^^^^^^
   |
   = note: `StructInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `EnumInfo` is never constructed
  --> src/typechecker/mod.rs:40:12
   |
40 | pub struct EnumInfo {
   |            ^^^^^^^^
   |
   = note: `EnumInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: multiple associated items are never used
   --> src/typechecker/mod.rs:45:12
    |
44  | impl TypeChecker {
    | ---------------- associated items in this implementation
45  |     pub fn new() -> Self {
    |            ^^^
...
56  |     pub fn check_program(&mut self, program: &Program) -> Result<()> {
    |            ^^^^^^^^^^^^^
...
70  |     fn collect_declaration_types(&mut self, declaration: &Declaration) -> Result<()> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^
...
143 |     fn check_declaration(&mut self, declaration: &Declaration) -> Result<()> {
    |        ^^^^^^^^^^^^^^^^^
...
171 |     fn check_function(&mut self, function: &Function) -> Result<()> {
    |        ^^^^^^^^^^^^^^
...
188 |     fn check_statement(&mut self, statement: &Statement) -> Result<()> {
    |        ^^^^^^^^^^^^^^^
...
292 |     fn infer_expression_type(&self, expr: &Expression) -> Result<AstType> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
522 |     fn types_compatible(&self, expected: &AstType, actual: &AstType) -> bool {
    |        ^^^^^^^^^^^^^^^^
...
526 |     fn enter_scope(&mut self) {
    |        ^^^^^^^^^^^
...
530 |     fn exit_scope(&mut self) {
    |        ^^^^^^^^^^
...
534 |     fn declare_variable(&mut self, name: &str, type_: AstType) -> Result<()> {
    |        ^^^^^^^^^^^^^^^^
...
549 |     fn get_variable_type(&self, name: &str) -> Result<AstType> {
    |        ^^^^^^^^^^^^^^^^^

warning: multiple methods are never used
  --> src/typechecker/types.rs:6:12
   |
4  | impl AstType {
   | ------------ methods in this implementation
5  |     /// Check if this type is numeric (integer or float)
6  |     pub fn is_numeric(&self) -> bool {
   |            ^^^^^^^^^^
...
23 |     pub fn is_integer(&self) -> bool {
   |            ^^^^^^^^^^
...
38 |     pub fn is_float(&self) -> bool {
   |            ^^^^^^^^
...
43 |     pub fn is_signed_integer(&self) -> bool {
   |            ^^^^^^^^^^^^^^^^^
...
51 |     pub fn is_unsigned_integer(&self) -> bool {
   |            ^^^^^^^^^^^^^^^^^^^
...
59 |     pub fn bit_size(&self) -> Option<usize> {
   |            ^^^^^^^^
...
71 |     pub fn default_value(&self) -> String {
   |            ^^^^^^^^^^^^^

warning: function `infer_binary_op_type` is never used
 --> src/typechecker/inference.rs:7:8
  |
7 | pub fn infer_binary_op_type(
  |        ^^^^^^^^^^^^^^^^^^^^

warning: function `infer_member_type` is never used
  --> src/typechecker/inference.rs:75:8
   |
75 | pub fn infer_member_type(
   |        ^^^^^^^^^^^^^^^^^

warning: function `promote_numeric_types` is never used
   --> src/typechecker/inference.rs:132:4
    |
132 | fn promote_numeric_types(left: &AstType, right: &AstType) -> Result<AstType> {
    |    ^^^^^^^^^^^^^^^^^^^^^

warning: function `types_comparable` is never used
   --> src/typechecker/inference.rs:186:4
    |
186 | fn types_comparable(left: &AstType, right: &AstType) -> bool {
    |    ^^^^^^^^^^^^^^^^

warning: function `types_compatible` is never used
 --> src/typechecker/validation.rs:4:8
  |
4 | pub fn types_compatible(expected: &AstType, actual: &AstType) -> bool {
  |        ^^^^^^^^^^^^^^^^

warning: function `can_implicitly_convert` is never used
  --> src/typechecker/validation.rs:88:8
   |
88 | pub fn can_implicitly_convert(from: &AstType, to: &AstType) -> bool {
   |        ^^^^^^^^^^^^^^^^^^^^^^

warning: function `requires_initialization` is never used
   --> src/typechecker/validation.rs:122:8
    |
122 | pub fn requires_initialization(type_: &AstType) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^^^^

warning: function `is_valid_condition_type` is never used
   --> src/typechecker/validation.rs:134:8
    |
134 | pub fn is_valid_condition_type(type_: &AstType) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^^^^

warning: function `can_be_indexed` is never used
   --> src/typechecker/validation.rs:141:8
    |
141 | pub fn can_be_indexed(type_: &AstType) -> Option<AstType> {
    |        ^^^^^^^^^^^^^^

warning: function `can_be_dereferenced` is never used
   --> src/typechecker/validation.rs:152:8
    |
152 | pub fn can_be_dereferenced(type_: &AstType) -> Option<AstType> {
    |        ^^^^^^^^^^^^^^^^^^^

warning: struct `BehaviorResolver` is never constructed
 --> src/typechecker/behaviors.rs:6:12
  |
6 | pub struct BehaviorResolver {
  |            ^^^^^^^^^^^^^^^^

warning: struct `BehaviorInfo` is never constructed
  --> src/typechecker/behaviors.rs:16:12
   |
16 | pub struct BehaviorInfo {
   |            ^^^^^^^^^^^^
   |
   = note: `BehaviorInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `BehaviorMethodInfo` is never constructed
  --> src/typechecker/behaviors.rs:23:12
   |
23 | pub struct BehaviorMethodInfo {
   |            ^^^^^^^^^^^^^^^^^^
   |
   = note: `BehaviorMethodInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `ImplInfo` is never constructed
  --> src/typechecker/behaviors.rs:31:12
   |
31 | pub struct ImplInfo {
   |            ^^^^^^^^
   |
   = note: `ImplInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: struct `MethodInfo` is never constructed
  --> src/typechecker/behaviors.rs:39:12
   |
39 | pub struct MethodInfo {
   |            ^^^^^^^^^^
   |
   = note: `MethodInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: multiple associated items are never used
   --> src/typechecker/behaviors.rs:46:12
    |
45  | impl BehaviorResolver {
    | --------------------- associated items in this implementation
46  |     pub fn new() -> Self {
    |            ^^^
...
55  |     pub fn register_behavior(&mut self, behavior: &BehaviorDefinition) -> Result<()> {
    |            ^^^^^^^^^^^^^^^^^
...
87  |     pub fn register_impl(&mut self, impl_block: &ImplBlock) -> Result<()> {
    |            ^^^^^^^^^^^^^
...
148 |     pub fn type_implements(&self, type_name: &str, behavior_name: &str) -> bool {
    |            ^^^^^^^^^^^^^^^
...
153 |     pub fn get_impl(&self, type_name: &str, behavior_name: &str) -> Option<&ImplInfo> {
    |            ^^^^^^^^
...
158 |     pub fn resolve_method(
    |            ^^^^^^^^^^^^^^
...
183 |     pub fn verify_impl(&self, impl_block: &ImplBlock) -> Result<()> {
    |            ^^^^^^^^^^^
...
219 |     pub fn get_implemented_behaviors(&self, type_name: &str) -> Vec<String> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: associated items `new`, `add`, `get`, and `apply` are never used
  --> src/type_system/mod.rs:25:12
   |
24 | impl TypeSubstitution {
   | --------------------- associated items in this implementation
25 |     pub fn new() -> Self {
   |            ^^^
...
31 |     pub fn add(&mut self, param: String, concrete: AstType) {
   |            ^^^
...
35 |     pub fn get(&self, param: &str) -> Option<&AstType> {
   |            ^^^
...
39 |     pub fn apply(&self, ast_type: &AstType) -> AstType {
   |            ^^^^^

warning: struct `TypeConstraint` is never constructed
  --> src/type_system/mod.rs:83:12
   |
83 | pub struct TypeConstraint {
   |            ^^^^^^^^^^^^^^
   |
   = note: `TypeConstraint` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: function `is_generic_type` is never used
  --> src/type_system/mod.rs:88:8
   |
88 | pub fn is_generic_type(ast_type: &AstType) -> bool {
   |        ^^^^^^^^^^^^^^^

warning: function `extract_type_parameters` is never used
   --> src/type_system/mod.rs:101:8
    |
101 | pub fn extract_type_parameters(ast_type: &AstType) -> Vec<String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^

warning: function `extract_type_params_recursive` is never used
   --> src/type_system/mod.rs:107:4
    |
107 | fn extract_type_params_recursive(ast_type: &AstType, params: &mut Vec<String>) {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: struct `TypeInstantiator` is never constructed
 --> src/type_system/instantiation.rs:4:12
  |
4 | pub struct TypeInstantiator<'a> {
  |            ^^^^^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/type_system/instantiation.rs:9:12
    |
8   | impl<'a> TypeInstantiator<'a> {
    | ----------------------------- associated items in this implementation
9   |     pub fn new(env: &'a mut TypeEnvironment) -> Self {
    |            ^^^
...
13  |     pub fn instantiate_function(
    |            ^^^^^^^^^^^^^^^^^^^^
...
46  |     pub fn instantiate_struct(
    |            ^^^^^^^^^^^^^^^^^^
...
83  |     pub fn instantiate_enum(
    |            ^^^^^^^^^^^^^^^^
...
118 |     fn instantiate_method(
    |        ^^^^^^^^^^^^^^^^^^
...
141 |     fn instantiate_statements(
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
151 |     fn instantiate_statement(
    |        ^^^^^^^^^^^^^^^^^^^^^
...
188 |     fn instantiate_expression(&mut self, expr: &Expression, substitution: &TypeSubstitution) -> Expression {
    |        ^^^^^^^^^^^^^^^^^^^^^^

warning: function `generate_instantiated_name` is never used
   --> src/type_system/instantiation.rs:239:4
    |
239 | fn generate_instantiated_name(base_name: &str, type_args: &[AstType]) -> String {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `type_to_string` is never used
   --> src/type_system/instantiation.rs:248:4
    |
248 | fn type_to_string(ast_type: &AstType) -> String {
    |    ^^^^^^^^^^^^^^

warning: struct `TypeEnvironment` is never constructed
 --> src/type_system/environment.rs:6:12
  |
6 | pub struct TypeEnvironment {
  |            ^^^^^^^^^^^^^^^
  |
  = note: `TypeEnvironment` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: struct `TypeScope` is never constructed
  --> src/type_system/environment.rs:16:8
   |
16 | struct TypeScope {
   |        ^^^^^^^^^

warning: multiple associated items are never used
   --> src/type_system/environment.rs:22:12
    |
21  | impl TypeEnvironment {
    | -------------------- associated items in this implementation
22  |     pub fn new() -> Self {
    |            ^^^
...
36  |     pub fn register_generic_function(&mut self, func: Function) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
...
42  |     pub fn register_generic_struct(&mut self, struct_def: StructDefinition) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^
...
48  |     pub fn register_generic_enum(&mut self, enum_def: EnumDefinition) {
    |            ^^^^^^^^^^^^^^^^^^^^^
...
54  |     pub fn push_scope(&mut self, type_params: Vec<TypeParameter>) {
    |            ^^^^^^^^^^
...
61  |     pub fn pop_scope(&mut self) {
    |            ^^^^^^^^^
...
67  |     pub fn add_substitution(&mut self, param: String, concrete: AstType) {
    |            ^^^^^^^^^^^^^^^^
...
73  |     pub fn resolve_type(&self, ast_type: &AstType) -> AstType {
    |            ^^^^^^^^^^^^
...
83  |     pub fn get_generic_function(&self, name: &str) -> Option<&Function> {
    |            ^^^^^^^^^^^^^^^^^^^^
...
87  |     pub fn get_generic_struct(&self, name: &str) -> Option<&StructDefinition> {
    |            ^^^^^^^^^^^^^^^^^^
...
91  |     pub fn get_generic_enum(&self, name: &str) -> Option<&EnumDefinition> {
    |            ^^^^^^^^^^^^^^^^
...
95  |     pub fn record_instantiation(&mut self, base_name: String, type_args: Vec<AstType>, specialized: AstType) {
    |            ^^^^^^^^^^^^^^^^^^^^
...
108 |     pub fn get_instantiation(&self, base_name: &str, type_args: &[AstType]) -> Option<&AstType> {
    |            ^^^^^^^^^^^^^^^^^
...
116 |     pub fn is_type_parameter(&self, name: &str) -> bool {
    |            ^^^^^^^^^^^^^^^^^
...
122 |     pub fn validate_type_args(&self, expected: &[TypeParameter], provided: &[AstType]) -> Result<(), String> {
    |            ^^^^^^^^^^^^^^^^^^

warning: struct `Monomorphizer` is never constructed
 --> src/type_system/monomorphization.rs:6:12
  |
6 | pub struct Monomorphizer {
  |            ^^^^^^^^^^^^^

warning: multiple associated items are never used
   --> src/type_system/monomorphization.rs:15:12
    |
14  | impl Monomorphizer {
    | ------------------ associated items in this implementation
15  |     pub fn new() -> Self {
    |            ^^^
...
25  |     pub fn monomorphize_program(&mut self, program: &Program) -> Result<Program, String> {
    |            ^^^^^^^^^^^^^^^^^^^^
...
86  |     fn collect_instantiations_from_declaration(&mut self, decl: &Declaration) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
105 |     fn collect_instantiations_from_function(&mut self, func: &Function) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
112 |     fn collect_instantiations_from_statement(&mut self, stmt: &crate::ast::Statement) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
146 |     fn collect_instantiations_from_expression(&mut self, expr: &Expression) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
223 |     fn collect_instantiations_from_type(&mut self, ast_type: &AstType) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
256 |     fn infer_type_arguments(&self, generic_func: &Function, args: &[Expression]) -> Result<Vec<AstType>, String> {
    |        ^^^^^^^^^^^^^^^^^^^^
...
287 |     fn type_uses_parameter(&self, ast_type: &AstType, param_name: &str) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^
...
298 |     fn infer_expression_type(&self, expr: &Expression) -> Result<AstType, String> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
315 |     fn transform_declarations(&mut self, declarations: Vec<Declaration>) -> Result<Vec<Declaration>, String> {
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
331 |     fn transform_function(&mut self, mut func: Function) -> Result<Function, String> {
    |        ^^^^^^^^^^^^^^^^^^
...
336 |     fn transform_statements(&mut self, statements: Vec<crate::ast::Statement>) -> Result<Vec<crate::ast::Statement>, String> {
    |        ^^^^^^^^^^^^^^^^^^^^
...
346 |     fn transform_statement(&mut self, stmt: crate::ast::Statement) -> Result<crate::ast::Statement, String> {
    |        ^^^^^^^^^^^^^^^^^^^
...
378 |     fn transform_expression(&mut self, expr: Expression) -> Result<Expression, String> {
    |        ^^^^^^^^^^^^^^^^^^^^

warning: function `generate_instantiated_name` is never used
   --> src/type_system/monomorphization.rs:475:4
    |
475 | fn generate_instantiated_name(base_name: &str, type_args: &[AstType]) -> String {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `type_to_string` is never used
   --> src/type_system/monomorphization.rs:484:4
    |
484 | fn type_to_string(ast_type: &AstType) -> String {
    |    ^^^^^^^^^^^^^^

warning: function `extract_generic_struct_types` is never used
   --> src/type_system/monomorphization.rs:503:4
    |
503 | fn extract_generic_struct_types(name: &str) -> Option<Vec<AstType>> {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `extract_base_name` is never used
   --> src/type_system/monomorphization.rs:512:4
    |
512 | fn extract_base_name(name: &str) -> String {
    |    ^^^^^^^^^^^^^^^^^

warning: unused imports: `*` and `self`
 --> tests/test_enum_improvements.rs:1:16
  |
1 | use zen::ast::{self, *};
  |                ^^^^  ^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `TypeParameter`
   --> src/typechecker/behaviors.rs:231:59
    |
231 |     use crate::ast::{BehaviorMethod, Function, Parameter, TypeParameter};
    |                                                           ^^^^^^^^^^^^^

warning: variants `Function` and `Enum` are never constructed
  --> src/ast.rs:27:5
   |
7  | pub enum AstType {
   |          ------- variants in this enum
...
27 |     Function {
   |     ^^^^^^^^
...
39 |     Enum {
   |     ^^^^
   |
   = note: `AstType` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: fields `llvm_type`, `variant_indices`, and `variants` are never read
  --> src/codegen/llvm/symbols.rs:12:9
   |
10 | pub struct EnumInfo<'ctx> {
   |            -------- fields in this struct
11 |     /// The LLVM struct type used to represent this enum
12 |     pub llvm_type: StructType<'ctx>,
   |         ^^^^^^^^^
13 |     /// Map from variant name to index
14 |     pub variant_indices: HashMap<String, u64>,
   |         ^^^^^^^^^^^^^^^
15 |     /// The enum variants with their payloads
16 |     pub variants: Vec<EnumVariant>,
   |         ^^^^^^^^
   |
   = note: `EnumInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `0` is never read
  --> src/codegen/llvm/symbols.rs:23:10
   |
23 |     Type(BasicTypeEnum<'ctx>),
   |     ---- ^^^^^^^^^^^^^^^^^^^
   |     |
   |     field in this variant
   |
   = note: `Symbol` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
   |
23 -     Type(BasicTypeEnum<'ctx>),
23 +     Type(()),
   |

warning: variants `StructType`, `EnumType`, `FunctionType`, `Variable`, and `Function` are never constructed
  --> src/codegen/llvm/symbols.rs:26:5
   |
21 | pub enum Symbol<'ctx> {
   |          ------ variants in this enum
...
26 |     StructType(StructType<'ctx>),
   |     ^^^^^^^^^^
...
29 |     EnumType(EnumInfo<'ctx>),
   |     ^^^^^^^^
...
32 |     FunctionType(FunctionType<'ctx>),
   |     ^^^^^^^^^^^^
...
35 |     Variable(PointerValue<'ctx>),
   |     ^^^^^^^^
...
38 |     Function(FunctionValue<'ctx>),
   |     ^^^^^^^^
   |
   = note: `Symbol` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `get_mut`, `exists_in_current_scope`, and `depth` are never used
   --> src/codegen/llvm/symbols.rs:111:12
    |
55  | impl<'ctx> SymbolTable<'ctx> {
    | ---------------------------- methods in this implementation
...
111 |     pub fn get_mut(&mut self, name: &str) -> Option<&mut Symbol<'ctx>> {
    |            ^^^^^^^
...
116 |     pub fn exists_in_current_scope(&self, name: &str) -> bool {
    |            ^^^^^^^^^^^^^^^^^^^^^^^
...
121 |     pub fn depth(&self) -> usize {
    |            ^^^^^

warning: multiple variants are never constructed
  --> src/error.rs:16:5
   |
14 | pub enum CompileError {
   |          ------------ variants in this enum
15 |     SyntaxError(String, Option<Span>),
16 |     UndeclaredVariable(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^
17 |     UndeclaredFunction(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^
18 |     TypeMismatch {
   |     ^^^^^^^^^^^^
...
23 |     InvalidLoopCondition(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^^^
24 |     MissingReturnStatement(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^^^^^
25 |     InternalError(String, Option<Span>),
26 |     UnsupportedFeature(String, Option<Span>),
   |     ^^^^^^^^^^^^^^^^^^
27 |     TypeError(String, Option<Span>),
28 |     FileNotFound(String, Option<String>),
   |     ^^^^^^^^^^^^
29 |     ParseError(String, Option<Span>),
   |     ^^^^^^^^^^
30 |     ComptimeError(String),
   |     ^^^^^^^^^^^^^
   |
   = note: `CompileError` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `cwd` is never read
  --> src/module_system/mod.rs:16:5
   |
10 | pub struct ModuleSystem {
   |            ------------ field in this struct
...
16 |     cwd: PathBuf,
   |     ^^^

warning: methods `load_module`, `resolve_module_path`, `get_modules`, and `merge_programs` are never used
   --> src/module_system/mod.rs:48:12
    |
19  | impl ModuleSystem {
    | ----------------- methods in this implementation
...
48  |     pub fn load_module(&mut self, module_path: &str) -> Result<&Program, CompileError> {
    |            ^^^^^^^^^^^
...
92  |     fn resolve_module_path(&self, module_path: &str) -> Result<PathBuf, CompileError> {
    |        ^^^^^^^^^^^^^^^^^^^
...
117 |     pub fn get_modules(&self) -> &HashMap<String, Program> {
    |            ^^^^^^^^^^^
...
122 |     pub fn merge_programs(&self, main_program: Program) -> Program {
    |            ^^^^^^^^^^^^^^

warning: associated items `extract_exports`, `resolve_program`, `resolve_function`, `resolve_statement`, and `resolve_expression` are never used
   --> src/module_system/resolver.rs:52:12
    |
12  | impl ModuleResolver {
    | ------------------- associated items in this implementation
...
52  |     pub fn extract_exports(program: &Program) -> HashSet<String> {
    |            ^^^^^^^^^^^^^^^
...
78  |     pub fn resolve_program(&self, program: &mut Program) -> Result<(), String> {
    |            ^^^^^^^^^^^^^^^
...
89  |     fn resolve_function(&self, func: &mut Function) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^
...
97  |     fn resolve_statement(&self, stmt: &mut Statement) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^
...
121 |     fn resolve_expression(&self, expr: &mut Expression) -> Result<(), String> {
    |        ^^^^^^^^^^^^^^^^^^

warning: field `modules` is never read
  --> src/stdlib/mod.rs:16:5
   |
15 | pub struct StdNamespace {
   |            ------------ field in this struct
16 |     modules: HashMap<String, StdModule>,
   |     ^^^^^^^

warning: field `0` is never read
  --> src/stdlib/mod.rs:20:10
   |
20 |     Core(core::CoreModule),
   |     ---- ^^^^^^^^^^^^^^^^
   |     |
   |     field in this variant
   |
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
   |
20 -     Core(core::CoreModule),
20 +     Core(()),
   |

warning: field `0` is never read
  --> src/stdlib/mod.rs:21:11
   |
21 |     Build(build::BuildModule),
   |     ----- ^^^^^^^^^^^^^^^^^^
   |     |
   |     field in this variant
   |
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
   |
21 -     Build(build::BuildModule),
21 +     Build(()),
   |

warning: field `0` is never read
  --> src/stdlib/mod.rs:22:8
   |
22 |     IO(io::IOModule),
   |     -- ^^^^^^^^^^^^
   |     |
   |     field in this variant
   |
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
   |
22 -     IO(io::IOModule),
22 +     IO(()),
   |

warning: field `0` is never read
  --> src/stdlib/mod.rs:23:10
   |
23 |     Math(math::MathModule),
   |     ---- ^^^^^^^^^^^^^^^^
   |     |
   |     field in this variant
   |
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
   |
23 -     Math(math::MathModule),
23 +     Math(()),
   |

warning: field `0` is never read
  --> src/stdlib/mod.rs:24:12
   |
24 |     String(string::StringModule),
   |     ------ ^^^^^^^^^^^^^^^^^^^^
   |     |
   |     field in this variant
   |
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
   |
24 -     String(string::StringModule),
24 +     String(()),
   |

warning: field `0` is never read
  --> src/stdlib/mod.rs:25:9
   |
25 |     Vec(vec::VecModule),
   |     --- ^^^^^^^^^^^^^^
   |     |
   |     field in this variant
   |
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
   |
25 -     Vec(vec::VecModule),
25 +     Vec(()),
   |

warning: field `0` is never read
  --> src/stdlib/mod.rs:26:8
   |
26 |     Fs(fs::FsModule),
   |     -- ^^^^^^^^^^^^
   |     |
   |     field in this variant
   |
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
   |
26 -     Fs(fs::FsModule),
26 +     Fs(()),
   |

warning: associated items `get_module` and `resolve_std_access` are never used
  --> src/stdlib/mod.rs:44:12
   |
29 | impl StdNamespace {
   | ----------------- associated items in this implementation
...
44 |     pub fn get_module(&self, name: &str) -> Option<&StdModule> {
   |            ^^^^^^^^^^
...
54 |     pub fn resolve_std_access(module_name: &str) -> Option<Expression> {
   |            ^^^^^^^^^^^^^^^^^^

warning: methods `get_function` and `list_functions` are never used
   --> src/stdlib/io.rs:155:12
    |
10  | impl IOModule {
    | ------------- methods in this implementation
...
155 |     pub fn get_function(&self, name: &str) -> Option<&StdFunction> {
    |            ^^^^^^^^^^^^
...
160 |     pub fn list_functions(&self) -> Vec<String> {
    |            ^^^^^^^^^^^^^^

warning: field `std_namespace` is never read
  --> src/typechecker/mod.rs:24:5
   |
12 | pub struct TypeChecker {
   |            ----------- field in this struct
...
24 |     std_namespace: StdNamespace,
   |     ^^^^^^^^^^^^^

warning: field `is_external` is never read
  --> src/typechecker/mod.rs:31:9
   |
28 | pub struct FunctionSignature {
   |            ----------------- field in this struct
...
31 |     pub is_external: bool,
   |         ^^^^^^^^^^^
   |
   = note: `FunctionSignature` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `variants` is never read
  --> src/typechecker/mod.rs:41:9
   |
40 | pub struct EnumInfo {
   |            -------- field in this struct
41 |     pub variants: Vec<(String, Option<AstType>)>,
   |         ^^^^^^^^
   |
   = note: `EnumInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: method `default_value` is never used
  --> src/typechecker/types.rs:71:12
   |
4  | impl AstType {
   | ------------ method in this implementation
...
71 |     pub fn default_value(&self) -> String {
   |            ^^^^^^^^^^^^^

warning: fields `name` and `type_params` are never read
  --> src/typechecker/behaviors.rs:17:9
   |
16 | pub struct BehaviorInfo {
   |            ------------ fields in this struct
17 |     pub name: String,
   |         ^^^^
18 |     pub type_params: Vec<String>,
   |         ^^^^^^^^^^^
   |
   = note: `BehaviorInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `param_types`, `return_type`, and `has_self` are never read
  --> src/typechecker/behaviors.rs:25:9
   |
23 | pub struct BehaviorMethodInfo {
   |            ------------------ fields in this struct
24 |     pub name: String,
25 |     pub param_types: Vec<AstType>,
   |         ^^^^^^^^^^^
26 |     pub return_type: AstType,
   |         ^^^^^^^^^^^
27 |     pub has_self: bool,
   |         ^^^^^^^^
   |
   = note: `BehaviorMethodInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `type_name`, `behavior_name`, and `type_params` are never read
  --> src/typechecker/behaviors.rs:32:9
   |
31 | pub struct ImplInfo {
   |            -------- fields in this struct
32 |     pub type_name: String,
   |         ^^^^^^^^^
33 |     pub behavior_name: String,
   |         ^^^^^^^^^^^^^
34 |     pub type_params: Vec<String>,
   |         ^^^^^^^^^^^
   |
   = note: `ImplInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `param_types` and `return_type` are never read
  --> src/typechecker/behaviors.rs:41:9
   |
39 | pub struct MethodInfo {
   |            ---------- fields in this struct
40 |     pub name: String,
41 |     pub param_types: Vec<AstType>,
   |         ^^^^^^^^^^^
42 |     pub return_type: AstType,
   |         ^^^^^^^^^^^
   |
   = note: `MethodInfo` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: methods `get_impl` and `get_implemented_behaviors` are never used
   --> src/typechecker/behaviors.rs:153:12
    |
45  | impl BehaviorResolver {
    | --------------------- methods in this implementation
...
153 |     pub fn get_impl(&self, type_name: &str, behavior_name: &str) -> Option<&ImplInfo> {
    |            ^^^^^^^^
...
219 |     pub fn get_implemented_behaviors(&self, type_name: &str) -> Vec<String> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `AstType`, `Expression`, `Statement`, `VariableDeclarationType`, and `self`
 --> tests/codegen_basic.rs:3:16
  |
3 | use zen::ast::{self, AstType, Expression, Statement, BinaryOperator, VariableDeclarationType};
  |                ^^^^  ^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^                  ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `zen::error::CompileError`
 --> tests/codegen_basic.rs:5:5
  |
5 | use zen::error::CompileError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::OptimizationLevel`
 --> tests/codegen_basic.rs:7:5
  |
7 | use inkwell::OptimizationLevel;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::execution_engine::JitFunction`
 --> tests/codegen_basic.rs:8:5
  |
8 | use inkwell::execution_engine::JitFunction;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `zen::error::CompileError`
 --> tests/codegen_functions.rs:5:5
  |
5 | use zen::error::CompileError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `inkwell::OptimizationLevel`
 --> tests/codegen_functions.rs:7:5
  |
7 | use inkwell::OptimizationLevel;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::execution_engine::JitFunction`
 --> tests/codegen_functions.rs:8:5
  |
8 | use inkwell::execution_engine::JitFunction;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `program`
   --> tests/test_behavior_integration.rs:172:9
    |
172 |     let program = parser.parse_program().expect("Failed to parse program");
    |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_program`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused import: `Monomorphizer`
 --> tests/test_generics.rs:2:77
  |
2 | use zen::type_system::{TypeEnvironment, TypeInstantiator, TypeSubstitution, Monomorphizer};
  |                                                                             ^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `zen::ast`
 --> tests/common/mod.rs:1:5
  |
1 | use zen::ast;
  |     ^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: method `temp_dir_path` is never used
  --> tests/common/mod.rs:64:12
   |
11 | impl ExecutionHelper {
   | -------------------- method in this implementation
...
64 |     pub fn temp_dir_path(&self) -> &std::path::Path {
   |            ^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: field `stderr` is never read
  --> tests/common/mod.rs:72:9
   |
70 | pub struct CapturedOutput {
   |            -------------- field in this struct
71 |     pub stdout: String,
72 |     pub stderr: String,
   |         ^^^^^^
   |
   = note: `CapturedOutput` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: methods `assert_stdout_eq`, `assert_stderr_contains`, `assert_stderr_empty`, `stdout_lines`, and `assert_stdout_matches` are never used
   --> tests/common/mod.rs:88:12
    |
76  | impl CapturedOutput {
    | ------------------- methods in this implementation
...
88  |     pub fn assert_stdout_eq(&self, expected: &str) {
    |            ^^^^^^^^^^^^^^^^
...
99  |     pub fn assert_stderr_contains(&self, s: &str) {
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
109 |     pub fn assert_stderr_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^
...
132 |     pub fn stdout_lines(&self) -> Vec<&str> {
    |            ^^^^^^^^^^^^
...
137 |     pub fn assert_stdout_matches(&self, pattern: &str) {
    |            ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `AstType`
 --> tests/test_stdlib_vec.rs:1:29
  |
1 | use zen::ast::{Declaration, AstType};
  |                             ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `zen::compiler::Compiler`
 --> tests/test_stdlib_vec.rs:4:5
  |
4 | use zen::compiler::Compiler;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::context::Context`
 --> tests/test_stdlib_vec.rs:5:5
  |
5 | use inkwell::context::Context;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CapturedOutput`
 --> tests/test_stdlib_vec.rs:8:49
  |
8 | use test_output_verification::{ExecutionHelper, CapturedOutput};
  |                                                 ^^^^^^^^^^^^^^

warning: field `stderr` is never read
  --> tests/test_output_verification.rs:68:9
   |
66 | pub struct CapturedOutput {
   |            -------------- field in this struct
67 |     pub stdout: String,
68 |     pub stderr: String,
   |         ^^^^^^
   |
   = note: `CapturedOutput` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: unused import: `zen::ast::Expression`
  --> tests/stdlib_integration.rs:34:9
   |
34 |     use zen::ast::Expression;
   |         ^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `zen::error::CompileError`
 --> tests/codegen_strings.rs:5:5
  |
5 | use zen::error::CompileError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `inkwell::OptimizationLevel`
 --> tests/codegen_strings.rs:7:5
  |
7 | use inkwell::OptimizationLevel;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::execution_engine::JitFunction`
 --> tests/codegen_strings.rs:8:5
  |
8 | use inkwell::execution_engine::JitFunction;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CapturedOutput`
 --> tests/ffi.rs:3:31
  |
3 | use common::{ExecutionHelper, CapturedOutput};
  |                               ^^^^^^^^^^^^^^

warning: methods `assert_stderr_contains`, `assert_stderr_empty`, and `assert_stdout_matches` are never used
   --> tests/common/mod.rs:99:12
    |
76  | impl CapturedOutput {
    | ------------------- methods in this implementation
...
99  |     pub fn assert_stderr_contains(&self, s: &str) {
    |            ^^^^^^^^^^^^^^^^^^^^^^
...
109 |     pub fn assert_stderr_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^
...
137 |     pub fn assert_stdout_matches(&self, pattern: &str) {
    |            ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `BinaryOperator`
 --> tests/codegen_structs.rs:3:54
  |
3 | use zen::ast::{self, AstType, Expression, Statement, BinaryOperator, VariableDeclarationType};
  |                                                      ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `zen::error::CompileError`
 --> tests/codegen_structs.rs:5:5
  |
5 | use zen::error::CompileError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `compile_and_run` is never used
  --> tests/codegen_structs.rs:12:4
   |
12 | fn compile_and_run<'ctx>(test_context: &mut TestContext<'ctx>, program: &ast::Program) -> i64 {
   |    ^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: variable does not need to be mutable
  --> tests/parser_imports.rs:19:13
   |
19 |         let mut lexer = Lexer::new(input);
   |             ----^^^^^
   |             |
   |             help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
  --> tests/parser_imports.rs:72:13
   |
72 |         let mut lexer = Lexer::new(input);
   |             ----^^^^^
   |             |
   |             help: remove this `mut`

warning: variable does not need to be mutable
   --> tests/parser_imports.rs:106:13
    |
106 |         let mut lexer = Lexer::new(input);
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> tests/parser_imports.rs:159:13
    |
159 |         let mut lexer = Lexer::new(input);
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> tests/parser_imports.rs:209:13
    |
209 |         let mut lexer = Lexer::new(input);
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused import: `zen::compiler::Compiler`
 --> tests/test_comptime_integration.rs:6:5
  |
6 | use zen::compiler::Compiler;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::context::Context`
 --> tests/test_comptime_integration.rs:7:5
  |
7 | use inkwell::context::Context;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `zen::error::CompileError`
 --> tests/codegen_loops.rs:5:5
  |
5 | use zen::error::CompileError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `inkwell::OptimizationLevel`
 --> tests/codegen_loops.rs:7:5
  |
7 | use inkwell::OptimizationLevel;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::execution_engine::JitFunction`
 --> tests/codegen_loops.rs:8:5
  |
8 | use inkwell::execution_engine::JitFunction;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Statement`
 --> tests/test_imports_no_comptime.rs:7:33
  |
7 |     use zen::ast::{Declaration, Statement};
  |                                 ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `BinaryOperator`
 --> tests/codegen_pointers.rs:3:54
  |
3 | use zen::ast::{self, AstType, Expression, Statement, BinaryOperator, VariableDeclarationType};
  |                                                      ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: function `compile_and_run` is never used
  --> tests/codegen_pointers.rs:12:4
   |
12 | fn compile_and_run<'ctx>(test_context: &mut TestContext<'ctx>, program: &ast::Program) -> i64 {
   |    ^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: unused import: `VariableDeclarationType`
 --> tests/codegen_conditionals.rs:3:95
  |
3 | use zen::ast::{self, AstType, Expression, Statement, BinaryOperator, ConditionalArm, Pattern, VariableDeclarationType};
  |                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `zen::error::CompileError`
 --> tests/codegen_conditionals.rs:5:5
  |
5 | use zen::error::CompileError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::OptimizationLevel`
 --> tests/codegen_conditionals.rs:7:5
  |
7 | use inkwell::OptimizationLevel;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::execution_engine::JitFunction`
 --> tests/codegen_conditionals.rs:8:5
  |
8 | use inkwell::execution_engine::JitFunction;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Function`, `Program`, and `TypeParameter`
 --> tests/parser_generics.rs:3:25
  |
3 | use zen::ast::{AstType, TypeParameter, Program, Declaration, Statement, Function};
  |                         ^^^^^^^^^^^^^  ^^^^^^^                          ^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `VariableDeclarationType`
 --> tests/codegen_errors.rs:3:70
  |
3 | use zen::ast::{self, AstType, Expression, Statement, BinaryOperator, VariableDeclarationType};
  |                                                                      ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `inkwell::OptimizationLevel`
 --> tests/codegen_errors.rs:7:5
  |
7 | use inkwell::OptimizationLevel;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `inkwell::execution_engine::JitFunction`
 --> tests/codegen_errors.rs:8:5
  |
8 | use inkwell::execution_engine::JitFunction;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `zen::error::CompileError`
 --> tests/parser.rs:4:5
  |
4 | use zen::error::CompileError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused variable: `left`
   --> tests/parser.rs:545:61
    |
545 |         if let Statement::Expression(Expression::BinaryOp { left, op, right }) = &func.body[4] {
    |                                                             ^^^^ help: try ignoring the field: `left: _`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `right`
   --> tests/parser.rs:545:71
    |
545 |         if let Statement::Expression(Expression::BinaryOp { left, op, right }) = &func.body[4] {
    |                                                                       ^^^^^ help: try ignoring the field: `right: _`

warning: unused imports: `AstType`, `ConditionalArm`, and `Function`
 --> tests/test_pattern_matching.rs:3:29
  |
3 | use zen::ast::{Declaration, Function, Statement, Expression, Pattern, AstType, ConditionalArm};
  |                             ^^^^^^^^                                  ^^^^^^^  ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused imports: `none_pattern` and `some_pattern`
 --> tests/test_result_option.rs:7:30
  |
7 |     ok_pattern, err_pattern, some_pattern, none_pattern
  |                              ^^^^^^^^^^^^  ^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `Statement`
 --> tests/test_io_module.rs:3:16
  |
3 | use zen::ast::{Statement, Expression, AstType};
  |                ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused imports: `AstType`, `Function`, and `Program`
 --> tests/test_ranges.rs:1:28
  |
1 | use zen::ast::{Expression, Program, Declaration, Function, Statement, AstType};
  |                            ^^^^^^^               ^^^^^^^^             ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `ConditionalArm`
 --> tests/parser_pattern_matching.rs:1:28
  |
1 | use zen::ast::{Expression, ConditionalArm, Pattern};
  |                            ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default


running 11 tests
...........
test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 10 tests
..........
test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
....
test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 31 tests
...............................
test result: ok. 31 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s


running 6 tests
......
test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 1 test
.
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
....
test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 3 tests
...
test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 3 tests
...
test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 1 test
.
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 5 tests
.....
test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
....
test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 3 tests
...
test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 7 tests
.......
test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
....
test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 7 tests
.......
test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s


running 15 tests
...............
test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 2 tests
..
test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 28 tests
............................
test result: ok. 28 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 5 tests
.....
test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 10 tests
..........
test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 7 tests
.......
test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 5 tests
.....
test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 6 tests
......
test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 5 tests
.....
test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 7 tests
.......
test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 8 tests
........
test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
....
test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s


running 3 tests
...
test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 2 tests
..
test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 5 tests
.....
test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 5 tests
.....
test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
i...
test result: ok. 3 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.02s


running 3 tests
...
test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 2 tests
..
test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 3 tests
...
test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 10 tests
..........
test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 5 tests
.....
test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 7 tests
.......
test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 10 tests
test_multiple_return_values --- FAILED
..... 6/10
test_struct_with_methods --- FAILED
. 8/10
test_nested_pattern_matching --- FAILED
.
failures:

---- test_multiple_return_values stdout ----

thread 'test_multiple_return_values' panicked at tests/test_language_features.rs:299:10:
Failed to compile and run: "Compilation failed: InternalError(\"Unresolved generic type 'DivModResult' found after monomorphization. This is a compiler bug.\", None)"
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- test_struct_with_methods stdout ----

thread 'test_struct_with_methods' panicked at tests/test_language_features.rs:111:10:
Failed to compile and run: "Compilation failed: InternalError(\"Unresolved generic type 'Point' found after monomorphization. This is a compiler bug.\", None)"

---- test_nested_pattern_matching stdout ----

thread 'test_nested_pattern_matching' panicked at tests/common/mod.rs:79:9:
Expected stdout to contain '(1,0) -> 2', but got: '(0,0) -> 0
(0,1) -> 1
(1,0) -> 0
(1,1) -> 1
'


failures:
    test_multiple_return_values
    test_nested_pattern_matching
    test_struct_with_methods

test result: FAILED. 7 passed; 3 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s

error: test failed, to rerun pass `--test test_language_features`
