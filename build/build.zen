// Zen Build System - Self-hosting build orchestrator

{ io, fs, path, process, string, vec, map, result } = @std
{ vec, map, result } = @std.collections

// Import compiler modules
{ compiler, lexer, parser, type_checker, optimizer, codegen, linker } = @std.compiler

// Build configuration
BuildConfig: {
    // Source directories
    src_dir: string,
    stdlib_dir: string,
    bootstrap_dir: string,
    
    // Output directories
    build_dir: string,
    bin_dir: string,
    lib_dir: string,
    
    // Build options
    optimization_level: i32,
    target: Target,
    debug: bool,
    verbose: bool,
    parallel: bool,
    
    // Compiler stages
    use_rust_compiler: bool,  // Stage 0: Use Rust compiler
    use_bootstrap: bool,       // Stage 1: Use bootstrap compiler
    self_hosted: bool,         // Stage 2: Fully self-hosted
}

// Build target
Target: 
    Native,
    Wasm,
    LLVM

// Build artifact
Artifact: {
    name: string,
    path: string,
    kind: ArtifactKind,
    dependencies: vec.Vec<string>,
    source_files: vec.Vec<string>,
}

ArtifactKind: 
    Executable,
    Library,
    Object

// Build task
BuildTask: {
    name: string,
    action: () result.Result<(), string>,
    dependencies: vec.Vec<string>,
    completed: bool,
}

// Build system state
BuildSystem: {
    config: BuildConfig,
    artifacts: map.Map<string, Artifact>,
    tasks: map.Map<string, BuildTask>,
    compiler_instance: ?compiler.Compiler,
}

// Initialize build system
init_build_system: (config: BuildConfig) BuildSystem  = {
    return BuildSystem {
        config: config,
        artifacts: map.new<string, Artifact>(),
        tasks: map.new<string, BuildTask>(),
        compiler_instance: none,
    }
}

// Stage 0: Build with Rust compiler
build_stage0 = (sys: &mut BuildSystem) Result<(), string> {
    io.print("Stage 0: Building with Rust compiler...\n")
    
    // Compile stdlib modules
    compile_stdlib_rust(sys)?
    
    // Compile bootstrap compiler
    compile_bootstrap_rust(sys)?
    
    io.print("Stage 0 complete!\n")
    return result.ok(())
}

// Compile stdlib with Rust compiler
compile_stdlib_rust = (sys: &mut BuildSystem) Result<(), string> {
    stdlib_files = fs.list_files(sys.config.stdlib_dir, "*.zen")?
    
    stdlib_files.iter() |file| {
        io.print("  Compiling stdlib: " + file + "\n")
        
        // Use external Rust compiler
        cmd = "cargo run --bin zenc -- " + file + " -o " + 
                  path.join(sys.config.lib_dir, path.basename(file) + ".o")
        
        res = process.run(cmd)
         res.error ? {
            return result.err("Failed to compile: " + file)
        }
    }
    
    return result.ok(())
}

// Compile bootstrap compiler with Rust
compile_bootstrap_rust = (sys: &mut BuildSystem) Result<(), string> {
    io.print("  Compiling bootstrap compiler...\n")
    
    bootstrap_file = path.join(sys.config.bootstrap_dir, "compiler.zen")
    output = path.join(sys.config.bin_dir, "zenc-bootstrap")
    
    cmd = "cargo run --bin zenc -- " + bootstrap_file + " -o " + output + 
              " -L " + sys.config.lib_dir
    
    res = process.run(cmd)
     res.error ? {
        return result.err("Failed to compile bootstrap compiler")
    }
    
    return result.ok(())
}

// Stage 1: Build with bootstrap compiler
build_stage1 = (sys: &mut BuildSystem) Result<(), string> {
    io.print("Stage 1: Building with bootstrap compiler...\n")
    
    // Initialize Zen compiler
    sys.compiler_instance = some(compiler.new(compiler.Config {
        optimization_level: sys.config.optimization_level,
        target: compiler_target(sys.config.target),
        debug: sys.config.debug,
    }))
    
    // Compile stdlib with bootstrap
    compile_stdlib_bootstrap(sys)?
    
    // Compile self-hosted compiler
    compile_compiler_bootstrap(sys)?
    
    io.print("Stage 1 complete!\n")
    return result.ok(())
}

// Compile stdlib with bootstrap compiler
compile_stdlib_bootstrap = (sys: &mut BuildSystem) Result<(), string> {
    comp = sys.compiler_instance.unwrap()
    stdlib_files = fs.list_files(sys.config.stdlib_dir, "*.zen")?
    
    stdlib_files.iter() |file| {
        io.print("  Compiling stdlib: " + file + "\n")
        
        source = fs.read_file(file)?
        output = path.join(sys.config.lib_dir, path.basename(file) + ".o")
        
        res = compiler.compile_file(comp, file, output)
         res.error ? {
            return result.err("Failed to compile: " + file)
        }
    }
    
    return result.ok(())
}

// Stage 2: Self-hosted build
build_stage2 = (sys: &mut BuildSystem) Result<(), string> {
    io.print("Stage 2: Self-hosted build...\n")
    
    // Use self-hosted compiler
    zenc = path.join(sys.config.bin_dir, "zenc")
    
    // Rebuild everything with self-hosted compiler
    rebuild_with_self_hosted(sys, zenc)?
    
    // Verify binary compatibility
    verify_self_hosting(sys)?
    
    io.print("Stage 2 complete! Zen is now self-hosted!\n")
    return result.ok(())
}

// Rebuild with self-hosted compiler
rebuild_with_self_hosted = (sys: &mut BuildSystem, compiler_path: string) Result<(), string> {
    // Rebuild stdlib
    stdlib_files = fs.list_files(sys.config.stdlib_dir, "*.zen")?
    
    stdlib_files.iter() |file| {
        io.print("  Self-compiling: " + file + "\n")
        
        output = path.join(sys.config.lib_dir, path.basename(file) + ".o")
        cmd = compiler_path + " " + file + " -o " + output
        
        res = process.run(cmd)
         res.error ? {
            return result.err("Self-compilation failed: " + file)
        }
    }
    
    // Rebuild compiler itself
    io.print("  Self-compiling compiler...\n")
    compiler_src = path.join(sys.config.bootstrap_dir, "compiler.zen")
    compiler_out = compiler_path + ".new"
    
    cmd = compiler_path + " " + compiler_src + " -o " + compiler_out + 
              " -L " + sys.config.lib_dir
    
    res = process.run(cmd)
     res.error ? {
        return result.err("Failed to self-compile compiler")
    }
    
    return result.ok(())
}

// Verify self-hosting worked
verify_self_hosting = (sys: &mut BuildSystem) Result<(), string> {
    io.print("Verifying self-hosted build...\n")
    
    original = path.join(sys.config.bin_dir, "zenc")
    rebuilt = original + ".new"
    
    // Compare file sizes (basic check)
    orig_size = fs.file_size(original)?
    new_size = fs.file_size(rebuilt)?
    
     (orig_size - new_size).abs() > 1000 ? {
        io.print("Warning: Binary sizes differ significantly\n")
    }
    
    // Run test suite with new compiler
    io.print("Running tests with self-hosted compiler...\n")
    cmd = rebuilt + " --test tests/"
    
    res = process.run(cmd)
    res.error ? {
        return result.err("Self-hosted compiler tests failed")
    }
    
    io.print("✓ Self-hosting verification complete!\n")
    return result.ok(())
}

// Clean build artifacts
clean = (sys: &mut BuildSystem) Result<(), string> {
    io.print("Cleaning build artifacts...\n")
    
    fs.remove_dir(sys.config.build_dir)?
    fs.create_dir(sys.config.build_dir)?
    fs.create_dir(sys.config.bin_dir)?
    fs.create_dir(sys.config.lib_dir)?
    
    return result.ok(())
}

// Run full build pipeline
build = (sys: &mut BuildSystem) Result<(), string> {
    // Clean if requested
    sys.config.clean ? {
        clean(sys).raise()
    }
    
    // Stage 0: Rust compiler
    sys.config.use_rust_compiler ? {
        build_stage0(sys).raise()
    }
    
    // Stage 1: Bootstrap
    sys.config.use_bootstrap ? {
        build_stage1(sys).raise()
    }
    
    // Stage 2: Self-hosted
    sys.config.self_hosted ? {
        build_stage2(sys).raise()
    }
    
    io.print("\n✅ Build complete!\n")
    return result.ok(())
}

// Convert build target to compiler target
compiler_target = (target: Target) compiler.Target {
    target ? {
        | Native {return compiler.Target.Native}
        | Wasm {return compiler.Target.Wasm}
        | LLVM {return compiler.Target.LLVM}
    }
}

// Main entry point
main: () i32  = {
    io.print("Zen Build System v0.1.0\n")
    io.print("========================\n\n")
    
    // Default configuration
    config = BuildConfig {
        src_dir: "src/",
        stdlib_dir: "stdlib/",
        bootstrap_dir: "bootstrap/",
        build_dir: "build/",
        bin_dir: "build/bin/",
        lib_dir: "build/lib/",
        optimization_level: 2,
        target: Target.Native,
        debug: false,
        verbose: true,
        parallel: true,
        use_rust_compiler: true,
        use_bootstrap: true,
        self_hosted: true,
    }
    
    // Initialize build system
    mut sys = init_build_system(config)
    
    // Run build
    result = build(&mut sys)
    
    result ? {
        | ok(_) => {
            io.print("Build succeeded!\n")
            return 0
        }
        | err(msg) => {
            io.eprint("Build failed: " + msg + "\n")
            return 1
        }
    }
}