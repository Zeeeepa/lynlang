// Zen Build System - Self-hosting build orchestrator

io := @std.io
fs := @std.fs
path := @std.path
process := @std.process
string := @std.string
vec := @std.vec
map := @std.map
result := @std.result

// Import compiler modules
compiler := @std.compiler.compiler
lexer := @std.compiler.lexer
parser := @std.compiler.parser
type_checker := @std.compiler.type_checker
optimizer := @std.compiler.optimizer
codegen := @std.compiler.codegen
linker := @std.compiler.linker

// Build configuration
struct BuildConfig {
    // Source directories
    src_dir: string,
    stdlib_dir: string,
    bootstrap_dir: string,
    
    // Output directories
    build_dir: string,
    bin_dir: string,
    lib_dir: string,
    
    // Build options
    optimization_level: i32,
    target: Target,
    debug: bool,
    verbose: bool,
    parallel: bool,
    
    // Compiler stages
    use_rust_compiler: bool,  // Stage 0: Use Rust compiler
    use_bootstrap: bool,       // Stage 1: Use bootstrap compiler
    self_hosted: bool,         // Stage 2: Fully self-hosted
}

// Build target
enum Target {
    Native,
    Wasm,
    LLVM,
}

// Build artifact
struct Artifact {
    name: string,
    path: string,
    kind: ArtifactKind,
    dependencies: vec.Vec<string>,
    source_files: vec.Vec<string>,
}

enum ArtifactKind {
    Executable,
    Library,
    Object,
}

// Build task
struct BuildTask {
    name: string,
    action: () result.Result<(), string>,
    dependencies: vec.Vec<string>,
    completed: bool,
}

// Build system state
struct BuildSystem {
    config: BuildConfig,
    artifacts: map.Map<string, Artifact>,
    tasks: map.Map<string, BuildTask>,
    compiler_instance: ?compiler.Compiler,
}

// Initialize build system
init_build_system = (config: BuildConfig) BuildSystem {
    return BuildSystem {
        config: config,
        artifacts: map.new<string, Artifact>(),
        tasks: map.new<string, BuildTask>(),
        compiler_instance: none,
    }
}

// Stage 0: Build with Rust compiler
build_stage0 = (sys: &mut BuildSystem) result.Result<(), string> {
    io.print("Stage 0: Building with Rust compiler...\n")
    
    // Compile stdlib modules
    compile_stdlib_rust(sys)?
    
    // Compile bootstrap compiler
    compile_bootstrap_rust(sys)?
    
    io.print("Stage 0 complete!\n")
    return result.ok(())
}

// Compile stdlib with Rust compiler
compile_stdlib_rust = (sys: &mut BuildSystem) result.Result<(), string> {
    let stdlib_files = fs.list_files(sys.config.stdlib_dir, "*.zen")?
    
    stdlib_files.iter() |file| {
        io.print("  Compiling stdlib: " + file + "\n")
        
        // Use external Rust compiler
        let cmd = "cargo run --bin zenc -- " + file + " -o " + 
                  path.join(sys.config.lib_dir, path.basename(file) + ".o")
        
        let res = process.run(cmd)
        if res.is_err() {
            return result.err("Failed to compile: " + file)
        }
    }
    
    return result.ok(())
}

// Compile bootstrap compiler with Rust
compile_bootstrap_rust = (sys: &mut BuildSystem) result.Result<(), string> {
    io.print("  Compiling bootstrap compiler...\n")
    
    let bootstrap_file = path.join(sys.config.bootstrap_dir, "compiler.zen")
    let output = path.join(sys.config.bin_dir, "zenc-bootstrap")
    
    let cmd = "cargo run --bin zenc -- " + bootstrap_file + " -o " + output + 
              " -L " + sys.config.lib_dir
    
    let res = process.run(cmd)
    if res.is_err() {
        return result.err("Failed to compile bootstrap compiler")
    }
    
    return result.ok(())
}

// Stage 1: Build with bootstrap compiler
build_stage1 = (sys: &mut BuildSystem) result.Result<(), string> {
    io.print("Stage 1: Building with bootstrap compiler...\n")
    
    // Initialize Zen compiler
    sys.compiler_instance = some(compiler.new(compiler.Config {
        optimization_level: sys.config.optimization_level,
        target: compiler_target(sys.config.target),
        debug: sys.config.debug,
    }))
    
    // Compile stdlib with bootstrap
    compile_stdlib_bootstrap(sys)?
    
    // Compile self-hosted compiler
    compile_compiler_bootstrap(sys)?
    
    io.print("Stage 1 complete!\n")
    return result.ok(())
}

// Compile stdlib with bootstrap compiler
compile_stdlib_bootstrap = (sys: &mut BuildSystem) result.Result<(), string> {
    let comp = sys.compiler_instance.unwrap()
    let stdlib_files = fs.list_files(sys.config.stdlib_dir, "*.zen")?
    
    stdlib_files.iter() |file| {
        io.print("  Compiling stdlib: " + file + "\n")
        
        let source = fs.read_file(file)?
        let output = path.join(sys.config.lib_dir, path.basename(file) + ".o")
        
        let res = compiler.compile_file(comp, file, output)
        if res.is_err() {
            return result.err("Failed to compile: " + file)
        }
    }
    
    return result.ok(())
}

// Stage 2: Self-hosted build
build_stage2 = (sys: &mut BuildSystem) result.Result<(), string> {
    io.print("Stage 2: Self-hosted build...\n")
    
    // Use self-hosted compiler
    let zenc = path.join(sys.config.bin_dir, "zenc")
    
    // Rebuild everything with self-hosted compiler
    rebuild_with_self_hosted(sys, zenc)?
    
    // Verify binary compatibility
    verify_self_hosting(sys)?
    
    io.print("Stage 2 complete! Zen is now self-hosted!\n")
    return result.ok(())
}

// Rebuild with self-hosted compiler
rebuild_with_self_hosted = (sys: &mut BuildSystem, compiler_path: string) result.Result<(), string> {
    // Rebuild stdlib
    let stdlib_files = fs.list_files(sys.config.stdlib_dir, "*.zen")?
    
    stdlib_files.iter() |file| {
        io.print("  Self-compiling: " + file + "\n")
        
        let output = path.join(sys.config.lib_dir, path.basename(file) + ".o")
        let cmd = compiler_path + " " + file + " -o " + output
        
        let res = process.run(cmd)
        if res.is_err() {
            return result.err("Self-compilation failed: " + file)
        }
    }
    
    // Rebuild compiler itself
    io.print("  Self-compiling compiler...\n")
    let compiler_src = path.join(sys.config.bootstrap_dir, "compiler.zen")
    let compiler_out = compiler_path + ".new"
    
    let cmd = compiler_path + " " + compiler_src + " -o " + compiler_out + 
              " -L " + sys.config.lib_dir
    
    let res = process.run(cmd)
    if res.is_err() {
        return result.err("Failed to self-compile compiler")
    }
    
    return result.ok(())
}

// Verify self-hosting worked
verify_self_hosting = (sys: &mut BuildSystem) result.Result<(), string> {
    io.print("Verifying self-hosted build...\n")
    
    let original = path.join(sys.config.bin_dir, "zenc")
    let rebuilt = original + ".new"
    
    // Compare file sizes (basic check)
    let orig_size = fs.file_size(original)?
    let new_size = fs.file_size(rebuilt)?
    
    if (orig_size - new_size).abs() > 1000 {
        io.print("Warning: Binary sizes differ significantly\n")
    }
    
    // Run test suite with new compiler
    io.print("Running tests with self-hosted compiler...\n")
    let cmd = rebuilt + " --test tests/"
    
    let res = process.run(cmd)
    if res.is_err() {
        return result.err("Self-hosted compiler tests failed")
    }
    
    io.print("✓ Self-hosting verification complete!\n")
    return result.ok(())
}

// Clean build artifacts
clean = (sys: &mut BuildSystem) result.Result<(), string> {
    io.print("Cleaning build artifacts...\n")
    
    fs.remove_dir(sys.config.build_dir)?
    fs.create_dir(sys.config.build_dir)?
    fs.create_dir(sys.config.bin_dir)?
    fs.create_dir(sys.config.lib_dir)?
    
    return result.ok(())
}

// Run full build pipeline
build = (sys: &mut BuildSystem) result.Result<(), string> {
    // Clean if requested
    if sys.config.clean {
        clean(sys)?
    }
    
    // Stage 0: Rust compiler
    if sys.config.use_rust_compiler {
        build_stage0(sys)?
    }
    
    // Stage 1: Bootstrap
    if sys.config.use_bootstrap {
        build_stage1(sys)?
    }
    
    // Stage 2: Self-hosted
    if sys.config.self_hosted {
        build_stage2(sys)?
    }
    
    io.print("\n✅ Build complete!\n")
    return result.ok(())
}

// Convert build target to compiler target
compiler_target = (target: Target) compiler.Target {
    target match {
        | Native => compiler.Target.Native
        | Wasm => compiler.Target.Wasm
        | LLVM => compiler.Target.LLVM
    }
}

// Main entry point
main = () i32 {
    io.print("Zen Build System v0.1.0\n")
    io.print("========================\n\n")
    
    // Default configuration
    let config = BuildConfig {
        src_dir: "src/",
        stdlib_dir: "stdlib/",
        bootstrap_dir: "bootstrap/",
        build_dir: "build/",
        bin_dir: "build/bin/",
        lib_dir: "build/lib/",
        optimization_level: 2,
        target: Target.Native,
        debug: false,
        verbose: true,
        parallel: true,
        use_rust_compiler: true,
        use_bootstrap: true,
        self_hosted: true,
    }
    
    // Initialize build system
    let mut sys = init_build_system(config)
    
    // Run build
    let result = build(&mut sys)
    
    result match {
        | ok(_) => {
            io.print("Build succeeded!\n")
            return 0
        }
        | err(msg) => {
            io.eprint("Build failed: " + msg + "\n")
            return 1
        }
    }
}