// Demonstrates bug with closures inside closures
// Currently this fails during type checking
{ io, Result } = @std

main = () void {
    io.println("Testing nested closures...")
    
    outer = () Result<Result<i32, string>, string> {
        // This inner closure causes type checking issues
        inner = () Result<i32, string> {
            Result.Ok(42)
        }
        Result.Ok(inner())
    }
    
    // The type checker incorrectly infers 'result' as Void
    result = outer()
    inner_result = result.raise()
    value = inner_result.raise()
    
    io.println("Value: ${value}")
}