// Test with explicit intermediate steps to debug payload corruption
{ io } = @std
{ Result, Option } = @std

create_inner = () Option<i32> {
    io.println("[create_inner] Creating Option.Some(42)")
    return Option.Some(42)
}

create_outer = () Result<Option<i32>, string> {
    io.println("[create_outer] Starting")
    inner = create_inner()
    
    // Test the inner value first
    inner ?
        | Option.Some(v) { io.println("[create_outer] Inner has value: ${v}") }
        | Option.None { io.println("[create_outer] Inner is None") }
    
    io.println("[create_outer] Wrapping in Result.Ok")
    return Result.Ok(inner)
}

main = () void {
    io.println("=== Verbose Nested Debug ===")
    
    // Test without function calls first
    io.println("\n--- Direct Creation ---")
    direct_inner = Option.Some(99)
    direct_outer = Result.Ok(direct_inner)
    direct_outer ?
        | Result.Ok(opt) {
            io.println("Direct outer is Ok")
            opt ?
                | Option.Some(v) { io.println("  Direct inner value: ${v}") }
                | Option.None { io.println("  Direct inner is None") }
        }
        | Result.Err(e) { io.println("Direct outer error: ${e}") }
    
    // Test with function calls
    io.println("\n--- Function Return ---")
    result = create_outer()
    result ?
        | Result.Ok(opt) {
            io.println("Function outer is Ok")
            opt ?
                | Option.Some(v) { io.println("  Function inner value: ${v}") }
                | Option.None { io.println("  Function inner is None") }
        }
        | Result.Err(e) { io.println("Function outer error: ${e}") }
}