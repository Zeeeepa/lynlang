// Comprehensive test for nested generic types
{ io } = @std
{ Option, Result } = @std

// Test deeply nested generics: Result<Result<Result<i32, string>, string>, string>
test_triple_nested = () Result<Result<Result<i32, string>, string>, string> {
    innermost = Result.Ok(999)
    middle = Result.Ok(innermost)
    Result.Ok(middle)
}

// Test Result<Option<Option<i32>>>
test_double_option = () Result<Option<Option<i32>>, string> {
    inner_opt = Option.Some(777)
    outer_opt = Option.Some(inner_opt)
    Result.Ok(outer_opt)
}

// Test Option<Option<Option<string>>>
test_triple_option = () Option<Option<Option<string>>> {
    Option.Some(Option.Some(Option.Some("deeply nested")))
}

// Test Result<Result<Option<i32>, string>, string>
test_mixed_nested = () Result<Result<Option<i32>, string>, string> {
    opt = Option.Some(456)
    inner = Result.Ok(opt)
    Result.Ok(inner)
}

// Test with Err variants
test_nested_err = () Result<Result<i32, string>, string> {
    inner = Result.Err("inner error")
    Result.Ok(inner)
}

main = () void {
    io.println("=== Testing Nested Generics ===")
    
    // Test triple nested Result
    io.println("\n1. Triple nested Result:")
    triple = test_triple_nested()
    triple ? | Result.Ok(r1) => {
        r1 ? | Result.Ok(r2) => {
            r2 ? | Result.Ok(val) => io.println("  Got value: ${val}")
                 | Result.Err(e) => io.println("  Inner error: ${e}")
        } | Result.Err(e) => io.println("  Middle error: ${e}")
    } | Result.Err(e) => io.println("  Outer error: ${e}")
    
    // Test double Option in Result
    io.println("\n2. Double Option in Result:")
    double_opt = test_double_option()
    double_opt ? | Result.Ok(opt1) => {
        opt1 ? | Option.Some(opt2) => {
            opt2 ? | Option.Some(val) => io.println("  Got value: ${val}")
                  | Option.None => io.println("  Inner None")
        } | Option.None => io.println("  Outer None")
    } | Result.Err(e) => io.println("  Error: ${e}")
    
    // Test triple Option
    io.println("\n3. Triple Option:")
    triple_opt = test_triple_option()
    triple_opt ? | Option.Some(o1) => {
        o1 ? | Option.Some(o2) => {
            o2 ? | Option.Some(s) => io.println("  Got string: ${s}")
                 | Option.None => io.println("  Innermost None")
        } | Option.None => io.println("  Middle None")
    } | Option.None => io.println("  Outermost None")
    
    // Test mixed nesting
    io.println("\n4. Mixed Result<Result<Option>>:")
    mixed = test_mixed_nested()
    mixed ? | Result.Ok(inner) => {
        inner ? | Result.Ok(opt) => {
            opt ? | Option.Some(val) => io.println("  Got value: ${val}")
                  | Option.None => io.println("  Option was None")
        } | Result.Err(e) => io.println("  Inner error: ${e}")
    } | Result.Err(e) => io.println("  Outer error: ${e}")
    
    // Test nested with error
    io.println("\n5. Nested with Err variant:")
    nested_err = test_nested_err()
    nested_err ? | Result.Ok(inner) => {
        inner ? | Result.Ok(val) => io.println("  Got value: ${val}")
               | Result.Err(e) => io.println("  Inner had error: ${e}")
    } | Result.Err(e) => io.println("  Outer error: ${e}")
    
    io.println("\n=== All nested generic tests complete ===")
}