// Trace through nested enum handling 
{ io } = @std
{ Option, Result } = @std

main = () i32 {
    // Create inner value
    inner = Option.Some(123)
    
    // Verify inner works
    inner ? | Option.Some(n) => {
        io.println("Step 1 - Inner Some: ${n}")
        n == 123 ? | true => io.println("  ✓ Inner value correct")
                  | false => io.println("  ✗ Inner value wrong!")
    } | Option.None => io.println("Step 1 - Inner was None")
    
    // Wrap in Result
    wrapped = Result.Ok(inner)
    io.println("Step 2 - Created Result.Ok(Option.Some(123))")
    
    // Extract from Result  
    wrapped ? | Result.Ok(extracted_opt) => {
        io.println("Step 3 - Extracted Option from Result.Ok")
        
        // Now pattern match the extracted Option
        extracted_opt ? | Option.Some(final_val) => {
            io.println("Step 4 - Final value: ${final_val}")
            final_val == 123 ? | true => {
                io.println("SUCCESS: Nested generic preserved value!")
                return 0
            } | false => {
                io.println("FAIL: Value corrupted (got ${final_val}, expected 123)")
                return 1
            }
        } | Option.None => {
            io.println("Step 4 - Extracted Option was None (wrong!)")
            return 2
        }
    } | Result.Err(e) => {
        io.println("Step 3 - Got Err: ${e}")
        return 3
    }
}