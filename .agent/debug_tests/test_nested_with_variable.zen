// Test nested Result when inner is created as a variable first
{ io, Result } = @std

// Test 1: Direct construction (works)
test_direct = () Result<Result<i32, string>, string> {
    Result.Ok(Result.Ok(42))
}

// Test 2: Variable construction (might have issue)  
test_variable = () Result<Result<i32, string>, string> {
    inner = Result.Ok(42)
    Result.Ok(inner)
}

// Extract using double raise
extract_direct = () Result<i32, string> {
    inner = test_direct().raise()
    value = inner.raise()
    Result.Ok(value)
}

extract_variable = () Result<i32, string> {
    inner = test_variable().raise()
    value = inner.raise()  
    Result.Ok(value)
}

main = () i32 {
    io.println("Testing direct construction:")
    r1 = extract_direct()
    r1 ? | Result.Ok(v) => io.println("  Direct value: ${v}")
        | Result.Err(e) => io.println("  Direct error: ${e}")
    
    io.println("Testing variable construction:")
    r2 = extract_variable()
    r2 ? | Result.Ok(v) => io.println("  Variable value: ${v}")
        | Result.Err(e) => io.println("  Variable error: ${e}")
    
    // Check if variable construction gave us 42
    r2 ? | Result.Ok(v) => {
        v == 42 ? | true => 0 | false => 1
    } | Result.Err(e) => 2
}