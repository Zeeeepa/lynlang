// Test triple nested generics: Option<Result<Option<i32>, string>>
{ io, Result, Option } = @std

main = () void {
    io.println("Testing triple nested generics")
    
    // Build from innermost out
    inner_opt = Option.Some(999)
    io.println("Inner Option created: Some(999)")
    
    // Test inner option directly
    inner_opt ?
        | Option.Some(v) { io.println("  Inner value directly: ${v}") }
        | Option.None { io.println("  Inner is None") }
    
    // Wrap in Result
    middle_result = Result.Ok(inner_opt)
    io.println("Middle Result created: Ok(Option.Some(999))")
    
    // Test middle result directly
    middle_result ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(v) { io.println("  Middle->Inner value: ${v}") }
                | Option.None { io.println("  Middle->Inner is None") }
        }
        | Result.Err(e) { io.println("  Middle error: ${e}") }
    
    // Wrap in Option
    outer_option = Option.Some(middle_result)
    io.println("Outer Option created: Some(Result.Ok(Option.Some(999)))")
    
    // Test full triple nesting
    outer_option ?
        | Option.Some(res) {
            io.println("  Outer: Got Some, extracting Result...")
            res ?
                | Result.Ok(opt) {
                    io.println("    Middle: Got Ok, extracting Option...")
                    opt ?
                        | Option.Some(v) { io.println("      Inner: Final value = ${v}") }
                        | Option.None { io.println("      Inner: Got None") }
                }
                | Result.Err(e) { io.println("    Middle: Got Err: ${e}") }
        }
        | Option.None { io.println("  Outer: Got None") }
}