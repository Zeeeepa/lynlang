// codegen.zen - Self-hosted code generator for Zen language
// Generates LLVM IR from typed AST

io := @std.io
core := @std.core
string := @std.string
vec := @std.vec
map := @std.map

// Import compiler modules
parser := @compiler.parser
type_checker := @compiler.type_checker

// IR representation
enum IROpcode {
    // Arithmetic
    Add,
    Sub,
    Mul,
    Div,
    Rem,
    
    // Comparison
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
    
    // Logical
    And,
    Or,
    Not,
    
    // Memory
    Alloca,
    Load,
    Store,
    GetElementPtr,
    
    // Control flow
    Br,
    CondBr,
    Ret,
    Call,
    Phi,
    
    // Constants
    ConstInt,
    ConstFloat,
    ConstString,
    ConstNull,
    
    // Type operations
    Bitcast,
    Trunc,
    Zext,
    Sext,
    FpTrunc,
    FpExt,
    PtrToInt,
    IntToPtr,
}

struct IRValue {
    id: u32,
    ir_type: IRType,
    name: Option<string>,
}

struct IRType {
    kind: IRTypeKind,
    size: u32,
}

enum IRTypeKind {
    Void,
    Integer(u32),  // bit width
    Float(u32),    // 32 or 64
    Pointer(Box<IRType>),
    Array(Box<IRType>, u32),
    Struct(Vec<IRType>),
    Function(Vec<IRType>, Box<IRType>),
}

struct IRInstruction {
    opcode: IROpcode,
    result: Option<IRValue>,
    operands: Vec<IRValue>,
    metadata: Option<string>,
}

struct IRBasicBlock {
    label: string,
    instructions: Vec<IRInstruction>,
    terminator: Option<IRInstruction>,
}

struct IRFunction {
    name: string,
    params: Vec<(string, IRType)>,
    return_type: IRType,
    blocks: Vec<IRBasicBlock>,
    is_external: bool,
}

struct IRModule {
    name: string,
    functions: Vec<IRFunction>,
    globals: Vec<IRGlobal>,
    types: Vec<IRTypeDefinition>,
}

struct IRGlobal {
    name: string,
    global_type: IRType,
    initializer: Option<IRValue>,
    is_constant: bool,
}

struct IRTypeDefinition {
    name: string,
    definition: IRType,
}

// Code generator state
struct CodeGen {
    module: IRModule,
    current_function: Option<*IRFunction>,
    current_block: Option<*IRBasicBlock>,
    value_counter: u32,
    label_counter: u32,
    string_constants: map.Map<string, IRValue>,
    type_map: map.Map<string, IRType>,
}

// Create new code generator
new := () *CodeGen {
    cg := core.allocate<CodeGen>()
    cg.module = IRModule {
        name: "main",
        functions: vec.new<IRFunction>(),
        globals: vec.new<IRGlobal>(),
        types: vec.new<IRTypeDefinition>(),
    }
    cg.current_function = None
    cg.current_block = None
    cg.value_counter = 0
    cg.label_counter = 0
    cg.string_constants = map.new<string, IRValue>()
    cg.type_map = create_builtin_types()
    return cg
}

// Create builtin IR types
create_builtin_types := () map.Map<string, IRType> {
    types := map.new<string, IRType>()
    
    // Integer types
    map.insert(types, "i8", IRType { kind: IRTypeKind.Integer(8), size: 1 })
    map.insert(types, "i16", IRType { kind: IRTypeKind.Integer(16), size: 2 })
    map.insert(types, "i32", IRType { kind: IRTypeKind.Integer(32), size: 4 })
    map.insert(types, "i64", IRType { kind: IRTypeKind.Integer(64), size: 8 })
    
    map.insert(types, "u8", IRType { kind: IRTypeKind.Integer(8), size: 1 })
    map.insert(types, "u16", IRType { kind: IRTypeKind.Integer(16), size: 2 })
    map.insert(types, "u32", IRType { kind: IRTypeKind.Integer(32), size: 4 })
    map.insert(types, "u64", IRType { kind: IRTypeKind.Integer(64), size: 8 })
    
    // Float types
    map.insert(types, "f32", IRType { kind: IRTypeKind.Float(32), size: 4 })
    map.insert(types, "f64", IRType { kind: IRTypeKind.Float(64), size: 8 })
    
    // Other
    map.insert(types, "bool", IRType { kind: IRTypeKind.Integer(1), size: 1 })
    map.insert(types, "void", IRType { kind: IRTypeKind.Void, size: 0 })
    
    return types
}

// Generate IR from typed AST
generate := (cg: *CodeGen, program: parser.Program) Result<IRModule, string> {
    // Generate code for each declaration
    for decl in program.declarations {
        generate_declaration(cg, decl)
    }
    
    return Ok(cg.module)
}

// Generate declaration
generate_declaration := (cg: *CodeGen, decl: parser.Declaration) void {
    match decl {
        parser.Declaration.Function(func) => generate_function(cg, func),
        parser.Declaration.Variable(var) => generate_global_variable(cg, var),
        parser.Declaration.Struct(s) => generate_struct_type(cg, s),
        parser.Declaration.Enum(e) => generate_enum_type(cg, e),
        parser.Declaration.TypeAlias(ta) => generate_type_alias(cg, ta),
        parser.Declaration.Import(imp) => {}, // Imports handled at module level
    }
}

// Generate function
generate_function := (cg: *CodeGen, func: parser.FunctionDecl) void {
    // Convert parameter types
    params := vec.new<(string, IRType)>()
    for param in func.params {
        ir_type := convert_type(cg, param.param_type)
        vec.push(params, (param.name, ir_type))
    }
    
    // Convert return type
    return_type := if func.return_type {
        convert_type(cg, func.return_type.unwrap())
    } else {
        IRType { kind: IRTypeKind.Void, size: 0 }
    }
    
    // Create IR function
    ir_func := IRFunction {
        name: func.name,
        params: params,
        return_type: return_type,
        blocks: vec.new<IRBasicBlock>(),
        is_external: false,
    }
    
    // Add to module
    vec.push(cg.module.functions, ir_func)
    
    // Set as current function
    func_ptr := &cg.module.functions[vec.len(cg.module.functions) - 1]
    cg.current_function = Some(func_ptr)
    
    // Create entry block
    entry_block := create_block(cg, "entry")
    vec.push(func_ptr.blocks, entry_block)
    cg.current_block = Some(&func_ptr.blocks[0])
    
    // Generate function body
    generate_block(cg, func.body)
    
    // Add implicit return if needed
    if return_type.kind == IRTypeKind.Void {
        emit_return_void(cg)
    }
    
    // Clear current function
    cg.current_function = None
    cg.current_block = None
}

// Generate block
generate_block := (cg: *CodeGen, block: parser.Block) void {
    for stmt in block.statements {
        generate_statement(cg, stmt)
    }
}

// Generate statement
generate_statement := (cg: *CodeGen, stmt: parser.Statement) void {
    match stmt {
        parser.Statement.Expression(expr) => {
            generate_expression(cg, expr)
        },
        parser.Statement.Return(expr) => {
            if expr {
                value := generate_expression(cg, expr.unwrap())
                emit_return(cg, value)
            } else {
                emit_return_void(cg)
            }
        },
        parser.Statement.If(if_stmt) => generate_if_statement(cg, if_stmt),
        parser.Statement.Loop(loop_stmt) => generate_loop_statement(cg, loop_stmt),
        parser.Statement.Break => emit_branch(cg, get_loop_exit_label(cg)),
        parser.Statement.Continue => emit_branch(cg, get_loop_header_label(cg)),
        parser.Statement.Block(block) => generate_block(cg, block),
    }
}

// Generate expression
generate_expression := (cg: *CodeGen, expr: parser.Expression) IRValue {
    match expr {
        parser.Expression.Binary(bin) => generate_binary_expr(cg, bin),
        parser.Expression.Unary(un) => generate_unary_expr(cg, un),
        parser.Expression.Call(call) => generate_call_expr(cg, call),
        parser.Expression.Index(idx) => generate_index_expr(cg, idx),
        parser.Expression.Member(mem) => generate_member_expr(cg, mem),
        parser.Expression.Identifier(name) => generate_identifier(cg, name),
        parser.Expression.IntegerLit(val) => generate_int_literal(cg, val),
        parser.Expression.FloatLit(val) => generate_float_literal(cg, val),
        parser.Expression.StringLit(val) => generate_string_literal(cg, val),
        parser.Expression.BoolLit(val) => generate_bool_literal(cg, val),
        parser.Expression.Match(match_expr) => generate_match_expr(cg, match_expr),
    }
}

// Generate binary expression
generate_binary_expr := (cg: *CodeGen, expr: parser.BinaryExpr) IRValue {
    left := generate_expression(cg, *expr.left)
    right := generate_expression(cg, *expr.right)
    
    opcode := match expr.operator {
        "+" => IROpcode.Add,
        "-" => IROpcode.Sub,
        "*" => IROpcode.Mul,
        "/" => IROpcode.Div,
        "%" => IROpcode.Rem,
        "==" => IROpcode.Eq,
        "!=" => IROpcode.Ne,
        "<" => IROpcode.Lt,
        "<=" => IROpcode.Le,
        ">" => IROpcode.Gt,
        ">=" => IROpcode.Ge,
        "&&" => IROpcode.And,
        "||" => IROpcode.Or,
        _ => panic(string.format("Unknown operator: {}", expr.operator)),
    }
    
    return emit_binary_op(cg, opcode, left, right)
}

// Generate literals
generate_int_literal := (cg: *CodeGen, value: i64) IRValue {
    return IRValue {
        id: next_value_id(cg),
        ir_type: IRType { kind: IRTypeKind.Integer(32), size: 4 },
        name: Some(string.format("{}", value)),
    }
}

generate_float_literal := (cg: *CodeGen, value: f64) IRValue {
    return IRValue {
        id: next_value_id(cg),
        ir_type: IRType { kind: IRTypeKind.Float(64), size: 8 },
        name: Some(string.format("{}", value)),
    }
}

generate_string_literal := (cg: *CodeGen, value: string) IRValue {
    // Check if already exists
    if map.contains(cg.string_constants, value) {
        return map.get(cg.string_constants, value).unwrap()
    }
    
    // Create global string constant
    str_value := IRValue {
        id: next_value_id(cg),
        ir_type: IRType { 
            kind: IRTypeKind.Pointer(Box.new(IRType { 
                kind: IRTypeKind.Integer(8), 
                size: 1 
            })),
            size: 8
        },
        name: Some(string.format("@.str.{}", cg.value_counter)),
    }
    
    map.insert(cg.string_constants, value, str_value)
    
    // Add global
    global := IRGlobal {
        name: str_value.name.unwrap(),
        global_type: IRType {
            kind: IRTypeKind.Array(
                Box.new(IRType { kind: IRTypeKind.Integer(8), size: 1 }),
                string.len(value) + 1
            ),
            size: string.len(value) + 1,
        },
        initializer: Some(str_value),
        is_constant: true,
    }
    vec.push(cg.module.globals, global)
    
    return str_value
}

generate_bool_literal := (cg: *CodeGen, value: bool) IRValue {
    return IRValue {
        id: next_value_id(cg),
        ir_type: IRType { kind: IRTypeKind.Integer(1), size: 1 },
        name: Some(if value { "true" } else { "false" }),
    }
}

// Helper functions
convert_type := (cg: *CodeGen, t: parser.Type) IRType {
    match t {
        parser.Type.Named(name) => {
            if map.contains(cg.type_map, name) {
                return map.get(cg.type_map, name).unwrap()
            }
            // Default to i32 for unknown types
            return IRType { kind: IRTypeKind.Integer(32), size: 4 }
        },
        parser.Type.Pointer(inner) => {
            inner_type := convert_type(cg, *inner)
            return IRType {
                kind: IRTypeKind.Pointer(Box.new(inner_type)),
                size: 8,
            }
        },
        parser.Type.Array(elem, size) => {
            elem_type := convert_type(cg, *elem)
            if size {
                return IRType {
                    kind: IRTypeKind.Array(Box.new(elem_type), size.unwrap() as u32),
                    size: elem_type.size * (size.unwrap() as u32),
                }
            }
            // Dynamic array (slice) - represented as struct { ptr, len }
            return IRType {
                kind: IRTypeKind.Struct(vec![
                    IRType { kind: IRTypeKind.Pointer(Box.new(elem_type)), size: 8 },
                    IRType { kind: IRTypeKind.Integer(64), size: 8 },
                ]),
                size: 16,
            }
        },
        _ => {
            // Default type
            return IRType { kind: IRTypeKind.Integer(32), size: 4 }
        }
    }
}

next_value_id := (cg: *CodeGen) u32 {
    id := cg.value_counter
    cg.value_counter = cg.value_counter + 1
    return id
}

next_label := (cg: *CodeGen, prefix: string) string {
    label := string.format("{}{}", prefix, cg.label_counter)
    cg.label_counter = cg.label_counter + 1
    return label
}

create_block := (cg: *CodeGen, label: string) IRBasicBlock {
    return IRBasicBlock {
        label: label,
        instructions: vec.new<IRInstruction>(),
        terminator: None,
    }
}

// Emit instructions
emit_binary_op := (cg: *CodeGen, opcode: IROpcode, left: IRValue, right: IRValue) IRValue {
    result := IRValue {
        id: next_value_id(cg),
        ir_type: left.ir_type,  // Assume same type for now
        name: None,
    }
    
    inst := IRInstruction {
        opcode: opcode,
        result: Some(result),
        operands: vec![left, right],
        metadata: None,
    }
    
    if cg.current_block {
        vec.push(cg.current_block.unwrap().instructions, inst)
    }
    
    return result
}

emit_return := (cg: *CodeGen, value: IRValue) void {
    inst := IRInstruction {
        opcode: IROpcode.Ret,
        result: None,
        operands: vec![value],
        metadata: None,
    }
    
    if cg.current_block {
        cg.current_block.unwrap().terminator = Some(inst)
    }
}

emit_return_void := (cg: *CodeGen) void {
    inst := IRInstruction {
        opcode: IROpcode.Ret,
        result: None,
        operands: vec.new<IRValue>(),
        metadata: None,
    }
    
    if cg.current_block {
        cg.current_block.unwrap().terminator = Some(inst)
    }
}

emit_branch := (cg: *CodeGen, label: string) void {
    // TODO: Implement branch emission
}

// TODO: Implement remaining code generation functions
generate_global_variable := (cg: *CodeGen, var: parser.VariableDecl) void {
    // Placeholder
}

generate_struct_type := (cg: *CodeGen, s: parser.StructDecl) void {
    // Placeholder
}

generate_enum_type := (cg: *CodeGen, e: parser.EnumDecl) void {
    // Placeholder
}

generate_type_alias := (cg: *CodeGen, ta: parser.TypeAliasDecl) void {
    // Placeholder
}

generate_if_statement := (cg: *CodeGen, stmt: parser.IfStmt) void {
    // Placeholder
}

generate_loop_statement := (cg: *CodeGen, stmt: parser.LoopStmt) void {
    // Placeholder
}

generate_unary_expr := (cg: *CodeGen, expr: parser.UnaryExpr) IRValue {
    // Placeholder
    return IRValue {
        id: 0,
        ir_type: IRType { kind: IRTypeKind.Void, size: 0 },
        name: None,
    }
}

generate_call_expr := (cg: *CodeGen, expr: parser.CallExpr) IRValue {
    // Placeholder
    return IRValue {
        id: 0,
        ir_type: IRType { kind: IRTypeKind.Void, size: 0 },
        name: None,
    }
}

generate_index_expr := (cg: *CodeGen, expr: parser.IndexExpr) IRValue {
    // Placeholder
    return IRValue {
        id: 0,
        ir_type: IRType { kind: IRTypeKind.Void, size: 0 },
        name: None,
    }
}

generate_member_expr := (cg: *CodeGen, expr: parser.MemberExpr) IRValue {
    // Placeholder
    return IRValue {
        id: 0,
        ir_type: IRType { kind: IRTypeKind.Void, size: 0 },
        name: None,
    }
}

generate_identifier := (cg: *CodeGen, name: string) IRValue {
    // Placeholder
    return IRValue {
        id: 0,
        ir_type: IRType { kind: IRTypeKind.Void, size: 0 },
        name: Some(name),
    }
}

generate_match_expr := (cg: *CodeGen, expr: parser.MatchExpr) IRValue {
    // Placeholder
    return IRValue {
        id: 0,
        ir_type: IRType { kind: IRTypeKind.Void, size: 0 },
        name: None,
    }
}

get_loop_exit_label := (cg: *CodeGen) string {
    // TODO: Implement loop context tracking
    return "loop.exit"
}

get_loop_header_label := (cg: *CodeGen) string {
    // TODO: Implement loop context tracking
    return "loop.header"
}