// type_checker.zen - Self-hosted type checker for Zen language

io := @std.io
core := @std.core
string := @std.string
vec := @std.vec
map := @std.map

// Import compiler modules
parser := @compiler.parser
errors := @compiler.errors

// Type system representation
enum TypeKind {
    Primitive,
    Struct,
    Enum,
    Function,
    Pointer,
    Array,
    Slice,
    Generic,
    TypeParameter,
    Unknown,
    Never,
}

struct Type {
    kind: TypeKind,
    name: string,
    size: u64,
    align: u64,
}

struct PrimitiveType {
    base: Type,
    is_signed: bool,
    is_floating: bool,
}

struct StructType {
    base: Type,
    fields: Vec<StructField>,
    is_packed: bool,
}

struct StructField {
    name: string,
    field_type: *Type,
    offset: u64,
    is_public: bool,
}

struct EnumType {
    base: Type,
    variants: Vec<EnumVariant>,
    discriminant_type: *Type,
}

struct EnumVariant {
    name: string,
    value: Option<i64>,
    payload_type: Option<*Type>,
}

struct FunctionType {
    base: Type,
    params: Vec<*Type>,
    return_type: *Type,
    is_variadic: bool,
    is_generic: bool,
}

struct ArrayType {
    base: Type,
    element_type: *Type,
    length: u64,
}

struct SliceType {
    base: Type,
    element_type: *Type,
}

struct PointerType {
    base: Type,
    pointee_type: *Type,
    is_mutable: bool,
}

struct GenericType {
    base: Type,
    base_type: *Type,
    type_args: Vec<*Type>,
}

// Type environment
struct TypeEnv {
    parent: Option<*TypeEnv>,
    bindings: map.Map<string, *Type>,
    types: map.Map<string, *Type>,
}

// Type checker state
struct TypeChecker {
    env: *TypeEnv,
    errors: Vec<TypeError>,
    primitive_types: map.Map<string, *Type>,
    current_function: Option<*FunctionType>,
}

struct TypeError {
    message: string,
    line: u32,
    column: u32,
    expected: Option<*Type>,
    actual: Option<*Type>,
}

// Create new type checker
new := () *TypeChecker {
    tc := core.allocate<TypeChecker>()
    tc.env = new_env(None)
    tc.errors = vec.new<TypeError>()
    tc.primitive_types = create_primitive_types()
    tc.current_function = None
    return tc
}

// Create new type environment
new_env := (parent: Option<*TypeEnv>) *TypeEnv {
    env := core.allocate<TypeEnv>()
    env.parent = parent
    env.bindings = map.new<string, *Type>()
    env.types = map.new<string, *Type>()
    return env
}

// Create primitive types
create_primitive_types := () map.Map<string, *Type> {
    types := map.new<string, *Type>()
    
    // Integer types
    add_primitive(&types, "i8", 1, 1, true, false)
    add_primitive(&types, "i16", 2, 2, true, false)
    add_primitive(&types, "i32", 4, 4, true, false)
    add_primitive(&types, "i64", 8, 8, true, false)
    add_primitive(&types, "isize", 8, 8, true, false)
    
    add_primitive(&types, "u8", 1, 1, false, false)
    add_primitive(&types, "u16", 2, 2, false, false)
    add_primitive(&types, "u32", 4, 4, false, false)
    add_primitive(&types, "u64", 8, 8, false, false)
    add_primitive(&types, "usize", 8, 8, false, false)
    
    // Floating point types
    add_primitive(&types, "f32", 4, 4, true, true)
    add_primitive(&types, "f64", 8, 8, true, true)
    
    // Other primitives
    add_primitive(&types, "bool", 1, 1, false, false)
    add_primitive(&types, "char", 4, 4, false, false)
    add_primitive(&types, "void", 0, 1, false, false)
    
    return types
}

add_primitive := (types: *map.Map<string, *Type>, name: string, size: u64, align: u64, 
                  is_signed: bool, is_floating: bool) void {
    prim := core.allocate<PrimitiveType>()
    prim.base = Type {
        kind: TypeKind.Primitive,
        name: name,
        size: size,
        align: align,
    }
    prim.is_signed = is_signed
    prim.is_floating = is_floating
    
    map.insert(types, name, &prim.base)
}

// Main type checking function
check := (tc: *TypeChecker, ast: parser.Program) Result<parser.Program, Vec<TypeError>> {
    // Type check all declarations
    for decl in ast.declarations {
        check_declaration(tc, decl)
    }
    
    if vec.len(tc.errors) > 0 {
        return Err(tc.errors)
    }
    
    return Ok(ast)
}

// Check declaration
check_declaration := (tc: *TypeChecker, decl: parser.Declaration) void {
    match decl {
        parser.Declaration.Function(func) => check_function(tc, func),
        parser.Declaration.Variable(var) => check_variable(tc, var),
        parser.Declaration.Struct(s) => check_struct(tc, s),
        parser.Declaration.Enum(e) => check_enum(tc, e),
        parser.Declaration.TypeAlias(ta) => check_type_alias(tc, ta),
        parser.Declaration.Import(imp) => check_import(tc, imp),
    }
}

// Check function declaration
check_function := (tc: *TypeChecker, func: parser.FunctionDecl) void {
    // Create function type
    param_types := vec.new<*Type>()
    for param in func.params {
        param_type := resolve_type(tc, param.param_type)
        vec.push(param_types, param_type)
        
        // Add parameter to environment
        add_binding(tc.env, param.name, param_type)
    }
    
    return_type := if func.return_type {
        resolve_type(tc, func.return_type.unwrap())
    } else {
        get_primitive_type(tc, "void")
    }
    
    func_type := core.allocate<FunctionType>()
    func_type.base = Type {
        kind: TypeKind.Function,
        name: func.name,
        size: 8,  // Function pointer size
        align: 8,
    }
    func_type.params = param_types
    func_type.return_type = return_type
    func_type.is_variadic = false
    func_type.is_generic = func.is_generic
    
    // Add function to environment
    add_type(tc.env, func.name, &func_type.base)
    
    // Type check body
    saved_func := tc.current_function
    tc.current_function = Some(func_type)
    
    check_block(tc, func.body)
    
    tc.current_function = saved_func
}

// Check variable declaration
check_variable := (tc: *TypeChecker, var: parser.VariableDecl) void {
    // Determine variable type
    var_type := if var.var_type {
        resolve_type(tc, var.var_type.unwrap())
    } else if var.value {
        // Infer type from initializer
        infer_expression_type(tc, var.value.unwrap())
    } else {
        add_error(tc, "Variable must have type or initializer", var.base.line, var.base.column)
        return
    }
    
    // Type check initializer if present
    if var.value {
        init_type := check_expression(tc, var.value.unwrap())
        if !types_compatible(var_type, init_type) {
            add_type_error(tc, "Type mismatch in variable initialization", 
                          var.base.line, var.base.column, var_type, init_type)
        }
    }
    
    // Add to environment
    add_binding(tc.env, var.name, var_type)
}

// Check import declaration
check_import := (tc: *TypeChecker, imp: parser.ImportDecl) void {
    // Imports are resolved at module level
    // For now, just mark them as valid
    // TODO: Implement module system integration
}

// Check block
check_block := (tc: *TypeChecker, block: parser.Block) void {
    // Create new scope
    tc.env = new_env(Some(tc.env))
    
    // Type check statements
    for stmt in block.statements {
        check_statement(tc, stmt)
    }
    
    // Restore parent scope
    if tc.env.parent {
        tc.env = tc.env.parent.unwrap()
    }
}

// Check statement
check_statement := (tc: *TypeChecker, stmt: parser.Statement) void {
    match stmt {
        parser.Statement.Expression(expr) => {
            check_expression(tc, expr)
        },
        parser.Statement.Return(expr) => {
            if tc.current_function {
                func := tc.current_function.unwrap()
                
                if expr {
                    ret_type := check_expression(tc, expr.unwrap())
                    if !types_compatible(func.return_type, ret_type) {
                        add_type_error(tc, "Return type mismatch", 0, 0, 
                                      func.return_type, ret_type)
                    }
                } else {
                    // Check if function expects void return
                    if func.return_type.name != "void" {
                        add_error(tc, "Missing return value", 0, 0)
                    }
                }
            } else {
                add_error(tc, "Return statement outside function", 0, 0)
            }
        },
        parser.Statement.If(if_stmt) => check_if_statement(tc, if_stmt),
        parser.Statement.Loop(loop_stmt) => check_loop_statement(tc, loop_stmt),
        parser.Statement.Break => {
            // TODO: Check if in loop context
        },
        parser.Statement.Continue => {
            // TODO: Check if in loop context
        },
        parser.Statement.Block(block) => check_block(tc, block),
    }
}

// Check expression and return its type
check_expression := (tc: *TypeChecker, expr: parser.Expression) *Type {
    match expr {
        parser.Expression.Binary(bin) => check_binary_expr(tc, bin),
        parser.Expression.Unary(un) => check_unary_expr(tc, un),
        parser.Expression.Call(call) => check_call_expr(tc, call),
        parser.Expression.Index(idx) => check_index_expr(tc, idx),
        parser.Expression.Member(mem) => check_member_expr(tc, mem),
        parser.Expression.Identifier(name) => {
            type_opt := lookup_binding(tc.env, name)
            if type_opt {
                return type_opt.unwrap()
            }
            add_error(tc, string.format("Undefined identifier: {}", name), 0, 0)
            return get_unknown_type()
        },
        parser.Expression.IntegerLit(val) => get_primitive_type(tc, "i32"),
        parser.Expression.FloatLit(val) => get_primitive_type(tc, "f64"),
        parser.Expression.StringLit(val) => {
            // String literals are slices of u8
            elem_type := get_primitive_type(tc, "u8")
            return make_slice_type(elem_type)
        },
        parser.Expression.BoolLit(val) => get_primitive_type(tc, "bool"),
        parser.Expression.Match(match_expr) => check_match_expr(tc, match_expr),
    }
}

// Check binary expression
check_binary_expr := (tc: *TypeChecker, expr: parser.BinaryExpr) *Type {
    left_type := check_expression(tc, *expr.left)
    right_type := check_expression(tc, *expr.right)
    
    // Type rules based on operator
    match expr.operator {
        "+" | "-" | "*" | "/" | "%" => {
            // Arithmetic operators
            if !is_numeric_type(left_type) || !is_numeric_type(right_type) {
                add_error(tc, "Arithmetic operators require numeric types", 
                         expr.base.line, expr.base.column)
                return get_unknown_type()
            }
            
            // Result type is the wider of the two
            return promote_numeric_types(left_type, right_type)
        },
        "==" | "!=" => {
            // Equality operators - types must be compatible
            if !types_compatible(left_type, right_type) {
                add_type_error(tc, "Incompatible types for equality comparison",
                              expr.base.line, expr.base.column, left_type, right_type)
            }
            return get_primitive_type(tc, "bool")
        },
        "<" | ">" | "<=" | ">=" => {
            // Comparison operators
            if !is_numeric_type(left_type) || !is_numeric_type(right_type) {
                add_error(tc, "Comparison operators require numeric types",
                         expr.base.line, expr.base.column)
            }
            return get_primitive_type(tc, "bool")
        },
        "&&" | "||" => {
            // Logical operators
            if !is_bool_type(left_type) || !is_bool_type(right_type) {
                add_error(tc, "Logical operators require boolean types",
                         expr.base.line, expr.base.column)
            }
            return get_primitive_type(tc, "bool")
        },
        _ => {
            add_error(tc, string.format("Unknown operator: {}", expr.operator),
                     expr.base.line, expr.base.column)
            return get_unknown_type()
        }
    }
}

// Helper functions
resolve_type := (tc: *TypeChecker, type_ast: parser.Type) *Type {
    match type_ast {
        parser.Type.Named(name) => {
            // Look up named type
            if map.contains(tc.primitive_types, name) {
                return map.get(tc.primitive_types, name).unwrap()
            }
            
            type_opt := lookup_type(tc.env, name)
            if type_opt {
                return type_opt.unwrap()
            }
            
            add_error(tc, string.format("Unknown type: {}", name), 0, 0)
            return get_unknown_type()
        },
        parser.Type.Pointer(inner) => {
            pointee := resolve_type(tc, *inner)
            return make_pointer_type(pointee, true)
        },
        parser.Type.Array(elem, size) => {
            element := resolve_type(tc, *elem)
            if size {
                return make_array_type(element, size.unwrap())
            }
            return make_slice_type(element)
        },
        parser.Type.Function(params, ret) => {
            // TODO: Implement function type resolution
            return get_unknown_type()
        },
        parser.Type.Generic(base, args) => {
            // TODO: Implement generic type resolution
            return get_unknown_type()
        }
    }
}

infer_expression_type := (tc: *TypeChecker, expr: parser.Expression) *Type {
    return check_expression(tc, expr)
}

types_compatible := (expected: *Type, actual: *Type) bool {
    // Simple compatibility check
    // TODO: Implement proper type compatibility rules
    return expected.name == actual.name
}

is_numeric_type := (t: *Type) bool {
    return t.kind == TypeKind.Primitive && 
           (string.starts_with(t.name, "i") || 
            string.starts_with(t.name, "u") || 
            string.starts_with(t.name, "f"))
}

is_bool_type := (t: *Type) bool {
    return t.kind == TypeKind.Primitive && t.name == "bool"
}

promote_numeric_types := (t1: *Type, t2: *Type) *Type {
    // Simple promotion rules
    // TODO: Implement proper type promotion
    if t1.size > t2.size {
        return t1
    }
    return t2
}

get_primitive_type := (tc: *TypeChecker, name: string) *Type {
    if map.contains(tc.primitive_types, name) {
        return map.get(tc.primitive_types, name).unwrap()
    }
    return get_unknown_type()
}

get_unknown_type := () *Type {
    static unknown := Type {
        kind: TypeKind.Unknown,
        name: "<unknown>",
        size: 0,
        align: 1,
    }
    return &unknown
}

make_pointer_type := (pointee: *Type, is_mutable: bool) *Type {
    ptr := core.allocate<PointerType>()
    ptr.base = Type {
        kind: TypeKind.Pointer,
        name: string.format("*{}", pointee.name),
        size: 8,
        align: 8,
    }
    ptr.pointee_type = pointee
    ptr.is_mutable = is_mutable
    return &ptr.base
}

make_array_type := (element: *Type, length: u64) *Type {
    arr := core.allocate<ArrayType>()
    arr.base = Type {
        kind: TypeKind.Array,
        name: string.format("[{}]{}", length, element.name),
        size: element.size * length,
        align: element.align,
    }
    arr.element_type = element
    arr.length = length
    return &arr.base
}

make_slice_type := (element: *Type) *Type {
    slice := core.allocate<SliceType>()
    slice.base = Type {
        kind: TypeKind.Slice,
        name: string.format("[]{}", element.name),
        size: 16,  // Pointer + length
        align: 8,
    }
    slice.element_type = element
    return &slice.base
}

// Environment operations
add_binding := (env: *TypeEnv, name: string, t: *Type) void {
    map.insert(env.bindings, name, t)
}

lookup_binding := (env: *TypeEnv, name: string) Option<*Type> {
    if map.contains(env.bindings, name) {
        return Some(map.get(env.bindings, name).unwrap())
    }
    
    if env.parent {
        return lookup_binding(env.parent.unwrap(), name)
    }
    
    return None
}

add_type := (env: *TypeEnv, name: string, t: *Type) void {
    map.insert(env.types, name, t)
}

lookup_type := (env: *TypeEnv, name: string) Option<*Type> {
    if map.contains(env.types, name) {
        return Some(map.get(env.types, name).unwrap())
    }
    
    if env.parent {
        return lookup_type(env.parent.unwrap(), name)
    }
    
    return None
}

// Error reporting
add_error := (tc: *TypeChecker, message: string, line: u32, column: u32) void {
    error := TypeError {
        message: message,
        line: line,
        column: column,
        expected: None,
        actual: None,
    }
    vec.push(tc.errors, error)
}

add_type_error := (tc: *TypeChecker, message: string, line: u32, column: u32, 
                   expected: *Type, actual: *Type) void {
    error := TypeError {
        message: message,
        line: line,
        column: column,
        expected: Some(expected),
        actual: Some(actual),
    }
    vec.push(tc.errors, error)
}

// TODO: Implement remaining type checking functions
check_struct := (tc: *TypeChecker, s: parser.StructDecl) void {
    // Placeholder
}

check_enum := (tc: *TypeChecker, e: parser.EnumDecl) void {
    // Placeholder
}

check_type_alias := (tc: *TypeChecker, ta: parser.TypeAliasDecl) void {
    // Placeholder
}

check_if_statement := (tc: *TypeChecker, stmt: parser.IfStmt) void {
    // Placeholder
}

check_loop_statement := (tc: *TypeChecker, stmt: parser.LoopStmt) void {
    // Placeholder
}

check_unary_expr := (tc: *TypeChecker, expr: parser.UnaryExpr) *Type {
    // Placeholder
    return get_unknown_type()
}

check_call_expr := (tc: *TypeChecker, expr: parser.CallExpr) *Type {
    // Placeholder
    return get_unknown_type()
}

check_index_expr := (tc: *TypeChecker, expr: parser.IndexExpr) *Type {
    // Placeholder
    return get_unknown_type()
}

check_member_expr := (tc: *TypeChecker, expr: parser.MemberExpr) *Type {
    // Placeholder
    return get_unknown_type()
}

check_match_expr := (tc: *TypeChecker, expr: parser.MatchExpr) *Type {
    // Placeholder
    return get_unknown_type()
}