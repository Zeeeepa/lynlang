// Unified Allocator-Based Async/Sync Demo
// Shows the SAME functions working with both sync and async allocators
// No function coloring - allocator determines behavior

{ io, GPA, AsyncPool, fs } = @std

// This function works with ANY allocator - sync or async!
read_and_process = (allocator: i64, filename: string) string {
    io.println("Processing ${filename}...")
    
    // Same fs.read_file call works with both allocators
    // Blocks if GPA, non-blocking if AsyncPool
    content = fs.read_file(allocator, filename).raise()
    
    // Same string operations work with both
    lines = content.split("\n").len()
    
    return "File: ${filename}, Lines: ${lines}"
}

// Another function that works with any allocator
batch_process = (allocator: i64, files: i64) i64 {
    results = Array.new(allocator)
    
    // Same loop works with both allocators  
    files.loop((file) {
        result = read_and_process(allocator, file)
        results.push(result)
    })
    
    return results
}

main = () i32 {
    io.println("=== Unified Allocator Demo ===")
    io.println("Same code, different behavior based on allocator choice")
    io.println("")
    
    test_files = ["config.txt", "data.csv", "readme.md"]
    
    // === SYNCHRONOUS EXECUTION ===
    io.println("ðŸ”„ Using GPA (synchronous allocator):")
    sync_alloc = GPA.init()
    
    // Same functions, BLOCKING behavior
    sync_results = batch_process(sync_alloc, test_files)
    sync_results.loop((result) { io.println("  ${result}") })
    
    io.println("")
    
    // === ASYNCHRONOUS EXECUTION ===  
    io.println("âš¡ Using AsyncPool (asynchronous allocator):")
    async_alloc = AsyncPool.init()
    
    // IDENTICAL functions, NON-BLOCKING behavior
    async_results = batch_process(async_alloc, test_files)
    async_results.loop((result) { io.println("  ${result}") })
    
    io.println("")
    io.println("ðŸŽ‰ Benefits Demonstrated:")
    io.println("  â€¢ Same functions work with both allocators")
    io.println("  â€¢ No async/await keywords needed")
    io.println("  â€¢ No function coloring problem")
    io.println("  â€¢ Allocator choice = execution model")
    io.println("  â€¢ Zero code duplication")
    
    return 0
}
