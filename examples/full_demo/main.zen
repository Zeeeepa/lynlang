// Zenlang Comprehensive Demo
// Showcases all major language features and capabilities

{ io, result, fs, net, math, string } = @std
{ Vec, DynVec } = @std.collections

// ==========================================
// 1. Pattern Matching - The Heart of Zen
// ==========================================

demonstrate_pattern_matching = () void {
    io.print("\n=== Pattern Matching Demo ===\n")
    
    // Simple boolean pattern
    is_adult = (age: i32) bool {
        age >= 18 ? { return true }
        return false
    }
    
    // Range patterns - check explicitly in new spec
    categorize_age = (age: i32) string {
        age <= 12 ?
            | true { return "Child" }
            | false {
                age <= 19 ?
                    | true { return "Teenager" }
                    | false {
                        age <= 64 ?
                            | true { return "Adult" }
                            | false { return "Senior" }
                    }
            }
        }
    }
    
    // Destructuring with Result types
    divide = (a: f64, b: f64) Result<f64, string> {
        b == 0.0 ?
            | true { return .Err("Division by zero") }
            | false { return .Ok(a / b) }
    }
    
    result = divide(10.0, 2.0)
    result ?
        | .Ok(value) { io.println("10 / 2 = ${value}") }
        | .Err(error) { io.println("Error: ${error}") }
    
    // Option pattern matching
    find_user = (id: u32) Option<string> {
        id == 1 ?
            | true { return .Some("Alice") }
            | false {
                id == 2 ?
                    | true { return .Some("Bob") }
                    | false { return .None }
            }
        }
    }
    
    user = find_user(1)
    user ?
        | .Some(name) { io.println("Found user: ${name}") }
        | .None { io.println("User not found") }
    
    // Guards in patterns - removed in new spec, use nested patterns
    classify_number = (n: i32) string {
        n < 0 ?
            | true { return "Negative" }
            | false {
                n == 0 ?
                    | true { return "Zero" }
                    | false {
                        n < 10 ?
                            | true { return "Single digit" }
                            | false {
                                n < 100 ?
                                    | true { return "Double digit" }
                                    | false { return "Large number" }
                            }
                    }
            }
        }
    }
    
    io.println("Number 42 is: ${classify_number(42)}")
}

// ==========================================
// 2. Memory Management & Smart Pointers
// ==========================================

demonstrate_memory_management = () void {
    io.println("\n=== Memory Management Demo ===\n")
    
    // Using Ptr<T> instead of raw pointers
    allocate_int = () Ptr<i32> {
        ptr = Ptr<i32>.new(42)
        io.println("Allocated value: ${ptr.val}")
        io.println("Address: ${ptr.addr}")
        return ptr
    }
    
    // Reference counting
    SharedData: {
        value: i32,
        refs: AtomicU32
    }
    
    SharedData.create = (val: i32) Ptr<SharedData> {
        data = Ptr<SharedData>.new(SharedData{
            value: val,
            refs: AtomicU32(1)
        })
        return data
    }
    
    SharedData.retain = (self) void {
        self.refs.fetch_add(1, .SeqCst)
    }
    
    SharedData.release = (self) void {
        old_refs = self.refs.fetch_sub(1, .SeqCst)
        old_refs == 1 ?
            | true {
                io.println("Freeing shared data with value: ${self.value}")
                // Memory would be freed here
            }
            | false { }
    }
    
    // RAII with defer
    use_resource = () void {
        resource = SharedData.create(100)
        @this.defer(resource.release())
        
        io.println("Using resource with value: ${resource.val.value}")
        // Resource automatically released when scope ends
    }
    
    use_resource()
}

// ==========================================
// 3. Behaviors (Traits/Interfaces)
// ==========================================

Printable: {
    format: (self) string
}

Comparable<T>: {
    compare: (self, other: T) i32
}

Person: {
    name: string,
    age: u32
}

Person.format = (self) string {
    return "Person { name: ${self.name}, age: ${self.age} }"
}

Person.compare = (self, other: Person) i32 {
    (self.age < other.age) ?
        | true { return -1 }
        | false {
            (self.age > other.age) ?
                | true { return 1 }
                | false { }
        }
    return 0
}

demonstrate_behaviors = () void {
    io.println("\n=== Behaviors Demo ===\n")
    
    alice = Person{ name: "Alice", age: 30 }
    bob = Person{ name: "Bob", age: 25 }
    
    io.println("${alice.format()}")
    io.println("${bob.format()}")
    
    comparison = alice.compare(bob)
    comparison == -1 ?
        | true { io.println("${alice.name} is younger than ${bob.name}") }
        | false {
            comparison == 0 ?
                | true { io.println("${alice.name} and ${bob.name} are the same age") }
                | false {
                    comparison == 1 ?
                        | true { io.println("${alice.name} is older than ${bob.name}") }
                        | false { }
                }
        }
}

// ==========================================
// 4. Comptime - Compile-Time Evaluation
// ==========================================

demonstrate_comptime = () void {
    io.println("\n=== Comptime Demo ===\n")
    
    // Compile-time computed lookup table
    FIBONACCI_TABLE = @meta.comptime((){
        table: Vec<u64, 20>
        table[0] = 0
        table[1] = 1
        (2..20).loop((i) {
            table[i] = table[i-1] + table[i-2]
        })
        table
    })
    
    io.println("10th Fibonacci number (from comptime table): ${FIBONACCI_TABLE[10]}")
    
    // Platform-specific constants
    MAX_PATH = @meta.comptime((){
        @std.target.os ?
            | .Windows { 260 }
            | .Linux { 4096 }
            | .Macos { 1024 }
            | _ { 256 }
    })
    
    io.println("Maximum path length on this platform: ${MAX_PATH}")
    
    // Type generation at compile time
    @meta.comptime((){
        WORD_SIZE = @std.target.pointer_size
        WORD_SIZE == 8 ?
            | true {
                NativeInt = i64
                NativeUInt = u64
            }
            | false {
                NativeInt = i32
                NativeUInt = u32
            }
    })
}

// ==========================================
// 5. Colorless Async & Concurrency
// ==========================================

demonstrate_concurrency = () void {
    io.println("\n=== Colorless Concurrency Demo ===\n")
    
    // Same function works sync or concurrent based on allocator
    fetch_data = (url: string, alloc: Ptr<Allocator>) Result<string, string> {
        // Allocator determines if this runs sync or concurrent
        connection = net.connect(url, alloc).raise()
        @this.defer(connection.close())
        
        data = connection.read_all(alloc).raise()
        return .Ok(data)
    }
    
    // Channel communication
    process_items = () void {
        chan = Channel<i32>.new(10)
        
        // Producer
        producer = () void {
            (0..5).loop((i) {
                chan.send(i)
                io.println("Sent: ${i}")
            })
            chan.close()
        }
        
        // Consumer
        consumer = () void {
            loop(() {
                item = chan.receive()
                item ?
                    | .Some(val) { io.println("Received: ${val}") }
                    | .None { break }
            })
        }
        
        // Run concurrently (in real implementation)
        producer()
        consumer()
    }
    
    // Atomic operations
    counter = AtomicU64(0)
    
    increment_counter = () void {
        (0..10).loop((_) {
            old = counter.fetch_add(1, .SeqCst)
            io.println("Counter incremented from ${old} to ${old + 1}")
        })
    }
    
    io.println("Final counter value: ${counter.load(.SeqCst)}")
}

// ==========================================
// 6. UFCS - Uniform Function Call Syntax
// ==========================================

// Free functions that can be called as methods
square = (x: i32) i32 { return x * x }
double = (x: i32) i32 { return x * 2 }
is_even = (x: i32) bool { return x % 2 == 0 }

demonstrate_ufcs = () void {
    io.println("\n=== UFCS Demo ===\n")
    
    value = 5
    
    // Method-style calls on primitive types
    squared = value.square()
    doubled = value.double()
    even = value.is_even()
    
    io.println("Value: ${value}")
    io.println("Squared: ${squared}")
    io.println("Doubled: ${doubled}")
    io.println("Is even: ${even}")
    
    // Chaining
    result = value
        .double()      // 10
        .square()      // 100
        .double()      // 200
    
    io.println("Chained result: ${result}")
}

// ==========================================
// 7. Error Handling Without Exceptions
// ==========================================

demonstrate_error_handling = () void {
    io.println("\n=== Error Handling Demo ===\n")
    
    // File operations with Result types
    read_config = (path: string) Result<string, string> {
        file = fs.open(path).raise()
        @this.defer(file.close())
        
        content = file.read_all().raise()
        return .Ok(content)
    }
    
    // Chain operations with ?
    process_config = (path: string) Result<void, string> {
        content = read_config(path).raise()
        lines = content.split('\n')
        
        lines.loop((line) {
            line.is_empty() ?
                | true { continue }
                | false { }

            
            parts = line.split('=')
            parts.len() == 2 ?
                | true { io.println("Config: ${parts[0]} = ${parts[1]}") }
                | false { }
        })
        
        return .Ok(void)
    }
    
    result = process_config("config.ini")
    result ?
        | .Ok(_) { io.println("✓ Config processed successfully") }
        | .Err(e) { io.println("✗ Error: ${e}") }
}

// ==========================================
// 8. String Interpolation
// ==========================================

demonstrate_string_interpolation = () void {
    io.println("\n=== String Interpolation Demo ===\n")
    
    name = "Zen"
    version = 1.1
    users = 1000
    
    // Basic interpolation
    message = "Welcome to ${name} v${version}!"
    io.println("${message}")
    
    // Expression interpolation
    stats = "${name} has ${users} users, averaging ${users / 10} per category"
    io.println("${stats}")
    
    // Nested interpolation
    format_user = (name: string, id: u32) string {
        return "User[id=${id}, name=\"${name}\"]"
    }
    
    user_info = format_user("Alice", 42)
    io.println("Created: ${user_info}")
}

// ==========================================
// 9. Loop Patterns
// ==========================================

demonstrate_loops = () void {
    io.println("\n=== Loop Patterns Demo ===\n")
    
    // Infinite loop with break
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter >= 5 ?
            | true { break }
            | false { }
        io.println("Infinite loop iteration: ${counter}")
    })
    
    // Conditional loop
    x ::= 10
    loop(() {
        x <= 0 ?
            | true { break }
            | false { }
        io.println("Conditional loop: x = ${x}")
        x = x - 2
    })
    
    // Range iteration
    (1..3).loop((i) {
        io.println("Range iteration: ${i}")
    })
    
    // Collection iteration
    items = Vec<i32, 3>([10, 20, 30])
    items.loop((item) {
        io.println("Item: ${item}")
    })
    
    // Enumerated iteration
    items.enumerate().loop((item, index) {
        io.println("Item ${index}: ${item}")
    })
    
    // Iterator chaining
    numbers = Vec<i32, 5>([1, 2, 3, 4, 5])
    sum = numbers   
        .filter((n) { n % 2 == 0 })
        .map((n) { n * n })
        .reduce(0, (acc, n) { return acc + n })
    
    io.println("Sum of squares of even numbers: ${sum}")
}

// ==========================================
// Main Entry Point
// ==========================================

main = () void {
    io.println("\n")
    io.println("""
╔══════════════════════════════════════╗
║    Zenlang Comprehensive Demo        ║
║    Language Version: 1.1.0           ║
╚══════════════════════════════════════╝
""")
    
    demonstrate_pattern_matching()
    demonstrate_memory_management()
    demonstrate_behaviors()
    demonstrate_comptime()
    demonstrate_concurrency()
    demonstrate_ufcs()
    demonstrate_error_handling()
    demonstrate_string_interpolation()
    demonstrate_loops()
    
    io.println("\n")
    io.println("""
╔═════════════════════════════════════════╗
║         Demo Complete! 🎉               ║
║                                         ║
║  Key Takeaways:                         ║
║  • No if/else/match - just ?            ║
║  • No exceptions - Result/Option        ║
║  • No null - Option<T>                  ║
║  • No raw pointers - Ptr<T>             ║
║  • Colorless concurrency via allocators ║
║  • Pattern matching everywhere          ║
╚═════════════════════════════════════════╝
""")
    io.println("\n")
}