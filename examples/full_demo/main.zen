// Zenlang Comprehensive Demo
// Showcases all major language features and capabilities

io := @std.build.import("io")
vec := @std.build.import("vec")
string := @std.build.import("string")
result := @std.build.import("result")
fs := @std.build.import("fs")
net := @std.build.import("net")
math := @std.build.import("math")

// ==========================================
// 1. Pattern Matching - The Heart of Zen
// ==========================================

demonstrate_pattern_matching: () void = {
    io.print("\n=== Pattern Matching Demo ===\n")
    
    // Simple boolean pattern
    is_adult: (age: i32) bool = {
        age >= 18 ? | true => true | false => false
    }
    
    // Range patterns
    categorize_age: (age: i32) string = {
        age ? | 0..=12 => "Child"
              | 13..=19 => "Teenager"
              | 20..=64 => "Adult"
              | _ => "Senior"
    }
    
    // Destructuring with Result types
    divide: (a: f64, b: f64) Result<f64, string> = {
        b == 0.0 ? 
            | true => Err("Division by zero")
            | false => Ok(a / b)
    }
    
    result := divide(10.0, 2.0)
    result ? | .Ok -> value => io.print("10 / 2 = $(value)\n")
             | .Err -> error => io.print("Error: $(error)\n")
    
    // Option pattern matching
    find_user: (id: u32) Option<string> = {
        id ? | 1 => Some("Alice")
             | 2 => Some("Bob")
             | _ => None
    }
    
    user := find_user(1)
    user ? | .Some -> name => io.print("Found user: $(name)\n")
           | .None => io.print("User not found\n")
    
    // Guards in patterns
    classify_number: (n: i32) string = {
        n ? | x -> x < 0 => "Negative"
            | x -> x == 0 => "Zero"
            | x -> x > 0 && x < 10 => "Single digit"
            | x -> x >= 10 && x < 100 => "Double digit"
            | _ => "Large number"
    }
    
    io.print("Number 42 is: $(classify_number(42))\n")
}

// ==========================================
// 2. Memory Management & Smart Pointers
// ==========================================

demonstrate_memory_management: () void = {
    io.print("\n=== Memory Management Demo ===\n")
    
    // Using Ptr<T> instead of raw pointers
    allocate_int: () Ptr<i32> = {
        ptr := Ptr<i32>::new(42)
        io.print("Allocated value: $(ptr.value)\n")
        io.print("Address: $(ptr.address)\n")
        ptr
    }
    
    // Reference counting
    SharedData: {
        value: i32,
        refs: Atomic<u32>
    }
    
    SharedData::create: (val: i32) Ptr<SharedData> = {
        data := Ptr<SharedData>::new(SharedData{
            value: val,
            refs: Atomic<u32>::new(1)
        })
        data
    }
    
    SharedData::retain: (self) void = {
        self.refs.fetch_add(1, .SeqCst)
    }
    
    SharedData::release: (self) void = {
        old_refs := self.refs.fetch_sub(1, .SeqCst)
        old_refs == 1 ? {
            io.print("Freeing shared data with value: $(self.value)\n")
            // Memory would be freed here
        }
    }
    
    // RAII with defer
    use_resource: () void = {
        resource := SharedData::create(100)
        defer resource.release()
        
        io.print("Using resource with value: $(resource.value.value)\n")
        // Resource automatically released when scope ends
    }
    
    use_resource()
}

// ==========================================
// 3. Behaviors (Traits/Interfaces)
// ==========================================

Printable: behavior {
    format: (self) string
}

Comparable<T>: behavior {
    compare: (self, other: T) i32
}

Person: {
    name: string,
    age: u32
}

Person::format: (self) string = {
    "Person { name: $(self.name), age: $(self.age) }"
}

Person::compare: (self, other: Person) i32 = {
    self.age < other.age ? | true => -1
                          | false => {
        self.age > other.age ? | true => 1
                              | false => 0
    }
}

demonstrate_behaviors: () void = {
    io.print("\n=== Behaviors Demo ===\n")
    
    alice := Person{ name: "Alice", age: 30 }
    bob := Person{ name: "Bob", age: 25 }
    
    io.print("$(alice.format())\n")
    io.print("$(bob.format())\n")
    
    comparison := alice.compare(bob)
    comparison ? | -1 => io.print("$(alice.name) is younger than $(bob.name)\n")
                 | 0 => io.print("$(alice.name) and $(bob.name) are the same age\n")
                 | 1 => io.print("$(alice.name) is older than $(bob.name)\n")
                 | _ => {}
}

// ==========================================
// 4. Comptime - Compile-Time Evaluation
// ==========================================

demonstrate_comptime: () void = {
    io.print("\n=== Comptime Demo ===\n")
    
    // Compile-time computed lookup table
    FIBONACCI_TABLE := comptime {
        table:: [20, u64]
        table[0] = 0
        table[1] = 1
        (2..20).loop((i) => {
            table[i] = table[i-1] + table[i-2]
        })
        table
    }
    
    io.print("10th Fibonacci number (from comptime table): $(FIBONACCI_TABLE[10])\n")
    
    // Platform-specific constants
    MAX_PATH := comptime {
        @std.target.os ?
            | .windows => 260
            | .linux => 4096
            | .macos => 1024
            | _ => 256
    }
    
    io.print("Maximum path length on this platform: $(MAX_PATH)\n")
    
    // Type generation at compile time
    comptime {
        WORD_SIZE := @std.target.pointer_size
        WORD_SIZE == 8 ? {
            NativeInt := i64
            NativeUInt := u64
        } : {
            NativeInt := i32
            NativeUInt := u32
        }
    }
}

// ==========================================
// 5. Colorless Async & Concurrency
// ==========================================

demonstrate_async: () void = {
    io.print("\n=== Colorless Async Demo ===\n")
    
    // Same function works sync or async based on allocator
    fetch_data: (url: string, alloc: Ptr<Allocator>) Result<string, string> = {
        // Allocator determines if this runs sync or async
        connection := net.connect(url, alloc)?
        defer connection.close()
        
        data := connection.read_all(alloc)?
        Ok(data)
    }
    
    // Channel communication
    process_items: () void = {
        chan := Channel<i32>::new(10)
        
        // Producer
        producer: () void = {
            (0..5).loop((i) => {
                chan.send(i)
                io.print("Sent: $(i)\n")
            })
            chan.close()
        }
        
        // Consumer
        consumer: () void = {
            loop {
                item := chan.receive()
                item ? | .Some -> val => io.print("Received: $(val)\n")
                       | .None => break
            }
        }
        
        // Run concurrently (in real implementation)
        producer()
        consumer()
    }
    
    // Atomic operations
    counter := Atomic<u64>::new(0)
    
    increment_counter: () void = {
        (0..10).loop((_) => {
            old := counter.fetch_add(1, .SeqCst)
            io.print("Counter incremented from $(old) to $(old + 1)\n")
        })
    }
    
    io.print("Final counter value: $(counter.load(.SeqCst))\n")
}

// ==========================================
// 6. UFCS - Uniform Function Call Syntax
// ==========================================

// Free functions that can be called as methods
square: (x: i32) i32 = { x * x }
double: (x: i32) i32 = { x * 2 }
is_even: (x: i32) bool = { x % 2 == 0 }

demonstrate_ufcs: () void = {
    io.print("\n=== UFCS Demo ===\n")
    
    value := 5
    
    // Method-style calls on primitive types
    squared := value.square()
    doubled := value.double()
    even := value.is_even()
    
    io.print("Value: $(value)\n")
    io.print("Squared: $(squared)\n")
    io.print("Doubled: $(doubled)\n")
    io.print("Is even: $(even)\n")
    
    // Chaining
    result := value
        .double()      // 10
        .square()      // 100
        .double()      // 200
    
    io.print("Chained result: $(result)\n")
}

// ==========================================
// 7. Error Handling Without Exceptions
// ==========================================

demonstrate_error_handling: () void = {
    io.print("\n=== Error Handling Demo ===\n")
    
    // File operations with Result types
    read_config: (path: string) Result<string, string> = {
        file := fs.open(path)?
        defer file.close()
        
        content := file.read_all()?
        Ok(content)
    }
    
    // Chain operations with ?
    process_config: (path: string) Result<void, string> = {
        content := read_config(path)?
        lines := content.split('\n')
        
        lines.loop((line) => {
            line.is_empty() ? | true => continue
            
            parts := line.split('=')
            parts.len() == 2 ? 
                | true => io.print("Config: $(parts[0]) = $(parts[1])\n")
                | false => {}
        })
        
        Ok(void)
    }
    
    result := process_config("config.ini")
    result ? | .Ok -> _ => io.print("✓ Config processed successfully\n")
             | .Err -> e => io.print("✗ Error: $(e)\n")
}

// ==========================================
// 8. String Interpolation
// ==========================================

demonstrate_string_interpolation: () void = {
    io.print("\n=== String Interpolation Demo ===\n")
    
    name := "Zen"
    version := 1.1
    users := 1000
    
    // Basic interpolation
    message := "Welcome to $(name) v$(version)!"
    io.print("$(message)\n")
    
    // Expression interpolation
    stats := "$(name) has $(users) users, averaging $(users / 10) per category"
    io.print("$(stats)\n")
    
    // Nested interpolation
    format_user: (name: string, id: u32) string = {
        "User[id=$(id), name=\"$(name)\"]"
    }
    
    user_info := format_user("Alice", 42)
    io.print("Created: $(user_info)\n")
}

// ==========================================
// 9. Loop Patterns
// ==========================================

demonstrate_loops: () void = {
    io.print("\n=== Loop Patterns Demo ===\n")
    
    // Infinite loop with break
    counter ::= 0
    loop {
        counter = counter + 1
        counter >= 5 ? | true => break
        io.print("Infinite loop iteration: $(counter)\n")
    }
    
    // Conditional loop
    x ::= 10
    loop (x > 0) {
        io.print("Conditional loop: x = $(x)\n")
        x = x - 2
    }
    
    // Range iteration
    (1..=3).loop((i) => {
        io.print("Range iteration: $(i)\n")
    })
    
    // Collection iteration
    items := vec![10, 20, 30]
    items.loop((item) => {
        io.print("Item: $(item)\n")
    })
    
    // Enumerated iteration
    items.enumerate().loop((i, item) => {
        io.print("Item $(i): $(item)\n")
    })
    
    // Iterator chaining
    numbers := vec![1, 2, 3, 4, 5]
    sum := numbers
        .filter((n) => n % 2 == 0)
        .map((n) => n * n)
        .reduce(0, (acc, n) => acc + n)
    
    io.print("Sum of squares of even numbers: $(sum)\n")
}

// ==========================================
// Main Entry Point
// ==========================================

main: () void = {
    io.print("\n")
    io.print("╔══════════════════════════════════════╗\n")
    io.print("║    Zenlang Comprehensive Demo       ║\n")
    io.print("║    Language Version: 1.1.0          ║\n")
    io.print("╚══════════════════════════════════════╝\n")
    
    demonstrate_pattern_matching()
    demonstrate_memory_management()
    demonstrate_behaviors()
    demonstrate_comptime()
    demonstrate_async()
    demonstrate_ufcs()
    demonstrate_error_handling()
    demonstrate_string_interpolation()
    demonstrate_loops()
    
    io.print("\n")
    io.print("╔══════════════════════════════════════╗\n")
    io.print("║         Demo Complete! 🎉           ║\n")
    io.print("║                                      ║\n")
    io.print("║  Key Takeaways:                      ║\n")
    io.print("║  • No if/else/match - just ?        ║\n")
    io.print("║  • No exceptions - Result/Option    ║\n")
    io.print("║  • No null - Option<T>              ║\n")
    io.print("║  • No raw pointers - Ptr<T>         ║\n")
    io.print("║  • No async/await - colorless       ║\n")
    io.print("║  • Pattern matching everywhere      ║\n")
    io.print("╚══════════════════════════════════════╝\n")
    io.print("\n")
}