// FFI (Foreign Function Interface) Demonstration
// Shows how to interface with C libraries

{ io, ffi } = @std

// External C function declarations
extern "C" {
    // From libc
    malloc = (size: usize) RawPtr<void>
    free = (ptr: RawPtr<void>) void
    memcpy = (dest: RawPtr<void>, src: RawPtr<void>, n: usize) RawPtr<void>
    strlen = (s: RawPtr<u8>) usize
    printf = (format: RawPtr<u8>, ...) i32
    
    // Math functions
    sin = (x: f64) f64
    cos = (x: f64) f64
    sqrt = (x: f64) f64
    pow = (base: f64, exp: f64) f64
}

CPoint: {
    x: f32,
    y: f32,
}

// Wrapper for safe FFI calls
SafeFFI: {
    // Wrap malloc/free with Zen memory safety
    alloc = (size: usize) Result<Ptr<void>, string> {
        ptr = malloc(size)
        ptr == .None ?
            | true { .Err("Allocation failed") }
            | false { .Ok(Ptr<void>.from_raw(ptr)) }
    }
    
    dealloc = (ptr: Ptr<void>) void {
        free(ptr.raw())
    }
    
    // Safe string operations
    c_string_len = (s: string) usize {
        strlen(s.as_ptr())
    }
    
    // Math wrappers
    compute_distance = (p1: CPoint, p2: CPoint) f64 {
        dx = (p2.x - p1.x) as f64
        dy = (p2.y - p1.y) as f64
        sqrt(dx * dx + dy * dy)
    }
}

// Demonstrate FFI usage
call_c_function = () string {
    ffi = SafeFFI{}
    
    // Allocate memory using C malloc
    buffer = ffi.alloc(256)
    @this.defer(buffer ?
        | .Ok(ptr) { ffi.dealloc(ptr) }
        | .Err(_) { })
    
    // Use C math functions
    angle = 45.0
    radians = angle * 3.14159 / 180.0
    sine = sin(radians)
    cosine = cos(radians)
    
    // Create C-compatible struct
    origin = CPoint{ x: 0.0, y: 0.0 }
    point = CPoint{ x: 3.0, y: 4.0 }
    distance = ffi.compute_distance(origin, point)
    
    result = "FFI: sin(45°)=" + sine + ", cos(45°)=" + cosine + ", distance=" + distance
    result
}

// Callback function that can be passed to C
zen_callback = (value: i32) i32 {
    @std.io.println("Callback called from C with value: " + value)
    value * 2
}

// Example of wrapping a C library
CLibWrapper: {
    handle: RawPtr<void>,
    
    // Load dynamic library
    load = (path: string) Result<CLibWrapper, string> {
        handle = ffi.dlopen(path, ffi.RTLD_LAZY)
        handle == .None ?
            | true { .Err("Failed to load library") }
            | false { .Ok(CLibWrapper{ handle: handle }) }
    }
    
    // Get function pointer
    get_symbol<T> = (self: CLibWrapper, name: string) Result<T, string> {
        sym = ffi.dlsym(self.handle, name)
        sym == .None ?
            | true { .Err("Symbol not found: " + name) }
            | false { .Ok(ffi.cast<T>(sym)) }
    }
    
    // Close library
    close = (self: CLibWrapper) void {
        ffi.dlclose(self.handle)
    }
}

// Example: Using a custom C library
use_custom_library = () Result<void, string> {
    lib = CLibWrapper.load("./libcustom.so").raise()
    @this.defer(lib.close())
    
    // Get function from library
    custom_func = lib.get_symbol<(i32, i32) i32>("add_numbers").raise()
    
    // Call the function
    result = custom_func(10, 20)
    @std.io.println("Custom library result: " + result)
    
    .Ok(void)
}

// Export the main demo function
demonstrate_ffi = () void {
    // Call C functions
    result = call_c_function()
    io.println("  " + result)
    
    // Try to use a custom library (may fail if not present)
    custom_result = use_custom_library()
    custom_result ?
        | .Ok(_) { io.println("  Custom library demo successful") }
        | .Err(msg) { io.println("  Custom library demo skipped: " + msg) }
}