// Library module with reusable functions and types

io = @std
math = @std

// Public API exports
@export {
    fibonacci,
    factorial,
    Vector2D,
    Matrix2x2,
    Result,
    Option,
}

// Mathematical functions
fibonacci = (n: i32) i32 {
    n <= 1 ?
        | true { n }
        | false { fibonacci(n - 1) + fibonacci(n - 2) }
}

factorial = (n: i32) i32 {
    n <= 1 ?
        | true { 1 }
        | false { n * factorial(n - 1) }
}

// Generic Result type for error handling
Result<T, E>: .Ok(T) | .Err(E)

// Generic Option type for nullable values
Option<T>: .Some(T) | .None

// Vector mathematics
Vector2D: {
    x: f64,
    y: f64,
}

Vector2D.new = (x: f64, y: f64) Vector2D {
    Vector2D { x: x, y: y }
}

// Vector addition
Vector2D.add = (self: Vector2D, other: Vector2D) Vector2D {
    Vector2D {
        x: self.x + other.x,
        y: self.y + other.y,
    }
}

// Vector subtraction
Vector2D.sub = (self: Vector2D, other: Vector2D) Vector2D {
    Vector2D {
        x: self.x - other.x,
        y: self.y - other.y,
    }
}

// Scalar multiplication
Vector2D.scale = (self: Vector2D, scalar: f64) Vector2D {
    Vector2D {
        x: self.x * scalar,
        y: self.y * scalar,
    }
}

// Dot product
Vector2D.dot = (self: Vector2D, other: Vector2D) f64 {
    self.x * other.x + self.y * other.y
}

// Magnitude
Vector2D.magnitude = (self: Vector2D) f64 {
    @std.math.sqrt(self.x * self.x + self.y * self.y)
}

// Normalize
Vector2D.normalize = (self: Vector2D) Vector2D {
    mag = self.magnitude()
    mag == 0.0 ?
        | true { self }
        | false { self.scale(1.0 / mag) }
}

// Angle between vectors
Vector2D.angle_to = (self: Vector2D, other: Vector2D) f64 {
    dot_product = self.dot(other)
    mag_product = self.magnitude() * other.magnitude()
    mag_product == 0.0 ?
        | true { 0.0 }
        | false { @std.math.acos(dot_product / mag_product) }
}

// Matrix operations
Matrix2x2: {
    m00: f64, m01: f64,
    m10: f64, m11: f64,
}

// Identity matrix
Matrix2x2.identity = () Matrix2x2 {
    Matrix2x2 {
        m00: 1.0, m01: 0.0,
        m10: 0.0, m11: 1.0,
    }
}

// Matrix multiplication
Matrix2x2.multiply = (self: Matrix2x2, other: Matrix2x2) Matrix2x2 {
    Matrix2x2 {
        m00: self.m00 * other.m00 + self.m01 * other.m10,
        m01: self.m00 * other.m01 + self.m01 * other.m11,
        m10: self.m10 * other.m00 + self.m11 * other.m10,
        m11: self.m10 * other.m01 + self.m11 * other.m11,
    }
}

// Transform vector
Matrix2x2.transform = (self: Matrix2x2, vec: Vector2D) Vector2D {
    Vector2D {
        x: self.m00 * vec.x + self.m01 * vec.y,
        y: self.m10 * vec.x + self.m11 * vec.y,
    }
}

// Determinant
Matrix2x2.determinant = (self: Matrix2x2) f64 {
    self.m00 * self.m11 - self.m01 * self.m10
}

// Inverse
Matrix2x2.inverse = (self: Matrix2x2) Option<Matrix2x2> {
    det = self.determinant()
    det == 0.0 ?
        | true { .None }
        | false {
            inv_det = 1.0 / det
            .Some(Matrix2x2 {
                m00: self.m11 * inv_det,
                m01: -self.m01 * inv_det,
                m10: -self.m10 * inv_det,
                m11: self.m00 * inv_det,
            })
        }
}

// Rotation matrix
Matrix2x2.rotation = (angle: f64) Matrix2x2 {
    c = @stdh.cos(angle)
    s = @stdh.sin(angle)
    Matrix2x2 {
        m00: c, m01: -s,
        m10: s, m11: c,
    }
}

// Scale matrix
Matrix2x2.scale = (sx: f64, sy: f64) Matrix2x2 {
    Matrix2x2 {
        m00: sx, m01: 0.0,
        m10: 0.0, m11: sy,
    }
}

// Export the main demo function
run_demo = () void {
    io.println("Demonstrating library functions...")
    
    // Math functions
    io.println("  Fibonacci(10) = ${fibonacci(10)}")
    io.println("  Factorial(5) = ${factorial(5)}")
    
    // Vector operations
    v1 = Vector2D.new(3.0, 4.0)
    v2 = Vector2D.new(1.0, 2.0)
    
    v3 = v1.add(v2)
    io.println("  Vector addition: (${v3.x}, ${v3.y})")
    
    magnitude = v1.magnitude()
    io.println("  Vector magnitude: ${magnitude}")
    
    normalized = v1.normalize()
    io.println("  Normalized vector: (${normalized.x}, ${normalized.y})")
    
    // Matrix operations
    rotation_matrix = Matrix2x2.rotation(math.PI / 4.0)
    rotated = rotation_matrix.transform(v1)
    io.println("  Rotated vector: (${rotated.x}, ${rotated.y})")
    
    io.println("Library demo complete!")
}