// Advanced Pattern Matching Examples
// Demonstrates the full power of Zen's pattern matching

{ io } = @std.io

// Complex enum with multiple payload types
Message: .Text({content: string}) | .Number({value: i32}) | .Pair({first: i32, second: i32}) | .List({items: [i32]}) | .Nested({msg: Message}) | .Empty

// Pattern matching with guards and destructuring
process_message = (msg: Message) string {
    msg ?
        | .Text(content) { "Text: " + content }
        | .Number(value) when value > 100 { "Large number: " + value }
        | .Number(value) { "Small number: " + value }
        | .Pair(first, second) when first == second { "Equal pair: " + first }
        | .Pair(first, second) { "Pair: (" + first + ", " + second + ")" }
        | .List(items) when items.len() == 0 { "Empty list" }
        | .List(items) when items.len() == 1 { "Single item: " + items[0] }
        | .List(items) { "List with " + items.len() + " items" }
        | .Nested(inner) { "Nested: " + process_message(inner.msg) }
        | .Empty { "Empty message" }
}

// Tree structure for recursive patterns
Tree<T>: .Leaf({value: T}) | .Node({left: Tree<T>, right: Tree<T>})

// Sum all values in a tree
sum_tree = (tree: Tree<i32>) i32 {
    tree ?
        | .Leaf(data) { data.value }
        | .Node(data) { sum_tree(data.left) + sum_tree(data.right) }
}

// Find maximum depth of tree
tree_depth<T> = (tree: Tree<T>) i32 {
    tree ?
        | .Leaf(_) { 1 }
        | .Node(data) {
            left_depth = tree_depth(data.left)
            right_depth = tree_depth(data.right)
            1 + (left_depth > right_depth ?
                | true { left_depth }
                | false { right_depth })
        }
}

// Pattern matching with ranges
categorize_score = (score: i32) string {
    score ?
        | (0..60) { "F" }
        | (60..70) { "D" }
        | (70..80) { "C" }
        | (80..90) { "B" }
        | (90..101) { "A" }
        | _ { "Invalid score" }
}

// Slice patterns
analyze_array = (arr: [i32]) string {
    arr ?
        | [] { "Empty array" }
        | [single] { "Single element: " + single }
        | [first, second] { "Two elements: " + first + " and " + second }
        | [first, ..rest] { "First: " + first + ", rest has " + rest.len() + " items" }
        | [first, ..middle, last] { "First: " + first + ", last: " + last }
}

// Custom pattern matching with behaviors
Matchable<T>: {
    matches: (self, pattern: T) bool,
}

Point: {
    x: i32,
    y: i32,
}

Point.implements(Matchable<Point>, {
    matches = (self, pattern: Point) bool {
        (pattern.x == -1 || self.x == pattern.x) &&
        (pattern.y == -1 || self.y == pattern.y)
    },
})

// Use custom matching
find_points = (points: [Point], pattern: Point) [Point] {
    points.filter((p) bool { p.matches(pattern) })
}

// Pattern matching in function parameters
describe_pair = (point: Point) string {
    "Point at (" + point.x + ", " + point.y + ")"
}

// Nested pattern matching
Shape: .Circle({center: Point, radius: f32}) | .Rectangle({top_left: Point, bottom_right: Point}) | .Polygon({vertices: [Point]})

describe_shape = (shape: Shape) string {
    shape ?
        | .Circle(data) { 
            "Circle at (" + data.center.x + ", " + data.center.y + ") with radius " + data.radius
        }
        | .Rectangle(data) {
            "Rectangle from (" + data.top_left.x + ", " + data.top_left.y + ") to (" + data.bottom_right.x + ", " + data.bottom_right.y + ")"
        }
        | .Polygon(data) when data.vertices.len() == 3 { "Triangle" }
        | .Polygon(data) when data.vertices.len() == 4 { "Quadrilateral" }
        | .Polygon(data) { "Polygon with " + data.vertices.len() + " vertices" }
}

// Pattern matching with Option and Result
safe_divide = (a: i32, b: i32) Result<i32, string> {
    b == 0 ?
        | true { .Err("Division by zero") }
        | false { .Ok(a / b) }
}

chain_operations = (x: i32) Result<i32, string> {
    // Chain multiple operations with pattern matching
    result1 = safe_divide(x, 2)
    result1 ?
        | .Ok(val) {
            result2 = safe_divide(val + 10, 3)
            result2 ?
                | .Ok(val2) { .Ok(val2 * 2) }
                | .Err(e) { .Err(e) }
        }
        | .Err(e) { .Err(e) }
}

// Main demonstration function
demonstrate_patterns = () string {
    io.println("  Pattern matching demonstrations:")
    
    // Test message patterns
    msg1 = Message.Text({content: "Hello"})
    msg2 = Message.Number({value: 150})
    msg3 = Message.Nested({msg: Message.Empty})
    
    io.println("    " + process_message(msg1))
    io.println("    " + process_message(msg2))
    io.println("    " + process_message(msg3))
    
    // Test tree patterns
    tree = Tree<i32>.Node({
        left: Tree<i32>.Leaf({value: 5}),
        right: Tree<i32>.Node({
            left: Tree<i32>.Leaf({value: 3}),
            right: Tree<i32>.Leaf({value: 7})
        })
    })
    
    io.println("    Tree sum: " + sum_tree(tree))
    io.println("    Tree depth: " + tree_depth(tree))
    
    // Test score categorization
    io.println("    Score 85: " + categorize_score(85))
    io.println("    Score 72: " + categorize_score(72))
    
    "Pattern matching complete"
}

// Export the main demo function  
showcase_patterns = () void {
    result = demonstrate_patterns()
}