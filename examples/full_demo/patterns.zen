// Advanced Pattern Matching Examples
// Demonstrates the full power of Zen's pattern matching

io = @std

// Complex enum with multiple payload types
Message: Text: {content: string} | Number: {value: i32} | Pair: {first: i32, second: i32} | List: {items: [i32]} | Nested: {msg: Message} | Empty

// Pattern matching with guards and destructuring
process_message = (msg: Message) string {
    msg ?
        | Text(content) { "Text: " + content.content }
        | Number(value) {
            value.value > 100 ?
                | true { "Large number: " + value.value }
                | false { "Small number: " + value.value }
        }
        | Pair(pair) {
            pair.first == pair.second ?
                | true { "Equal pair: " + pair.first }
                | false { "Pair: (" + pair.first + ", " + pair.second + ")" }
        }
        | List(list) {
            list.items.len() == 0 ?
                | true { "Empty list" }
                | false {
                    list.items.len() == 1 ?
                        | true { "Single item: " + list.items[0] }
                        | false { "List with " + list.items.len() + " items" }
                }
        }
        | Nested(nested) { "Nested: " + process_message(nested.msg) }
        | Empty { "Empty message" }
}

// Tree structure for recursive patterns
Tree<T>: Leaf: {value: T} | Node: {left: Tree<T>, right: Tree<T>}

// Sum all values in a tree
sum_tree = (tree: Tree<i32>) i32 {
    tree ?
        | Leaf(leaf) { leaf.value }
        | Node(node) { sum_tree(node.left) + sum_tree(node.right) }
}

// Find maximum depth of tree
tree_depth<T> = (tree: Tree<T>) i32 {
    tree ?
        | Leaf(_) { 1 }
        | Node(node) {
            left_depth = tree_depth(node.left)
            right_depth = tree_depth(node.right)
            1 + (left_depth > right_depth ?
                | true { left_depth }
                | false { right_depth })
        }
}

// Pattern matching with ranges
categorize_score = (score: i32) string {
    score ?
        | (0..60) { "F" }
        | (60..70) { "D" }
        | (70..80) { "C" }
        | (80..90) { "B" }
        | (90..101) { "A" }
        | _ { "Invalid score" }
}

// Slice patterns
analyze_array = (arr: [i32]) string {
    arr ?
        | [] { "Empty array" }
        | [single] { "Single element: " + single }
        | [first, second] { "Two elements: " + first + " and " + second }
        | [first, ..rest] { "First: " + first + ", rest has " + rest.len() + " items" }
        | [first, ..middle, last] { "First: " + first + ", last: " + last }
}

// Custom pattern matching with behaviors
Matchable<T>: {
    matches: (self, pattern: T) bool,
}

Point: {
    x: i32,
    y: i32,
}

Point.implements(Matchable<Point>, {
    matches = (self, pattern: Point) bool {
        (pattern.x == -1 || self.x == pattern.x) &&
        (pattern.y == -1 || self.y == pattern.y)
    },
})

// Use custom matching
find_points = (points: [Point], pattern: Point) [Point] {
    points.filter((p) bool { p.matches(pattern) })
}

// Pattern matching in function parameters
describe_pair = (point: Point) string {
    "Point at (" + point.x + ", " + point.y + ")"
}

// Nested pattern matching
Shape: Circle: {center: Point, radius: f32} | Rectangle: {top_left: Point, bottom_right: Point} | Polygon: {vertices: [Point]}

describe_shape = (shape: Shape) string {
    shape ?
        | Circle(circle) { 
            "Circle at (" + circle.center.x + ", " + circle.center.y + ") with radius " + circle.radius
        }
        | Rectangle(rect) {
            "Rectangle from (" + rect.top_left.x + ", " + rect.top_left.y + ") to (" + rect.bottom_right.x + ", " + rect.bottom_right.y + ")"
        }
        | Polygon(poly) {
            poly.vertices.len() == 3 ?
                | true { "Triangle" }
                | false {
                    poly.vertices.len() == 4 ?
                        | true { "Quadrilateral" }
                        | false { "Polygon with " + poly.vertices.len() + " vertices" }
                }
        }
}

// Pattern matching with Option and Result
safe_divide = (a: i32, b: i32) Result<i32, string> {
    b == 0 ?
        | true { Err("Division by zero") }
        | false { Ok(a / b) }
}

chain_operations = (x: i32) Result<i32, string> {
    // Chain multiple operations with pattern matching
    result1 = safe_divide(x, 2)
    result1 ?
        | Ok(val) {
            result2 = safe_divide(val + 10, 3)
            result2 ?
                | Ok(val2) { Ok(val2 * 2) }
                | Err(e) { Err(e) }
        }
        | Err(e) { Err(e) }
}

// Main demonstration function
demonstrate_patterns = () string {
    io.println("  Pattern matching demonstrations:")
    
    // Test message patterns
    msg1 = Message.Text {content: "Hello"}
    msg2 = Message.Number {value: 150}
    msg3 = Message.Nested {msg: Message.Empty}
    
    io.println("    " + process_message(msg1))
    io.println("    " + process_message(msg2))
    io.println("    " + process_message(msg3))
    
    // Test tree patterns
    tree = Tree<i32>.Node {
        left: Tree<i32>.Leaf {value: 5},
        right: Tree<i32>.Node {
            left: Tree<i32>.Leaf {value: 3},
            right: Tree<i32>.Leaf {value: 7}
        }
    }
    
    io.println("    Tree sum: " + sum_tree(tree))
    io.println("    Tree depth: " + tree_depth(tree))
    
    // Test score categorization
    io.println("    Score 85: " + categorize_score(85))
    io.println("    Score 72: " + categorize_score(72))
    
    "Pattern matching complete"
}

// Export the main demo function  
showcase_patterns = () void {
    result = demonstrate_patterns()
}