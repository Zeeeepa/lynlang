// Advanced Pattern Matching Examples
// Demonstrates the full power of Zen's pattern matching

io := @std.io

// Complex enum with multiple payload types
 Message =
    | Text: {content: string},
    | Number: {value: i32},
    | Pair: {first: i32, second: i32},
    | List: {items: [i32]},
    | Nested: {msg: Message},
    |Empty

// Pattern matching with guards and destructuring
process_message = (msg: Message) string {
    msg ?
        | .Text -> (content) => "Text: " + content
        | .Number -> (value) -> value > 100 => "Large number: " + value
        | .Number -> (value) => "Small number: " + value
        | .Pair -> (first, second) -> first == second => "Equal pair: " + first
        | .Pair -> (first, second) => "Pair: (" + first + ", " + second + ")"
        | .List -> (items) -> items.len() == 0 => "Empty list"
        | .List -> (items) -> items.len() == 1 => "Single item: " + items[0]
        | .List -> (items) => "List with " + items.len() + " items"
        | .Nested -> (msg: inner) => "Nested: " + process_message(inner)
        | .Empty => "Empty message"
};

// Tree structure for recursive patterns
Tree<T>: |
    Leaf -> {value: T}
    | Node -> {left: Tree<T>, right: Tree<T>}

// Sum all values in a tree
sum_tree = (tree: Tree<i32>) i32 {
    tree ?
        | .Leaf -> (value) => value
        | .Node -> (left, right) => sum_tree(left) + sum_tree(right)
};

// Find maximum depth of tree
tree_depth<T> = (tree: Tree<T>) i32 {
    tree ?
        | .Leaf -> _ => 1
        | .Node -> (left, right) => {
            left_depth := tree_depth(left);
            right_depth := tree_depth(right);
            1 + (left_depth > right_depth ? | true => left_depth | false => right_depth)
        }
};

// Pattern matching with ranges
categorize_score = (score: i32) string {
    score ?
        | 0..=59 => "F"
        | 60..=69 => "D"
        | 70..=79 => "C"
        | 80..=89 => "B"
        | 90..=100 => "A"
        | _ => "Invalid score"
};

// Slice patterns
analyze_array = (arr: [i32]) string {
    arr ?
        | [] => "Empty array"
        | [single] => "Single element: " + single
        | [first, second] => "Two elements: " + first + " and " + second
        | [first, ..rest] => "First: " + first + ", rest has " + rest.len() + " items"
        | [first, ..middle, last] => "First: " + first + ", last: " + last
};

// Custom pattern matching with behaviors
behavior Matchable<T> {
    matches = (self: Self, pattern: T) bool;
}

Point: {
    x: i32,
    y: i32,
}

impl Matchable<Point> for Point {
    matches = (self: Self, pattern: Point) bool {
        pattern.x == -1 || self.x == pattern.x &&
        pattern.y == -1 || self.y == pattern.y
    };
}

// Use custom matching
find_points = (points: [Point], pattern: Point) [Point] {
    points.filter((p) => p.matches(pattern))
};

// Pattern matching in function parameters
describe_pair = ({x, y}: Point) string {
    "Point at (" + x + ", " + y + ")"
};

// Nested pattern matching
Shape: |
    Circle -> {center: Point, radius: f32}
    | Rectangle -> {top_left: Point, bottom_right: Point}
    | Polygon -> {vertices: [Point]}

describe_shape = (shape: Shape) string {
    shape ?
        | .Circle -> (center: {x, y}, radius) => 
            "Circle at (" + x + ", " + y + ") with radius " + radius
        | .Rectangle -> (top_left: {x: x1, y: y1}, bottom_right: {x: x2, y: y2}) =>
            "Rectangle from (" + x1 + ", " + y1 + ") to (" + x2 + ", " + y2 + ")"
        | .Polygon -> (vertices) -> vertices.len() == 3 => "Triangle"
        | .Polygon -> (vertices) -> vertices.len() == 4 => "Quadrilateral"
        | .Polygon -> (vertices) => "Polygon with " + vertices.len() + " vertices"
};

// Pattern matching with Option and Result
safe_divide = (a: i32, b: i32) Result<i32, string> {
    b == 0 ?
        | true => .Err -> "Division by zero"
        | false => .Ok -> (a / b)
};

chain_operations = (x: i32) Result<i32, string> {
    // Chain multiple operations with pattern matching
    result1 := safe_divide(x, 2);
    result1 ?
        | .Ok -> val => {
            result2 := safe_divide(val + 10, 3);
            result2 ?
                | .Ok -> val2 => .Ok -> (val2 * 2)
                | .Err -> e => .Err -> e
        }
        | .Err -> e => .Err -> e
};

// Main demonstration function
demonstrate_patterns = () string {
    io.println("  Pattern matching demonstrations:");
    
    // Test message patterns
    msg1 := Message::Text -> {content: "Hello"};
    msg2 := Message::Number -> {value: 150};
    msg3 := Message::Nested -> {msg: Message::Empty};
    
    io.println("    " + process_message(msg1));
    io.println("    " + process_message(msg2));
    io.println("    " + process_message(msg3));
    
    // Test tree patterns
    tree := Tree<i32>::Node -> {
        left: Tree<i32>::Leaf -> {value: 5},
        right: Tree<i32>::Node -> {
            left: Tree<i32>::Leaf -> {value: 3},
            right: Tree<i32>::Leaf -> {value: 7}
        }
    };
    
    io.println("    Tree sum: " + sum_tree(tree));
    io.println("    Tree depth: " + tree_depth(tree));
    
    // Test score categorization
    io.println("    Score 85: " + categorize_score(85));
    io.println("    Score 72: " + categorize_score(72));
    
    "Pattern matching complete"
};

// Export the main demo function  
showcase_patterns = () void {
    result := demonstrate_patterns()
}