// Complete Error Handling Example - NO try keyword, NO async keyword!
// This demonstrates Zenlang's approach: errors as values with ? operator

{ io } = @std
{ fs } = @std
{ json } = @std
{ http } = @std

// Custom error types - errors are just values
AppError: FileError: {path: String, cause: fs.Error} | ParseError: {message: String} | NetworkError: {url: String, status: u32} | ValidationError: {fields: DynVec<String>} | DatabaseError: {query: String, cause: String} | BusinessLogicError: {rule: String}

// Result type for our operations
AppResult<T>: Result<T, AppError>

// Configuration structure
Config: {
    database_url: String
    api_key: String
    port: u16
    max_connections: u32
}

// User model
User: {
    id: u64
    name: String
    email: String
    age: u32
}

// NO try keyword! Use ? operator to bubble errors
load_config = (path: String) AppResult<Config>  {
    // Read file - ? bubbles up any fs.Error
    content := fs.read_file(path)
        .map_err((e) { AppError.FileError{path: path, cause: e} }).raise()
    
    // Parse JSON - ? bubbles up parse errors
    data := json.parse(content)
        .map_err((e) { AppError.ParseError{message: e.to_string()} }).raise()
    
    // Extract fields with validation
    config := Config{
        database_url: data.get("database_url")
            Ok_or(AppError.ValidationError(["database_url required"]))?
            .as_string()
            Ok_or(AppError.ValidationError(["database_url must be string"]))?,
        
        api_key: data.get("api_key")
            Ok_or(AppError.ValidationError(["api_key required"]))?
            .as_string()
            Ok_or(AppError.ValidationError(["api_key must be string"]))?,
        
        port: data.get("port")
            Ok_or(AppError.ValidationError(["port required"]))?
            .as_u16()
            Ok_or(AppError.ValidationError(["port must be number"]))?,
        
        max_connections: data.get("max_connections")
            .unwrap_or(json.Value.Number(10))
            .as_u32()
            .unwrap_or(10)
    }
    
    Ok(config)
}

// Validate user - collect multiple errors
validate_user = (user: User) AppResult<User>  {
    errors ::= DynVec<String>()
    
    // Check name
    user.name.len() < 2 ?
        | true { errors.push("name too short") }
        | false {}
    
    user.name.len() > 100 ?
        | true { errors.push("name too long") }
        | false {}
    
    // Check email
    user.email.contains("@") ?
        | false { errors.push("invalid email format") }
        | true {}
    
    // Check age
    user.age < 13 ?
        | true { errors.push("user too young") }
        | false {}
    
    user.age > 150 ?
        | true { errors.push("invalid age") }
        | false {}
    
    // Return error if validation failed
    errors.is_empty() ?
        | true { Ok(user) }
        | false { Err(AppError.ValidationError{fields: errors}) }
}

// Database operations with error bubbling
// NO async keyword - use allocator for concurrency!
fetch_user = (id: u64, db: Database, alloc: Ptr<Allocator>) AppResult<User>  {
    query := "SELECT * FROM users WHERE id = ?"
    
    // Execute query - errors bubble with ?
    result := db.query(query, [id], alloc)
        .map_err((e) => AppError.DatabaseError(query, e.to_string()))?
    
    // Check if user exists
    result.rows.is_empty() ?
        | true { Err(AppError.BusinessLogicError("User not found")) }
        | false {
            row := result.rows[0]
            user := User{
                id: row.get("id").as_u64()?,
                name: row.get("name").as_string()?,
                email: row.get("email").as_string()?,
                age: row.get("age").as_u32()?
            }
            Ok(user)
        }
}

// HTTP operations - NO async fn! Allocator determines sync/async
fetch_external_data = (url: String, alloc: Ptr<Allocator>) AppResult<json.Value>  {
    // Make HTTP request - allocator controls execution mode
    response := http.get(url, alloc)
        .map_err((e) => AppError.NetworkError(url, 0))?
    
    // Check status code
    response.status >= 200 && response.status < 300 ?
        | true {
            // Parse response body
            json.parse(response.body)
                .map_err((e) => AppError.ParseError("Invalid JSON from API"))
        }
        | false { Err(AppError.NetworkError(url, response.status)) }
}

// Complex operation with multiple error sources
process_user_request: (
    user_id: u64, 
    action: String,
    db: Database,
    alloc: Ptr<Allocator>
) AppResult<String> = {
    // Fetch user - bubbles database errors
    user := fetch_user(user_id, db, alloc)?
    
    // Validate user - bubbles validation errors
    validated_user := validate_user(user)?
    
    // Process action with pattern matching
    result := action ?
        | "profile" {
            // Fetch additional data
            profile_data := fetch_external_data(
                "https://api.example.com/profile/" + user_id.to_string(),
                alloc
            )?
            Ok("Profile: " + profile_data.to_string())
        }
        | "delete" {
            // Check permissions
            validated_user.age >= 18 ?
                | true {
                    db.execute("DELETE FROM users WHERE id = ?", [user_id], alloc)
                        .map_err((e) => AppError.DatabaseError("delete", e.to_string()))?
                    Ok("User deleted")
                }
                | false { Err(AppError.BusinessLogicError("Cannot delete minor account")) }
        }
        | "update" -> new_data {
            // Parse and update
            updates := json.parse(new_data)
                .map_err((e) => AppError.ParseError("Invalid update data"))?
            
            db.execute(
                "UPDATE users SET data = ? WHERE id = ?",
                [updates.to_string(), user_id.to_string()],
                alloc
            ).map_err((e) => AppError.DatabaseError("update", e.to_string()))?
            
            Ok("User updated")
        }
        | _ { Err(AppError.BusinessLogicError("Unknown action: " + action)) }
    
    result
}

// Error recovery with fallback
resilient_config_load = (primary: String, fallback: String) AppResult<Config>  {
    // Try primary config
    load_config(primary) ?
        | Ok -> config { Ok(config) }
        | Err -> e {
            // Log the error
            io.println("Primary config failed: $(e), trying fallback...")
            
            // Try fallback - this error bubbles if it fails too
            load_config(fallback)
        }
}

// Batch processing with error collection
process_batch = (users: DynVec<User>, db: Database, alloc: Ptr<Allocator>) (DynVec<User>, DynVec<AppError>)  {
    successes ::= DynVec<User>(alloc)
    failures ::= DynVec<AppError>(alloc)
    
    users.loop((user) {
        // Process each user, collecting errors
        validate_user(user) ?
            | Ok -> valid {
                // Save to database
                save_result := db.insert("users", valid, alloc)
                save_result ?
                    | Ok -> _ { successes.push(valid) }
                    | Err -> e { failures.push( }
                        AppError.DatabaseError("insert", e.to_string())
                    )
            }
            | Err -> e { failures.push(e) }
    }
    
    (successes, failures)
}

// Main application - NO async keyword!
main = () void  {
    // Choose allocator based on environment
    alloc := @debug ?
        | true { SyncAllocator{ }}    // Sync for debugging
        | false { AsyncAllocator{ }}   // Concurrent for production
    
    // Load configuration with fallback
    config := resilient_config_load("config.json", "default.json") ?
        | Ok -> c { c }
        | Err -> e {
            io.println("Failed to load config: ${e}")
            io.println("Using defaults...")
            Config{
                database_url: "sqlite::memory:",
                api_key: "demo",
                port: 8080,
                max_connections: 10
            }
        }
    
    // Connect to database
    db := Database.connect(config.database_url, &alloc) ?
        | Ok -> conn { conn }
        | Err -> e {
            io.println("Database connection failed: $(e)")
            return
        }
    defer db.close()
    
    // Process a request
    result = process_user_request(123, "profile", db, alloc.ref())
    
    // Handle the result
    result ?
        | Ok(message) { io.println("Success: ${message}") }
        | Err(error) {
            // Pattern match on error types for specific handling
            error ?
                | FileError -> path, cause {  }
                    io.println("File error at $(path): $(cause)")
                | ParseError -> msg {  }
                    io.println("Parse error: $(msg)")
                | NetworkError -> url, status {  }
                    io.println("Network error from $(url): HTTP $(status)")
                | ValidationError -> fields {  }
                    io.println("Validation failed: $(fields.join(", "))")
                | DatabaseError -> query, cause {  }
                    io.println("Database error in query '$(query)': $(cause)")
                | BusinessLogicError -> rule {  }
                    io.println("Business rule violation: $(rule)")
        }
    
    // Batch processing example
    test_users := [
        User{ id: 1, name: "Alice", email: "alice@example.com", age: 25 },
        User{ id: 2, name: "B", email: "invalid", age: 200 },  // Will fail validation
        User{ id: 3, name: "Charlie", email: "charlie@example.com", age: 30 }
    ]
    
    (saved, errors) := process_batch(test_users, db, &alloc)
    io.println("Saved $(saved.len()) users, $(errors.len()) failures")
    
    // Report errors
    for err in errors {
        io.println("Batch error: $(err)")
    }
}

// Unit tests - always use sync allocator for determinism
test "config loading" {
    test_alloc := TestAllocator{}
    
    // Test missing file
    result := load_config("nonexistent.json")
    assert(result.is_err())
    
    // Test invalid JSON
    fs.write_file("invalid.json", "not json")
    result2 := load_config("invalid.json")
    assert(result2.is_err())
    
    // Test valid config
    valid_json := json.object({
        "database_url": "test://db",
        "api_key": "test123",
        "port": 3000
    })
    fs.write_file("valid.json", valid_json.to_string())
    result3 := load_config("valid.json")
    assert(result3.is_ok())
    
    // Cleanup
    fs.remove("invalid.json")
    fs.remove("valid.json")
}

test "user validation" {
    // Valid user
    valid := User{ id: 1, name: "Alice", email: "alice@test.com", age: 25 }
    assert(validate_user(valid).is_ok())
    
    // Invalid name
    invalid_name := User{ id: 2, name: "A", email: "test@test.com", age: 25 }
    result := validate_user(invalid_name)
    assert(result.is_err())
    
    // Invalid email
    invalid_email := User{ id: 3, name: "Bob", email: "notanemail", age: 25 }
    result2 := validate_user(invalid_email)
    assert(result2.is_err())
    
    // Multiple errors
    multiple := User{ id: 4, name: "B", email: "bad", age: 200 }
    result3 := validate_user(multiple)
    result3 ?
        | Err -> .ValidationError -> fields { assert(fields.len() == 3) }
        | _ { assert(false, "Should have validation errors") }
}

// This example demonstrates:
// 1. NO try keyword - we use ? operator for error propagation
// 2. NO async keyword - we use allocators for concurrency
// 3. Errors as values with Result<T, E>
// 4. Pattern matching for error handling
// 5. Error transformation with map_err
// 6. Error recovery with fallbacks
// 7. Batch error collection
// 8. Testing error paths