// Channel-Based Concurrency
// Communication between concurrent tasks

{ io } = @std
{ Channel, spawn, sleep_ms } = @std.concurrent

// Producer-consumer pattern
producer = (ch: Channel<i32>, id: u32) void {
    for i in 0..5 {
        ch.send(id * 100 + i)
        sleep_ms(100)
    }
}

consumer = (ch: Channel<i32>, id: u32) void {
    loop {
        ch.receive() ?
            | Some -> val {
                io.println("Consumer ${id} got: ${val}")
                sleep_ms(50)
            }
            | None { break }
    }
    io.println("Consumer ${id} done")
}

// Pipeline pattern
pipeline = () void {
    // Create channels for pipeline stages
    ch1 := Channel<i32>.new(10)
    ch2 := Channel<i32>.new(10)
    
    // Stage 1: Generate numbers
    spawn(() => {
        for i in 0..10 {
            ch1.send(i)
        }
        ch1.close()
    })
    
    // Stage 2: Square numbers
    spawn(() => {
        loop {
            ch1.receive() ?
                | Some -> n {
                    ch2.send(n * n)
                }
                | None {
                    ch2.close()
                    break
                }
        }
    })
    
    // Stage 3: Print results
    loop {
        ch2.receive() ?
            | Some -> n { io.println("Result: ${n}") }
            | None { break }
    }
}

// Fan-out/fan-in pattern
work_pool = () void {
    work := Channel<i32>.new(100)
    results := Channel<i32>.new(100)
    
    // Create workers
    for id in 0..3 {
        spawn(() => {
            loop {
                work.receive() ?
                    | Some -> job {
                        // Process job
                        result := job * 2
                        results.send(result)
                    }
                    | None { break }
            }
        })
    }
    
    // Send work
    spawn(() => {
        for i in 0..20 {
            work.send(i)
        }
        work.close()
    })
    
    // Collect results
    mut count := 0
    while count < 20 {
        results.receive() ?
            | Some -> r {
                io.println("Result: ${r}")
                count += 1
            }
            | None {}
    }
}

main = () void {
    io.println("=== Channel Concurrency ===")
    
    // Basic producer-consumer
    ch := Channel<i32>.new(5)
    
    spawn(() => producer(ch.clone(), 1))
    spawn(() => consumer(ch.clone(), 1))
    spawn(() => consumer(ch.clone(), 2))
    
    sleep_ms(2000)
    ch.close()
    sleep_ms(500)
    
    // Pipeline
    io.println("\n=== Pipeline ===")
    pipeline()
    
    // Work pool
    io.println("\n=== Work Pool ===")
    work_pool()
}