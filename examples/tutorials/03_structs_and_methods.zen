// Structs and Methods
// User-defined types with UFCS

{ io } = @std

// Basic struct
Person: {
    name: string,
    age: u32,
}

// Methods via UFCS (Uniform Function Call Syntax)
Person.new = (name: string, age: u32) Person {
    return Person { name, age }
}

Person.greet = (self) string {
    return "Hello, I'm ${self.name}, age ${self.age}"
}

Person.birthday = (self::) void {
    self.age += 1
}

// Generic struct
Pair<T>: {
    first: T,
    second: T,
}

Pair.swap = (self) Pair<T> {
    return Pair { first: self.second, second: self.first }
}

// Enum (sum type)
Status: |
    Active({ since: u32 })
    | Inactive
    | Pending({ until: u32 })

Status.describe = (self) string {
    self ?
        | Active({since}) { return "Active since year ${since}" }
        | Inactive { return "Currently inactive" }
        | Pending({until}) { return "Pending until year ${until}" }
}

main = () void {
    io.println("=== Structs & Methods ===")
    
    // Create and use structs
    alice = Person.new("Alice", 25)
    bob = Person { name: "Bob", age: 30 }
    
    io.println(alice.greet())
    io.println(bob.greet())
    
    // Mutable methods
    charlie ::= Person { name: "Charlie", age: 20 }
    charlie.birthday()
    io.println("After birthday: ${charlie.greet()}")
    
    // Generic types
    numbers = Pair { first: 10, second: 20 }
    swapped = numbers.swap()
    io.println("Swapped: ${swapped.first}, ${swapped.second}")
    
    // Enum pattern matching
    statuses = [
        Status.Active { since: 2020 },
        Status.Inactive,
        Status.Pending { until: 2025 },
    ]
    
    statuses.loop((status) {
        io.println(status.describe())
    })
}