// Math Utilities Module
{ maths } = @std

// Fibonacci number (iterative for efficiency)
fibonacci = (n: i32) i64 {
    n <= 1 ?
        | true { n as i64 }
        | false {
            a ::= 0i64
            b ::= 1i64
            range(2, n + 1).each(() => {
                next = a + b
                a = b
                b = next
            })
            b
        }
}

// Factorial with overflow protection
factorial = (n: i32) Result<i64, string> {
    n < 0 ?
        | true { Result.Err("Negative input") }
        | false {
            n > 20 ?
                | true { Result.Err("Too large (overflow)") }
                | false {
                    result ::= 1i64
                    range(1, n + 1).each((i) => result *= i as i64)
                    Result.Ok(result)
                }
        }
}

// Prime number check (optimized)
is_prime = (n: i32) bool {
    n <= 1 ?
        | true { false }
        | false {
            n == 2 ?
                | true { true }
                | false {
                    n % 2 == 0 ?
                        | true { false }
                        | false {
                            limit = maths.sqrt(n as f64) as i32
                            i ::= 3
                            (i <= limit).loop({
                                n % i == 0 ?
                                    | true { return false }
                                    | false { }
                                i += 2
                            })
                            true
                        }
                }
        }
}

// Greatest Common Divisor (Euclidean algorithm)
gcd = (a: i32, b: i32) i32 {
    b == 0 ?
        | true { a.abs() }
        | false { gcd(b, a % b) }
}

// Least Common Multiple
lcm = (a: i32, b: i32) i32 {
    a.abs() * b.abs() / gcd(a, b)
}

export { fibonacci, factorial, is_prime, gcd, lcm }