// build.zen - Build configuration for the full example
// Demonstrates the Zen build system with targets, dependencies, and OS detection

{ io, fs } = @std

// ============================================================================
// Build System Types (defined locally until module imports support types)
// ============================================================================

OptimizeMode:
    Debug,
    ReleaseFast,
    ReleaseSmall,
    ReleaseSafe

OsTag:
    Linux,
    Macos,
    Windows,
    Freebsd,
    Native

CpuArch:
    X86_64,
    Aarch64,
    Arm,
    Wasm32,
    Native

InstallDir:
    Bin,
    Lib,
    Include,
    Share

Target: {
    os_tag: OsTag,
    cpu_arch: CpuArch
}

Version: {
    major: i32,
    minor: i32,
    patch: i32
}

Executable: {
    name: StaticString,
    root_source_file: StaticString,
    optimize: OptimizeMode,
    strip: bool
}

StaticLibrary: {
    name: StaticString,
    root_source_file: StaticString,
    version: Version
}

Test: {
    name: StaticString,
    root_source_file: StaticString
}

Dependency: {
    name: StaticString,
    url: StaticString
}

Build: {
    optimize: OptimizeMode,
    strip: bool,
    enable_stack_traces: bool,
    target: Target,
    build_dir: StaticString,
    cache_dir: StaticString,
    install_prefix: StaticString
}

// ============================================================================
// Helper Functions
// ============================================================================

native_target = () Target {
    return Target {
        os_tag: OsTag.Native,
        cpu_arch: CpuArch.Native
    }
}

os_name = (t: Target) StaticString {
    t.os_tag ?
        | Linux { "linux" }
        | Macos { "macos" }
        | Windows { "windows" }
        | Freebsd { "freebsd" }
        | Native { "native" }
}

cpu_name = (t: Target) StaticString {
    t.cpu_arch ?
        | X86_64 { "x86_64" }
        | Aarch64 { "aarch64" }
        | Arm { "arm" }
        | Wasm32 { "wasm32" }
        | Native { "native" }
}

add_executable = (b: Build, name: StaticString, root: StaticString) Executable {
    io.println("  Adding executable: ${name}")
    // Check if source file exists
    fs.exists(root) ?
        | true { io.println("    Source file found: ${root}") }
        | false { io.println("    WARNING: Source file not found: ${root}") }
    return Executable {
        name: name,
        root_source_file: root,
        optimize: b.optimize,
        strip: b.strip
    }
}

add_test = (b: Build, root: StaticString) Test {
    io.println("  Adding test: ${root}")
    return Test {
        name: root,
        root_source_file: root
    }
}

add_static_library = (b: Build, name: StaticString, root: StaticString, ver: Version) StaticLibrary {
    io.println("  Adding static library: ${name}")
    return StaticLibrary {
        name: name,
        root_source_file: root,
        version: ver
    }
}

add_dependency = (b: Build, name: StaticString, url: StaticString) Dependency {
    io.println("  Adding dependency: ${name} from ${url}")
    return Dependency { name: name, url: url }
}

link_system_library = (exe: Executable, lib: StaticString) void {
    io.println("    Linking system library: ${lib}")
}

link_framework = (exe: Executable, framework: StaticString) void {
    io.println("    Linking framework: ${framework}")
}

add_library_path = (exe: Executable, path: StaticString) void {
    io.println("    Adding library path: ${path}")
}

define_symbol = (exe: Executable, name: StaticString, value: StaticString) void {
    io.println("    Defining symbol: ${name}=${value}")
}

install_artifact = (b: Build, exe: Executable) void {
    io.println("  Installing artifact: ${exe.name}")
}

install_library = (b: Build, lib: StaticLibrary) void {
    io.println("  Installing library: ${lib.name}")
}

install_file = (b: Build, src: StaticString, dest: StaticString) void {
    io.println("  Installing file: ${src} -> ${dest}")
}

get_install_path = (b: Build, dir: InstallDir, path: StaticString) StaticString {
    dir ?
        | Bin { "${b.install_prefix}/bin/${path}" }
        | Lib { "${b.install_prefix}/lib/${path}" }
        | Include { "${b.install_prefix}/include/${path}" }
        | Share { "${b.install_prefix}/share/${path}" }
}

// ============================================================================
// Build Configuration
// ============================================================================

configure = (is_release: bool) Build {
    io.println("Initializing build configuration...")

    // Create build directory
    fs.create_dir("build") ?
        | Ok(_) { io.println("  Created build/") }
        | Err(_) { io.println("  build/ exists") }

    is_release ?
        | true {
            io.println("Building in RELEASE mode")
            return Build {
                optimize: OptimizeMode.ReleaseFast,
                strip: true,
                enable_stack_traces: false,
                target: native_target(),
                build_dir: "build/",
                cache_dir: "build/cache/",
                install_prefix: "/usr/local"
            }
        }
        | false {
            io.println("Building in DEBUG mode")
            return Build {
                optimize: OptimizeMode.Debug,
                strip: false,
                enable_stack_traces: true,
                target: native_target(),
                build_dir: "build/",
                cache_dir: "build/cache/",
                install_prefix: "/usr/local"
            }
        }
}

setup_targets = (b: Build) void {
    io.println("\nConfiguring build targets...")

    // Create main executable
    exe = add_executable(b, "zen_demo", "main.zen")

    // Add test executable
    test_exe = add_test(b, "test.zen")

    // Add static library for utilities
    utils_lib = add_static_library(b, "zen_utils", "utils.zen", Version { major: 1, minor: 0, patch: 0 })

    // Add dependency
    sys_dep = add_dependency(b, "system", "system://libc")

    // OS-specific configuration
    io.println("\nOS-specific configuration:")
    b.target.os_tag ?
        | Linux {
            link_system_library(exe, "c")
            link_system_library(exe, "m")
            add_library_path(exe, "/usr/lib/x86_64-linux-gnu")
            io.println("  Linux: linked libc and libm")
        }
        | Macos {
            link_framework(exe, "Foundation")
            link_framework(exe, "CoreFoundation")
            add_library_path(exe, "/usr/lib")
            io.println("  macOS: linked Foundation frameworks")
        }
        | Windows {
            link_system_library(exe, "kernel32")
            link_system_library(exe, "user32")
            add_library_path(exe, "C:/Windows/System32")
            io.println("  Windows: linked system libraries")
        }
        | _ {
            link_system_library(exe, "c")
            io.println("  Generic: linked libc")
        }

    // Define compile-time symbols
    io.println("\nDefining symbols:")
    define_symbol(exe, "ZEN_VERSION", "1.0.0")
    define_symbol(exe, "ZEN_BUILD_DATE", "2024-01-01")

    // Install artifacts
    io.println("\nInstalling artifacts:")
    install_artifact(b, exe)
    install_library(b, utils_lib)

    // Install additional files
    include_path = get_install_path(b, InstallDir.Include, "zen_utils.zen")
    share_path = get_install_path(b, InstallDir.Share, "zen_demo/README.md")
    install_file(b, "utils.zen", include_path)
    install_file(b, "README.md", share_path)
}

// ============================================================================
// Build Commands
// ============================================================================

clean = () void {
    io.println("Cleaning build artifacts...")
    io.println("  Would remove: build/")
    io.println("  Would remove: output.c")
    io.println("  Would remove: output.ll")
    io.println("Clean complete!")
}

run_tests = () void {
    io.println("Running tests...")
    io.println("  Executing: test.zen")
    io.println("Tests complete!")
}

// ============================================================================
// Main Entry Point
// ============================================================================

main = () i32 {
    io.println("=== ZEN BUILD SYSTEM ===\n")

    // Configure build (debug mode by default)
    b = configure(false)

    // Show target info
    io.println("\nTarget: ${os_name(b.target)}-${cpu_name(b.target)}")

    // Setup all targets
    setup_targets(b)

    io.println("\n=== BUILD CONFIGURATION COMPLETE ===")

    return 0
}
