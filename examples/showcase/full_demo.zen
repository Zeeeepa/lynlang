// Zen Language - Complete Feature Showcase
// Demonstrates: No keywords • UFC • Pattern matching • Clean syntax

{ io, maths, Result, Option, Channel, spawn, inline, simd } = @std
{ MutPtr, Ptr, RawPtr } = @std

// ─── Variables & Types ───
showcase_basics = () void {
    io.println("\n◆ Variables & Types")
    
    language = "Zen"        // Immutable by default
    version ::= 1.0        // Mutable with ::=
    version += 0.1
    
    precise: f64 = maths.PI  // Optional type annotation
    io.println("  ${language} v${version:.1f}, π=${precise:.4f}")
}

// ─── Uniform Function Call ───
showcase_ufc = () void {
    io.println("\n◆ UFC - Everything Composes")
    
    double = (x: i32) i32 { x * 2 }
    square = (x: i32) i32 { x * x }
    
    result = 3.double().square()  // Any function as method
    io.println("  3 → double → square = ${result}")
}

// ─── Pattern Matching ───
showcase_patterns = () void {
    io.println("\n◆ Pattern Matching")
    
    Event: |
        Click { x: i32, y: i32 }
        | KeyPress(char)
        | Quit
    
    handle = (e: Event) void {
        io.print("  ")
        e ?
            | Click { x, y } { io.println("Click (${x},${y})") }
            | KeyPress(key) { io.println("Key '${key}'") }
            | Quit { io.println("Quit") }
    }
    
    handle(Event.Click { x: 10, y: 20 })
    handle(Event.KeyPress('Z'))
}

// ─── Error Handling ───
showcase_errors = () void {
    io.println("\n◆ Explicit Errors")
    
    safe_divide = (a: f64, b: f64) Result<f64, string> {
        b == 0 ?
            | true { Result.Err("Division by zero") }
            | false { Result.Ok(a / b) }
    }
    
    result = safe_divide(100, 10)
        .bind((x) => safe_divide(x, 2))
        .map((x) => x * maths.PI)
    
    result ?
        | Ok(val) { io.println("  100÷10÷2×π = ${val:.2f}") }
        | Err(msg) { io.println("  Error: ${msg}") }
}

// ─── Memory & Pointers ───
showcase_memory = () void {
    io.println("\n◆ Explicit Pointers")
    
    value = 42
    ptr: Ptr<i32> = Ptr.to(value)      // Immutable pointer
    
    data ::= [1, 2, 3]
    mut: MutPtr<[i32]> = MutPtr.to(data)  // Mutable pointer
    
    io.println("  Ptr<i32> → ${ptr.deref()}")
    io.println("  MutPtr<[i32]> → [${mut.deref()[0]}, ...]") 
}

// ─── FFI Integration ───
inline.c("""
    static double fibonacci_ratio(int n) {
        if (n < 2) return 1.0;
        double a = 1, b = 1, c;
        for (int i = 2; i < n; i++) {
            c = a + b; a = b; b = c;
        }
        return b / a;  // Approaches golden ratio
    }
""")

showcase_ffi = () void {
    io.println("\n◆ C Integration")
    ratio = fibonacci_ratio(20)
    io.println("  F(20)/F(19) ≈ φ = ${ratio:.6f}")
}

// ─── Concurrency ───
showcase_concurrency = () void {
    io.println("\n◆ Channels & Spawn")
    
    worker = (id: i32, ch: Channel<i32>) void {
        ch.send(id * id)
    }
    
    ch = Channel<i32>.new(3)
    
    (1..=3).loop((i) { spawn(() => worker(i, ch)) })
    
    results = []
    (1..=3).loop((_) {
        ch.receive() ?
            | Some(val) { results.push(val) }
            | None { }
    })
    
    io.println("  Workers: [1,2,3] → [${results.join(", ")}]")
}

// ─── Compile-Time ───
showcase_comptime = () void {
    io.println("\n◆ Compile-Time Evaluation")
    
    FIBONACCI :: [1, 1, 2, 3, 5, 8, 13, 21]
    PRIMES :: [2, 3, 5, 7, 11, 13, 17, 19]
    
    min = <T>(a: T, b: T) T {
        a < b ? | true { a } | false { b }
    }
    
    io.println("  Fib[7]=${FIBONACCI[6]}, Prime[5]=${PRIMES[4]}, min(5,3)=${min(5, 3)}")
}

// ─── SIMD Vectorization ───
showcase_simd = () void {
    io.println("\n◆ SIMD Operations")
    
    a = simd.f32x4(1.0, 2.0, 3.0, 4.0)
    b = simd.f32x4(5.0, 6.0, 7.0, 8.0)
    
    sum = simd.add(a, b)
    dot = simd.dot(a, b)  // 1×5 + 2×6 + 3×7 + 4×8 = 70
    
    io.println("  [1,2,3,4] + [5,6,7,8] = [6,8,10,12]")
    io.println("  dot product = 70.0")
}

// ─── Entry Point ───
main = () void {
    io.println("\n━━━ Zen Language Showcase ━━━")
    io.println("No keywords • UFC • Pattern matching • Clean syntax\n")
    
    showcase_basics()
    showcase_ufc()
    showcase_patterns()
    showcase_errors()
    showcase_memory()
    showcase_ffi()
    showcase_concurrency()
    showcase_comptime()
    showcase_simd()
    
    io.println("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
}