// Zen Language Showcase
// Elegant • Efficient • Expressive

{ io, Result, Option } = @std
{ Vec, HashMap } = @std.collections  
{ Channel, spawn, AtomicU32 } = @std.concurrent

// === Clean Domain Modeling ===

Status: | Online | Away | Offline

User: {
    name: string,
    status: Status
}

Message: |
    Text -> { from: string, content: string }
    | Image -> { from: string, url: string }
    | System -> string

// === Pattern Matching ===

format_message = (msg: Message) string {
    msg ?
        | Text -> { from, content } { "[${from}]: ${content}" }
        | Image -> { from, url } { "[${from}] shared: ${url}" }
        | System -> event { "System: ${event}" }
}

status_icon = (s: Status) string {
    s ? | Online { "●" } | Away { "○" } | Offline { "◌" }
}

// === Generics with Bounds ===

Queue<T>: {
    items: Vec<T>,
    max_size: usize
}

Queue.push<T> = (mut self, item: T) Result<(), string> {
    if self.items.len() >= self.max_size {
        Result.Err("Queue full")
    } else {
        self.items.push(item)
        Result.Ok(())
    }
}

// === Async Operations ===

MessageHub: {
    channel: Channel<Message>,
    active_users: AtomicU32
}

MessageHub.process = async (self) void {
    loop {
        self.channel.recv() ?
            | Some -> msg {
                io.println(format_message(msg))
            }
            | None { break }
    }
}

// === Compile-Time Evaluation ===

FIBONACCI_10 = comptime {
    mut a, mut b := 0, 1
    for _ in 0..10 {
        a, b = b, a + b
    }
    return a
}

// === FFI Integration ===

inline.c("""
    #include <time.h>
    long get_timestamp() { return time(NULL); }
""")

// === Error Propagation ===

load_config = (path: string) Result<Config, string> {
    io.read_file(path) ?>
        .parse_json() ?>
}

Config: {
    port: u16,
    max_connections: usize
}

// === Main Demo ===

main = async () void {
    io.println("=== Zen Language Demo ===\n")
    
    // Type system & pattern matching
    users := [
        User { name: "Alice", status: .Online },
        User { name: "Bob", status: .Away }
    ]
    
    for user in users {
        io.println("${status_icon(user.status)} ${user.name}")
    }
    
    // Message handling
    messages := [
        Message.System("Server started"),
        Message.Text { from: "Alice", content: "Hello!" },
        Message.Image { from: "Bob", url: "photo.jpg" }
    ]
    
    io.println("\nMessages:")
    for msg in messages {
        io.println("  ${format_message(msg)}")
    }
    
    // Async & channels
    hub := MessageHub {
        channel: Channel<Message>.new(10),
        active_users: AtomicU32.new(2)
    }
    
    spawn(async () => await hub.process())
    
    // Compile-time computation
    io.println("\nCompile-time Fibonacci(10): ${FIBONACCI_10}")
    
    // Error handling
    load_config("config.json") ?
        | Ok -> cfg { io.println("Server port: ${cfg.port}") }
        | Err -> e { io.println("Config error: ${e}") }
    
    io.println("\n✓ Demo complete")
}