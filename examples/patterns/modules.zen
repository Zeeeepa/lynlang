// Module organization patterns

{ io, maths } = @std

// Simple module exports
module.exports = {
    Point: Point,
    distance: distance,
    Color: Color,
    mix: mix
}

// Types
Point: {
    x: f64,
    y: f64
}

Color: {
    r: u8,
    g: u8,
    b: u8
}

// Functions to export
distance = (p1: Point, p2: Point) f64 {
    dx = p2.x - p1.x
    dy = p2.y - p1.y
    maths.sqrt(dx * dx + dy * dy)
}

mix = (c1: Color, c2: Color, t: f64) Color {
    lerp = (a: u8, b: u8, t: f64) u8 {
        (a + (b - a) * t) as u8
    }
    
    Color {
        r: lerp(c1.r, c2.r, t),
        g: lerp(c1.g, c2.g, t),
        b: lerp(c1.b, c2.b, t)
    }
}

// Private helpers (not exported)
_validate_color = (c: Color) bool {
    c.r <= 255 && c.g <= 255 && c.b <= 255
}

main = () void {
    io.println("=== Module Patterns ===\n")
    
    // Using exported types
    p1 = Point { x: 0, y: 0 }
    p2 = Point { x: 3, y: 4 }
    io.println("Distance: ${distance(p1, p2)}")
    
    // Color mixing
    red = Color { r: 255, g: 0, b: 0 }
    blue = Color { r: 0, g: 0, b: 255 }
    purple = mix(red, blue, 0.5)
    io.println("Mixed color: rgb(${purple.r}, ${purple.g}, ${purple.b})")
    
    // Import from another module (example syntax)
    // math_utils = module.import("utils/math")
    // result = math_utils.calculate(42)
}