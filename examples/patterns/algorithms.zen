// Algorithms - Core patterns for common problems
// Idiomatic Zen implementations

{ io } = @std

// === Sorting - Quicksort ===
quicksort = <T: Ord>(items ::= Vec<T>) void {
    items.len() <= 1 ? | true { return } | false {}
    
    pivot = items[items.len() / 2]
    left = items.filter((x) => x < pivot)
    middle = items.filter((x) => x == pivot)  
    right = items.filter((x) => x > pivot)
    
    quicksort(left)
    quicksort(right)
    
    items.clear()
    items.extend(left)
    items.extend(middle)
    items.extend(right)
}

// === Searching - Binary Search ===
binary_search = <T: Ord>(items: Vec<T>, target: T) Option<usize> {
    left ::= 0
    right ::= items.len()
    
    loop {
        left >= right ? | true { return Option.None } | false {}
        
        mid = (left + right) / 2
        items[mid] == target ? 
            | true { return Option.Some(mid) }
            | false {
                items[mid] < target ?
                    | true { left = mid + 1 }
                    | false { right = mid }
            }
    }
}

// === Dynamic Programming - Fibonacci ===
fibonacci_memo = (n: u32) u64 {
    cache ::= Map<u32, u64>.new()
    _fib(n, cache)
}

_fib = (n: u32, cache ::= Map<u32, u64>) u64 {
    n <= 1 ? | true { return n } | false {}
    
    cache.get(n) ?
        | Some(val) { val }
        | None {
            result = _fib(n - 1, cache) + _fib(n - 2, cache)
            cache.set(n, result)
            result
        }
}

// === Graph Traversal ===
Graph<T>: {
    edges: Map<T, Vec<T>>
}

Graph.new = <T>() Graph<T> {
    Graph { edges: Map<T, Vec<T>>.new() }
}

Graph.add_edge = <T>(self, from: T, to: T) void {
    self.edges.get_or_insert(from, Vec<T>.new()).push(to)
}

Graph.bfs = <T: Eq>(self, start: T) Vec<T> {
    visited ::= Set<T>.new()
    queue ::= Vec<T>.from([start])
    result ::= Vec<T>.new()
    
    loop {
        queue.is_empty() ? | true { break } | false {}
        
        node = queue.remove(0)
        visited.contains(node) ? | true { continue } | false {}
        
        visited.insert(node)
        result.push(node)
        
        self.edges.get(node) ?
            | Some(neighbors) {
                neighbors.loop((n) {
                    visited.contains(n) ? | false { queue.push(n) } | true {}
                })
            }
            | None {}
    }
    
    result
}

// === Functional Patterns ===
fold = <T, U>(items: Vec<T>, init: U, f: (U, T) => U) U {
    acc ::= init
    items.loop((item) { acc = f(acc, item) })
    acc
}

scan = <T, U>(items: Vec<T>, init: U, f: (U, T) => U) Vec<U> {
    acc ::= init
    result ::= Vec<U>.from([init])
    
    items.loop((item) {
        acc = f(acc, item)
        result.push(acc)
    })
    
    result
}

// === Main Demo ===
main = () void {
    io.println("=== Algorithm Patterns ===\n")
    
    // Sorting
    numbers ::= Vec.from([3, 1, 4, 1, 5, 9, 2, 6])
    io.println("Original: ${numbers}")
    quicksort(numbers)
    io.println("Sorted: ${numbers}")
    
    // Searching
    target = 5
    binary_search(numbers, target) ?
        | Some(idx) { io.println("Found ${target} at index ${idx}") }
        | None { io.println("${target} not found") }
    
    // Dynamic Programming
    fib_n = 20
    io.println("\nFibonacci(${fib_n}) = ${fibonacci_memo(fib_n)}")
    
    // Graph Traversal
    graph = Graph<string>.new()
    graph.add_edge("A", "B")
    graph.add_edge("A", "C")
    graph.add_edge("B", "D")
    graph.add_edge("C", "D")
    graph.add_edge("D", "E")
    
    path = graph.bfs("A")
    io.println("\nBFS from A: ${path.join(" â†’ ")}")
    
    // Functional Patterns
    sum = fold([1, 2, 3, 4, 5], 0, (a, b) => a + b)
    io.println("\nSum: ${sum}")
    
    running_sum = scan([1, 2, 3, 4, 5], 0, (a, b) => a + b)
    io.println("Running sum: ${running_sum}")
}