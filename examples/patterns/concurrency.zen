// Concurrency - Channels, spawning, and parallel patterns
// Zen's approach to concurrent programming

{ io } = @std
{ spawn, Channel, Mutex, AtomicU32 } = @std

// === Worker Pool ===
WorkerPool<T>: {
    jobs: Channel<T>,
    results: Channel<Result<void, string>>
}

WorkerPool.new = <T>(workers: u32) WorkerPool<T> {
    pool = WorkerPool {
        jobs: Channel<T>.new(workers * 2),
        results: Channel<Result<void, string>>.new(workers * 2)
    }
    
    (0..workers).loop((id) {
        spawn(() => {
            loop {
                pool.jobs.receive() ?
                    | Some(job) {
                        // Process job (would be customized per use case)
                        pool.results.send(Result.Ok(void))
                    }
                    | None { break }
            }
        })
    })
    
    pool
}

// === Pipeline Pattern ===
pipeline = <T, U>(
    input: Channel<T>,
    stages: Vec<(T) => U>
) Channel<U> {
    current = input
    
    stages.loop((stage) {
        next = Channel<U>.new(10)
        spawn(() => {
            loop {
                current.receive() ?
                    | Some(val) { next.send(stage(val)) }
                    | None { 
                        next.close()
                        break 
                    }
            }
        })
        current = next
    })
    
    current
}

// === Fan-Out/Fan-In ===
fanout = <T: Clone>(input: Channel<T>, n: u32) Vec<Channel<T>> {
    outputs = (0..n).map((_) => Channel<T>.new(10))
    
    spawn(() => {
        loop {
            input.receive() ?
                | Some(val) {
                    outputs.loop((ch) { ch.send(val.clone()) })
                }
                | None {
                    outputs.loop((ch) { ch.close() })
                    break
                }
        }
    })
    
    outputs
}

fanin = <T>(inputs: Vec<Channel<T>>) Channel<T> {
    output = Channel<T>.new(inputs.len() * 10)
    pending = AtomicU32.new(inputs.len())
    
    inputs.loop((ch) {
        spawn(() => {
            loop {
                ch.receive() ?
                    | Some(val) { output.send(val) }
                    | None {
                        pending.fetch_sub(1) == 1 ?
                            | true { output.close() }
                            | false {}
                        break
                    }
            }
        })
    })
    
    output
}

// === Rate Limiter ===
RateLimiter: {
    permits: Channel<void>,
    rate: u32
}

RateLimiter.new = (rate: u32) RateLimiter {
    permits = Channel<void>.new(rate)
    
    // Fill initial permits
    (0..rate).loop((_) { permits.send(void) })
    
    // Refill periodically
    spawn(() => {
        loop {
            @std.time.sleep(1000 / rate)
            permits.try_send(void)
        }
    })
    
    RateLimiter { permits: permits, rate: rate }
}

RateLimiter.acquire = (self) void {
    self.permits.receive()
}

// === Main Demo ===
main = () void {
    io.println("=== Concurrency Patterns ===\n")
    
    // Worker Pool
    pool = WorkerPool<i32>.new(4)
    (1..=10).loop((i) {
        pool.jobs.send(i)
    })
    pool.jobs.close()
    
    // Pipeline
    source = Channel<i32>.new(10)
    spawn(() => {
        (1..=5).loop((i) { source.send(i) })
        source.close()
    })
    
    result = pipeline(source, [
        (x: i32) => x * 2,
        (x: i32) => x + 10,
        (x: i32) => x / 3
    ])
    
    io.println("Pipeline results:")
    loop {
        result.receive() ?
            | Some(val) { io.println("  ${val}") }
            | None { break }
    }
    
    // Fan-out/Fan-in
    input = Channel<i32>.new(10)
    spawn(() => {
        (1..=3).loop((i) { input.send(i) })
        input.close()
    })
    
    workers = fanout(input, 3)
    merged = fanin(workers)
    
    io.println("\nFan-out/Fan-in:")
    loop {
        merged.receive() ?
            | Some(val) { io.println("  Received: ${val}") }
            | None { break }
    }
    
    // Rate Limiting
    limiter = RateLimiter.new(5)  // 5 ops per second
    io.println("\nRate limited operations:")
    (1..=3).loop((i) {
        limiter.acquire()
        io.println("  Operation ${i} executed")
    })
}