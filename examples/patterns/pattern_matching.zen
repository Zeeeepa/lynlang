// Pattern Matching - The ? Operator
// Zen's unified approach to conditionals and destructuring

{ io, Result, Option } = @std

// === Sum Types (Algebraic Data Types) ===
Json: |
    Null
    | Bool(bool)
    | Number(f64)
    | String(string)
    | Array(Vec<Json>)
    | Object(Map<string, Json>)

Json.stringify = (self) string {
    self ?
        | Null { "null" }
        | Bool(b) { b ? | true { "true" } | false { "false" } }
        | Number(n) { "${n}" }
        | String(s) { "\"${s}\"" }
        | Array(items) { 
            "[${items.map((j) => j.stringify()).join(", ")}]"
        }
        | Object(pairs) {
            fields = pairs.entries().map((kv) => 
                "\"${kv.key}\": ${kv.value.stringify()}"
            )
            "{${fields.join(", ")}}"
        }
}

// === Nested Patterns ===
BinaryTree<T>: |
    Empty
    | Node(T, BinaryTree<T>, BinaryTree<T>)

BinaryTree.height = <T>(self) u32 {
    self ?
        | Empty { 0 }
        | Node(_, left, right) {
            1 + @std.maths.max(left.height(), right.height())
        }
}

// === Guards and Ranges ===
describe = (n: i32) string {
    n ?
        | _ when n < 0 { "negative" }
        | 0 { "zero" }
        | 1..=10 { "small positive" }
        | _ { "large positive" }
}

// === Option Handling ===
safe_divide = (a: f64, b: f64) Option<f64> {
    b == 0 ?
        | true { Option.None }
        | false { Option.Some(a / b) }
}

// === Result Chaining ===
parse_and_double = (s: string) Result<i32, string> {
    s.parse_i32() ?
        | Ok(n) { Result.Ok(n * 2) }
        | Err(e) { Result.Err("Parse error: ${e}") }
}

main = () void {
    // Sum type usage
    data = Json.Object(Map.from_pairs([
        ("name", Json.String("Zen")),
        ("version", Json.Number(1.0)),
        ("features", Json.Array([
            Json.String("pattern matching"),
            Json.String("UFC"),
            Json.Bool(true)
        ]))
    ]))
    io.println("JSON: ${data.stringify()}")
    
    // Binary tree
    tree = BinaryTree.Node(1,
        BinaryTree.Node(2, BinaryTree.Empty, BinaryTree.Empty),
        BinaryTree.Node(3, BinaryTree.Empty, BinaryTree.Empty)
    )
    io.println("Tree height: ${tree.height()}")
    
    // Guards
    [-5, 0, 3, 50].loop((n) {
        io.println("${n} is ${describe(n)}")
    })
    
    // Option chaining
    safe_divide(10, 2) ?
        | Some(v) { io.println("10/2 = ${v}") }
        | None { io.println("Division failed") }
}