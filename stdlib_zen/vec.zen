// vec.zen - Dynamic vector/array operations for Zen

struct Vec<T> {
    data: *T,
    len: u64,
    cap: u64,
}

// Create a new empty vector
new := <T>() Vec<T> {
    return Vec<T> {
        data: null,
        len: 0,
        cap: 0,
    }
}

// Create a vector with initial capacity
with_capacity := <T>(capacity: u64) Vec<T> {
    data := @compiler.builtin("alloc", capacity * @sizeof(T)) as *T
    return Vec<T> {
        data: data,
        len: 0,
        cap: capacity,
    }
}

// Push an element to the vector
push := <T>(v: *Vec<T>, elem: T) void {
    if v.len >= v.cap {
        // Need to grow the vector
        new_cap := if v.cap == 0 { 4 } else { v.cap * 2 }
        new_data := @compiler.builtin("alloc", new_cap * @sizeof(T)) as *T
        
        // Copy old data to new buffer
        if v.len > 0 {
            @compiler.builtin("memcpy", new_data, v.data, v.len * @sizeof(T))
            @compiler.builtin("free", v.data)
        }
        
        v.data = new_data
        v.cap = new_cap
    }
    
    v.data[v.len] = elem
    v.len = v.len + 1
}

// Pop an element from the vector
pop := <T>(v: *Vec<T>) T? {
    if v.len == 0 {
        return none
    }
    
    v.len = v.len - 1
    return some(v.data[v.len])
}

// Get element at index
get := <T>(v: *Vec<T>, index: u64) T? {
    if index >= v.len {
        return none
    }
    return some(v.data[index])
}

// Set element at index
set := <T>(v: *Vec<T>, index: u64, value: T) bool {
    if index >= v.len {
        return false
    }
    v.data[index] = value
    return true
}

// Get the length of the vector
len := <T>(v: *Vec<T>) u64 {
    return v.len
}

// Check if vector is empty
is_empty := <T>(v: *Vec<T>) bool {
    return v.len == 0
}

// Clear the vector (remove all elements)
clear := <T>(v: *Vec<T>) void {
    v.len = 0
}

// Free the vector's memory
free := <T>(v: *Vec<T>) void {
    if v.data != null {
        @compiler.builtin("free", v.data)
        v.data = null
        v.len = 0
        v.cap = 0
    }
}

// Resize the vector
resize := <T>(v: *Vec<T>, new_len: u64, default_value: T) void {
    if new_len > v.cap {
        // Need to grow
        new_cap := new_len
        new_data := @compiler.builtin("alloc", new_cap * @sizeof(T)) as *T
        
        // Copy old data
        if v.len > 0 {
            @compiler.builtin("memcpy", new_data, v.data, v.len * @sizeof(T))
        }
        
        // Initialize new elements with default value
        i := v.len
        while i < new_len {
            new_data[i] = default_value
            i = i + 1
        }
        
        if v.data != null {
            @compiler.builtin("free", v.data)
        }
        
        v.data = new_data
        v.cap = new_cap
    } else if new_len > v.len {
        // Just need to initialize new elements
        i := v.len
        while i < new_len {
            v.data[i] = default_value
            i = i + 1
        }
    }
    
    v.len = new_len
}

// Clone a vector
clone := <T>(v: *Vec<T>) Vec<T> {
    new_vec := with_capacity<T>(v.cap)
    new_vec.len = v.len
    
    if v.len > 0 {
        @compiler.builtin("memcpy", new_vec.data, v.data, v.len * @sizeof(T))
    }
    
    return new_vec
}

// Find an element in the vector
find := <T>(v: *Vec<T>, predicate: (T) bool) T? {
    i := 0
    while i < v.len {
        if predicate(v.data[i]) {
            return some(v.data[i])
        }
        i = i + 1
    }
    return none
}

// Map over vector elements
map := <T, U>(v: *Vec<T>, f: (T) U) Vec<U> {
    result := with_capacity<U>(v.len)
    i := 0
    while i < v.len {
        push(&result, f(v.data[i]))
        i = i + 1
    }
    return result
}

// Filter vector elements
filter := <T>(v: *Vec<T>, predicate: (T) bool) Vec<T> {
    result := new<T>()
    i := 0
    while i < v.len {
        if predicate(v.data[i]) {
            push(&result, v.data[i])
        }
        i = i + 1
    }
    return result
}

// Reduce vector to a single value
reduce := <T, U>(v: *Vec<T>, initial: U, f: (U, T) U) U {
    result := initial
    i := 0
    while i < v.len {
        result = f(result, v.data[i])
        i = i + 1
    }
    return result
}