Test run started at Sun Aug 31 01:24:32 UTC 2025
warning: unused import: `FloatValue`
   --> src/codegen/llvm/expressions.rs:526:41
    |
526 |         use inkwell::values::{IntValue, FloatValue, PointerValue};
    |                                         ^^^^^^^^^^
    |
    = note: `#[warn(unused_imports)]` on by default

warning: use of deprecated method `inkwell::types::IntType::<'ctx>::ptr_type`: Starting from version 15.0, LLVM doesn't differentiate between pointer types. Use Context::ptr_type instead.
   --> src/codegen/llvm/functions.rs:445:54
    |
445 |             let i8_ptr_type = self.context.i8_type().ptr_type(inkwell::AddressSpace::default());
    |                                                      ^^^^^^^^
    |
    = note: `#[warn(deprecated)]` on by default

warning: use of deprecated method `inkwell::types::IntType::<'ctx>::ptr_type`: Starting from version 15.0, LLVM doesn't differentiate between pointer types. Use Context::ptr_type instead.
   --> src/codegen/llvm/functions.rs:476:54
    |
476 |             let i8_ptr_type = self.context.i8_type().ptr_type(inkwell::AddressSpace::default());
    |                                                      ^^^^^^^^

warning: use of deprecated method `inkwell::types::FunctionType::<'ctx>::ptr_type`: Starting from version 15.0, LLVM doesn't differentiate between pointer types. Use Context::ptr_type instead.
   --> src/codegen/llvm/types.rs:113:46
    |
113 |                 Ok(Type::Basic(function_type.ptr_type(AddressSpace::default()).into()))
    |                                              ^^^^^^^^

warning: unused variable: `target_llvm_type`
   --> src/codegen/llvm/expressions.rs:530:13
    |
530 |         let target_llvm_type = self.to_llvm_type(target_type)?;
    |             ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_target_llvm_type`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `call`
   --> src/codegen/llvm/functions.rs:454:13
    |
454 |         let call = self.builder.build_call(
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_call`

warning: unused variable: `call`
   --> src/codegen/llvm/functions.rs:485:13
    |
485 |         let call = self.builder.build_call(
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_call`

warning: unused variable: `expected`
  --> src/codegen/llvm/statements.rs:21:33
   |
21 |                     if let Some(expected) = expected_ret_type {
   |                                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected`

warning: unused variable: `actual_type`
  --> src/codegen/llvm/statements.rs:22:29
   |
22 |                         let actual_type = value.get_type();
   |                             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_actual_type`

warning: variable does not need to be mutable
  --> src/parser/expressions.rs:92:13
   |
92 |         let mut expr = self.parse_primary_expression()?;
   |             ----^^^^
   |             |
   |             help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `saved_pos`
   --> src/parser/expressions.rs:200:25
    |
200 |                     let saved_pos = self.current_span.start;
    |                         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_saved_pos`

warning: unreachable pattern
   --> src/typechecker/mod.rs:518:13
    |
518 |             _ => Ok(AstType::Void), // Default for unhandled cases
    |             ^ no value can reach this
    |
note: multiple earlier patterns match some of the same values
   --> src/typechecker/mod.rs:518:13
    |
294 |             Expression::Integer32(_) => Ok(AstType::I32),
    |             ------------------------ matches some of the same values
295 |             Expression::Integer64(_) => Ok(AstType::I64),
    |             ------------------------ matches some of the same values
296 |             Expression::Float32(_) => Ok(AstType::F32),
    |             ---------------------- matches some of the same values
297 |             Expression::Float64(_) => Ok(AstType::F64),
    |             ---------------------- matches some of the same values
...
518 |             _ => Ok(AstType::Void), // Default for unhandled cases
    |             ^ ...and 31 other patterns collectively make this unreachable
    = note: `#[warn(unreachable_patterns)]` on by default

warning: `zen` (lib) generated 12 warnings (run `cargo fix --lib -p zen` to apply 2 suggestions)
warning: variants `Function`, `Struct`, `Enum`, `Option`, `Result`, and `Range` are never constructed
  --> src/ast.rs:27:5
   |
7  | pub enum AstType {
   |          ------- variants in this enum
...
27 |     Function {
   |     ^^^^^^^^
...
35 |     Struct {
   |     ^^^^^^
...
39 |     Enum {
   |     ^^^^
...
45 |     Option(Box<AstType>), // Option<T>
   |     ^^^^^^
46 |     Result {
   |     ^^^^^^
...
50 |     Range {
   |     ^^^^^
   |
   = note: `AstType` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

