// Comprehensive test implementing LANGUAGE_SPEC.zen
// This file tests all core features as defined in the spec

// ============================================================================
// Core Imports (Lines 92-106)
// ============================================================================

{ io, math } = @std
{ String, StringBuilder } = @std
{ requires, implements, reflect, meta, inline, simd } = @std
{ GPA, AsyncPool, Allocator } = @std
{ Vec, DynVec } = @std
{ Actor, Channel, Mutex, AtomicU32 } = @std

// ============================================================================
// Type Definitions (Lines 109-196)
// ============================================================================

// No null! Only Option types
Option<T>: Some(T) | None

// Result type for error handling
Result<T, E>: Ok(T) | Err(E)

// Simple struct
Point: {
    x:: f64,  // mutable field
    y:: f64 = 0.0  // with default value
}

// Trait definition - methods that types can implement
Geometric: {
    area: (self) f64,
    perimeter: (self) f64
}

Circle: {
    center: Point,
    radius: f64
}

// Implement trait for type using .implements()
Circle.implements(Geometric, {
    area = (self) f64 {
        return math.pi * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * math.pi * self.radius
    }
})

Rectangle: {
    top_left: Point,
    bottom_right: Point
}

Rectangle.implements(Geometric, {
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return width * height
    },
    perimeter = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return 2.0 * (width + height)
    }
})

// Enum type (sum type)
Shape: Circle | Rectangle
// Enforce all Shape variants must implement Geometric
Shape.requires(Geometric)

// UFC overloading based on enum variants
GameEntity: Player | Enemy | Powerup

// Overload functions for each variant
get_health = (e: GameEntity.Player) u32 { return 100 }
get_health = (e: GameEntity.Enemy) u32 { return 50 }
get_health = (e: GameEntity.Powerup) u32 { return 0 }

get_speed = (e: GameEntity.Player) f64 { return 5.0 }
get_speed = (e: GameEntity.Enemy) f64 { return 3.0 }
get_speed = (e: GameEntity.Powerup) f64 { return 0.0 }

// ============================================================================
// Main Function - Test All Features
// ============================================================================

main = () void {
    io.println("=== LANGUAGE_SPEC.zen Complete Test ===")
    io.println("")
    
    // ========================================================================
    // Variable Declarations (Lines 298-306)
    // ========================================================================
    io.println("== Variable Declarations ==")
    
    x: i32  // forward declaration
    x = 10
    y = 10  // Immutable assignment
    z: i32 = 20  // Immutable with type
    w:: i32  // mutable forward declaration
    w = 20
    v ::= 30  // Mutable assignment
    u:: i32 = 40  // mutable with type
    
    io.println("x = ${x}")
    io.println("y = ${y}")
    io.println("z = ${z}")
    io.println("w = ${w}")
    v = v + 5
    io.println("v after mutation = ${v}")
    u = u * 2
    io.println("u after mutation = ${u}")
    io.println("")
    
    // ========================================================================
    // Pattern Matching (Lines 352-361)
    // ========================================================================
    io.println("== Pattern Matching ==")
    
    // Boolean pattern matching - no ternary
    is_ready = true
    is_ready ? {
        io.println("Starting game!")
    }
    
    // For if-else, use full pattern match
    has_data = false
    has_data ?
        | true { io.println("Processing data...") }
        | false { io.println("Waiting for data...") }
    
    io.println("")
    
    // ========================================================================
    // Structs and Mutable Fields (Lines 364-372)
    // ========================================================================
    io.println("== Structs and Mutable Fields ==")
    
    circle = Circle { 
        center: Point { x: 100.0, y: 100.0 }, 
        radius: 50.0 
    }
    
    // Access struct fields
    io.println("Circle center: (${circle.center.x}, ${circle.center.y})")
    io.println("Circle radius: ${circle.radius}")
    
    // Mutate mutable fields
    circle.center.x = 150.0
    circle.center.y = 150.0
    io.println("New center: (${circle.center.x}, ${circle.center.y})")
    
    io.println("")
    
    // ========================================================================
    // Traits and Methods (Lines 136-143)
    // ========================================================================
    io.println("== Traits and Methods ==")
    
    io.println("Circle area: ${circle.area()}")
    io.println("Circle perimeter: ${circle.perimeter()}")
    
    rect = Rectangle {
        top_left: Point { x: 0.0, y: 0.0 },
        bottom_right: Point { x: 50.0, y: 50.0 }
    }
    
    io.println("Rectangle area: ${rect.area()}")
    io.println("Rectangle perimeter: ${rect.perimeter()}")
    
    io.println("")
    
    // ========================================================================
    // Option Type - No Null (Lines 462-473)
    // ========================================================================
    io.println("== Option Type ==")
    
    maybe_radius: Option<f64> = Some(5.5)
    maybe_radius ?
        | Some(r) {
            new_circle = Circle {
                center: Point { x: 0.0, y: 0.0 },
                radius: r
            }
            io.println("Created circle with radius ${r}, area: ${new_circle.area()}")
        }
        | None {
            io.println("No radius provided")
        }
    
    empty_value: Option<f64> = None
    empty_value ?
        | Some(v) { io.println("Has value: ${v}") }
        | None { io.println("Empty option") }
    
    io.println("")
    
    // ========================================================================
    // Result Type (Lines 113-114)
    // ========================================================================
    io.println("== Result Type ==")
    
    success: Result<i32, String> = Ok(42)
    success ?
        | Ok(v) { io.println("Success value: ${v}") }
        | Err(e) { io.println("Error: ${e}") }
    
    failure: Result<i32, String> = Err("Something went wrong")
    failure ?
        | Ok(v) { io.println("Success: ${v}") }
        | Err(e) { io.println("Error occurred: ${e}") }
    
    io.println("")
    
    // ========================================================================
    // Loops (Lines 431-459)
    // ========================================================================
    io.println("== Loops ==")
    
    // Range iterations
    io.println("Range (0..5):")
    (0..5).loop((i) {
        io.println("  Count: ${i}")
    })
    
    // Step ranges (when implemented)
    // (0..20).step(5).loop((i) {
    //     io.println("  Step: ${i}")  // 0, 5, 10, 15
    // })
    
    // Infinite loop with break
    counter ::= 0
    io.println("Infinite loop with break:")
    loop(() {
        counter = counter + 1
        counter > 3 ?
            | true { 
                io.println("  Breaking at ${counter}")
                break 
            }
            | false { io.println("  Count: ${counter}") }
    })
    
    io.println("")
    
    // ========================================================================
    // UFC (Uniform Function Call) (Line 5)
    // ========================================================================
    io.println("== UFC ==")
    
    double = (n: i32) i32 { return n * 2 }
    triple = (n: i32) i32 { return n * 3 }
    
    // Function as method call
    result1 = 5.double()
    io.println("5.double() = ${result1}")
    
    result2 = 7.triple()
    io.println("7.triple() = ${result2}")
    
    io.println("")
    
    // ========================================================================
    // @this.defer() - Cleanup (Lines 217, 309-314, etc)
    // ========================================================================
    io.println("== Defer for Cleanup ==")
    
    @this.defer(io.println("Deferred cleanup 1"))
    @this.defer(io.println("Deferred cleanup 2"))
    
    io.println("Main execution continuing...")
    
    // Nested scope with defer
    {
        io.println("Entering nested scope")
        @this.defer(io.println("Nested scope cleanup"))
        io.println("In nested scope")
    }
    
    io.println("")
    
    // ========================================================================
    // String Interpolation
    // ========================================================================
    io.println("== String Interpolation ==")
    
    name = "Zen"
    version = 1.0
    message = "Language: ${name}, Version: ${version}"
    io.println(message)
    
    // Complex expressions in interpolation
    calculation = "Result: ${10 * 5 + 2}"
    io.println(calculation)
    
    io.println("")
    
    io.println("=== All Tests Complete ===")
}