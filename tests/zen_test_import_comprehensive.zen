// Comprehensive test for new import syntax
// Tests imports at module level and in comptime blocks

// Module-level imports (new syntax without comptime)
{ core } = @std.core
{ vec } = @std.vec
{ string } = @std.string
{ build } = @std.build
io := build.import("io")
fs := build.import("fs")
{ math } = @std.math
{ meta } = @std.meta
reflect := build.import("reflect")
{ ast } = @std.compiler.ast
{ outer_meta } = @std.meta
{ inner_reflect } = @std.reflect
{ inner_ast } = @std.compiler.ast

// Test imports inside functions
test_function_imports = () void   {
    // Local imports work too
    { json } = @std.json
    { http } = @std.http
    
    // Use imported modules
    data := json.parse("{\"test\": true}")
    response := http.get("https://example.com")
}

// Comptime blocks are for meta-programming, not imports
@comptime {
    // Can use imports for compile-time code generation
    generate_struct = (name: string) void   {
        meta.define_type(name, reflect.struct_type([
            ("id", "i64"),
            ("name", "string"),
        ]))
    }
}

// Test nested comptime for meta-programming
@comptime {
    @comptime {
        // Meta-programming logic
        process_ast = (node: inner_ast.Node) void   {
            inner_reflect.inspect(node)
        }
    }
}

// Test conditional imports
DEBUG := true

compile_time_import = () void   {
    DEBUG ? | true { { }
        { debug } = @std.debug
        { log } = @std.log
        log.debug("Debug mode enabled")
    } | false { { }}
}

// Test imports in match expressions
import_based_on_platform = () void   {
    platform := core.get_platform()
    
    match platform {
        | "linux" { { }
            { linux } = @std.linux
            linux.specific_function()
        }
        | "windows" { { }
            { windows } = @std.windows
            windows.specific_function()
        }
        | "macos" { { }
            { macos } = @std.macos
            macos.specific_function()
        }
        | _ { { }
            { generic } = @std.generic
            generic.fallback()
        }
    }
}

// Test imports in loops (unusual but valid)
test_loop_imports = () void   {
    modules := ["math", "string", "vec"]
    
    i := 0
    loop i < modules.len() {
        // Dynamic imports (if supported)
        mod := build.import(modules[i])
        // Use the module
        mod.init()
        i = i + 1
    }
}

// Test imports with aliases
test_aliased_imports = () void   {
    // Multiple ways to import with aliases
    { v } = @std.vec
    { Vector } = @std.vec
    { DynamicArray } = @std.vec
    
    // All refer to the same module
    v1 := v.new()
    v2 := Vector.new()
    v3 := DynamicArray.new()
}

// Main test function
main = () i32   {
    // Test that all imports work
    io.println("Testing comprehensive import syntax...")
    
    // Use various imported modules
    v := vec.new()
    s := string.from("test")
    result := math.sqrt(16.0)
    
    // Test function with local imports
    test_function_imports()
    
    // Test conditional imports
    compile_time_import()
    
    // Test platform-specific imports
    import_based_on_platform()
    
    // Test loop imports
    test_loop_imports()
    
    // Test aliased imports
    test_aliased_imports()
    
    io.println("All import tests passed!")
    return 0
}