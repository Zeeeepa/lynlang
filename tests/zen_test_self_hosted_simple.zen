// Simplified self-hosted test suite for Zen
// Tests core stdlib functionality written in Zen

core = @std
{ Vec, DynVec } = @std
hashmap = @std

// External functions
extern printf = (format: RawPtr<i8>, ...) i32
extern puts = (str: RawPtr<i8>) i32

// Test helper
assert_eq = (actual: i64, expected: i64, test_name: string) bool   {
    actual == expected ? | true {
        printf("[PASS] %s\n", test_name)
        return true
    } | false {
        printf("[FAIL] %s: expected %d, got %d\n", test_name, expected, actual)
        return false  
    }
}

// Test basic loops
test_loops = () bool   {
    puts("\nTesting Loops...")
    passed := true
    
    // Test conditional loop
    counter := 5
    sum := 0
    loop counter > 0 {
        sum = sum + counter
        counter = counter - 1
    }
    passed = passed && assert_eq(sum, 15, "Conditional loop sum")
    
    // Test Range with callback
    range_sum := 0
    idx := 1
    loop idx < 6 {
        range_sum = range_sum + idx
        idx = idx + 1
    }
    passed = passed && assert_eq(range_sum, 15, "Range loop sum")
    
    // Test nested loops
    product := 0
    i := 1
    loop i <= 3 {
        j := 1
        loop j <= 3 {
            product = product + (i * j)
            j = j + 1
        }
        i = i + 1
    }
    passed = passed && assert_eq(product, 36, "Nested loops product")
    
    return passed
}

// Test DynVec operations
test_vec = () bool   {
    puts("\nTesting DynVec...")
    passed := true
    
    // Create and populate dynvec
    v := DynVec<i64>.new()
    v.push(10).unwrap()
    v.push(20).unwrap()
    v.push(30).unwrap()
    
    passed = passed && assert_eq(v.len(), 3, "DynVec length after push")
    
    // Get element
    elem_result := v.get(1)
    elem_result ? | core.Result:Ok(val) {
        passed = passed && assert_eq(val, 20, "DynVec get element")
    } | core.Result:Err(_) {
        passed = false
        puts("[FAIL] DynVec get returned error")
    }
    
    // Pop element  
    popped := v.pop()
    popped ? | core.Option:Some(val) {
        passed = passed && assert_eq(val, 30, "DynVec pop value")
        passed = passed && assert_eq(v.len(), 2, "DynVec length after pop")
    } | core.Option:None {
        passed = false
        puts("[FAIL] DynVec pop returned None")
    }
    
    v.free()
    return passed
}

// Test HashMap operations
test_hashmap = () bool   {
    puts("\nTesting HashMap...")
    passed := true
    
    // Create hashmap
    map := hashmap.hashmap_new<i64, i64>(hashmap.hash_i64, hashmap.eq_i64)
    
    // Insert values
    hashmap.hashmap_insert(&map, 1, 100)
    hashmap.hashmap_insert(&map, 2, 200)
    hashmap.hashmap_insert(&map, 3, 300)
    
    passed = passed && assert_eq(hashmap.hashmap_len(&map), 3, "HashMap length")
    
    // Get value
    val := hashmap.hashmap_get(&map, 2)
    val ? | core.Option:Some(v) {
        passed = passed && assert_eq(v, 200, "HashMap get value")
    } | core.Option:None {
        passed = false
        puts("[FAIL] HashMap get returned None")
    }
    
    // Remove value
    removed := hashmap.hashmap_remove(&map, 2)
    removed ? | core.Option:Some(v) {
        passed = passed && assert_eq(v, 200, "HashMap remove value")
        passed = passed && assert_eq(hashmap.hashmap_len(&map), 2, "HashMap length after remove")
    } | core.Option:None {
        passed = false
        puts("[FAIL] HashMap remove returned None")
    }
    
    hashmap.hashmap_free(&map)
    return passed
}

// Test algorithms
test_algorithms = () bool   {
    puts("\nTesting Algorithms...")
    passed := true
    
    // Factorial using loops
    factorial = (n: i64) i64   {
        result := 1
        i := 1
        loop i <= n {
            result = result * i
            i = i + 1
        }
        return result
    }
    
    passed = passed && assert_eq(factorial(5), 120, "Factorial of 5")
    passed = passed && assert_eq(factorial(6), 720, "Factorial of 6")
    
    // Fibonacci using loops
    fibonacci = (n: i64) i64   {
        n <= 1 ? | true { { return n  }} | false {}
        
        prev := 0
        curr := 1
        i := 2
        loop i <= n {
            next := prev + curr
            prev = curr
            curr = next
            i = i + 1
        }
        return curr
    }
    
    passed = passed && assert_eq(fibonacci(10), 55, "Fibonacci of 10")
    passed = passed && assert_eq(fibonacci(12), 144, "Fibonacci of 12")
    
    return passed
}

// Main test runner
main = () i32   {
    puts("===== Zen Self-Hosted Tests =====")
    
    passed := 0
    failed := 0
    
    // Run tests
    test_loops() ? | true {
        passed = passed + 1
    } | false {
        failed = failed + 1
    }
    
    test_vec() ? | true {
        passed = passed + 1
    } | false {
        failed = failed + 1
    }
    
    test_hashmap() ? | true {
        passed = passed + 1
    } | false {
        failed = failed + 1
    }
    
    test_algorithms() ? | true {
        passed = passed + 1
    } | false {
        failed = failed + 1
    }
    
    // Print summary
    puts("\n===== Test Summary =====")
    printf("Passed: %d\n", passed)
    printf("Failed: %d\n", failed)
    
    failed == 0 ? | true {
        puts("\nAll tests passed!")
        return 0
    } | false {
        puts("\nSome tests failed!")
        return 1
    }
}