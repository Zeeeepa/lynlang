// Language Specification Compliance Tests
// Tests to ensure core language features follow the spec

{ build } = @std.build
core := build.import("core")
testing := build.import("testing")
io := build.import("io")

// Test pattern matching with ? operator
test_pattern_matching = () bool   {
    // Test basic value patterns
    score := 100
    result := score ? 
        | 100 { "Perfect" }
        | 0 { "Failed" }
        | _ { "In progress" }
    
    result == "Perfect" ? 
        | true {}
        | false { return false }
    
    // Test range patterns
    age := 25
    category := age ?
        | 0..=12 { "Child" }
        | 13..=19 { "Teen" }
        | 20..=64 { "Adult" }
        | _ { "Senior" }
    
    category == "Adult" ?
        | true {}
        | false { return false }
    
    // Test guards with pattern matching
    value := 75
    size := value ?
        | v { v > 100 ? | true { "Large" } | false { 
            v > 50 ? | true { "Medium" } | false {
                v > 0 ? | true { "Small" } | false { "Zero or negative" }
            }
        } }
    
    size == "Medium" ?
        | true {}
        | false { return false }
    
    // Test multiple patterns (or-patterns)
    day := 3
    day_type := day ?
        | 1 | 2 | 3 | 4 | 5 { "Weekday" }
        | 6 | 7 { "Weekend" }
        | _ { "Invalid day" }
    
    day_type == "Weekday" ?
        | true {}
        | false { return false }
    
    return true
}

// Test that there are no if/else keywords
test_no_if_else_keywords = () bool   {
    // All conditionals must use ? operator
    condition := true
    result := condition ?
        | true { "yes" }
        | false { "no" }
    
    result == "yes" ?
        | true {}
        | false { return false }
    
    // Test bool shorthand
    is_valid := false
    is_valid ? { return false }
    
    return true
}

// Test Result/Option types for error handling
test_error_as_values = () bool   {
    // Create a Result
    success := Result:Ok(42)
    failure := Result:Err("error")
    
    // Pattern match on Result
    success ?
        | .Ok(val) {
            val == 42 ?
                | true {}
                | false { return false }
        }
        | .Err(_) { return false }
    
    failure ?
        | .Ok(_) { return false }
        | .Err(err) {
            err == "error" ?
                | true {}
                | false { return false }
        }
    
    // Create an Option
    some_value := Option:Some(10)
    none_value := Option:None
    
    // Pattern match on Option
    some_value ?
        | .Some(val) {
            val == 10 ?
                | true {}
                | false { return false }
        }
        | .None { return false }
    
    none_value ?
        | .Some(_) { return false }
        | .None {}
    
    return true
}

// Test loop keyword (only loop, no while/for)
test_loop_keyword = () bool   {
    // Conditional loop (while-like)
    counter := 5
    sum := 0
    
    loop(() {
        counter > 0 ?
            | true {
                sum = sum + counter
                counter = counter - 1
            }
            | false { break }
    })
    
    sum == 15 ?
        | true {}
        | false { return false }
    
    // Range iteration
    range_sum := 0
    (0..5).loop((i) {
        range_sum = range_sum + i
    })
    
    range_sum == 10 ?  // 0 + 1 + 2 + 3 + 4
        | true {}
        | false { return false }
    
    // Break from infinite loop
    count := 0
    loop(() {
        count = count + 1
        count >= 3 ? 
            | true { break }
            | false {}
    })
    
    count == 3 ?
        | true {}
        | false { return false }
    
    return true
}

// Test struct syntax (no tuples allowed)
test_struct_syntax = () bool   {
    // Structs are the only product type
    Point := {
        x: f64,
        y: f64,
    }
    
    p := Point{ x: 3.0, y: 4.0 }
    
    p.x == 3.0 && p.y == 4.0 ?
        | true {}
        | false { return false }
    
    // No tuples - must use structs
    Pair := {
        first: i32,
        second: string,
    }
    
    pair := Pair{ first: 42, second: "answer" }
    
    pair.first == 42 && pair.second == "answer" ?
        | true {}
        | false { return false }
    
    return true
}

// Test variable declarations
test_variable_declarations = () bool   {
    // Immutable binding
    PI := 3.14159
    
    // Mutable binding
    counter := 0
    counter = counter + 1
    
    counter == 1 ?
        | true {}
        | false { return false }
    
    // Typed immutable
    MAX_SIZE: u32 = 1000
    
    MAX_SIZE == 1000 ?
        | true {}
        | false { return false }
    
    // Typed mutable
    buffer: [10, u8]
    buffer[0] = 65  // 'A'
    
    buffer[0] == 65 ?
        | true {}
        | false { return false }
    
    return true
}

// Test @std namespace (only allowed namespace)
test_std_namespace = () bool   {
    // All imports must go through @std.build
    // This test verifies the pattern works
    
    // The build object is from @std
    build_exists := true  // If we got here, build exists
    
    build_exists ?
        | true {}
        | false { return false }
    
    return true
}

// Main test runner
main = () i32   {
    io.print("ğŸ§ª Zen Language Specification Compliance Tests\n")
    io.print("=" * 50 + "\n\n")
    
    suite := testing.new_suite("Language Spec Compliance")
    
    // Run all tests
    testing.run_test(Ptr:new(suite), "Pattern Matching (?)", test_pattern_matching)
    testing.run_test(Ptr:new(suite), "No if/else Keywords", test_no_if_else_keywords)
    testing.run_test(Ptr:new(suite), "Errors as Values", test_error_as_values)
    testing.run_test(Ptr:new(suite), "Loop Keyword Only", test_loop_keyword)
    testing.run_test(Ptr:new(suite), "Struct Syntax (No Tuples)", test_struct_syntax)
    testing.run_test(Ptr:new(suite), "Variable Declarations", test_variable_declarations)
    testing.run_test(Ptr:new(suite), "@std Namespace Only", test_std_namespace)
    
    // Print summary
    io.print("\n" + "=" * 50 + "\n")
    io.print("Test Summary:\n")
    io.print("  Total:  " + suite.total + "\n")
    io.print("  Passed: " + suite.passed + " âœ…\n")
    io.print("  Failed: " + suite.failed + " âŒ\n")
    
    suite.failed == 0 ?
        | true {
            io.print("\nğŸ‰ All tests passed! Language spec compliant.\n")
            return 0
        }
        | false {
            io.print("\nâŒ Some tests failed. Review spec compliance.\n")
            return 1
        }
}