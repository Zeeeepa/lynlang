// Comprehensive test for LANGUAGE_SPEC.zen features
// Testing all key design principles from the spec

// Import the standard library - only @std and @this are special
{ io, math } = @std
{ String, StringBuilder } = @std
{ Option } = @std.option
{ Result } = @std.result
{ Vec, DynVec } = @std
{ GPA, AsyncPool, Allocator } = @std

// Test 1: No keywords - everything is just identifiers
// loop, if, else, while, for, match, async, await, impl, trait, class, interface, null
// These should all be valid variable names
test_no_keywords = () void {
    loop = 42  // 'loop' is just an identifier, not a keyword
    if = "hello"
    else = true
    while = 3.14
    for = 100
    match = "world"
    async = 5
    await = 10
    impl = 15
    trait = 20
    class = 25
    interface = 30
    null = 35  // Even 'null' is just an identifier!
    
    io.println("No keywords test passed!")
}

// Test 2: Pattern matching with ? operator (no match keyword)
test_pattern_matching = () void {
    value: Option<i32> = Option.Some(42)
    
    // Pattern matching with ? operator
    value ?
        | Some(x) { io.println("Got value: ${x}") }
        | None { io.println("No value") }
    
    // Boolean pattern matching
    is_ready = true
    is_ready ?
        | true { io.println("Ready!") }
        | false { io.println("Not ready") }
    
    // Short form for boolean patterns
    has_data = false
    has_data ? {
        io.println("Processing data...")
    }
}

// Test 3: UFC (Uniform Function Call)
// Any function can be called as a method
test_ufc = () void {
    // Define a standalone function
    double = (x: i32) i32 {
        return x * 2
    }
    
    // Call it normally
    result1 = double(5)
    
    // Call it as a method using UFC
    result2 = 5.double()
    
    io.println("UFC test: ${result1} == ${result2}")
}

// Test 4: Assignment operators
test_assignments = () void {
    // Immutable assignment with =
    x = 42
    
    // Mutable assignment with ::=
    y ::= 100
    y = y + 1  // Can modify y
    
    // Type definition with :
    z: i32 = 50
    w:: i32 = 60  // Mutable with type
    
    io.println("Assignment test passed!")
}

// Test 5: No null - only Option<T>
test_no_null = () void {
    // No null exists - use Option instead
    maybe_value: Option<String> = Option.None
    
    maybe_value ?
        | Some(s) { io.println("String: ${s}") }
        | None { io.println("No string") }
    
    // Create Some variant
    another_value = Option.Some("Hello")
    
    another_value ?
        | Some(s) { io.println("Got: ${s}") }
        | None { io.println("Nothing") }
}

// Test 6: Error propagation with .raise()
test_error_propagation = () Result<i32, String> {
    // Simulate a function that might fail
    parse_int = (s: String) Result<i32, String> {
        s.to_i32() ?
            | Some(n) { return Result.Ok(n) }
            | None { return Result.Err("Invalid number") }
    }
    
    // Use .raise() to propagate errors
    value = parse_int("42").raise()
    doubled = value * 2
    
    return Result.Ok(doubled)
}

// Test 7: Loops - no for/while keywords
test_loops = () void {
    // Infinite loop with loop()
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter > 5 ?
            | true { break }
            | false { io.println("Count: ${counter}") }
    })
    
    // Collection loop with .loop()
    items = Vec<i32, 3>()
    items.push(1)
    items.push(2)
    items.push(3)
    
    items.loop((item) {
        io.println("Item: ${item}")
    })
    
    // Range loops
    (0..5).loop((i) {
        io.println("Range: ${i}")
    })
    
    // Step ranges
    (0..10).step(2).loop((i) {
        io.println("Step: ${i}")
    })
}

// Test 8: Explicit pointer types (no * or &)
test_pointers = () void {
    value = 42
    
    // Immutable pointer
    ptr: Ptr<i32> = value.ref()
    io.println("Value via ptr: ${ptr.val}")
    
    // Mutable pointer
    mut_value ::= 100
    mut_ptr: MutPtr<i32> = mut_value.mut_ref()
    mut_ptr.val = 200
    io.println("Modified value: ${mut_value}")
    
    // Raw pointer for FFI
    raw: RawPtr<i32> = value.raw_ptr()
    io.println("Address: ${raw.addr}")
}

// Test 9: Structs and enums (no unions or tuples)
Point: {
    x: f64,
    y: f64,
}

// Enum type (sum type)
Shape: Circle | Rectangle | Triangle

Circle: {
    center: Point,
    radius: f64,
}

Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

Triangle: {
    p1: Point,
    p2: Point,
    p3: Point,
}

test_structs_enums = () void {
    // Create struct
    p = Point { x: 10.0, y: 20.0 }
    io.println("Point: (${p.x}, ${p.y})")
    
    // Create enum variant
    shape: Shape = Shape.Circle
    circle = Circle {
        center: Point { x: 0.0, y: 0.0 },
        radius: 5.0,
    }
    
    // Pattern match on enum
    shape ?
        | Circle { io.println("It's a circle") }
        | Rectangle { io.println("It's a rectangle") }
        | Triangle { io.println("It's a triangle") }
}

// Test 10: Traits via .implements() and .requires()
Drawable: {
    draw: (self) void,
}

// Implement trait for Circle
Circle.implements(Drawable, {
    draw = (self) void {
        io.println("Drawing circle at (${self.center.x}, ${self.center.y}) with radius ${self.radius}")
    },
})

// Require all Shape variants to implement Drawable
Shape.requires(Drawable)

test_traits = () void {
    c = Circle {
        center: Point { x: 5.0, y: 5.0 },
        radius: 3.0,
    }
    
    c.draw()
}

// Test 11: @std and @this special symbols
test_special_symbols = () void {
    // @std is for standard library
    { println } = @std.io
    
    // @this is for current scope
    @this.defer(() {
        println("Deferred cleanup")
    })
    
    println("Special symbols test")
}

// Test 12: Allocators determine sync/async behavior
test_allocators = () void {
    // Sync allocator - everything blocks
    sync_alloc = GPA.init()
    @this.defer(sync_alloc.deinit())
    
    // Async allocator - everything is non-blocking
    async_alloc = AsyncPool.init()
    @this.defer(async_alloc.deinit())
    
    // Same function behaves differently based on allocator
    fetch_data = (url: String, alloc: Allocator) Result<String, String> {
        // This blocks or doesn't based on allocator!
        return Result.Ok("Data from ${url}")
    }
    
    // Sync call
    sync_result = fetch_data("http://example.com", sync_alloc)
    
    // Async call (non-blocking)
    async_result = fetch_data("http://example.com", async_alloc)
    
    io.println("Allocator test passed")
}

// Test 13: String interpolation with ${}
test_string_interpolation = () void {
    name = "Zen"
    version = 1.0
    count = 42
    
    message = "Hello from ${name} v${version} with ${count} features!"
    io.println(message)
}

// Test 14: Generic types with constraints
Container<T: Drawable>: {
    items: DynVec<T>,
    
    add: (item: T) void,
    draw_all: () void,
}

test_generics = () void {
    // Generic function
    print_twice<T>(value: T) void {
        io.println("${value}")
        io.println("${value}")
    }
    
    print_twice(42)
    print_twice("Hello")
}

// Main test runner
main = () void {
    io.println("=== Running LANGUAGE_SPEC.zen Tests ===")
    
    test_no_keywords()
    test_pattern_matching()
    test_ufc()
    test_assignments()
    test_no_null()
    
    test_error_propagation() ?
        | Ok(v) { io.println("Error propagation test: ${v}") }
        | Err(e) { io.println("Error: ${e}") }
    
    test_loops()
    test_pointers()
    test_structs_enums()
    test_traits()
    test_special_symbols()
    test_allocators()
    test_string_interpolation()
    test_generics()
    
    io.println("=== All Tests Complete ===")
}