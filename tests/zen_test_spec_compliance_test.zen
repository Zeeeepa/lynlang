// Language Specification Compliance Test Suite
// Tests all critical features per LANGUAGE_SPEC.md v1.1.0

test = @std.test
assert = @std.assert
assert_eq = @std.assert_eq

// Test pattern matching with ? operator
test("pattern_matching_basic") {
    value := 42
    result := value ? 
        | 42 { "correct" }
        | _ { "incorrect" }
    assert_eq(result, "correct")
}

test("pattern_matching_ranges") {
    age := 25
    category := age ?
        | 0..=12 => "child"
        | 13..=19 => "teen"
        | 20..=64 => "adult"
        | _ { "senior" }
    assert_eq(category, "adult")
}

test("pattern_matching_destructuring") {
    result := Result:Ok(42)
    value := result ?
        | .Ok -> v { v }
        | .Err -> _ { 0 }
    assert_eq(value, 42)
}

test("pattern_matching_guards") {
    value := 75
    category := value ?
        | v -> v > 100 { "large" }
        | v -> v > 50 { "medium" }
        | v -> v > 0 { "small" }
        | _ { "zero or negative" }
    assert_eq(category, "medium")
}

// Test variable declarations
test("variable_immutable") {
    x := 10
    assert_eq(x, 10)
}

test("variable_mutable") {
    counter := 0
    counter = counter + 1
    assert_eq(counter, 1)
}

test("variable_typed") {
    value: i32 = 100
    assert_eq(value, 100)
}

// Test functions
test("function_basic") {
    double = (x: i32) i32   { x * 2 }
    assert_eq(double(5), 10)
}

test("function_generic") {
    identity<T>: (value: T) T  = { value }
    assert_eq(identity(42), 42)
    assert_eq(identity("hello"), "hello")
}

test("function_ufcs") {
    Rectangle: { width: f64, height: f64 }
    area = (rect: Rectangle) f64   { rect.width * rect.height }
    
    r := Rectangle{ width: 10.0, height: 5.0 }
    assert_eq(r.area(), 50.0)
}

// Test loops
test("loop_conditional") {
    counter := 3
    sum := 0
    loop (counter > 0) {
        sum = sum + counter
        counter = counter - 1
    }
    assert_eq(sum, 6)
}

test("loop_range") {
    sum := 0
    (0..5).loop((i) => {
        sum = sum + i
    })
    assert_eq(sum, 10)
}

// Test structs
test("struct_creation") {
    Point: { x: f64, y: f64 }
    p := Point{ x: 3.0, y: 4.0 }
    assert_eq(p.x, 3.0)
    assert_eq(p.y, 4.0)
}

test("struct_mutable_field") {
    Counter: { value: i32 }
    c := Counter{ value: 0 }
    c.value = 10
    assert_eq(c.value, 10)
}

// Test enums
test("enum_basic") {
    Status: Active
        | Inactive
        | Pending
    
    s := Status:Active
    result := s ?
        | .Active { "running" }
        | .Inactive { "stopped" }
        | .Pending { "waiting" }
    assert_eq(result, "running")
}

test("enum_with_data") {
    Option<T> = 
        | Some(value: T)
        | None
    
    opt := Option:Some(42)
    value := opt ?
        | .Some -> v { v }
        | .None { 0 }
    assert_eq(value, 42)
}

// Test error handling
test("result_type") {
    Result<T, E> = 
        | Ok(value: T)
        | Err(error: E)
    
    divide = (a: i32, b: i32) Result<i32, string>   {
        b == 0 ?
            | true { .Err("division by zero") }
            | false { .Ok(a / b) }
    }
    
    result := divide(10, 2)
    value := result ?
        | .Ok -> v { v }
        | .Err -> _ { -1 }
    assert_eq(value, 5)
}

// Test pointers
test("pointer_basic") {
    ptr := Ptr:new(42)
    assert_eq(ptr.value, 42)
}

test("pointer_ref_counted") {
    ref1 := Ref:new(100)
    ref2 := ref1.clone()
    assert_eq(ref1.value, 100)
    assert_eq(ref2.value, 100)
}

// Test arrays
test("array_fixed_size") {
    arr := [5, i32]{ 1, 2, 3, 4, 5 }
    assert_eq(arr[0], 1)
    assert_eq(arr[4], 5)
    assert_eq(arr.len(), 5)
}

// Test behaviors
test("behavior_comparable") {
    Comparable<T> = {
        compare: (a: T, b: T) i32,
    }
    
    i32_comparable := Comparable<i32>{
        compare: (a: i32, b: i32) i32 {
            a < b ? | true { -1 }
                   | false { a > b ? | true => 1 }
                                      | false { 0 }
        }
    }
    
    assert_eq(i32_comparable.compare(5, 10), -1)
    assert_eq(i32_comparable.compare(10, 5), 1)
    assert_eq(i32_comparable.compare(5, 5), 0)
}

// Test string interpolation
test("string_interpolation") {
    name := "World"
    greeting := "Hello, $(name)!"
    assert_eq(greeting, "Hello, World!")
}

// Test operator precedence
test("operator_precedence") {
    result := 2 + 3 * 4
    assert_eq(result, 14)
    
    result2 := (2 + 3) * 4
    assert_eq(result2, 20)
}

// Test bool patterns
test("bool_pattern_simple") {
    is_valid = () bool   { true }
    
    result := is_valid() ? { "valid" }
    assert_eq(result, "valid")
}

test("bool_pattern_with_branches") {
    check = (x: i32) bool   { x > 0 }
    
    result := check(5) ?
        | true { "positive" }
        | false { "non-positive" }
    assert_eq(result, "positive")
}

// Test comptime execution
test("comptime_basic") {
    TABLE := @comptime {
        table: [4, i32]
        (0..4).loop((i) => {
            table[i] = i * i
        })
        table
    }
    
    assert_eq(TABLE[0], 0)
    assert_eq(TABLE[1], 1)
    assert_eq(TABLE[2], 4)
    assert_eq(TABLE[3], 9)
}

// Test type aliases
test("type_alias") {
    type UserId = u64
    type Point2D = { x: f64, y: f64 }
    
    id: UserId = 12345
    point: Point2D = { x: 1.0, y: 2.0 }
    
    assert_eq(id, 12345)
    assert_eq(point.x, 1.0)
}

// Test defer
test("defer_execution") {
    counter := 0
    
    run = () void   {
        counter = 1
        defer counter = 3
        counter = 2
    }
    
    run()
    assert_eq(counter, 3)
}

// Test null coalesce operator
test("null_coalesce") {
    Option<T> = 
        | Some(value: T)
        | None
    
    value := None ?? 42
    assert_eq(value, 42)
    
    value2 := Some(10) ?? 42
    assert_eq(value2, 10)
}

// Run all tests
main = () void   {
    @std.testing.run_all()
}