// Comprehensive test aligned with LANGUAGE_SPEC.zen
// Testing all core features that should be working

{ io } = @std

// Test struct (lines 117-120)
Point: {
    x:: f64,
    y:: f64
}

// Test simple enum (line 165)
Shape: Circle | Rectangle

// Test Option type (line 109-110)
Option<T>: Some(T) | None

// Test Result type (line 112-113)
Result<T, E>: Ok(T) | Err(E)

// Test function definitions with various signatures
add = (a: i32, b: i32) i32 {
    return a + b
}

// Test simple functions for now
// TODO: Enum variant overloading not yet working
get_player_health = () i32 { return 100 }
get_enemy_health = () i32 { return 50 }

main = () void {
    io.println("=== LANGUAGE_SPEC.zen Alignment Test ===")
    
    // Test variable declarations (lines 299-306)
    io.println("\n1. Variable Declarations:")
    x: i32
    x = 10
    y = 10
    z: i32 = 20
    w :: i32
    w = 20
    v ::= 30
    u :: i32 = 40
    io.println("All variable forms working: x=${x}, y=${y}, z=${z}, w=${w}, v=${v}, u=${u}")
    
    // Test mutable reassignment
    v = 35
    w = 25
    io.println("Mutable reassignment: v=${v}, w=${w}")
    
    // Test pattern matching (lines 352-361)
    io.println("\n2. Pattern Matching:")
    is_ready = true
    is_ready ?
        | true { io.println("Simple pattern: Ready!") }
        | false { io.println("Not ready") }
    
    has_data = false
    has_data ?
        | true { io.println("Has data") }
        | false { io.println("Pattern with branches: No data") }
    
    // Test struct creation and field access (lines 364-365)
    io.println("\n3. Structs:")
    point = Point { x: 100.0, y: 200.0 }
    io.println("Point created: x=${point.x}, y=${point.y}")
    point.x = 150.0
    io.println("Field mutation: x=${point.x}")
    
    // Test enum variants (simplified for now)
    io.println("\n4. Enum Variants:")
    shape = Shape.Circle
    shape ?
        | Circle { io.println("Shape is a Circle") }
        | Rectangle { io.println("Shape is a Rectangle") }
    
    // Test ranges and loops (lines 431-439)
    io.println("\n5. Ranges and Loops:")
    io.print("Range 0..5: ")
    (0..5).loop((i) {
        io.print("${i} ")
    })
    io.println("")
    
    // TODO: step() not yet implemented
    // io.print("Step range 0..20 by 5: ")
    // (0..20).step(5).loop((i) {
    //     io.print("${i} ")
    // })
    // io.println("")
    
    // Test infinite loop with break (lines 452-459)
    io.println("\n6. Infinite Loop with Break:")
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter > 3 ?
            | true { break }
            | false { io.print("${counter} ") }
    })
    io.println("(broke at ${counter})")
    
    // Test UFC (lines 441-445)
    io.println("\n7. UFC (Uniform Function Call):")
    result1 = add(5, 3)
    // result2 = 5.add(3)  // TODO: UFC on literals not yet working
    io.println("Traditional call: ${result1}")
    
    // Test Option handling (lines 462-473)
    io.println("\n8. Option Type:")
    maybe_value: Option<i32> = Option.Some(42)
    maybe_value ?
        | Some(val) { io.println("Option has value: ${val}") }
        | None { io.println("Option is None") }
    
    none_value: Option<i32> = Option.None
    none_value ?
        | Some(val) { io.println("Should not print: ${val}") }
        | None { io.println("Correctly handled None") }
    
    // Test string interpolation
    io.println("\n9. String Interpolation:")
    name = "Zen"
    version = 1
    message = "Language: ${name}, Version: ${version}, Calc: ${10 + 15}"
    io.println(message)
    
    io.println("\n=== All Core Features Aligned with LANGUAGE_SPEC.zen ===")
}