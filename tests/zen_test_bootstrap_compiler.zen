// Test for Bootstrap Compiler Components

core := @std.core
io := @std.io
string := @std.string

// Test imports work correctly (no comptime needed)
test_imports: () bool  = {
    // These imports should work at module level
    math := @std.math
    vec := @std.vec
    
    // Test we can use imported modules
    v := vec.new<i32>()
    vec.push(&mut v, 42)
    
    vec.len(v) == 1 && vec.get(v, 0) == 42 ? {
        io.print("[PASS] Module imports work correctly\n")
        return true
    } : {
        io.print("[FAIL] Module imports failed\n")
        return false
    }
}

// Test time module functionality
test_time_module: () bool  = {
    time := @std.time
    
    // Create duration
    ms := time.milliseconds(100)
    us := time.microseconds(100000)
    
    // Check conversions
    time.as_millis(ms) == 100 && time.as_micros(us) == 100000 ? {
        io.print("[PASS] Time module works\n")
        return true
    } : {
        io.print("[FAIL] Time module failed\n")
        return false
    }
}

// Test logging module
test_log_module: () bool  = {
    log := @std.log
    
    // Set log level
    log.set_level(log.LogLevel.Debug)
    
    // Test logging (won't actually check output, just that it doesn't crash)
    log.debug("Debug message")
    log.info("Info message")
    log.warn("Warning message")
    
    // Check level functions
    log.is_enabled(log.LogLevel.Debug) && !log.is_enabled(log.LogLevel.Trace) ? {
        io.print("[PASS] Log module works\n")
        return true
    } : {
        io.print("[FAIL] Log module failed\n")
        return false
    }
}

// Test args module parsing
test_args_module: () bool  = {
    args := @std.args
    
    // Create parser
    parser := args.new_parser("test", "Test program")
    
    // Add flags
    args.add_flag(&mut parser, args.flag_short('h', "help", "Show help"))
    args.add_flag(&mut parser, args.flag_value('o', "output", "FILE", "Output file"))
    
    // Create test arguments
    test_args := vec.of(["test", "-h", "-o", "output.txt", "input.zen"])
    
    // Parse arguments
    result := args.parse(&parser, test_args)
    
    match result {
        | Result<args.ParsedArgs, string>.Ok(parsed) => {
            args.has_flag(&parsed, "help") && 
            args.get_flag(&parsed, "output") == Option<string>.Some("output.txt") &&
            vec.len(parsed.positional) == 1 ? {
                io.print("[PASS] Args module works\n")
                return true
            } : {
                io.print("[FAIL] Args parsing incorrect\n")
                return false
            }
        }
        | Result<args.ParsedArgs, string>.Err(e) => {
            io.print("[FAIL] Args parsing error: ")
            io.print(e)
            io.print("\n")
            return false
        }
    }
}

// Test LLVM codegen module
test_llvm_codegen: () bool  = {
    codegen_llvm := @std.compiler.codegen_llvm
    
    // Create code generator
    gen := codegen_llvm.new_codegen("test_module")
    
    // Generate simple module
    codegen_llvm.emit(&mut gen, "; Test LLVM IR")
    codegen_llvm.emit(&mut gen, "define i32 @test() {")
    codegen_llvm.emit(&mut gen, "  ret i32 42")
    codegen_llvm.emit(&mut gen, "}")
    
    // Check output contains expected LLVM IR
    string.contains(gen.output, "define i32 @test()") &&
    string.contains(gen.output, "ret i32 42") ? {
        io.print("[PASS] LLVM codegen works\n")
        return true
    } : {
        io.print("[FAIL] LLVM codegen failed\n")
        return false
    }
}

// Test compiler driver structure
test_compiler_driver: () bool  = {
    // Test that compiler modules can be imported
    lexer := @std.compiler.lexer
    parser := @std.compiler.parser
    type_checker := @std.compiler.type_checker
    codegen := @std.compiler.codegen
    
    // Basic smoke test - modules exist and can be referenced
    io.print("[PASS] Compiler driver modules accessible\n")
    return true
}

// Main test runner
main: () i32  = {
    io.print("=================================\n")
    io.print("Testing Bootstrap Compiler\n")
    io.print("=================================\n\n")
    
    total_tests := 6
    passed_tests := 0
    
    test_imports() ? { passed_tests = passed_tests + 1 } : {}
    test_time_module() ? { passed_tests = passed_tests + 1 } : {}
    test_log_module() ? { passed_tests = passed_tests + 1 } : {}
    test_args_module() ? { passed_tests = passed_tests + 1 } : {}
    test_llvm_codegen() ? { passed_tests = passed_tests + 1 } : {}
    test_compiler_driver() ? { passed_tests = passed_tests + 1 } : {}
    
    io.print("\n=================================\n")
    io.print("Results: ")
    io.print_int(passed_tests)
    io.print(" / ")
    io.print_int(total_tests)
    io.print(" tests passed\n")
    io.print("=================================\n")
    
    passed_tests == total_tests ? {
        io.print("\n✅ All bootstrap tests passed!\n")
        return 0
    } : {
        io.print("\n❌ Some bootstrap tests failed.\n")
        return 1
    }
}