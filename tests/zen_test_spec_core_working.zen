// Core working features from LANGUAGE_SPEC.zen
// These are the features that are currently implemented and working

{ io } = @std

// Test Point struct from line 117-120
Point: {
    x:: f64,
    y:: f64
}

// Test function definitions (various lines)
calculate_distance = (p1: Point, p2: Point) f64 {
    dx = p1.x - p2.x
    dy = p1.y - p2.y
    return dx * dx + dy * dy  // Simplified, no sqrt
}

// UFC example - any function can be called as method
double = (n: i32) i32 {
    return n * 2
}

triple = (n: i32) i32 {
    return n * 3
}

main = () void {
    io.println("=== Testing Core LANGUAGE_SPEC.zen Features ===")
    
    // Test 1: Variable declarations (lines 298-306)
    io.println("\n1. Variable Declarations:")
    x: i32              // forward declaration
    x = 10              // immutable assignment
    y = 20              // immutable 
    z ::= 30            // mutable
    w :: i32 = 40       // mutable with type
    
    io.println("x = ${x}, y = ${y}, z = ${z}, w = ${w}")
    z = 35              // mutate z
    io.println("After mutation: z = ${z}")
    
    // Test 2: String interpolation (line 186 and others)
    io.println("\n2. String Interpolation:")
    name = "Zen"
    version = 1
    io.println("Welcome to ${name} v${version}!")
    
    // Test 3: Pattern matching with ? (lines 352-361)
    io.println("\n3. Pattern Matching:")
    is_ready = true
    is_ready ? {
        io.println("System is ready!")
    }
    
    has_data = false
    has_data ?
        | true { io.println("Processing data...") }
        | false { io.println("Waiting for data...") }
    
    // Test 4: Structs (lines 117-120, 364-371)
    io.println("\n4. Structs:")
    p1 = Point { x: 0.0, y: 0.0 }
    p2 = Point { x: 3.0, y: 4.0 }
    
    io.println("Point 1: (${p1.x}, ${p1.y})")
    io.println("Point 2: (${p2.x}, ${p2.y})")
    
    // Mutate struct fields
    p2.x = 5.0
    io.println("After mutation - Point 2: (${p2.x}, ${p2.y})")
    
    dist_sq = calculate_distance(p1, p2)
    io.println("Distance squared: ${dist_sq}")
    
    // Test 5: UFC (Uniform Function Call)
    io.println("\n5. UFC - Uniform Function Call:")
    num = 7
    doubled = num.double()      // Call function as method
    tripled = num.triple()      // Another UFC call
    io.println("${num} doubled = ${doubled}, tripled = ${tripled}")
    
    // Test 6: Range loops (lines 432-434)
    io.println("\n6. Range Loops:")
    io.print("Range 0..5: ")
    (0..5).loop((i) {
        io.print("${i} ")
    })
    io.println("")
    
    // Test 7: Loops with conditions (lines 453-460)
    io.println("\n7. Loop with break:")
    counter ::= 0
    loop {
        counter = counter + 1
        io.print("${counter} ")
        counter >= 5 ?
            | true { break }
            | false { }
    }
    io.println("")
    
    // Test 8: @this.defer (line 217 and others) 
    io.println("\n8. Defer statements:")
    test_defer = () void {
        io.println("Entering scope")
        @this.defer(io.println("Deferred: Cleanup 1"))
        @this.defer(io.println("Deferred: Cleanup 2"))
        io.println("Doing work...")
    }
    test_defer
    
    io.println("\n=== All Core Tests Completed ===")
}