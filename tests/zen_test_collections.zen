// Collection tests from LANGUAGE_SPEC.zen lines 374-385, 316-349
// Tests Vec, DynVec, and mixed-type collections

{ io } = @std
{ Vec, DynVec, GPA } = @std

// Test types for mixed collections
GameEntity:
    Player,
    Enemy,
    Powerup
Shape:
    Circle,
    Rectangle

Circle: {
    center: Point,
    radius: f64,
    area = (self) f64 {
        return 3.14159 * self.radius * self.radius
    }
}

Rectangle: {
    top_left: Point,
    bottom_right: Point,
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return width * height
    }
}

Point: {
    x: f64,
    y: f64
}

main = () void {
    // Initialize allocator
    sync_alloc = GPA.init()
    @this.defer(sync_alloc.deinit())
    
    // Static sized vector (line 374)
    shapes = Vec<Shape, 100>()
    shapes.push(Circle { center: Point { x: 0, y: 0 }, radius: 10 })
    
    // Dynamic vector with allocator (lines 377-379)
    dynamic_shapes = DynVec<Shape>(sync_alloc.allocator())
    @this.defer(dynamic_shapes.deinit())
    
    dynamic_shapes.push(Rectangle {
        top_left: Point { x: 0, y: 0 },
        bottom_right: Point { x: 50, y: 50 }
    })
    
    // Mixed type vector - can hold multiple variant types! (lines 316-322)
    entities = DynVec<GameEntity.Player, GameEntity.Enemy>(sync_alloc)
    @this.defer(entities.deinit())
    
    entities.push(GameEntity.Player)
    entities.push(GameEntity.Enemy)
    entities.push(GameEntity.Player)
    
    // Loop over mixed types with pattern matching (lines 324-335)
    entities.loop((entity) {
        entity ?
            | Player {
                io.println("Found Player")
            }
            | Enemy {
                io.println("Found Enemy")
            }
    })
    
    // Another example with shapes (lines 337-349)
    mixed_items = DynVec<Circle, Rectangle>(sync_alloc)
    @this.defer(mixed_items.deinit())
    
    mixed_items.push(Circle { center: Point { x: 0, y: 0 }, radius: 5 })
    mixed_items.push(Rectangle {
        top_left: Point { x: 0, y: 0 },
        bottom_right: Point { x: 10, y: 10 }
    })
    
    // Pattern match directly on type variants (lines 344-349)
    mixed_items.loop((item) {
        item ?
            | Circle { io.println("Circle area: ${item.area()}") }
            | Rectangle { io.println("Rectangle area: ${item.area()}") }
    })
    
    // UFC collection.loop() with accumulator (lines 441-445)
    total_area ::= 0.0
    dynamic_shapes.loop((shape) {
        total_area = total_area + shape.area()
    })
    
    // Loop with index (lines 447-450)
    dynamic_shapes.loop((shape, i) {
        io.println("Shape ${i}: area = ${shape.area()}")
    })
    
    io.println("Total area: ${total_area}")
}