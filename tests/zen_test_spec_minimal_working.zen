// Minimal working subset of LANGUAGE_SPEC.zen
// This tests what currently works in our implementation

{ io } = @std

// Option type - the foundation of no-null approach
Option<T>: Some(T) | None

// Result type for error handling  
Result<T, E>: Ok(T) | Err(E)

// Simple struct
Point: {
    x: f64,
    y: f64,
}

// Basic enum 
Shape: .Circle | .Rectangle

// Function with type annotations (using : not :: for now)
calculate_area = (shape: Shape, size: f64) f64 {
    shape ?
        | .Circle { return 3.14159 * size * size }
        | .Rectangle { return size * size }
}

// Mutable variables with ::=
main = () void {
    // Immutable by default
    radius = 5.0
    
    // Mutable with ::=
    total_area ::= 0.0
    
    // Pattern matching on boolean
    is_ready = true
    is_ready ? {
        io.println("Ready!")
    }
    
    // Option handling
    maybe_value: Option<f64> = Some(42.0)
    maybe_value ?
        | Some(val) { 
            io.println("Value: ${val}")
            total_area = total_area + val
        }
        | None { 
            io.println("No value")
        }
    
    // Result handling
    result: Result<f64, string> = Ok(100.0)
    result ?
        | Ok(val) { io.println("Success: ${val}") }
        | Err(msg) { io.println("Error: ${msg}") }
    
    // Range loops
    (0..5).loop((i) {
        io.println("Index: ${i}")
    })
    
    // Shape pattern matching
    my_shape: Shape = .Circle
    area = calculate_area(my_shape, radius)
    io.println("Area: ${area}")
}