// Complete test for all pointer operations from LANGUAGE_SPEC.zen

{ io } = @std

Point: {
    x :: i32, // mutable fields
    y :: i32
}

main = () void {
    // Create a mutable point
    point ::= Point { x: 100, y: 200 }
    
    io.println("=== Testing Ptr<T> (immutable pointer) ===")
    point_ptr: Ptr<Point> = point.ref()
    io.print("Point x via ptr: ")
    io.print_int(point_ptr.val.x)
    io.println("")
    io.print("Point y via ptr: ")
    io.print_int(point_ptr.val.y)
    io.println("")
    
    io.println("")
    io.println("=== Testing MutPtr<T> (mutable pointer) ===")
    point_mut: MutPtr<Point> = point.mut_ref()
    
    // Modify through mutable pointer
    // Note: This requires mutable field access through pointer
    // For now, we'll test what we can
    io.print("Point x via mut_ptr: ")
    io.print_int(point_mut.val.x)
    io.println("")
    
    io.println("")
    io.println("=== Testing .addr (get pointer address) ===")
    // Note: .addr should return the memory address
    // This might print as an integer
    addr_val = point_ptr.addr
    io.print("Pointer address (as usize): ")
    // We'll need to cast or print the address
    // For now let's see if it compiles
    io.println("<address>")
    
    io.println("")
    io.println("=== Testing integer pointer ===")
    x ::= 42
    x_ptr: Ptr<i32> = x.ref()
    io.print("Value via ptr: ")
    io.print_int(x_ptr.val)
    io.println("")
    
    x_mut: MutPtr<i32> = x.mut_ref()
    io.print("Value via mut ptr: ")
    io.print_int(x_mut.val)
    io.println("")
}
