// Consolidated Option type tests
{ io, Option , get_default_allocator} = @std

main = () void {
    alloc = get_default_allocator()
    io.println("=== Option Type Tests ===")
    
    // Test 1: Basic Option creation and pattern matching
    io.println("\n1. Basic Option creation:")
    val = Option.Some(42)
    io.println("Created Option.Some(42)")
    
    empty = Option.None
    io.println("Created Option.None")
    
    // Test 2: Pattern matching
    io.println("\n2. Pattern matching:")
    val ?
        | Option.Some(x) { io.println("  Some value: ${x}") }
        | Option.None { io.println("  Empty") }
    
    empty ?
        | Option.Some(y) { io.println("  Some value: ${y}") }
        | Option.None { io.println("  Empty value") }
    
    // Test 3: Different data types
    io.println("\n3. Different types in Option:")
    str_opt = Option.Some("hello")
    str_opt ?
        | Option.Some(s) { io.println("  String: ${s}") }
        | Option.None { io.println("  No StaticString") }
    
    // Test 4: Option arithmetic  
    io.println("\n4. Option arithmetic:")
    opt1 = Option.Some(10)
    opt2 = Option.Some(20)
    
    result = opt1 ?
        | Option.Some(a) {
            opt2 ?
                | Option.Some(b) { Option.Some(a + b) }
                | Option.None { Option.None }
        }
        | Option.None { Option.None }
    
    result ?
        | Option.Some(r) { io.println("  10 + 20 = ${r}") }
        | Option.None { io.println("  Failed") }
    
    // Test 5: Multiple Option.None checks
    io.println("\n5. Multiple Option.None patterns:")
    none1 = Option.None
    none2 = Option.None
    
    none1 ?
        | Option.Some(x) { io.println("  First has value: ${x}") }
        | Option.None { io.println("  First is Option.None") }
    
    none2 ?
        | Option.Some(y) { io.println("  Second has value: ${y}") }
        | Option.None { io.println("  Second is Option.None") }
    
    // Test 6: Option with blocks
    io.println("\n6. Option with block expressions:")
    computed = {
        temp = Option.Some(100)
        temp ?
            | Option.Some(t) { Option.Some(t * 2) }
            | Option.None { Option.None }
    }
    
    computed ?
        | Option.Some(v) { io.println("  Computed: ${v}") }
        | Option.None { io.println("  No value") }
    
    // Test 7: Chained Option operations
    io.println("\n7. Chained Option operations:")
    chain = Option.Some(5)
    doubled = chain ?
        | Option.Some(n) { Option.Some(n * 2) }
        | Option.None { Option.None }
    
    doubled ?
        | Option.Some(d) { io.println("  5 * 2 = ${d}") }
        | Option.None { io.println("  Failed") }
    
    // Test 8: Option extraction
    io.println("\n8. Option extraction:")
    extract_test = Option.Some(999)
    extract_test ?
        | Option.Some(extracted) {
            io.println("  Extracted: ${extracted}")
            extracted_doubled = extracted * 2
            io.println("  Doubled: ${extracted_doubled}")
        }
        | Option.None { io.println("  Nothing to extract") }
    
    io.println("\n=== All Option tests passed ===")
}