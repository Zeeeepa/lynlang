// End-to-end test for self-hosted Zen compiler
// Tests the complete compilation pipeline using Zen-written components

// Import standard library modules
io = @std
test = @std
fs = @std

// Import compiler components
lexer = @std
parser = @std
type_checker = @std
codegen = @std

// Test program source code
const TEST_PROGRAM: string = `
    // Simple test program
    io = @std
    
    main = ()  {
        message: string = "Hello from self-hosted compiler!"
        io.println(message)
        
        count: i32 = 0
        loop {
            if count >= 5 {
                break
            }
            io.print("Count: ")
            io.println(count)
            count = count + 1
        }
    }
`

// Test lexical analysis
test_lexer = ()  {
    test.describe("Lexer Tests")
    
    // Create lexer instance
    lex := lexer.new(TEST_PROGRAM)
    
    // Tokenize the program
    tokens := lex.tokenize()
    
    // Verify token count
    test.assert(tokens.len() > 0, "Should produce tokens")
    
    // Check for specific tokens
    has_fn := false
    has_main := false
    has_loop := false
    
    for token in tokens {
        token.kind ?
            .Keyword("fn") => has_fn = true
            .Identifier("main") => has_main = true
            .Keyword("loop") => has_loop = true
            _ => {}
        }
    }
    
    test.assert(has_fn, "Should have function declaration")
    test.assert(has_main, "Should have main identifier")
    test.assert(has_loop, "Should have loop keyword")
}

// Test parsing
test_parser = ()  {
    test.describe("Parser Tests")
    
    // Create lexer and parser
    lex := lexer.new(TEST_PROGRAM)
    tokens := lex.tokenize()
    p := parser.new(tokens)
    
    // Parse the program
    ast := p.parse()
    
    // Verify AST structure
    test.assert(ast.declarations.len() > 0, "Should have declarations")
    
    // Find main function
    main_func := null
    for decl in ast.declarations {
        decl ?
            .Function(f) if f.name == "main" => main_func = f
            _ => {}
        }
    }
    
    test.assert(main_func != null, "Should have main function")
    test.assert(main_func.body.len() > 0, "Main should have body")
}

// Test type checking
test_type_checker = ()  {
    test.describe("Type Checker Tests")
    
    // Create full pipeline
    lex := lexer.new(TEST_PROGRAM)
    tokens := lex.tokenize()
    p := parser.new(tokens)
    ast := p.parse()
    
    // Type check the AST
    tc := type_checker.new()
    typed_ast := tc.check(ast)
    
    // Verify no type errors
    test.assert(tc.errors.len() == 0, "Should have no type errors")
    
    // Verify types are assigned
    for decl in typed_ast.declarations {
        decl ?
            .Function(f) => {
                test.assert(f.return_type != null, "Function should have return type")
                for param in f.parameters {
                    test.assert(param.type != null, "Parameters should have types")
                }
            }
            _ => {}
        }
    }
}

// Test code generation
test_codegen = ()  {
    test.describe("Code Generation Tests")
    
    // Create full pipeline
    lex := lexer.new(TEST_PROGRAM)
    tokens := lex.tokenize()
    p := parser.new(tokens)
    ast := p.parse()
    tc := type_checker.new()
    typed_ast := tc.check(ast)
    
    // Generate code
    gen := codegen.new("test_output")
    output := gen.generate(typed_ast)
    
    // Verify output
    test.assert(output != null, "Should generate output")
    test.assert(output.len() > 0, "Output should not be empty")
    
    // Check for expected LLVM IR patterns
    test.assert(output.contains("define"), "Should have function definitions")
    test.assert(output.contains("@main"), "Should have main function")
    test.assert(output.contains("br "), "Should have branch instructions for loop")
}

// Test full compilation pipeline
test_full_pipeline = ()  {
    test.describe("Full Pipeline Test")
    
    // Create temporary file for test program
    test_file := "test_program.zen"
    fs.write_file(test_file, TEST_PROGRAM)
    
    // Compile the program
    result := compile_file(test_file)
    
    // Verify compilation succeeded
    test.assert(result.is_ok(), "Compilation should succeed")
    
    // Clean up
    fs.remove_file(test_file)
    if result.is_ok() {
        fs.remove_file(result.unwrap())
    }
}

// Helper function to compile a file
compile_file = (path: string) Result<string, string>   {
    // Read source file
    source := fs.read_file(path)?
    
    // Lexical analysis
    lex := lexer.new(source)
    tokens := lex.tokenize()
    
    // Parsing
    p := parser.new(tokens)
    ast := p.parse()
    
    // Type checking
    tc := type_checker.new()
    typed_ast := tc.check(ast)
    
    if tc.errors.len() > 0 {
        return Err("Type checking failed")
    }
    
    // Code generation
    output_file := path.replace(".zen", ".ll")
    gen := codegen.new(output_file)
    gen.generate(typed_ast)
    
    return Ok(output_file)
}

// Main test runner
main = ()  {
    io.println("Running Self-Hosted Compiler Tests")
    io.println("===================================")
    
    test_lexer()
    test_parser()
    test_type_checker()
    test_codegen()
    test_full_pipeline()
    
    io.println("")
    io.println("All tests passed!")
}