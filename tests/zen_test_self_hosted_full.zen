// Comprehensive Test Suite for Self-Hosted Zen Compiler
// Tests all major components: lexer, parser, type checker, and codegen

// Import all compiler modules
io = @std.io
lexer = @std.lexer
parser = @std.parser
type_checker = @std.type_checker
codegen = @std.codegen
string = @std.string
mem = @std.mem

// Test the lexer component
test_lexer = () bool   {
    io.print("Testing lexer...\n")
    
    // Test basic tokenization
    input := "x := 42 + 3.14"
    lex := lexer.lexer_new(input)
    
    // Get first token (identifier)
    tok1 := lexer.lexer_next_token(&lex)
    tok1.token_type match {
        | Identifier { io.print("✓ Identifier token recognized\n") }
        | _ {
            io.print("✗ Expected identifier, got other token\n")
            return false
        }
    }
    
    // Get assignment operator
    tok2 := lexer.lexer_next_token(&lex)
    tok2.token_type match {
        | Symbol { io.print("✓ Assignment operator recognized\n") }
        | _ {
            io.print("✗ Expected symbol token\n")
            return false
        }
    }
    
    // Get integer literal
    tok3 := lexer.lexer_next_token(&lex)
    tok3.token_type match {
        | Integer { io.print("✓ Integer literal recognized\n") }
        | _ {
            io.print("✗ Expected integer token\n")
            return false
        }
    }
    
    io.print("✓ Lexer tests passed\n")
    return true
}

// Test the parser component
test_parser = () bool   {
    io.print("Testing parser...\n")
    
    // Parse a simple expression
    input := "x := 42"
    lex := lexer.lexer_new(input)
    p := parser.parser_new(&lex)
    
    // Parse statement
    stmt := parser.parser_parse_statement(&p)
    stmt match {
        | null {
            io.print("✗ Failed to parse statement\n")
            return false
        }
        | _ { io.print("✓ Statement parsed successfully\n") }
    }
    
    // Parse function definition
    func_input := "add = (a: i32, b: i32) i32 { return a + b }"
    func_lex := lexer.lexer_new(func_input)
    func_parser := parser.parser_new(&func_lex)
    
    func := parser.parser_parse_function(&func_parser)
    func match {
        | null {
            io.print("✗ Failed to parse function\n")
            return false
        }
        | _ { io.print("✓ Function parsed successfully\n") }
    }
    
    io.print("✓ Parser tests passed\n")
    return true
}

// Test the type checker component
test_type_checker = () bool   {
    io.print("Testing type checker...\n")
    
    // Create type environment
    env := type_checker.type_env_new(null)
    checker := type_checker.type_checker_new(env)
    
    // Test type inference
    // Simple integer literal should infer to i32
    int_expr := parser.make_integer_expression(42)
    int_type := type_checker.infer_expression_type(&checker, int_expr)
    
    int_type match {
        | I32 { io.print("✓ Integer type inference correct\n") }
        | _ {
            io.print("✗ Integer type inference failed\n")
            return false
        }
    }
    
    // Test binary operation type checking
    // Both operands must have same type
    add_expr := parser.make_binary_expression(
        parser.make_integer_expression(1),
        parser.BinaryOperator.Add,
        parser.make_integer_expression(2)
    )
    
    add_type := type_checker.infer_expression_type(&checker, add_expr)
    add_type match {
        | I32 { io.print("✓ Binary operation type checking correct\n") }
        | _ {
            io.print("✗ Binary operation type checking failed\n")
            return false
        }
    }
    
    io.print("✓ Type checker tests passed\n")
    return true
}

// Test the code generator component
test_codegen = () bool   {
    io.print("Testing code generator...\n")
    
    // Create code generator
    gen := codegen.codegen_new("test_module")
    
    // Generate code for a simple function
    // main = () i32 { return 0 }
    main_func := codegen.codegen_function(&gen, "main", [], codegen.LLVMType.I32)
    
    // Generate return instruction
    zero_val := codegen.make_const_int32(0)
    codegen.codegen_return(&gen, zero_val)
    
    // Verify generated code
    ir := codegen.codegen_get_ir(&gen)
    string.contains(ir, "define i32 @main()") match {
        | true { io.print("✓ Function declaration generated\n") }
        | false {
            io.print("✗ Function declaration not generated\n")
            return false
        }
    }
    
    string.contains(ir, "ret i32 0") match {
        | true { io.print("✓ Return instruction generated\n") }
        | false {
            io.print("✗ Return instruction not generated\n")
            return false
        }
    }
    
    io.print("✓ Code generator tests passed\n")
    return true
}

// Test integration of all components
test_integration = () bool   {
    io.print("Testing full compilation pipeline...\n")
    
    // Compile a simple program
    program := "
        add = (a: i32, b: i32) i32   {
            return a + b
        }
        
        main = () i32   {
            result := add(10, 20)
            return result
        }
    "
    
    // Lex the program
    lex := lexer.lexer_new(program)
    
    // Parse the program
    p := parser.parser_new(&lex)
    ast := parser.parser_parse_program(&p)
    
    ast match {
        | null {
            io.print("✗ Failed to parse program\n")
            return false
        }
        | _ { io.print("✓ Program parsed successfully\n") }
    }
    
    // Type check the program
    env := type_checker.type_env_new(null)
    checker := type_checker.type_checker_new(env)
    
    type_checker.check_program(&checker, ast) match {
        | true { io.print("✓ Type checking passed\n") }
        | false {
            io.print("✗ Type checking failed\n")
            return false
        }
    }
    
    // Generate code for the program
    gen := codegen.codegen_new("test")
    codegen.codegen_program(&gen, ast)
    
    ir := codegen.codegen_get_ir(&gen)
    
    // Verify generated code contains expected elements
    string.contains(ir, "@add") && 
    string.contains(ir, "@main") &&
    string.contains(ir, "call") match {
        | true { io.print("✓ Code generation successful\n") }
        | false {
            io.print("✗ Code generation incomplete\n")
            return false
        }
    }
    
    io.print("✓ Integration test passed\n")
    return true
}

// Main test runner
main = () i32   {
    io.print("=== Self-Hosted Compiler Test Suite ===\n\n")
    
    passed := 0
    failed := 0
    
    // Run lexer tests
    test_lexer() match {
        | true { passed = passed + 1 }
        | false { failed = failed + 1 }
    }
    
    io.print("\n")
    
    // Run parser tests
    test_parser() match {
        | true { passed = passed + 1 }
        | false { failed = failed + 1 }
    }
    
    io.print("\n")
    
    // Run type checker tests
    test_type_checker() match {
        | true { passed = passed + 1 }
        | false { failed = failed + 1 }
    }
    
    io.print("\n")
    
    // Run code generator tests
    test_codegen() match {
        | true { passed = passed + 1 }
        | false { failed = failed + 1 }
    }
    
    io.print("\n")
    
    // Run integration tests
    test_integration() match {
        | true { passed = passed + 1 }
        | false { failed = failed + 1 }
    }
    
    io.print("\n========================================\n")
    io.print("Results: ")
    io.print_int(passed)
    io.print(" passed, ")
    io.print_int(failed)
    io.print(" failed\n")
    
    failed == 0 match {
        | true {
            io.print("✓ All tests passed!\n")
            return 0
        }
        | false {
            io.print("✗ Some tests failed\n")
            return 1
        }
    }
}