// Comprehensive test of LANGUAGE_SPEC.zen features that are currently working
// This matches the main function structure from LANGUAGE_SPEC.zen as closely as possible

{ io } = @std

// Option type (line 110-111 from spec)
Option<T>: Some(T) | None

// Result type for error handling (line 113-114 from spec)  
Result<T, E>: Ok(T) | Err(E)

// Simple struct (line 117-121 from spec)
Point: {
    x:: f64,
    y:: f64 = 0.0
}

// Functions demonstrating UFC
double = (n: i32) i32 {
    return n * 2
}

triple = (n: i32) i32 {
    return n * 3
}

// Function with defer
test_defer = () void {
    io.println("  Starting function")
    @this.defer(io.println("  Cleaning up (deferred)"))
    io.println("  Working...")
}

main = () void {
    io.println("=== LANGUAGE_SPEC.zen Working Features Demo ===")
    io.println("")
    
    // Variable declarations (lines 298-306 from spec)
    io.println("1. Variable declarations (all forms):")
    x: i32              // forward declaration
    x = 10              // assignment
    y = 20              // immutable inference
    z: i32 = 30         // immutable with type
    w:: i32             // mutable forward declaration
    w = 40              // mutable assignment
    v ::= 50            // mutable inference
    u:: i32 = 60        // mutable with type
    
    io.println("  x = ${x}")
    io.println("  y = ${y}")
    io.println("  z = ${z}")
    io.println("  w = ${w}")
    
    // Mutable variables can be changed
    v = 55
    u = 65
    w = 45
    io.println("  v (changed) = ${v}")
    io.println("  u (changed) = ${u}")
    io.println("  w (changed) = ${w}")
    
    // Option types (line 362 from spec)
    io.println("")
    io.println("2. Option types (no null!):")
    maybe_num: Option<i32> = Some(42)
    maybe_num ? 
        | Some(n) { io.println("  Got value: ${n}") }
        | None { io.println("  Got None") }
    
    nothing: Option<i32> = None
    nothing ?
        | Some(n) { io.println("  Value: ${n}") }
        | None { io.println("  Got None as expected") }
    
    // Result types
    io.println("")
    io.println("3. Result types for error handling:")
    success: Result<i32, string> = Ok(100)
    success ?
        | Ok(val) { io.println("  Success: ${val}") }
        | Err(e) { io.println("  Error: ${e}") }
    
    failure: Result<i32, string> = Err("Something went wrong")
    failure ?
        | Ok(val) { io.println("  Success: ${val}") }
        | Err(e) { io.println("  Error: ${e}") }
    
    // Pattern matching (line 351 from spec)
    io.println("")
    io.println("4. Pattern matching with ? operator:")
    is_ready = true
    is_ready ? {
        io.println("  Ready! (bool pattern short form)")
    }
    
    has_data = false
    has_data ?
        | true { io.println("  Has data") }
        | false { io.println("  No data (if-else pattern)") }
    
    // UFC (Uniform Function Call) - Key feature!
    io.println("")
    io.println("5. UFC (Uniform Function Call):")
    io.println("  Traditional: double(5) = ${double(5)}")
    io.println("  UFC style: 5.double() = ${5.double()}")
    io.println("  Chaining: 5.double().triple() = ${5.double().triple()}")
    
    // Loops (line 452 from spec)
    io.println("")
    io.println("6. Loops:")
    
    // Infinite loop with break
    io.println("  Infinite loop with break:")
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter > 3 ?
            | true { break }
            | false { io.println("    Count: ${counter}") }
    })
    
    // Range loop (line 431 from spec)
    io.println("  Range loop (0..5):")
    (0..5).loop((i) {
        io.println("    ${i}")
    })
    
    // Structs (line 340 from spec)
    io.println("")
    io.println("7. Structs:")
    p = Point { x: 10.0, y: 20.0 }
    io.println("  Point.x = ${p.x}")
    io.println("  Point.y = ${p.y}")
    
    // Mutable struct fields
    p.x = 15.0
    p.y = 25.0
    io.println("  After mutation: x = ${p.x}, y = ${p.y}")
    
    // @this.defer (line 217, 384, 414 from spec)
    io.println("")
    io.println("8. @this.defer statement:")
    test_defer()
    
    // String interpolation (line 389 from spec)
    io.println("")
    io.println("9. String interpolation:")
    name = "Zen"
    version = 1
    io.println("  Language: ${name}, Version: ${version}")
    
    // Standard library (@std)
    io.println("")
    io.println("10. Standard library access:")
    io.println("  Using @std.io for all printing")
    
    io.println("")
    io.println("=== All tests complete! ===")
}