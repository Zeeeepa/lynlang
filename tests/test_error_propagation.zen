// Test error propagation patterns in Zen
{io, Result, Error, Array, get_default_allocator} = @std

// Example file operations that can fail
FileError:
    NotFound
    | PermissionDenied  
    | IOError

// Mock file read that returns Result
read_file = (path: StaticString) Result<StaticString, FileError> {
    // Simulate different file scenarios
    path == "valid.txt" ? {
        return Result.Ok("File contents here")
    }
    path == "missing.txt" ? {
        return Result.Err(FileError.NotFound)
    }
    path == "protected.txt" ? {
        return Result.Err(FileError.PermissionDenied)
    }
    return Result.Err(FileError.IOError)
}

// Parse configuration from StaticString
parse_config = (content: StaticString) Result<i32, StaticString> {
    content == "File contents here" ? {
        return Result.Ok(42)
    }
    return Result.Err("Invalid config format")
}

// Manual error propagation (current approach)
load_config_manual = (path: StaticString) Result<i32, StaticString> {
    io.println("Loading config manually from: ${path}")
    
    // Read file with explicit error handling
    file_result ::= read_file(path)
    file_result ?
        | .Ok(content) {
            io.println("  File read successfully")
            // Parse the content
            parse_result ::= parse_config(content)
            parse_result ?
                | .Ok(value) {
                    io.println("  Config parsed: ${value}")
                    return Result.Ok(value)
                }
                | .Err(error) {
                    io.println("  Parse error: ${error}")
                    return Result.Err(error)
                }
        }
        | .Err(error) {
            error_msg ::= error ?
                | .NotFound { "File not found" }
                | .PermissionDenied { "Permission denied" }
                | .IOError { "IO error occurred" }
            io.println("  File error: ${error_msg}")
            return Result.Err(error_msg)
        }
}

// Simulated .raise() approach (what it would look like with compiler support)
// This demonstrates the intended usage pattern
load_config_with_raise_simulation = (path: StaticString) Result<i32, StaticString> {
    io.println("Loading config with raise simulation from: ${path}")
    
    // This simulates what .raise() would do:
    // file_content := read_file(path).raise()  // Would return early on error
    // config := parse_config(file_content).raise()  // Would return early on error
    // return Result.Ok(config)
    
    // For now, we use the propagate helper
    file_result ::= read_file(path)
    file_result ?
        | .Ok(content) {
            io.println("  File read successfully")
            return parse_config(content)
        }
        | .Err(error) {
            error_msg ::= error ?
                | .NotFound { "File not found" }
                | .PermissionDenied { "Permission denied" }
                | .IOError { "IO error occurred" }
            io.println("  File error: ${error_msg}")
            return Result.Err(error_msg)
        }
}

// Chain multiple operations using combinators  
// process_files = (paths: Array<StaticString>) Result<i32, StaticString> {
//     io.println("Processing multiple files")
//     
//     // For now, just process a fixed set of paths
//     // Array.len() is not yet implemented
//     total ::= 0
// Note: Commented out for now as Array indexing is not yet implemented
process_files = () Result<i32, StaticString> {
    io.println("Processing multiple files")
    
    total ::= 0
    
    // Process first file if it exists
    config_result ::= load_config_manual("valid.txt")
    config_result ?
        | .Ok(value) {
            total = total + value
        }
        | .Err(error) {
            return Result.Err("Failed processing file: ${error}")
        }
    
    return Result.Ok(total)
}

// Test the Result methods
test_result_methods = () void {
    io.println("\n▶ Testing Result methods:")
    
    ok_result ::= Result.Ok(10)
    err_result ::= Result.Err("Something went wrong")
    
    // Note: is_ok, is_err, unwrap_or, map, and_then methods are not yet implemented
    // Just test basic pattern matching for now
    
    io.println("  Testing OK result:")
    ok_result ?
        | .Ok(val) { io.println("    Value: ${val}") }
        | .Err(_) { io.println("    Error (unexpected)") }
    
    io.println("  Testing Err result:")
    err_result ?
        | .Ok(_) { io.println("    Value (unexpected)") }
        | .Err(msg) { io.println("    Error: ${msg}") }
}

main = () i32 {
    alloc = get_default_allocator()
    io.println("╔════════════════════════════════════════╗")
    io.println("║   ERROR PROPAGATION TEST SUITE        ║")
    io.println("╚════════════════════════════════════════╝")
    
    // Test manual error handling
    io.println("\n▶ Testing manual error propagation:")
    
    result1 ::= load_config_manual("valid.txt")
    result1 ?
        | .Ok(value) { io.println("✓ Success: got value ${value}") }
        | .Err(error) { io.println("✗ Error: ${error}") }
    
    result2 ::= load_config_manual("missing.txt")
    result2 ?
        | .Ok(value) { io.println("✓ Success: got value ${value}") }
        | .Err(error) { io.println("✗ Error: ${error}") }
    
    // Test simulated raise approach
    io.println("\n▶ Testing raise simulation:")
    
    result3 ::= load_config_with_raise_simulation("valid.txt")
    result3 ?
        | .Ok(value) { io.println("✓ Success: got value ${value}") }
        | .Err(error) { io.println("✗ Error: ${error}") }
    
    result4 ::= load_config_with_raise_simulation("protected.txt")
    result4 ?
        | .Ok(value) { io.println("✓ Success: got value ${value}") }
        | .Err(error) { io.println("✗ Error: ${error}") }
    
    // Test processing multiple files
    io.println("\n▶ Testing batch processing:")
    
    // Note: Array literals not yet supported, so we call process_files without arguments
    batch_result ::= process_files()
    batch_result ?
        | .Ok(total) { io.println("✓ Batch success: total = ${total}") }
        | .Err(error) { io.println("✗ Batch error: ${error}") }
    
    // Test Result methods
    test_result_methods()
    
    io.println("\n╔════════════════════════════════════════╗")
    io.println("║   ALL TESTS COMPLETED                 ║")
    io.println("╚════════════════════════════════════════╝")
    
    return 0
}