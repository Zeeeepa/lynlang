// Test features that are currently implemented
{ io } = @std

// Test struct
Point: {
    x:: f64,
    y:: f64
}

// Test function
calculate_distance = (p1: Point, p2: Point) f64 {
    dx = p2.x - p1.x
    dy = p2.y - p1.y
    return dx * dx + dy * dy  // squared distance
}

main = () void {
    io.println("=== Testing Current Zen Features ===")
    
    // Test variables (all forms)
    x:: i32
    x = 10
    y = 20           // Immutable
    z: i32 = 30      // With type
    w:: i32          // Mutable forward
    w = 40
    v ::= 50         // Mutable
    u:: i32 = 60     // Mutable with type
    
    io.println("Variables: x=${x}, y=${y}, z=${z}, w=${w}, v=${v}, u=${u}")
    
    // Test struct creation and access
    p1 = Point { x: 0.0, y: 0.0 }
    p2 = Point { x: 3.0, y: 4.0 }
    
    io.println("Point 1: (${p1.x}, ${p1.y})")
    io.println("Point 2: (${p2.x}, ${p2.y})")
    
    // Test function call
    dist_sq = calculate_distance(p1, p2)
    io.println("Distance squared: ${dist_sq}")
    
    // Test boolean pattern matching
    is_ready = true
    is_ready ? {
        io.println("System is ready!")
    }
    
    has_data = false
    has_data ?
        | true { io.println("Processing data...") }
        | false { io.println("Waiting for data...") }
    
    // Test range loop
    io.println("Counting 0 to 4:")
    (0..5).loop((i) {
        io.println("  ${i}")
    })
    
    // Test step range
    io.println("Counting by 2s:")
    (0..10).step(2).loop((i) {
        io.println("  ${i}")
    })
    
    // Test infinite loop with break
    counter ::= 0
    io.println("Counting with infinite loop:")
    loop(() {
        io.println("  Counter: ${counter}")
        counter = counter + 1
        counter >= 3 ? {
            break
        }
    })
    
    io.println("All tests completed!")
}