// ============================================================================
// LANGUAGE_SPEC.zen Validation Test Suite
// Tests all features defined in LANGUAGE_SPEC.zen that are currently working
// ============================================================================

{ io, math } = @std

// ============================================================================
// CORE DESIGN PRINCIPLES FROM LANGUAGE_SPEC.zen
// ============================================================================

// 1. No keywords: No if/else/while/for/match/async/await/impl/trait/class/interface/null
// 2. Only two @ symbols: @std and @this
// 3. Pattern matching with ? operator
// 4. UFC (Uniform Function Call) - any function can be called as method
// 5. Allocators determine sync/async behavior
// 6. Explicit pointer types: Ptr<>, MutPtr<>, RawPtr<>
// 7. No null/nil - only Option<T>
// 8. No unions, no tuples - only structs and enums
// 9. Assignment operators: =, ::=, :, ::
// 10. Error propagation with .raise()
// 11. Loops: loop(), .loop(), ranges
// 12. Traits via .implements() and .requires()
// 13. Compile-time metaprogramming

// ============================================================================
// Option and Result Types (Lines 109-113)
// ============================================================================

Option<T>: Some(T) | None
Result<T, E>: Ok(T) | Err(E)

// ============================================================================
// Struct Definitions (Lines 117-163)
// ============================================================================

// Simple struct with mutable fields and defaults
Point: {
    x:: f64,
    y:: f64 = 0.0,
}

// Trait definition
Geometric: {
    area: (self) f64,
    perimeter: (self) f64,
}

Circle: {
    center: Point,
    radius: f64,
}

// Implement trait for Circle
Circle.implements(Geometric, {
    area = (self) f64 {
        return math.pi * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * math.pi * self.radius
    },
})

Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

// Implement trait for Rectangle
Rectangle.implements(Geometric, {
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return width * height
    },
    perimeter = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return 2.0 * (width + height)
    },
})

// Enum type that requires trait (Line 165-168)
Shape: Circle | Rectangle
Shape.requires(Geometric)

// ============================================================================
// UFC Overloading Example (Lines 171-181)
// NOTE: This feature is not yet fully implemented
// ============================================================================

// GameEntity: Player | Enemy | Powerup
// get_health = (e: GameEntity.Player) u32 { return 100 }
// get_health = (e: GameEntity.Enemy) u32 { return 50 }
// get_health = (e: GameEntity.Powerup) u32 { return 0 }

// ============================================================================
// Main Test Function (Adapted from lines 297-488)
// ============================================================================

main = () void {
    io.println("=====================================")
    io.println("   LANGUAGE_SPEC.zen Validation     ")
    io.println("=====================================")
    
    // ========================================================================
    // Variable Declarations (Lines 298-306)
    // ========================================================================
    io.println("\n=== Variable Declarations ===")
    
    x: i32  // forward declaration
    x = 10
    io.println("✓ Forward decl: x = ${x}")
    
    y = 10  // Immutable assignment
    io.println("✓ Immutable: y = ${y}")
    
    z: i32 = 20  // Immutable with type
    io.println("✓ Immutable typed: z = ${z}")
    
    w:: i32  // mutable forward declaration
    w = 20
    w = 25
    io.println("✓ Mutable forward: w = ${w}")
    
    v ::= 30  // Mutable assignment
    v = 35
    io.println("✓ Mutable: v = ${v}")
    
    u:: i32 = 40  // mutable with type
    u = 45
    io.println("✓ Mutable typed: u = ${u}")
    
    // ========================================================================
    // Struct Creation and Field Access (Lines 340-371)
    // ========================================================================
    io.println("\n=== Structs and Traits ===")
    
    circle = Circle { 
        center: Point { x: 100.0, y: 100.0 }, 
        radius: 50.0
    }
    io.println("✓ Circle created: radius = ${circle.radius}")
    io.println("  Area: ${circle.area()}")
    io.println("  Perimeter: ${circle.perimeter()}")
    
    // Field access
    io.println("✓ Field access: center.x = ${circle.center.x}")
    
    rectangle = Rectangle {
        top_left: Point { x: 0.0, y: 10.0 },
        bottom_right: Point { x: 10.0, y: 0.0 }
    }
    io.println("✓ Rectangle area: ${rectangle.area()}")
    
    // ========================================================================
    // Pattern Matching (Lines 351-361, 408-412, 454-459)
    // ========================================================================
    io.println("\n=== Pattern Matching ===")
    
    // Boolean pattern matching
    is_ready = true
    is_ready ? {
        io.println("✓ Single branch pattern")
    }
    
    // Full pattern match
    has_data = false
    has_data ?
        | true { io.println("Has data") }
        | false { io.println("✓ Pattern match false branch") }
    
    // Option type pattern matching (Lines 461-473)
    maybe_radius: Option<f64> = Some(5.5)
    maybe_radius ?
        | Some(radius) {
            io.println("✓ Option Some: radius = ${radius}")
        }
        | None {
            io.println("No radius")
        }
    
    empty: Option<f64> = None
    empty ?
        | Some(val) { io.println("Value: ${val}") }
        | None { io.println("✓ Option None handled") }
    
    // ========================================================================
    // Loops and Ranges (Lines 431-459)
    // ========================================================================
    io.println("\n=== Loops and Ranges ===")
    
    // Range iteration
    io.print("Range (0..5): ")
    (0..5).loop((i) {
        io.print("${i} ")
    })
    io.println("")
    
    // Range with step - not yet implemented
    // (0..10).step(2).loop((i) { ... })
    
    // Infinite loop with break
    counter ::= 0
    io.print("Infinite loop: ")
    loop(() {
        io.print("${counter} ")
        counter = counter + 1
        counter > 3 ?
            | true { break }
            | false { }
    })
    io.println("")
    
    // ========================================================================
    // String Interpolation (Throughout the file)
    // ========================================================================
    io.println("\n=== String Interpolation ===")
    
    language = "Zen"
    version = 1.0
    features = 13
    
    summary = "Language: ${language}, Version: ${version}, Features: ${features}"
    io.println("✓ ${summary}")
    
    // ========================================================================
    // UFC Examples - Not yet fully implemented
    // ========================================================================
    io.println("\n=== UFC Status ===")
    io.println("✓ Basic UFC works (method calls on structs)")
    io.println("⚠ UFC overloading on enum variants not yet implemented")
    
    io.println("\n=====================================")
    io.println("    ✓ LANGUAGE_SPEC Validated       ")
    io.println("=====================================")
}