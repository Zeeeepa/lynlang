// Self-hosted tests for Zen standard library
// Tests core functionality written in Zen

core = @std
{ Vec, DynVec } = @std
hashmap = @std
io = @std

// External functions for testing
extern printf = (format: RawPtr<i8>, ...) i32
extern puts = (str: RawPtr<i8>) i32

// Test result tracking
TestResult: {
    passed: i32,
    failed: i32,
}

// Assert helper
assert_eq = (actual: i64, expected: i64, test_name: string) bool   {
    actual == expected ? | true {
        printf("[PASS] %s\n", test_name)
        return true
    } | false {
        printf("[FAIL] %s: expected %d, got %d\n", test_name, expected, actual)
        return false
    }
}

// Test Range functionality
test_range = () bool   {
    puts("\nTesting Range...")
    passed := true
    
    // Test basic range
    r := core.range(0, 5)
    passed = passed && assert_eq(r.start, 0, "range start")
    passed = passed && assert_eq(r.end, 5, "range end")
    passed = passed && assert_eq(r.step, 1, "range step")
    
    // Test range with step
    r2 := core.range_step(0, 10, 2)
    passed = passed && assert_eq(r2.step, 2, "range custom step")
    
    // Test inclusive range
    r3 := core.range_inclusive(1, 3)
    passed = passed && assert_eq(r3.end, 4, "inclusive range end")
    
    // Test range loop with proper lambda syntax
    sum := 0
    callback = (i: i64) void   {
        sum = sum + i
    }
    core.range(0, 5).loop(callback)
    passed = passed && assert_eq(sum, 10, "range loop sum")
    
    return passed
}

// Test DynVec functionality
test_vec = () bool   {
    puts("\nTesting DynVec...")
    passed := true
    
    // Create new dynvec
    v := DynVec<i64>.new()
    passed = passed && assert_eq(v.len(), 0, "new DynVec length")
    passed = passed && assert_eq(v.is_empty() as i64, 1, "new DynVec is empty")
    
    // Push elements
    v.push(10).unwrap()
    v.push(20).unwrap()
    v.push(30).unwrap()
    passed = passed && assert_eq(v.len(), 3, "DynVec length after push")
    
    // Get elements
    elem_result := v.get(1)
    elem_result ? | core.Result:Ok(val) {
        passed = passed && assert_eq(val, 20, "DynVec get element")
    } | core.Result:Err(_) {
        passed = false
        puts("[FAIL] DynVec get returned error")
    }
    
    // Pop element
    popped := v.pop()
    popped ? | core.Option:Some(val) {
        passed = passed && assert_eq(val, 30, "DynVec pop value")
        passed = passed && assert_eq(v.len(), 2, "DynVec length after pop")
    } | core.Option:None {
        passed = false
        puts("[FAIL] DynVec pop returned None")
    }
    
    // Set element
    v.set(0, 100).unwrap()
    elem2_result := v.get(0)
    elem2_result ? | core.Result:Ok(val) {
        passed = passed && assert_eq(val, 100, "DynVec set element")
    } | core.Result:Err(_) {
        passed = false
    }
    
    // Clear DynVec
    v.clear()
    passed = passed && assert_eq(v.len(), 0, "DynVec length after clear")
    
    // Free DynVec
    v.free()
    
    return passed
}

// Test HashMap functionality
test_hashmap = () bool   {
    puts("\nTesting HashMap...")
    passed := true
    
    // Create new hashmap
    map := hashmap.hashmap_new<i64, i64>(hashmap.hash_i64, hashmap.eq_i64)
    passed = passed && assert_eq(hashmap.hashmap_len(&map), 0, "new hashmap length")
    passed = passed && assert_eq(hashmap.hashmap_is_empty(&map) as i64, 1, "new hashmap is empty")
    
    // Insert key-value pairs
    hashmap.hashmap_insert(&map, 1, 100)
    hashmap.hashmap_insert(&map, 2, 200)
    hashmap.hashmap_insert(&map, 3, 300)
    passed = passed && assert_eq(hashmap.hashmap_len(&map), 3, "hashmap length after insert")
    
    // Get value
    val := hashmap.hashmap_get(&map, 2)
    val ? | core.Option:Some(v) {
        passed = passed && assert_eq(v, 200, "hashmap get value")
    } | core.Option:None {
        passed = false
        puts("[FAIL] hashmap get returned None")
    }
    
    // Check contains
    contains := hashmap.hashmap_contains(&map, 1)
    passed = passed && assert_eq(contains as i64, 1, "hashmap contains key")
    
    not_contains := hashmap.hashmap_contains(&map, 10)
    passed = passed && assert_eq(not_contains as i64, 0, "hashmap doesn't contain key")
    
    // Remove key
    removed := hashmap.hashmap_remove(&map, 2)
    removed ? | core.Option:Some(v) {
        passed = passed && assert_eq(v, 200, "hashmap remove value")
        passed = passed && assert_eq(hashmap.hashmap_len(&map), 2, "hashmap length after remove")
    } | core.Option:None {
        passed = false
        puts("[FAIL] hashmap remove returned None")
    }
    
    // Clear hashmap
    hashmap.hashmap_clear(&map)
    passed = passed && assert_eq(hashmap.hashmap_len(&map), 0, "hashmap length after clear")
    
    // Free hashmap
    hashmap.hashmap_free(&map)
    
    return passed
}

// Test min/max functions
test_min_max = () bool   {
    puts("\nTesting min/max...")
    passed := true
    
    passed = passed && assert_eq(core.min(5, 10), 5, "min of 5 and 10")
    passed = passed && assert_eq(core.min(-5, 5), -5, "min of -5 and 5")
    passed = passed && assert_eq(core.max(5, 10), 10, "max of 5 and 10")
    passed = passed && assert_eq(core.max(-5, 5), 5, "max of -5 and 5")
    
    return passed
}

// Test abs function
test_abs = () bool   {
    puts("\nTesting abs...")
    passed := true
    
    passed = passed && assert_eq(core.abs(5), 5, "abs of positive")
    passed = passed && assert_eq(core.abs(-5), 5, "abs of negative")
    passed = passed && assert_eq(core.abs(0), 0, "abs of zero")
    
    return passed
}

// Main test runner
main = () i32   {
    puts("=== Zen Standard Library Self-Hosted Tests ===")
    
    results := TestResult {
        passed: 0,
        failed: 0,
    }
    
    // Run tests
    test_range() ? | true {
        results.passed = results.passed + 1
    } | false {
        results.failed = results.failed + 1
    }
    
    test_vec() ? | true {
        results.passed = results.passed + 1
    } | false {
        results.failed = results.failed + 1
    }
    
    test_hashmap() ? | true {
        results.passed = results.passed + 1
    } | false {
        results.failed = results.failed + 1
    }
    
    test_min_max() ? | true {
        results.passed = results.passed + 1
    } | false {
        results.failed = results.failed + 1
    }
    
    test_abs() ? | true {
        results.passed = results.passed + 1
    } | false {
        results.failed = results.failed + 1
    }
    
    // Print summary
    puts("\n=== Test Summary ===")
    printf("Passed: %d\n", results.passed)
    printf("Failed: %d\n", results.failed)
    
    results.failed == 0 ? | true {
        puts("\nAll tests passed! 🎉")
        return 0
    } | false {
        puts("\nSome tests failed!")
        return 1
    }
}