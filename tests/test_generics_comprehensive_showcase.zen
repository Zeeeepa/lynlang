// Comprehensive showcase of working generic features in Zen
// Demonstrates deeply nested generics, type inference, and payload extraction
{ io, Result, Option, HashMap, Array , get_default_allocator } = @std

main = () void {
    alloc = get_default_allocator()
    io.println("=== Comprehensive Generic Features Showcase ===\n")
    
    // ========== SECTION 1: Deeply Nested Generics ==========
    io.println("▸ DEEPLY NESTED GENERICS:")
    
    // 1.1: Quadruple nested Results - fixed!
    io.println("  • Quadruple nested: Result<Result<Result<Result<i32,E>,E>,E>,E>")
    quad_nested = () Result<Result<Result<Result<i32, StaticString>, StaticString>, StaticString>, StaticString> {
        Result.Ok(Result.Ok(Result.Ok(Result.Ok(42))))
    }
    q = quad_nested()
    q1 = q.raise()
    q2 = q1.raise()
    q3 = q2.raise()
    q4 = q3.raise()
    io.println("    Value extracted: ${q4} ✓")
    
    // 1.2: Mixed Option and Result nesting
    io.println("  • Mixed nesting: Option<Result<Option<Result<i32,E>>,E>>")
    mixed_nested = () Option<Result<Option<Result<i32, StaticString>>, StaticString>> {
        Option.Some(Result.Ok(Option.Some(Result.Ok(100))))
    }
    m = mixed_nested()
    m ?
        | Option.Some(res1) {
            opt = res1.raise()
            opt ?
                | Option.Some(res2) {
                    val = res2.raise()
                    io.println("    Value extracted: ${val} ✓")
                }
                | Option.None { io.println("    Error: Got None") }
        }
        | Option.None { io.println("    Error: Got None") }
    
    // ========== SECTION 2: Generic Type Inference ==========
    io.println("\n▸ GENERIC TYPE INFERENCE:")
    
    // 2.1: HashMap with i32 keys (easier than StaticString)
    io.println("  • HashMap<i32, StaticString> operations:")
    map = HashMap<i32, StaticString>(alloc)
    map.insert(1, "one")
    map.insert(2, "two")
    
    val1 = map.get(1)
    val1 ?
        | Option.Some(v) { io.println("    map[1] = '${v}' ✓") }
        | Option.None { io.println("    key 1 not found") }
    
    val2 = map.get(2)
    val2 ?
        | Option.Some(v) { io.println("    map[2] = '${v}' ✓") }
        | Option.None { io.println("    key 2 not found") }
    
    // 2.2: Array operations with generics
    io.println("  • Array<i32> operations:")
    arr = Array.new(alloc, 10, 0)  // size 10, initialized with 0
    arr.set(0, 10)
    arr.set(1, 20)
    arr.set(2, 30)
    
    io.println("    Array length: ${arr.len()}")
    io.println("    arr[0] = ${arr.get(0)} (via set/get)")
    io.println("    arr[1] = ${arr.get(1)} (via set/get)")
    io.println("    arr[2] = ${arr.get(2)} (via set/get)")
    
    // ========== SECTION 3: Numeric Methods (Fixed) ==========
    io.println("\n▸ NUMERIC METHODS (NOW WORKING):")
    
    // 3.1: abs() method
    negative = -42
    positive = negative.abs()
    io.println("  • abs(-42) = ${positive} ✓")
    
    // 3.2: min/max methods
    x = 100
    y = 50
    minimum = x.min(y)
    maximum = x.max(y)
    io.println("  • min(100, 50) = ${minimum} ✓")
    io.println("  • max(100, 50) = ${maximum} ✓")
    
    // ========== SECTION 4: Error Propagation with Generics ==========
    io.println("\n▸ ERROR PROPAGATION WITH GENERICS:")
    
    // 4.1: Chain of Result operations
    io.println("  • Chained Result operations:")
    chain_results = () Result<i32, StaticString> {
        v1 = Result.Ok(10).raise()
        v2 = Result.Ok(20).raise()
        v3 = Result.Ok(30).raise()
        Result.Ok(v1 + v2 + v3)
    }
    
    chained = chain_results()
    chained ?
        | Result.Ok(v) { io.println("    10 + 20 + 30 = ${v} ✓") }
        | Result.Err(e) { io.println("    Error: ${e}") }
    
    // ========== SECTION 5: Complex Generic Patterns ==========
    io.println("\n▸ COMPLEX GENERIC PATTERNS:")
    
    // 5.1: Result with complex error type
    io.println("  • Result<i32, Option<StaticString>>:")
    complex_error = () Result<i32, Option<StaticString>> {
        Result.Err(Option.Some("Complex error message"))
    }
    
    ce = complex_error()
    ce ?
        | Result.Ok(v) { io.println("    Got value: ${v}") }
        | Result.Err(err_opt) {
            err_opt ?
                | Option.Some(msg) { io.println("    Error: ${msg} ✓") }
                | Option.None { io.println("    Unknown error") }
        }
    
    // 5.2: Option<Option<i32>> double wrapping
    io.println("  • Option<Option<i32>>:")
    double_option = Option.Some(Option.Some(555))
    double_option ?
        | Option.Some(inner) {
            inner ?
                | Option.Some(val) { io.println("    Value: ${val} ✓") }
                | Option.None { io.println("    Inner None") }
        }
        | Option.None { io.println("    Outer None") }
    
    io.println("\n=== All Generic Features Working Successfully! ===")
}