// Test file for enhanced LSP features
// This file demonstrates UFC method resolution, allocator warnings, and semantic tokens

import memory_unified (get_default_allocator)
import collections/hashmap (HashMap)
import vec (DynVec, Vec)
import string (String, StaticString)
import core/option (Option)
import core/result (Result)

// Test 1: UFC method resolution with nested generics
fn test_ufc_nested_generics() {
    let result: Result<Option<String>, String> = Result.Ok(Option.Some("test"));

    // Test UFC on nested types - should resolve correctly
    result.is_ok();  // Should resolve to Result methods
    result.map_err((e) { e.to_upper() });  // Method chaining

    let opt: Option<Result<i32, String>> = Option.Some(Result.Ok(42));
    opt.is_some();  // Should resolve to Option methods
    opt.unwrap().raise();  // Nested UFC calls
}

// Test 2: Allocator warnings and quick fixes
fn test_allocator_requirements() {
    // These should trigger allocator warnings:
    let bad_map = HashMap();  // ERROR: Missing allocator
    let bad_vec = DynVec();    // ERROR: Missing allocator
    let bad_array = Array();   // ERROR: Missing allocator

    // These are correct:
    let good_map = HashMap(get_default_allocator());
    let good_vec = DynVec(get_default_allocator());

    // Test allocator-requiring methods
    good_vec.push(42);  // Should show INFO about allocating method
    good_map.insert("key", "value");  // Should show INFO
}

// Test 3: String type handling
fn test_string_types() {
    let static_str: StaticString = "compile-time string";
    let dynamic_str: String = String("runtime string", get_default_allocator());

    // UFC methods on strings
    static_str.len();
    static_str.to_upper();  // Might need allocator

    dynamic_str.concat(" more");  // Allocating operation
    dynamic_str.split(",");  // Returns Array, needs allocator
}

// Test 4: Complex UFC chains
fn test_complex_ufc_chains() {
    let data = HashMap(get_default_allocator());
    data.insert("key", Option.Some(Result.Ok([1, 2, 3])));

    // Complex UFC chain
    data.get("key")
        .unwrap()
        .unwrap()
        .raise()
        .len();  // Should resolve each method correctly
}

// Test 5: Error propagation with raise
fn test_error_propagation() Result<i32, String> {
    let maybe_value: Result<i32, String> = Result.Ok(42);

    // Test raise() for error propagation
    let value = maybe_value.raise();  // Should be highlighted specially

    Result.Ok(value * 2)
}

// Test 6: Collection methods with generics
fn test_generic_collections() {
    let vec_of_options: DynVec<Option<i32>> = DynVec(get_default_allocator());
    vec_of_options.push(Option.Some(1));
    vec_of_options.push(Option.None);

    // UFC on generic collection
    vec_of_options.len();
    vec_of_options.get(0).unwrap().is_some();

    let map_of_results: HashMap<String, Result<i32, String>> = HashMap(get_default_allocator());
    map_of_results.insert("test", Result.Ok(42));

    // UFC on values from map
    map_of_results.get("test").unwrap().is_ok();
}

// Test 7: Loop constructs with UFC
fn test_loops_with_ufc() {
    let vec = DynVec(get_default_allocator());
    vec.push(1);
    vec.push(2);
    vec.push(3);

    // UFC with loop
    vec.loop((item) {
        print(item.to_string());  // UFC on loop variable
    });

    (0..5).loop((i) {
        print(i.to_string());  // UFC in range loop
    });
}

// Test 8: Pattern matching with UFC
fn test_pattern_matching() {
    let opt = Option.Some(42);

    match opt {
        Option.Some(value) => {
            value.to_string();  // UFC in match arm
        },
        Option.None => {
            print("None");
        }
    }

    let result: Result<String, i32> = Result.Ok("test");
    match result {
        Result.Ok(s) => s.to_upper(),
        Result.Err(e) => e.to_string()
    }
}

// Main test runner
fn main() {
    test_ufc_nested_generics();
    test_allocator_requirements();
    test_string_types();
    test_complex_ufc_chains();

    match test_error_propagation() {
        Result.Ok(v) => print("Success: ", v),
        Result.Err(e) => print("Error: ", e)
    }

    test_generic_collections();
    test_loops_with_ufc();
    test_pattern_matching();

    print("All LSP feature tests completed!");
}