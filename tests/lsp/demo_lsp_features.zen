// Demo file to showcase enhanced LSP features
{io, Result, Option, get_default_allocator, HashMap, DynVec, String} = @std

main = () i32 {
    // 1. Allocator warnings - LSP should warn about missing allocator
    bad_hashmap = HashMap()      // WARNING: needs allocator
    bad_dynvec = DynVec()        // WARNING: needs allocator

    // 2. Correct usage with allocator
    alloc = get_default_allocator()
    good_map = HashMap(alloc)    // OK: has allocator
    good_vec = DynVec(alloc)     // OK: has allocator

    // 3. UFC method completion examples
    // String methods - type . after string to see completions
    text = "Hello, World!"
    len = text.len()             // UFC: string method
    upper = text.to_upper()      // UFC: string method
    has_world = text.contains("World")  // UFC: string method

    // 4. Result UFC methods
    divide = (a: i32, b: i32) Result<i32, String> {
        b == 0 ? {
            return Result.Err("Division by zero")
        }
        Result.Ok(a / b)
    }

    result = divide(10, 2)
    value = result.raise()       // UFC: Result method (propagates error)

    // 5. Option UFC methods
    find_value = () Option<i32> {
        Some(42)
    }

    opt = find_value()
    // Type opt. to see Option methods like is_some(), is_none(), unwrap()

    // 6. HashMap UFC methods
    good_map.insert("name", "Alice")   // UFC: HashMap method
    good_map.insert("age", "30")
    name = good_map.get("name")        // Returns Option<V>

    // 7. DynVec UFC methods
    good_vec.push(10)                  // UFC: DynVec method
    good_vec.push(20)
    good_vec.push(30)
    first = good_vec.get(0)            // Returns Option<T>

    // 8. Loop UFC method (works on collections)
    good_vec.loop((item) {             // UFC: loop method
        io.println("Item: ${item}")
    })

    // 9. Nested generics with UFC
    nested_result = Result.Ok(Some(100))  // Result<Option<i32>, String>
    // Type nested_result. to see Result methods

    complex_map = HashMap(alloc)          // HashMap for complex values
    complex_map.insert("data", Some(nested_result))
    data = complex_map.get("data")        // Option<Option<Result<Option<i32>, String>>>

    io.println("Demo completed successfully!")
    0
}

// Function that can be called with UFC syntax
process_string = (s: String, prefix: String) String {
    "${prefix}: ${s}"
}

// Usage: "hello".process_string("Greeting") via UFC