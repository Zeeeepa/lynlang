// Test key features from LANGUAGE_SPEC.zen
{ io, math } = @std

// Test Option type (no null!)
Option<T>: Some(T) | None

// Test Result type
Result<T, E>: Ok(T) | Err(E)

// Test struct with default values
Point: {
    x:: f64,
    y:: f64 = 0
}

// Test pattern matching
test_pattern_match = () void {
    maybe_value: Option<i32> = Some(42)
    
    maybe_value ?
        | Some(val) { io.println("Value: ${val}") }
        | None { io.println("No value") }
    
    // Boolean pattern
    is_ready = true
    is_ready ? {
        io.println("Ready!")
    }
}

// Test UFC (Uniform Function Call)
double = (x: i32) i32 { return x * 2 }

test_ufc = () void {
    value = 5
    result1 = double(value)      // Traditional
    result2 = value.double()      // UFC style
    io.println("Traditional: ${result1}, UFC: ${result2}")
}

// Test ranges and loops
test_loops = () void {
    // Range loop
    (0..3).loop((i) {
        io.println("Count: ${i}")
    })
}

// Test error handling
divide = (a: f64, b: f64) Result<f64, String> {
    b == 0 ?
        | true { return Err("Division by zero") }
        | false { return Ok(a / b) }
}

main = () void {
    io.println("=== Testing LANGUAGE_SPEC.zen features ===")
    
    // Test struct
    p = Point { x: 10.0, y: 20.0 }
    io.println("Point: x=${p.x}, y=${p.y}")
    
    // Test pattern matching
    test_pattern_match()
    
    // Test UFC
    test_ufc()
    
    // Test loops
    test_loops()
    
    // Test error handling
    result = divide(10.0, 2.0)
    result ?
        | Ok(val) { io.println("10/2 = ${val}") }
        | Err(e) { io.println("Error: ${e}") }
}