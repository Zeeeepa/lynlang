// Test .requires() trait enforcement from LANGUAGE_SPEC.zen line 168
// Shape.requires(Geometric) means all Shape variants must implement Geometric

{ io, math } = @std
{ requires, implements } = @std

// Trait definition
Geometric: {
    area: (self) f64,
    perimeter: (self) f64
}

// Circle struct
Circle: {
    center: Point,
    radius: f64
}

Point: {
    x: f64,
    y: f64
}

// Rectangle struct  
Rectangle: {
    top_left: Point,
    bottom_right: Point
}

// Implement Geometric for Circle
Circle.implements(Geometric, {
    area = (self) f64 {
        return math.pi * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * math.pi * self.radius
    }
})

// Implement Geometric for Rectangle
Rectangle.implements(Geometric, {
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return width * height
    },
    perimeter = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return 2.0 * (width + height)
    }
})

// Enum type that requires all variants implement Geometric
Shape: Circle | Rectangle

// This enforces that all Shape variants must implement Geometric
Shape.requires(Geometric)

// Generic function that accepts any Geometric type
print_area<T: Geometric>(shape: T) void {
    io.println("Area: ${shape.area()}")
}

main = () void {
    c = Circle { 
        center: Point { x: 0.0, y: 0.0 },
        radius: 5.0 
    }
    
    r = Rectangle {
        top_left: Point { x: 0.0, y: 0.0 },
        bottom_right: Point { x: 10.0, y: 5.0 }
    }
    
    // Both should work since they implement Geometric
    io.println("Circle area: ${c.area()}")
    io.println("Rectangle area: ${r.area()}")
    
    // Should also work with generic function (once generics are fully implemented)
    // print_area(c)
    // print_area(r)
}