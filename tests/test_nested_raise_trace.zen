// Trace nested Result with raise() to find the issue
{ io, Result } = @std

// Function that returns Result<Result<i32, string>, string>
get_nested = () Result<Result<i32, string>, string> {
    inner = Result.Ok(42)
    io.println("Created inner Result.Ok(42)")
    
    outer = Result.Ok(inner)
    io.println("Created outer Result.Ok(inner)")
    
    outer
}

// Test without raise - should work
test_pattern_match = () void {
    io.println("\n=== Pattern matching test ===")
    result = get_nested()
    result ? | Result.Ok(inner) => {
        io.println("Got inner from outer")
        inner ? | Result.Ok(v) => io.println("Value: ${v}")
               | Result.Err(e) => io.println("Inner error: ${e}")
    } | Result.Err(e) => io.println("Outer error: ${e}")
}

// Test with single raise
test_single_raise = () void {
    io.println("\n=== Single raise test ===")
    
    // This should extract the inner Result<i32, string>
    inner = get_nested().raise()
    io.println("After raise, got inner Result")
    
    // Now pattern match on the inner Result
    inner ? | Result.Ok(v) => io.println("Inner value: ${v}")
           | Result.Err(e) => io.println("Inner error: ${e}")
}

// Test with double raise  
test_double_raise = () Result<i32, string> {
    io.println("\n=== Double raise test ===")
    
    // First raise to get inner Result
    inner = get_nested().raise()
    io.println("First raise done")
    
    // Second raise to get value from inner
    value = inner.raise()
    io.println("Second raise done, value: ${value}")
    
    Result.Ok(value)
}

main = () i32 {
    test_pattern_match()
    test_single_raise()
    
    result = test_double_raise()
    result ? | Result.Ok(v) => {
        io.println("Final value from double raise: ${v}")
        0
    } | Result.Err(e) => {
        io.println("Error: ${e}")
        1
    }
}