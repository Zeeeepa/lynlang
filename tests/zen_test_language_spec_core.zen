// Core LANGUAGE_SPEC.zen features test
// Tests essential features from the spec

// Imports - only @std and @this are special
{ io } = @std

// Option type - no null!
Option<T>: Some(T) | None

// Result type for error handling
Result<T, E>: Ok(T) | Err(E)

// Simple struct with mutable fields
Point: {
    x:: f64,  // mutable field with ::
    y:: f64   // mutable field
}

// Circle struct
Circle: {
    center: Point,
    radius: f64
}

// Rectangle struct
Rectangle: {
    top_left: Point,
    bottom_right: Point
}

// Enum type (sum type)
Shape: Circle | Rectangle

// Area calculation for Circle
area = (c: Circle) f64 {
    return 3.14159 * c.radius * c.radius
}

// Area calculation for Rectangle  
area = (r: Rectangle) f64 {
    width = r.bottom_right.x - r.top_left.x
    height = r.bottom_right.y - r.top_left.y
    return width * height
}

// Parse radius from number
parse_radius = (val: f64) Result<f64, String> {
    val > 0.0 ?
        | true { return Ok(val) }
        | false { return Err("Radius must be positive") }
}

main = () void {
    // Variable declaration styles from spec
    x: i32        // forward declaration
    x = 10        // immutable assignment
    y = 20        // immutable assignment (type inferred)
    z : i32 = 30  // immutable with type
    w :: i32      // mutable forward declaration  
    w = 40        // assign to mutable
    v ::= 50      // mutable assignment (type inferred)
    u :: i32 = 60 // mutable with type

    // Mutable updates
    v = 55        // update mutable
    w = 45        // update mutable
    
    // Boolean pattern matching - no if/else keywords!
    is_ready = true
    is_ready ? {
        io.println("System ready!")
    }
    
    // Full boolean pattern match (if-else equivalent)
    has_data = false
    has_data ?
        | true { io.println("Processing data...") }
        | false { io.println("Waiting for data...") }
    
    // Create struct with mutable fields
    mut_point = Point { x: 1.0, y: 2.0 }
    mut_point.x = 5.0  // Can mutate x since it's defined with ::
    mut_point.y = 10.0  // Can mutate y
    
    // Option handling - no null!
    maybe_radius: Option<f64> = Some(5.5)
    maybe_radius ?
        | Some(r) {
            circle = Circle {
                center: Point { x: 100.0, y: 100.0 },
                radius: r
            }
            io.println("Circle created with radius")
        }
        | None {
            io.println("No radius provided")
        }
    
    // Result handling with error propagation
    result = parse_radius(10.0)
    result ?
        | Ok(r) { io.println("Valid radius") }
        | Err(e) { io.println("Error: invalid radius") }
    
    // Test negative radius
    bad_result = parse_radius(-5.0)
    bad_result ?
        | Ok(r) { io.println("Should not happen") }
        | Err(e) { io.println("Correctly rejected negative radius") }
    
    // Shape enum usage
    shape1 = Shape.Circle
    shape2 = Shape.Rectangle
    
    // Pattern match on Shape
    shape1 ?
        | Circle { io.println("It's a circle") }
        | Rectangle { io.println("It's a rectangle") }
    
    // Range iteration
    io.println("Counting 0 to 2:")
    (0..3).loop((i) {
        io.println("  Count iteration")
    })
    
    // Infinite loop with break
    io.println("Loop with break:")
    counter ::= 0
    loop(() {
        counter = counter + 1
        io.println("  Loop iteration")
        counter >= 3 ?
            | true { break }
            | false { }  // continue
    })
    
    // Nested pattern matching
    maybe_shape: Option<Shape> = Some(Shape.Circle)
    maybe_shape ?
        | Some(s) {
            s ?
                | Circle { io.println("Optional circle") }
                | Rectangle { io.println("Optional rectangle") }
        }
        | None {
            io.println("No shape")
        }
    
    io.println("All tests passed!")
}