// Error handling tests from LANGUAGE_SPEC.zen lines 198-211
// Tests Result type and .raise() error propagation

{io, Result, get_default_allocator} = @std

// Import Result and Option from stdlib  
{io, Result, get_default_allocator} = @std

// Parse function that returns Result (lines 198-203)
parse_radius = (s: string) Result<f64, string> {
    s.to_f64() ?
        | .Some(v) { return Result.Ok(v) }
        | .None { return Result.Err("Invalid radius") }
}

// Error propagation with .raise() (lines 205-211)
// Commented out - Config, File, json not implemented
// load_config = (path: string) Result<Config, string> {
//     file = File.open(path).raise()      // If Err, returns early
//     contents = file.read_all().raise()  // If Err, returns early
//     config = json.parse(contents).raise() // If Err, returns early
//     return Result.Ok(config)
// }

// Helper function that may fail
divide = (a: f64, b: f64) Result<f64, string> {
    b == 0 ?
        | true { return Result.Err("Division by zero") }
        | false { return Result.Ok(a / b) }
}

// Chain of operations with error handling
calculate = (x: f64, y: f64) Result<f64, string> {
    // Each .raise() will return early if error
    step1 = divide(x, y).raise()
    step2 = divide(step1, 2.0).raise()
    step3 = divide(100.0, step2).raise()
    return Result.Ok(step3)
}

// Manual error handling without .raise()
safe_calculate = (x: f64, y: f64) f64 {
    result = divide(x, y)
    result ?
        | .Ok(val1) {
            // Continue with value
            next = divide(val1, 2.0)
            next ?
                | .Ok(v2) { return v2 }
                | .Err(_) { return 0.0 }
        }
        | .Err(msg) {
            io.println("Error: ${msg}")
            return 0.0
        }
}

main = () void {
    alloc = get_default_allocator()
    // Test parse_radius
    result1 = parse_radius("3.14")
    result1 ?
        | .Ok(r1) { io.println("Parsed radius: ${r1}") }
        | .Err(e1) { io.println("Parse error: ${e1}") }
    
    result2 = parse_radius("invalid")
    result2 ?
        | .Ok(r2) { io.println("Parsed radius: ${r2}") }
        | .Err(e2) { io.println("Parse error: ${e2}") }
    
    // Test error propagation
    calc_result = calculate(100.0, 5.0)
    calc_result ?
        | .Ok(v3) { io.println("Result: ${v3}") }
        | .Err(e3) { io.println("Calculation error: ${e3}") }
    
    // Test with division by zero
    error_result = calculate(100.0, 0.0)
    error_result ?
        | .Ok(v4) { io.println("Result: ${v4}") }
        | .Err(e4) { io.println("Calculation error: ${e4}") }
    
    // Manual handling
    safe_val = safe_calculate(50.0, 10.0)
    io.println("Safe result: ${safe_val}")
}