// Test what's currently working from LANGUAGE_SPEC.zen

io = @std.io

// Option type definition
Option<T>: Some(T) | None

// Result type definition  
Result<T, E>: Ok(T) | Err(E)

// Simple struct
Point: {
    x: i32,
    y: i32,
}

// Simple function
add = (a: i32, b: i32) i32 {
    return a + b
}

// Main test function
main = () void {
    io.println("=== LANGUAGE_SPEC.zen Working Features ===")
    io.println("")
    
    // 1. Pattern matching with ? operator
    io.println("1. Pattern matching with ?")
    maybe: Option<i32> = Option.Some(42)
    maybe ?
        | Some(v) { io.println("   Option has value: 42") }
        | None { io.println("   No value") }
    
    // 2. Result type pattern matching
    io.println("")
    io.println("2. Result type")
    result: Result<i32, string> = Result.Ok(100)
    result ?
        | Ok(v) { io.println("   Success with value: 100") }
        | Err(e) { io.println("   Error") }
    
    // 3. Boolean pattern matching (no if/else keywords!)
    io.println("")
    io.println("3. Boolean patterns (no if/else!)")
    is_ready = true
    is_ready ? { 
        io.println("   System ready") 
    }
    
    has_data = false
    has_data ?
        | true { io.println("   Has data") }
        | false { io.println("   No data") }
    
    // 4. Assignment operators
    io.println("")
    io.println("4. Assignment operators")
    
    // Immutable assignment with =
    x = 10
    io.println("   x = 10 (immutable)")
    
    // Mutable assignment with ::=
    y ::= 20
    y = y + 5
    io.println("   y ::= 20, then y = y + 5, now y = 25")
    
    // 5. Struct usage
    io.println("")
    io.println("5. Struct usage")
    p = Point { x: 10, y: 20 }
    io.println("   Created Point with x=10, y=20")
    
    // 6. Function calls
    io.println("")
    io.println("6. Function calls")
    sum = add(5, 3)
    io.println("   add(5, 3) = 8")
    
    // 7. @this.defer for cleanup
    io.println("")
    io.println("7. @this.defer for cleanup")
    io.println("   Setting up defer...")
    @this.defer(io.println("   Cleanup executed (appears at end)"))
    io.println("   After defer setup")
    
    // 8. Nested pattern matching
    io.println("")
    io.println("8. Nested patterns")
    outer: Option<Result<i32, string>> = Option.Some(Result.Ok(42))
    outer ?
        | Some(inner) {
            inner ?
                | Ok(val) { io.println("   Nested: Got value 42") }
                | Err(e) { io.println("   Nested: Error") }
        }
        | None { io.println("   Outer is None") }
    
    io.println("")
    io.println("=== All working features tested! ===")
    // Deferred action will print here
}