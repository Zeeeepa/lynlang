// Working features from LANGUAGE_SPEC.zen

{ io } = @std

// Option and Result types
Option<T>: Some(T) | None
Result<T, E>: Ok(T) | Err(E)

// Simple struct
Point: {
    x: f64,
    y: f64,
}

// Enum variants
Shape: .Circle | .Rectangle
GameEntity: .Player | .Enemy | .Powerup

main = () void {
    io.println("=== LANGUAGE_SPEC.zen Working Features ===")
    
    // 1. Enum literals and pattern matching
    io.println("1. Enum literals:")
    maybe = Some(42)
    maybe ?
        | Some(val) { io.println("  ✓ Option.Some works") }
        | None { io.println("  Option is None") }
    
    nothing = None
    nothing ?
        | Some(val) { io.println("  Has value") }
        | None { io.println("  ✓ Option.None works") }
    
    // 2. Result type
    io.println("2. Result type:")
    success = Ok(100)
    success ?
        | Ok(val) { io.println("  ✓ Result.Ok works") }
        | Err(msg) { io.println("  Error") }
    
    // 3. Mutable variables with ::=
    io.println("3. Mutable variables:")
    x = 10
    io.println("  ✓ Immutable: x = 10")
    
    y ::= 20
    y = y + 1
    io.println("  ✓ Mutable: y ::= 20, then y = 21")
    
    // 4. Pattern matching with ?
    io.println("4. Pattern matching:")
    is_ready = true
    is_ready ? {
        io.println("  ✓ Boolean pattern works")
    }
    
    has_data = false
    has_data ?
        | true { io.println("  Has data") }
        | false { io.println("  ✓ Full boolean pattern works") }
    
    // 5. Range loops
    io.println("5. Range loops:")
    (0..3).loop((i) {
        io.println("  ✓ Range iteration")
    })
    
    // 6. Structs
    io.println("6. Structs:")
    p = Point { x: 1.0, y: 2.0 }
    io.println("  ✓ Struct creation works")
    
    // 7. Simple enums
    io.println("7. Enum matching:")
    entity = GameEntity.Player
    entity ?
        | .Player { io.println("  ✓ Enum variant matching works") }
        | .Enemy { io.println("  Enemy") }
        | .Powerup { io.println("  Powerup") }
    
    io.println("=== Test Complete ===")
}