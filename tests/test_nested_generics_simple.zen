// Simple test for nested generics
{io, Option, Result, get_default_allocator} = @std

main = () i32 {
    alloc = get_default_allocator()
    // Test Option<Option<i32>>
    double_opt = Option.Some(Option.Some(42))
    
    double_opt ?
        | Some(inner) {
            inner ?
                | Some(v) { io.print_int(v) }  // Should print 42
                | None { io.print("Inner None") }
        }
        | None { io.print("Outer None") }
    
    io.print("\n")
    
    // Test Result<Option<i32>, i32>
    res = Result.Ok(Option.Some(100))
    
    res ?
        | Ok(opt) {
            opt ?
                | Some(v) { io.print_int(v) }  // Should print 100
                | None { io.print("None value") }
        }
        | Err(e) { 
            io.print("Error: ")
            io.print_int(e) 
        }
    
    io.print("\n")
    
    // Test Option<Result<i32, i32>>
    opt_res = Option.Some(Result.Ok(200))
    
    opt_res ?
        | Some(r) {
            r ?
                | Ok(v) { io.print_int(v) }  // Should print 200
                | Err(e) { 
                    io.print("Error: ")
                    io.print_int(e) 
                }
        }
        | None { io.print("No result") }
    
    io.print("\n")
    
    // Test triple nesting: Result<Option<Result<i32, i32>>, i32>
    triple = Result.Ok(Option.Some(Result.Ok(300)))
    
    triple ?
        | Ok(opt) {
            opt ?
                | Some(inner_res) {
                    inner_res ?
                        | Ok(v) { io.print_int(v) }  // Should print 300
                        | Err(e) { 
                            io.print("Inner error: ")
                            io.print_int(e) 
                        }
                }
                | None { io.print("Middle None") }
        }
        | Err(e) { 
            io.print("Outer error: ")
            io.print_int(e) 
        }
    
    io.print("\n")
    
    return 0
}