// Simplified test for nested generic types - start with basic cases
{ io } = @std
{ Option, Result } = @std

// Simple test without nested generics first
test_simple_option = () Option<i32> {
    return Option.Some(42)
}

test_simple_result = () Result<i32, string> {
    return Result.Ok(100)
}

main = () void {
    io.println("Testing simple generics first...")
    
    // Test simple Option<i32>
    opt = test_simple_option()
    opt ? | Option.Some(n) => io.println("Simple Option value: ${n}")
          | Option.None => io.println("Got None")
    
    // Test simple Result<i32, string>
    res = test_simple_result()
    res ? | Result.Ok(n) => io.println("Simple Result value: ${n}")
          | Result.Err(e) => io.println("Got error: ${e}")
    
    io.println("Now testing nested generics...")
    
    // Create nested value directly without function
    nested_opt = Option.Some(42)
    nested_result = Result.Ok(nested_opt)
    
    nested_result ? | Result.Ok(inner_opt) => {
        inner_opt ? | Option.Some(value) => io.println("Nested value direct: ${value}")
                    | Option.None => io.println("Inner None")
    } | Result.Err(msg) => {
        io.println("Error: ${msg}")
    }
}