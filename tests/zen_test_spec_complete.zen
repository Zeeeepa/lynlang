// Complete test file based on LANGUAGE_SPEC.zen
// Testing all core features that should work

{ io } = @std
{ Option } = @std.option

// Enum definitions - exact from spec
Result<T, E>: Ok(T) | Err(E)

// Simple struct
Point: {
    x: f64,
    y: f64,
}

// Simple enum without dot syntax (line 162 style)
Shape: Circle, Rectangle

// Enum with struct variants
Circle: {
    center: Point,
    radius: f64,
}

Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

main = () void {
    // Test immutable assignment
    x = 42
    io.print("x is ")
    io.print(x)
    io.print("\n")
    
    // Test mutable assignment
    counter ::= 0
    counter = counter + 1
    io.print("counter is ")
    io.print(counter)
    io.print("\n")
    
    // Test boolean pattern matching short form
    flag = true
    flag ? {
        io.print("Flag is true\n")
    }
    
    // Test full boolean pattern
    is_ready = false
    is_ready ?
        | true { io.print("Ready!\n") }
        | false { io.print("Not ready\n") }
    
    // Test integer patterns
    value = 42
    value ?
        | 0 { io.print("Zero\n") }
        | 42 { io.print("Found 42\n") }
        | _ { io.print("Other\n") }
    
    // Test comparison pattern
    score = 85
    score > 80 ?
        | true { io.print("High score!\n") }
        | false { io.print("Low score\n") }
    
    // Test Option enum creation
    maybe_value: Option<i32> = Some(100)
    maybe_value ?
        | Some(v) { 
            io.print("Has value: ")
            io.print(v)
            io.print("\n")
        }
        | None { io.print("No value\n") }
    
    // Test None variant
    empty: Option<i32> = None
    empty ?
        | Some(_) { io.print("Should not print\n") }
        | None { io.print("Empty as expected\n") }
}