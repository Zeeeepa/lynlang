// Comprehensive Test Suite for Zen Language
// Tests all language features and stdlib modules

// Import test framework and modules
test = @std
io = @std
string = @std
math = @std
fs = @std
collections = @std

// Language Feature Tests
//========================

// Test variables and types
test_variables = test("Variables and Types", () void => {
    // Immutable variables
    x := 42;
    test.assert_eq(x, 42);
    
    // Mutable variables
    y := 10;
    y = 20;
    test.assert_eq(y, 20);
    
    // Type inference
    name := "Zen";
    test.assert_eq(name, "Zen");
    
    // Explicit types
    count: i32 = 100;
    test.assert_eq(count, 100);
    
    // Boolean
    flag := true;
    test.assert(flag);
    
    // Arrays
    arr := [1, 2, 3, 4, 5];
    test.assert_eq(arr.len, 5);
    test.assert_eq(arr[0], 1);
})

// Test functions
test_functions = test("Functions", () void => {
    // Simple function
    add = (a: i32, b: i32) i32 => a + b;
    test.assert_eq(add(2, 3), 5);
    
    // Function with multiple returns
    divmod = (a: i32, b: i32) (i32, i32) => (a / b, a % b);
    (q, r) := divmod(10, 3);
    test.assert_eq(q, 3);
    test.assert_eq(r, 1);
    
    // Generic function
    identity<T> = (x: T) T => x;
    test.assert_eq(identity(42), 42);
    test.assert_eq(identity("hello"), "hello");
    
    // Higher-order function
    apply = (f: *(i32) i32, x: i32) i32 => f(x);
    double = (x: i32) i32 => x * 2;
    test.assert_eq(apply(double, 5), 10);
})

// Test pattern matching
test_pattern_matching = test("Pattern Matching", () void => {
    // Simple pattern matching
    classify = (x: i32) string => {
        x ? | 0 { "zero" }
           | 1..=10 => "small"
           | 11..=100 => "medium"
           | _ { "large" }
    }
    
    test.assert_eq(classify(0), "zero");
    test.assert_eq(classify(5), "small");
    test.assert_eq(classify(50), "medium");
    test.assert_eq(classify(200), "large");
    
    // Pattern matching with enums
    Result(T, E): | Ok { value: T } | Err { error: E }
    
    process = (r: Result<i32, string>) i32 => {
        r ? | .Ok -> value { value * 2 }
           | .Err -> _ { -1 }
    }
    
    ok_result := Result.Ok -> value: 10;
    err_result := Result.Err -> error: "failed";
    
    test.assert_eq(process(ok_result), 20);
    test.assert_eq(process(err_result), -1);
})

// Test structs
test_structs = test("Structs", () void => {
    // Simple struct
    Point: {
        x: f32,
        y: f32,
    }
    
    p := Point { x: 10.0, y: 20.0 };
    test.assert_eq(p.x, 10.0);
    test.assert_eq(p.y, 20.0);
    
    // Struct with methods (UFCS)
    Point.distance = (self: &Point, other: &Point) f32 => {
        dx := self.x - other.x;
        dy := self.y - other.y;
        return math.sqrt(dx * dx + dy * dy)
    }
    
    p2 := Point { x: 13.0, y: 24.0 };
    dist := p.distance(&p2);
    test.assert_eq(dist, 5.0);
    
    // Struct with defaults
    Config: {
        host: string = "localhost",
        port: u16 = 8080,
        debug: bool = false,
    }
    
    cfg := Config { port: 3000 };
    test.assert_eq(cfg.host, "localhost");
    test.assert_eq(cfg.port, 3000);
    test.assert_false(cfg.debug);
})

// Test enums
test_enums = test("Enums", () void => {
    // Simple enum
    Color: 
        Red,
        Green,
        Blue,
    
    c := Color.Red;
    test.assert(c == Color.Red);
    
    // Enum with payloads
    Message: 
        Text -> content: string,
        Number -> value: i32,
        Binary -> data: []u8,
    
    msg := Message.Text -> content: "Hello";
    
    msg ? | .Text -> content { test.assert_eq(content, "Hello") }
         | _ { test.assert(false, "Expected Text message") }
})

// Test loops
test_loops = test("Loops", () void => {
    // Basic loop
    count := 0;
    loop count < 5 {
        count += 1
    }
    test.assert_eq(count, 5);
    
    // Loop with break
    i := 0;
    loop {
        i += 1;
        i == 10 ? | true { break }
    }
    test.assert_eq(i, 10);
    
    // Loop with continue
    sum := 0;
    j := 0;
    loop j < 10 {
        j += 1;
        j % 2 == 0 ? | true { continue; }
        sum += j
    }
    test.assert_eq(sum, 25); // 1 + 3 + 5 + 7 + 9
    
    // For-in loop (when implemented)
    // arr := [1, 2, 3, 4, 5];
    // total := 0;
    // loop x in arr {
    //     total += x
    // }
    // test.assert_eq(total, 15);
})

// Test error handling
test_error_handling = test("Error Handling", () void => {
    // Result type
    divide = (a: i32, b: i32) Result<i32, string> => {
        b == 0 ? | true { return .Err -> "Division by zero" }
               | false { return .Ok -> a / b }
    }
    
    result1 := divide(10, 2);
    test.assert_eq(test.assert_ok(result1), 5);
    
    result2 := divide(10, 0);
    test.assert_eq(test.assert_err(result2), "Division by zero");
    
    // Option type
    find = (arr: []i32, target: i32) Option<usize> => {
        i := 0;
        loop i < arr.len {
            arr[i] == target ? | true { return .Some -> i; }
            i += 1
        }
        return .None
    }
    
    arr := [10, 20, 30, 40];
    idx := find(arr, 30);
    test.assert_eq(test.assert_some(idx), 2);
    
    idx2 := find(arr, 50);
    test.assert_none(idx2);
})

// Test generics
test_generics = test("Generics", () void => {
    // Generic struct
    Box<T> = {
        value: T,
    }
    
    int_box := Box<i32> { value: 42 };
    str_box := Box<string> { value: "hello" };
    
    test.assert_eq(int_box.value, 42);
    test.assert_eq(str_box.value, "hello");
    
    // Generic function
    swap<T> = (a: &T, b: &T) void => {
        temp := *a;
        *a = *b;
        *b = temp
    }
    
    x := 10;
    y := 20;
    swap(&x, &y);
    test.assert_eq(x, 20);
    test.assert_eq(y, 10);
})

// Test behaviors (traits)
test_behaviors = test("Behaviors", () void => {
    // Define behavior
    Printable: behavior {
        to_string = (self: &Self) string
    }
    
    // Implement for Point
    Point.to_string = (self: &Point) string => {
        return "($(self.x), $(self.y))"
    }
    
    p := Point { x: 3.0, y: 4.0 };
    test.assert_eq(p.to_string(), "(3.0, 4.0)");
})

// Stdlib Module Tests
//====================

// Test string module
test_string_module = test("String Module", () void => {
    // String creation and manipulation
    s := "Hello, World!";
    test.assert_eq(string.len(s), 13);
    test.assert(string.contains(s, "World"));
    test.assert_false(string.contains(s, "Zen"));
    
    // String splitting
    parts := string.split("a,b,c", ",");
    test.assert_eq(parts.len, 3);
    test.assert_eq(parts[0], "a");
    test.assert_eq(parts[1], "b");
    test.assert_eq(parts[2], "c");
    
    // String joining
    joined := string.join(["Hello", "World"], " ");
    test.assert_eq(joined, "Hello World");
    
    // String trimming
    trimmed := string.trim("  hello  ");
    test.assert_eq(trimmed, "hello");
    
    // Case conversion
    upper := string.to_upper("hello");
    lower := string.to_lower("WORLD");
    test.assert_eq(upper, "HELLO");
    test.assert_eq(lower, "world");
})

// Test math module
test_math_module = test("Math Module", () void => {
    // Basic math functions
    test.assert_eq(math.abs(-42), 42);
    test.assert_eq(math.min(10, 20), 10);
    test.assert_eq(math.max(10, 20), 20);
    
    // Power and roots
    test.assert_eq(math.pow(2, 3), 8);
    test.assert_eq(math.sqrt(16), 4);
    
    // Trigonometry
    test.assert_lt(math.abs(math.sin(0)), 0.001);
    test.assert_lt(math.abs(math.cos(0) - 1.0), 0.001);
    
    // Constants
    test.assert_lt(math.abs(math.PI - 3.14159), 0.001);
    test.assert_lt(math.abs(math.E - 2.71828), 0.001);
})

// Test collections module
test_collections_module = test("Collections Module", () void => {
    // Vector
    v := collections.Vec<i32>.new();
    v.push(10);
    v.push(20);
    v.push(30);
    
    test.assert_eq(v.len(), 3);
    test.assert_eq(v.get(0), .Some -> 10);
    test.assert_eq(v.pop(), .Some -> 30);
    test.assert_eq(v.len(), 2);
    
    // HashMap
    map := collections.HashMap<string, i32>.new();
    map.set("one", 1);
    map.set("two", 2);
    map.set("three", 3);
    
    test.assert_eq(map.get("two"), .Some -> 2);
    test.assert_eq(map.len(), 3);
    test.assert(map.contains("one"));
    test.assert_false(map.contains("four"));
    
    // HashSet
    set := collections.HashSet<i32>.new();
    set.insert(1);
    set.insert(2);
    set.insert(3);
    set.insert(2); // Duplicate
    
    test.assert_eq(set.len(), 3);
    test.assert(set.contains(2));
    test.assert_false(set.contains(4));
})

// Test file system module
test_fs_module = test("File System Module", () void => {
    // Create temporary file
    temp_file := "/tmp/zen_test.txt";
    content := "Hello from Zen!";
    
    // Write file
    result := fs.write_file(temp_file, content);
    test.assert_ok(result);
    
    // Read file
    read_result := fs.read_file(temp_file);
    read_content := test.assert_ok(read_result);
    test.assert_eq(read_content, content);
    
    // Check file exists
    test.assert(fs.exists(temp_file));
    
    // Get file info
    info := test.assert_ok(fs.stat(temp_file));
    test.assert_eq(info.size, content.len);
    test.assert_false(info.is_dir);
    
    // Delete file
    delete_result := fs.remove(temp_file);
    test.assert_ok(delete_result);
    test.assert_false(fs.exists(temp_file));
})

// Benchmark Tests
//================

// Benchmark string operations
benchmark_strings = () void => {
    s := "Hello, World!";
    
    test.benchmark("String concatenation", () void => {
        result := s + " " + s;
    }, 10000);
    
    test.benchmark("String splitting", () void => {
        parts := string.split(s, ",");
    }, 10000);
    
    test.benchmark("String searching", () void => {
        found := string.contains(s, "World");
    }, 10000);
}

// Benchmark collections
benchmark_collections = () void => {
    test.benchmark("Vec push", () void => {
        v := collections.Vec<i32>.new();
        i := 0;
        loop i < 100 {
            v.push(i);
            i += 1
        }
    }, 1000);
    
    test.benchmark("HashMap insert", () void => {
        map := collections.HashMap<i32, i32>.new();
        i := 0;
        loop i < 100 {
            map.set(i, i * 2);
            i += 1
        }
    }, 1000);
}

// Benchmark math operations
benchmark_math = () void => {
    test.benchmark("Math.sqrt", () void => {
        result := math.sqrt(1234.5678);
    }, 100000);
    
    test.benchmark("Math.sin", () void => {
        result := math.sin(1.234);
    }, 100000);
    
    test.benchmark("Math.pow", () void => {
        result := math.pow(2.5, 3.7);
    }, 100000);
}

// Test Suite Definition
//=====================

suite := test.TestSuite {
    name: "Zen Comprehensive Test Suite",
    tests: [
        // Language features
        test_variables,
        test_functions,
        test_pattern_matching,
        test_structs,
        test_enums,
        test_loops,
        test_error_handling,
        test_generics,
        test_behaviors,
        
        // Stdlib modules
        test_string_module,
        test_math_module,
        test_collections_module,
        test_fs_module,
    ],
    setup: .Some -> () void => {
        io.print("Setting up test environment...\n");
    },
    teardown: .Some -> () void => {
        io.print("Cleaning up test environment...\n");
    },
    parallel: false,
}

// Main entry point
main = () i32   {
    io.print("Zen Language Comprehensive Test Suite\n");
    io.print("=====================================\n\n");
    
    // Create test runner
    runner := test.TestRunner.new();
    runner.verbose = true;
    runner.add_suite(suite);
    
    // Run tests
    success := runner.run();
    
    // Run benchmarks if all tests pass
    success ? | true {
        io.print("\nRunning Benchmarks...\n");
        io.print("====================\n");
        
        benchmark_strings();
        benchmark_collections();
        benchmark_math();
        
        io.print("\nAll benchmarks complete!\n");
    }
    
    // Generate report
    report := test.generate_report(&runner, "text");
    fs.write_file("test_results.txt", report)?;
    
    return success ? | true { 0 | false => 1 }
}