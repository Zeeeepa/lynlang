// Comprehensive showcase of LANGUAGE_SPEC.zen features
// This demonstrates all key language features from the spec

// ============================================================================
// IMPORTS - Only @std and @this are special (Lines 92-107)
// ============================================================================
{ io } = @std

// ============================================================================
// TYPE DEFINITIONS (Lines 109-196)
// ============================================================================

// Option type - no null/nil allowed (Lines 109-110)
Option<T>: Some(T) | None

// Result type for error handling (Lines 112-113)
Result<T, E>: Ok(T) | Err(E)

// Simple struct with mutable and default values (Lines 117-120)
Point: {
    x:: f64,      // mutable field with ::
    y:: f64 = 0   // with default value
}

// More complex struct (Lines 129-133)
Circle: {
    center: Point,
    radius: f64,
}

// Another struct type (Lines 145-149)
Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

// Enum type - sum types (Line 165)
Shape: Circle | Rectangle

// Game entity enum with variants (Line 172)
GameEntity: Player | Enemy | Powerup

// ============================================================================
// FUNCTIONS (Lines 174-211)
// ============================================================================

// UFC overloading for enum variants (Lines 174-181)
get_health = (e: GameEntity.Player) u32 { return 100 }
get_health = (e: GameEntity.Enemy) u32 { return 50 }
get_health = (e: GameEntity.Powerup) u32 { return 0 }

// Parse function with Result type (Lines 199-203)
parse_radius = (s: string) Result<f64, string> {
    // Simplified - in real implementation would use s.to_f64()
    return Ok(5.0)  
}

// Simple division function with error handling
divide = (a: f64, b: f64) Result<f64, string> {
    b == 0.0 ?
        | true { return Err("Division by zero") }
        | false { return Ok(a / b) }
}

// ============================================================================
// MAIN FUNCTION - Demonstrating all features
// ============================================================================
main = () void {
    io.println("=== ZEN LANGUAGE SPEC SHOWCASE ===")
    io.println("")
    
    // ========================================================================
    // VARIABLE DECLARATIONS (Lines 298-306)
    // ========================================================================
    io.println("1. Variable Declarations:")
    
    // Forward declaration
    x: i32
    x = 10
    io.println("  Forward decl: x = ${x}")
    
    // Immutable assignment
    y = 20
    io.println("  Immutable: y = ${y}")
    
    // Mutable assignment
    z ::= 30
    z = z + 5
    io.println("  Mutable: z = ${z}")
    
    // Mutable with type
    w:: i32 = 40
    w = w + 10
    io.println("  Mutable typed: w = ${w}")
    io.println("")
    
    // ========================================================================
    // PATTERN MATCHING WITH ? (Lines 352-361)
    // ========================================================================
    io.println("2. Pattern Matching:")
    
    // Boolean pattern - single branch
    is_ready = true
    is_ready ? {
        io.println("  Single branch: Ready!")
    }
    
    // Full pattern match
    has_data = false
    has_data ?
        | true { io.println("  Has data: processing...") }
        | false { io.println("  No data: waiting...") }
    io.println("")
    
    // ========================================================================
    // OPTION TYPE - NO NULL (Lines 462-473)
    // ========================================================================
    io.println("3. Option Type (no null):")
    
    maybe_value: Option<i32> = Some(42)
    maybe_value ?
        | Some(v) { io.println("  Some(${v})") }
        | None { io.println("  None") }
    
    empty_value: Option<i32> = None
    empty_value ?
        | Some(v) { io.println("  Unexpected: ${v}") }
        | None { io.println("  None (as expected)") }
    io.println("")
    
    // ========================================================================
    // RESULT TYPE & ERROR HANDLING (Lines 199-211)
    // ========================================================================
    io.println("4. Result Type:")
    
    ok_result: Result<i32, string> = Ok(100)
    ok_result ?
        | Ok(v) { io.println("  Ok(${v})") }
        | Err(e) { io.println("  Err: ${e}") }
    
    err_result: Result<i32, string> = Err("Something went wrong")
    err_result ?
        | Ok(v) { io.println("  Ok: ${v}") }
        | Err(e) { io.println("  Err(\"${e}\")") }
    
    // Test divide function
    div_result = divide(10.0, 2.0)
    div_result ?
        | Ok(v) { io.println("  10/2 = ${v}") }
        | Err(e) { io.println("  Error: ${e}") }
    io.println("")
    
    // ========================================================================
    // STRUCTS (Lines 117-120, 364-370)
    // ========================================================================
    io.println("5. Structs:")
    
    point = Point { x: 10.0, y: 20.0 }
    io.println("  Point: (${point.x}, ${point.y})")
    
    // Mutable field access
    point.x = 15.0
    io.println("  After mutation: (${point.x}, ${point.y})")
    
    circle = Circle {
        center: Point { x: 0, y: 0 },
        radius: 5.0
    }
    io.println("  Circle: center=(${circle.center.x}, ${circle.center.y}), r=${circle.radius}")
    io.println("")
    
    // ========================================================================
    // ENUMS AND PATTERN MATCHING (Lines 165-182, 324-335)
    // ========================================================================
    io.println("6. Enums:")
    
    // Create enum variants
    player = GameEntity.Player
    enemy = GameEntity.Enemy
    
    // Pattern match on enum
    player ?
        | Player { io.println("  Player health: ${get_health(player)}") }
        | Enemy { io.println("  Enemy health: ${get_health(enemy)}") }
        | Powerup { io.println("  Powerup") }
    
    enemy ?
        | Player { io.println("  Player") }
        | Enemy { io.println("  Enemy health: ${get_health(enemy)}") }
        | Powerup { io.println("  Powerup") }
    io.println("")
    
    // ========================================================================
    // LOOPS AND RANGES (Lines 432-460)
    // ========================================================================
    io.println("7. Loops and Ranges:")
    
    io.println("  Range (0..3):")
    (0..3).loop((i) {
        io.println("    ${i}")
    })
    
    io.println("  Loop with counter:")
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter > 3 ?
            | true { break }
            | false { io.println("    Loop ${counter}") }
    })
    io.println("")
    
    // ========================================================================
    // STRING INTERPOLATION (Throughout)
    // ========================================================================
    io.println("8. String Interpolation:")
    name = "Zen"
    version = 1.0
    io.println("  Language: ${name} v${version}")
    io.println("")
    
    io.println("=== END SHOWCASE ===")
}