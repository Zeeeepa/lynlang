// Comprehensive test verifying LANGUAGE_SPEC.zen implementation
// Tests are organized by feature from the spec

// ============================================================================
// IMPORTS - Testing @std special symbol
// ============================================================================
{ io, maths } = @std
{ String, StringBuilder } = @std
{ requires, implements, reflect, meta, inline, simd } = @std
{ GPA, AsyncPool, Allocator} = @std
{ Vec, DynVec} = @std
{ Actor, Channel, Mutex, AtomicU32 } = @std

// TODO: Test these imports once available
// sdl2 = @std.import("sdl2")
// ecs = @std.import("ecs")

// ============================================================================
// TYPE DEFINITIONS - No null, only Option and Result
// ============================================================================
Option<T>: Some(T) | None
Result<T, E>: Ok(T) | Err(E)

// ============================================================================
// STRUCTS - Simple struct syntax
// ============================================================================
Point: {
    x:: f64,  // mutable field  
    y:: f64 = 0  // with default value
}

Circle: {
    center: Point,
    radius: f64,
}

Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

// ============================================================================
// TRAITS - Testing .implements() and .requires()
// ============================================================================
Geometric: {
    area: (self) f64,
    perimeter: (self) f64,
}

// Implementation for Circle
Circle.implements(Geometric, {
    area = (self) f64 {
        return 3.14159 * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * 3.14159 * self.radius
    },
})

// Implementation for Rectangle
Rectangle.implements(Geometric, {
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return width * height
    },
    perimeter = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return 2.0 * (width + height)
    },
})

// ============================================================================
// ENUMS - Sum types with .requires()
// ============================================================================
Shape: Circle | Rectangle
Shape.requires(Geometric)  // All Shape variants must implement Geometric

// Testing UFC overloading based on enum variants
GameEntity: Player | Enemy | Powerup

// Overload functions for each variant
get_health = (e: GameEntity.Player) u32 { return 100 }
get_health = (e: GameEntity.Enemy) u32 { return 50 }
get_health = (e: GameEntity.Powerup) u32 { return 0 }

get_speed = (e: GameEntity.Player) f64 { return 5.0 }
get_speed = (e: GameEntity.Enemy) f64 { return 3.0 }
get_speed = (e: GameEntity.Powerup) f64 { return 0.0 }

// ============================================================================
// GENERIC FUNCTIONS WITH CONSTRAINTS
// ============================================================================
print_area<T: Geometric>(shape: T) void {
    io.println("Area: ${shape.area()}")
}

// TODO: Test once Serializable trait is available
// Container<T: Geometric + Serializable>: {
//     items: DynVec<T>,
//     add: (item: T) void,
//     total_area: () f64,
// }

// ============================================================================
// ERROR HANDLING - Result type and .raise()
// ============================================================================
parse_radius = (s: string) Result<f64, string> {
    // TODO: Implement string to f64 conversion
    // For now, return a dummy value
    return Ok(5.0)
}

// TODO: Test .raise() once File and json are available
// load_config = (path: string) Result<Config, Error> {
//     file = File.open(path).raise()  
//     contents = file.read_all().raise()
//     config = json.parse(contents).raise()
//     return Ok(config)
// }

// ============================================================================
// ACTORS AND CONCURRENCY
// ============================================================================
create_fibonacci = () Actor {
    outer = 100
    return Actor((receiver) {
        a ::= 0
        b ::= 1
        loop(() {
            receiver.send(a + outer)
            temp = a + b
            a = b
            b = temp
        })
    })
}

// ============================================================================
// REFLECTION AND METAPROGRAMMING
// ============================================================================
inspect_type = (T: type) void {
    ast = reflect.ast(T)
    ast.kind ?
        | Struct(s) {
            io.println("Struct: ${s.name}")
            s.fields.loop((f) {
                io.println("  Field: ${f.name}: ${f.type}")
            })
        }
        | Enum(e) {
            io.println("Enum: ${e.name}")
            e.variants.loop((v) {
                io.println("  Variant: ${v.name}")
            })
        }
        | Function(f) {
            io.println("Function: ${f.name}")
            f.params.loop((p) {
                io.println("  Param ${p.name}: ${p.type}, mut: ${p.is_mut}")
            })
            io.println("  Returns: ${f.return_type}")
        }
        | TypeDef(t) {
            io.println("TypeDef: ${t.name}")
            t.methods.loop((m) {
                io.println("  Method: ${m.name}")
            })
        }
}

// TODO: Test compile-time AST modification once available
// @meta.comptime((){
//     original = reflect.ast(parse_radius)
//     new_body = original.body.prepend(
//         AST.Call("io.println", ["Parsing radius from: ${s}"])
//     )
//     meta.replace(parse_radius, original.with_body(new_body))
// })

// ============================================================================
// LOW-LEVEL CONTROL - Inline C/LLVM and SIMD
// ============================================================================
// TODO: Test once inline.c is available
// fast_memcpy = (dst: RawPtr<u8>, src: RawPtr<u8>, len: usize) void {
//     inline.c("""
//         memcpy(${dst.addr}, ${src.addr}, ${len});
//     """)
// }

// TODO: Test once simd is available
// vector_add = (a: Vec<f32, 8>, b: Vec<f32, 8>) Vec<f32, 8> {
//     return simd.add(a, b)
// }

// ============================================================================
// MAIN FUNCTION - Testing all features
// ============================================================================
main = () void {
    io.println("=== ZEN LANGUAGE SPEC VERIFICATION ===")
    
    // ========================================================================
    // 1. VARIABLE DECLARATIONS - All 6 forms from spec
    // ========================================================================
    io.println("\n1. Variable Declarations (6 forms):")
    x: i32              // forward declaration
    x = 10              // assignment
    y = 10              // immutable inference
    z: i32 = 20         // immutable with type
    w:: i32             // mutable forward declaration
    w = 20              
    v ::= 30            // mutable inference
    u:: i32 = 40        // mutable with type
    
    io.println("x = ${x}, y = ${y}, z = ${z}")
    io.println("w = ${w}, v = ${v}, u = ${u}")
    
    // ========================================================================
    // 2. ALLOCATORS - Sync and async behavior
    // ========================================================================
    io.println("\n2. Allocators:")
    // TODO: Test once GPA and AsyncPool are implemented
    // sync_alloc = GPA.init()
    // @this.defer(sync_alloc.deinit())
    // async_alloc = AsyncPool.init()
    // @this.defer(async_alloc.deinit())
    
    // ========================================================================
    // 3. MIXED TYPE VECTORS - DynVec with multiple variants
    // ========================================================================
    io.println("\n3. Mixed Type Vectors:")
    // TODO: Test once DynVec is fully implemented
    // entities = DynVec<GameEntity.Player, GameEntity.Enemy>(sync_alloc)
    // @this.defer(entities.deinit())
    // entities.push(GameEntity.Player)
    // entities.push(GameEntity.Enemy)
    
    // ========================================================================
    // 4. PATTERN MATCHING - No keywords, only ?
    // ========================================================================
    io.println("\n4. Pattern Matching:")
    
    // Boolean short form
    is_ready = true
    is_ready ? {
        io.println("Ready to go!")
    }
    
    // Full boolean pattern matching
    has_data = false
    has_data ?
        | true { io.println("Has data") }
        | false { io.println("No data") }
    
    // Option pattern matching
    maybe: Option<i32> = Some(42)
    maybe ?
        | Some(n) { io.println("Option value: ${n}") }
        | None { io.println("Option is None") }
    
    // Result pattern matching
    result: Result<i32, string> = Ok(100)
    result ?
        | Ok(val) { io.println("Result Ok: ${val}") }
        | Err(msg) { io.println("Result Err: ${msg}") }
    
    // ========================================================================
    // 5. EXPLICIT POINTER TYPES - No * or &
    // ========================================================================
    io.println("\n5. Pointer Types:")
    circle = Circle { center: Point { x: 100.0, y: 100.0 }, radius: 50.0 }
    // TODO: Test once pointer types are implemented
    // circle_ptr: Ptr<Circle> = circle.ref()
    // circle_mut: MutPtr<Circle> = circle.mut_ref()
    // io.println("Circle area: ${circle_ptr.val.area()}")
    // circle_mut.val.radius = 75
    // io.println("New area: ${circle_mut.val.area()}")
    
    // ========================================================================
    // 6. COLLECTIONS - Vec and DynVec
    // ========================================================================
    io.println("\n6. Collections:")
    // TODO: Test once Vec and DynVec are fully implemented
    // shapes = Vec<Shape, 100>()
    // shapes.push(Circle { center: Point { x: 0, y: 0 }, radius: 10 })
    // dynamic_shapes = DynVec<Shape>(sync_alloc.allocator())
    // @this.defer(dynamic_shapes.deinit())
    
    // ========================================================================
    // 7. STRING BUILDING
    // ========================================================================
    io.println("\n7. String Building:")
    // TODO: Test once StringBuilder is implemented
    // sb = StringBuilder(sync_alloc)
    // @this.defer(sb.deinit())
    // sb.append("Hello").append(" ").append("World").append_line("!")
    // built_string = sb.build()
    // io.println(built_string)
    
    // ========================================================================
    // 8. CONCURRENCY - Channels, Actors, Mutex, Atomic
    // ========================================================================
    io.println("\n8. Concurrency:")
    // TODO: Test once concurrency primitives are implemented
    // message_chan = Channel<string>(10)
    // @this.defer(message_chan.close())
    
    // ========================================================================
    // 9. RANGE ITERATION - With .loop()
    // ========================================================================
    io.println("\n9. Range Iteration:")
    io.println("Basic range (0..5):")
    (0..5).loop((i) {
        io.println("  ${i}")
    })
    
    // TODO: Test step ranges once implemented
    // io.println("Step range (0..20).step(5):")
    // (0..20).step(5).loop((i) {
    //     io.println("  ${i}")
    // })
    
    // ========================================================================
    // 10. UFC - Collection.loop() and method chaining
    // ========================================================================
    io.println("\n10. UFC (Uniform Function Call):")
    double = (n: i32) i32 { return n * 2 }
    triple = (n: i32) i32 { return n * 3 }
    result_ufc = 5.double()
    io.println("5.double() = ${result_ufc}")
    chained = 5.double().triple()
    io.println("5.double().triple() = ${chained}")
    
    // ========================================================================
    // 11. INFINITE LOOP with break
    // ========================================================================
    io.println("\n11. Infinite Loop:")
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter > 3 ?
            | true { 
                io.println("Breaking at ${counter}")
                break 
            }
            | false { io.println("Counter: ${counter}") }
    })
    
    // ========================================================================
    // 12. REFLECTION at runtime
    // ========================================================================
    io.println("\n12. Reflection:")
    // TODO: Test once reflection is implemented
    // inspect_type(Circle)
    // inspect_type(Shape)
    
    // ========================================================================
    // 13. @this.defer - RAII cleanup
    // ========================================================================
    io.println("\n13. Defer mechanism:")
    @this.defer(io.println("Deferred: Cleanup 3"))
    @this.defer(io.println("Deferred: Cleanup 2"))
    @this.defer(io.println("Deferred: Cleanup 1"))
    
    io.println("\nMain function completed!")
}

// ============================================================================
// MODULE EXPORTS
// ============================================================================
// TODO: Test once module.exports is implemented
// module.exports = {
//     Shape: Shape,
//     Circle: Circle,
//     Rectangle: Rectangle,
//     Geometric: Geometric,
//     GameEntity: GameEntity,
//     get_health: get_health,
//     get_speed: get_speed,
//     parse_radius: parse_radius,
//     create_fibonacci: create_fibonacci,
// }