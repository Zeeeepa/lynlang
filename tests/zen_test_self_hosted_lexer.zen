// Test suite for self-hosted lexer
// Tests the lexer implementation written in Zen

core = @std.core
io = @std.io

// Import the lexer (when module system supports it)
// For now, we'll test basic concepts

// Test token types
test_token_recognition = () bool   {
    // Test data - simplified for now
    // Will test with proper tuples when supported
    
    passed := true
    
    io.print("Testing token recognition...\n")
    io.print("  Testing identifier: hello\n")
    io.print("  Testing integer: 123\n")
    io.print("  Testing float: 3.14\n")
    io.print("  Testing string: \"test\"\n")
    io.print("  Testing char: 'c'\n")
    io.print("  Testing keyword: if\n")
    io.print("  Testing operator: +\n")
    io.print("  Testing symbol: (\n")
    io.print("  Testing comment: //\n")
    
    return passed
}

// Test operator recognition
test_operators = () bool   {
    operators := [
        ":=",   // immutable assignment
        ":=",  // mutable assignment  
        "=",    // definition
        "==",   // equality
        "!=",   // not equal
        "<=",   // less than or equal
        ">=",   // greater than or equal
        "<",    // less than
        ">",    // greater than
        "+",    // addition
        "-",    // subtraction
        "*",    // multiplication
        "/",    // division
        "%",    // modulo
        "&",    // bitwise and
        "|",    // bitwise or / pattern match
        "^",    // bitwise xor
        "<<",   // left shift
        ">>",   // right shift
        "&&",   // logical and
        "||",   // logical or
        "!",    // logical not
        "?",    // conditional
        "->",   // arrow
        "=>",   // pattern result
        "..",   // range
        "...",  // varargs
        ":",   // type annotation
    ]
    
    io.print("Testing operator recognition...\n")
    
    i := 0
    loop i < 28 {
        io.print("  Operator: ")
        // Would print operators[i] when array indexing works fully
        io.print(" - OK\n")
        i = i + 1
    }
    
    return true
}

// Test keywords
test_keywords = () bool   {
    keywords := [
        "loop",     // iteration
        "break",    // loop break
        "continue", // loop continue
        "return",   // function return
        "extern",   // external declaration
        "export",   // export declaration
        "import",   // import (in future)
        "comptime", // compile-time evaluation
        "type",     // type keyword
        "void",     // void type
        "bool",     // boolean type
        "true",     // boolean literal
        "false",    // boolean literal
    ]
    
    io.print("Testing keyword recognition...\n")
    
    // Test each keyword
    passed := true
    
    return passed
}

// Test string parsing
test_string_parsing = () bool   {
    io.print("Testing string parsing...\n")
    io.print("  Simple string\n")
    io.print("  String with newline\n")
    io.print("  String with tab\n")
    io.print("  String with quote\n")
    io.print("  String with backslash\n")
    io.print("  Multi-word string\n")
    
    return true
}

// Test number parsing
test_number_parsing = () bool   {
    io.print("Testing number parsing...\n")
    io.print("  Integer: 0\n")
    io.print("  Integer: 42\n")
    io.print("  Integer: 123456789\n")
    io.print("  Float: 3.14\n")
    io.print("  Float: 0.5\n")
    io.print("  Float: 1.0\n")
    io.print("  Binary: 0b1010\n")
    io.print("  Octal: 0o755\n")
    io.print("  Hex: 0xDEADBEEF\n")
    
    return true
}

// Test comment handling
test_comments = () bool   {
    io.print("Testing comment handling...\n")
    
    // Single-line comments
    // Should be skipped by lexer
    
    /* Multi-line comments
       should also be handled
       properly by the lexer */
    
    // Nested /* comments */ should work
    
    return true
}

// Test error cases
test_error_cases = () bool   {
    io.print("Testing error cases...\n")
    
    // Unterminated string
    // "this string has no end
    
    // Invalid characters
    // @ $ # (except in specific contexts)
    
    // Invalid number formats
    // 123.456.789
    // 0xGHI
    
    return true
}

// Test position tracking
test_position_tracking = () bool   {
    io.print("Testing position tracking...\n")
    
    // Each token should track:
    // - line number
    // - column number
    // - start position
    // - end position
    
    return true
}

// Main test runner
main = () void   {
    io.print("=== Self-Hosted Lexer Tests ===\n\n")
    
    tests_passed := 0
    tests_failed := 0
    
    // Run tests
    test_token_recognition() ? 
        | true { { tests_passed = tests_passed + 1  }}
        | false { { tests_failed = tests_failed + 1  }}
    
    test_operators() ?
        | true { { tests_passed = tests_passed + 1  }}
        | false { { tests_failed = tests_failed + 1  }}
    
    test_keywords() ?
        | true { { tests_passed = tests_passed + 1  }}
        | false { { tests_failed = tests_failed + 1  }}
    
    test_string_parsing() ?
        | true { { tests_passed = tests_passed + 1  }}
        | false { { tests_failed = tests_failed + 1  }}
    
    test_number_parsing() ?
        | true { { tests_passed = tests_passed + 1  }}
        | false { { tests_failed = tests_failed + 1  }}
    
    test_comments() ?
        | true { { tests_passed = tests_passed + 1  }}
        | false { { tests_failed = tests_failed + 1  }}
    
    test_error_cases() ?
        | true { { tests_passed = tests_passed + 1  }}
        | false { { tests_failed = tests_failed + 1  }}
    
    test_position_tracking() ?
        | true { { tests_passed = tests_passed + 1  }}
        | false { { tests_failed = tests_failed + 1  }}
    
    // Print summary
    io.print("\n=== Test Summary ===\n")
    io.print("Tests completed\n")
    
    tests_failed == 0 ?
        | true {
            io.print("\nAll tests passed!\n")
        }
        | false {
            io.print("\nSome tests failed\n")
        }
}