// Core features from LANGUAGE_SPEC.zen that should be working
// Testing the fundamental design principles

{ io, math } = @std

// ============================================================================
// CORE PRINCIPLE 1: No keywords - everything is pattern matching or functions
// ============================================================================

test_no_keywords = () void {
    io.println("=== Testing No Keywords Principle ===")
    
    // No if/else - use pattern matching
    value = true
    value ?
        | true { io.println("✓ Boolean pattern matching works (true branch)") }
        | false { io.println("False branch") }
    
    // Single branch pattern
    is_ready = true
    is_ready ? { 
        io.println("✓ Single branch pattern works") 
    }
    
    // No explicit else needed
    condition = false
    condition ?
        | true { io.println("Won't print") }
        | false { io.println("✓ Pattern matching false branch works") }
}

// ============================================================================
// CORE PRINCIPLE 2: Assignment operators - =, ::=, :, ::
// ============================================================================

test_assignment_operators = () void {
    io.println("\n=== Testing Assignment Operators ===")
    
    // Forward declaration with type
    x: i32
    x = 10
    io.println("✓ Forward declaration: x = ${x}")
    
    // Immutable assignment (inferred)
    y = 20
    io.println("✓ Immutable assignment: y = ${y}")
    
    // Immutable with type
    z: i32 = 30
    io.println("✓ Immutable with type: z = ${z}")
    
    // Mutable assignment
    w ::= 40
    io.println("✓ Mutable assignment: w = ${w}")
    w = 50
    io.println("✓ Mutable reassignment: w = ${w}")
    
    // Mutable with type
    v:: i32 = 60
    v = 70
    io.println("✓ Mutable with type: v = ${v}")
}

// ============================================================================
// CORE PRINCIPLE 3: Structs and Enums (no tuples, no unions)
// ============================================================================

// Simple struct
Point: {
    x:: f64,
    y:: f64 = 0.0,  // with default
}

// Nested struct
Circle: {
    center: Point,
    radius: f64,
}

Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

// Enum type (sum type)
Shape: Circle | Rectangle

test_structs_enums = () void {
    io.println("\n=== Testing Structs and Enums ===")
    
    // Create struct instances
    p = Point { x: 3.0, y: 4.0 }
    io.println("✓ Point created: (${p.x}, ${p.y})")
    
    circle = Circle { 
        center: Point { x: 0.0, y: 0.0 },
        radius: 5.0
    }
    io.println("✓ Circle created with radius: ${circle.radius}")
    
    rect = Rectangle {
        top_left: Point { x: 0.0, y: 10.0 },
        bottom_right: Point { x: 10.0, y: 0.0 }
    }
    io.println("✓ Rectangle created")
    
    // Enum pattern matching
    shape: Shape = Circle { center: p, radius: 3.0 }
    shape ?
        | Circle { io.println("✓ Enum pattern match: Circle") }
        | Rectangle { io.println("Rectangle") }
}

// ============================================================================
// CORE PRINCIPLE 4: Option<T> - No null/nil
// ============================================================================

Option<T>: Some(T) | None

test_option_type = () void {
    io.println("\n=== Testing Option Type (No Null) ===")
    
    // Some value
    maybe_value: Option<i32> = Some(42)
    maybe_value ?
        | Some(v) { io.println("✓ Option Some: value = ${v}") }
        | None { io.println("No value") }
    
    // None case
    empty: Option<i32> = None
    empty ?
        | Some(v) { io.println("Has value: ${v}") }
        | None { io.println("✓ Option None works") }
}

// ============================================================================
// CORE PRINCIPLE 5: Result<T, E> for error handling
// ============================================================================

Result<T, E>: Ok(T) | Err(E)

divide = (a: f64, b: f64) Result<f64, string> {
    b == 0.0 ?
        | true { return Err("Division by zero") }
        | false { return Ok(a / b) }
}

test_result_type = () void {
    io.println("\n=== Testing Result Type ===")
    
    result = divide(10.0, 2.0)
    result ?
        | Ok(v) { io.println("✓ Result Ok: 10/2 = ${v}") }
        | Err(e) { io.println("Error: ${e}") }
    
    error_result = divide(10.0, 0.0)
    error_result ?
        | Ok(v) { io.println("Value: ${v}") }
        | Err(e) { io.println("✓ Result Err: ${e}") }
}

// ============================================================================
// CORE PRINCIPLE 6: Traits via .implements()
// ============================================================================

Geometric: {
    area: (self) f64,
    perimeter: (self) f64,
}

Circle.implements(Geometric, {
    area = (self) f64 {
        return math.pi * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * math.pi * self.radius
    },
})

Rectangle.implements(Geometric, {
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.top_left.y - self.bottom_right.y
        return width * height
    },
    perimeter = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.top_left.y - self.bottom_right.y
        return 2.0 * (width + height)
    },
})

test_traits = () void {
    io.println("\n=== Testing Traits ===")
    
    circ = Circle {
        center: Point { x: 0.0, y: 0.0 },
        radius: 10.0
    }
    
    area = circ.area()
    io.println("✓ Circle area via trait: ${area}")
    
    perimeter = circ.perimeter()
    io.println("✓ Circle perimeter via trait: ${perimeter}")
    
    rectangle = Rectangle {
        top_left: Point { x: 0.0, y: 10.0 },
        bottom_right: Point { x: 10.0, y: 0.0 }
    }
    
    rect_area = rectangle.area()
    io.println("✓ Rectangle area via trait: ${rect_area}")
}

// ============================================================================
// CORE PRINCIPLE 7: Loops - loop(), .loop(), ranges
// ============================================================================

test_loops = () void {
    io.println("\n=== Testing Loops ===")
    
    // Range loop
    io.print("✓ Range loop (0..5): ")
    (0..5).loop((i) {
        io.print("${i} ")
    })
    io.println("")
    
    // Infinite loop with break
    counter ::= 0
    io.print("✓ Infinite loop with break: ")
    loop(() {
        io.print("${counter} ")
        counter = counter + 1
        counter >= 3 ?
            | true { break }
            | false { }
    })
    io.println("")
}

// ============================================================================
// CORE PRINCIPLE 8: String interpolation
// ============================================================================

test_string_interpolation = () void {
    io.println("\n=== Testing String Interpolation ===")
    
    name = "Zen"
    version = 1.0
    count = 42
    
    message = "Language: ${name}, Version: ${version}, Count: ${count}"
    io.println("✓ ${message}")
    
    // Interpolation with expressions
    expr_result = "Sum: ${10 + 20}, Product: ${5 * 6}"
    io.println("✓ Expression interpolation: ${expr_result}")
}

// ============================================================================
// Main test runner
// ============================================================================

main = () void {
    io.println("=====================================")
    io.println("  LANGUAGE_SPEC.zen Core Test Suite  ")
    io.println("=====================================")
    
    test_no_keywords()
    test_assignment_operators()
    test_structs_enums()
    test_option_type()
    test_result_type()
    test_traits()
    test_loops()
    test_string_interpolation()
    
    io.println("\n=====================================")
    io.println("       All Core Tests Complete       ")
    io.println("=====================================")
}