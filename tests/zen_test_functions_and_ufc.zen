// Function and UFC tests from LANGUAGE_SPEC.zen
// Tests function definitions and Uniform Function Call

{ io } = @std

// Simple function
add = (a: i32, b: i32) i32 {
    return a + b
}

// Function with mutable parameters - not yet implemented
// increment = (x :: i32) void {
//     x = x + 1
// }

// Generic function - not yet implemented
// print_value<T>(value: T) void {
//     io.println("Value: ${value}")
// }

// UFC - can be called as method on first parameter
double = (x: i32) i32 {
    return x * 2
}

// Multiple overloads - not yet implemented
// get_name = (x: i32) string { return "integer" }
// get_name = (x: f64) string { return "float" }
// get_name = (x: string) string { return "string" }

// Commenting out structs - not fully working
// Vector: {
//     x: f64,
//     y: f64
// }

// Mutable parameters not yet implemented
// normalize = (v :: Vector) void {
//     mag = v.magnitude()  // UFC call
//     v.x = v.x / mag
//     v.y = v.y / mag
// }

main = () i32 {
    // Regular function calls
    sum = add(5, 3)
    io.println("5 + 3 = ${sum}")
    
    // UFC - function called as method
    value = 10
    doubled = value.double()  // Same as double(value)
    io.println("10.double() = ${doubled}")
    
    // Also works with regular call syntax
    tripled = double(15)
    io.println("double(15) = ${tripled}")
    
    // Chaining via UFC
    result = 5
        .double()              // 10
        .double()              // 20
        .double()              // 40
    io.println("5 chained double 3 times = ${result}")
    
    return 0
}