// Test behaviors (structural contracts)
// Language spec v1.1.0 compliance

test, assert, assert_eq := @std.testing

// Define behaviors as structs with function pointers
Comparable<T> = {
    compare: (a: T, b: T) i32,
}

Hashable<T> = {
    hash: (value: T) u64,
}

Serializable<T> = {
    serialize: (value: T, writer: Ptr<Writer>) Result<void, Error>,
    deserialize: (reader: Ptr<Reader>) Result<T, Error>,
}

// Test basic behavior implementation
test("behavior implementation") {
    // Create behavior instance for i32
    i32_comparable := Comparable<i32>{
        compare: (a: i32, b: i32) i32 {
            a < b ? | true => -1
                   | false => a > b ? | true => 1
                                     | false => 0
        }
    }
    
    // Use the behavior
    result := i32_comparable.compare(5, 10)
    assert(result == -1)
    
    result2 := i32_comparable.compare(10, 5)
    assert(result2 == 1)
    
    result3 := i32_comparable.compare(5, 5)
    assert(result3 == 0)
}

// Test behavior with custom types
test("behavior with structs") {
    Person: {
        name: string,
        age: u32,
    }
    
    // Create hashable behavior for Person
    person_hashable := Hashable<Person>{
        hash: (p: Person) u64 {
            // Simple hash combining name and age
            name_hash := hash_string(p.name)
            age_hash := p.age as u64
            name_hash ^ (age_hash << 32)
        }
    }
    
    person := Person{ name: "Alice", age: 30 }
    hash_value := person_hashable.hash(person)
    assert(hash_value != 0)
}

// Helper hash function for testing
hash_string: (s: string) u64  = {
    hash := 5381 as u64
    (0..s.len()).loop((i) => {
        hash = ((hash << 5) + hash) + (s.bytes()[i] as u64)
    })
    hash
}

// Test generic functions with behaviors
test("generic functions with behaviors") {
    // Generic sort function that uses Comparable behavior
    sort<T>: (items: Ptr<[?, T]>, len: usize, cmp: Comparable<T>) void  = {
        (0..len).loop((i) => {
            ((i+1)..len).loop((j) => {
                cmp.compare(items.value[i], items.value[j]) > 0 ?
                    | true => {
                        // Swap items
                        temp := items.value[i]
                        items.value[i] = items.value[j]
                        items.value[j] = temp
                    }
                    | false => {}
            })
        })
    }
    
    // Test with integers
    numbers := Ptr:new([5, i32]{ 3, 1, 4, 1, 5 })
    i32_cmp := Comparable<i32>{
        compare: (a: i32, b: i32) i32 {
            a < b ? | true => -1
                   | false => a > b ? | true => 1
                                     | false => 0
        }
    }
    
    sort(numbers, 5, i32_cmp)
    
    assert(numbers.value[0] == 1)
    assert(numbers.value[1] == 1)
    assert(numbers.value[2] == 3)
    assert(numbers.value[3] == 4)
    assert(numbers.value[4] == 5)
}

// Test multiple behaviors on same type
test("multiple behaviors") {
    Point: {
        x: f64,
        y: f64,
    }
    
    // Comparable behavior for Point
    point_comparable := Comparable<Point>{
        compare: (a: Point, b: Point) i32 {
            // Compare by distance from origin
            dist_a := (a.x * a.x + a.y * a.y)
            dist_b := (b.x * b.x + b.y * b.y)
            dist_a < dist_b ? | true => -1
                            | false => dist_a > dist_b ? | true => 1
                                                        | false => 0
        }
    }
    
    // Hashable behavior for Point
    point_hashable := Hashable<Point>{
        hash: (p: Point) u64 {
            // Simple hash combining x and y
            x_bits := p.x as u64
            y_bits := p.y as u64
            x_bits ^ (y_bits << 32)
        }
    }
    
    p1 := Point{ x: 3.0, y: 4.0 }
    p2 := Point{ x: 1.0, y: 1.0 }
    
    // Use Comparable
    cmp_result := point_comparable.compare(p1, p2)
    assert(cmp_result == 1)  // p1 is farther from origin
    
    // Use Hashable
    hash1 := point_hashable.hash(p1)
    hash2 := point_hashable.hash(p2)
    assert(hash1 != hash2)
}

// Test behavior composition
test("behavior composition") {
    // Behavior that combines multiple behaviors
    Equatable<T> = {
        equals: (a: T, b: T) bool,
    }
    
    // Create equatable from comparable
    make_equatable<T>: (cmp: Comparable<T>) Equatable<T>  = {
        Equatable<T>{
            equals: (a: T, b: T) bool {
                cmp.compare(a, b) == 0
            }
        }
    }
    
    i32_cmp := Comparable<i32>{
        compare: (a: i32, b: i32) i32 {
            a < b ? | true => -1
                   | false => a > b ? | true => 1
                                     | false => 0
        }
    }
    
    i32_eq := make_equatable(i32_cmp)
    
    assert(i32_eq.equals(5, 5) == true)
    assert(i32_eq.equals(5, 10) == false)
}

// Test automatic derivation placeholder
test("derived behaviors") {
    // In a real implementation, this would be auto-generated
    // by #derive(Comparable, Hashable)
    
    Color: {
        r: u8,
        g: u8,
        b: u8,
    }
    
    // Manually implement what would be derived
    Color_comparable := Comparable<Color>{
        compare: (a: Color, b: Color) i32 {
            // Lexicographic comparison
            a.r != b.r ? 
                | true => a.r < b.r ? | true => -1
                                     | false => 1
                | false => a.g != b.g ?
                    | true => a.g < b.g ? | true => -1
                                         | false => 1
                    | false => a.b < b.b ? | true => -1
                                          | false => a.b > b.b ? | true => 1
                                                                | false => 0
        }
    }
    
    Color_hashable := Hashable<Color>{
        hash: (c: Color) u64 {
            ((c.r as u64) << 16) | ((c.g as u64) << 8) | (c.b as u64)
        }
    }
    
    red := Color{ r: 255, g: 0, b: 0 }
    blue := Color{ r: 0, g: 0, b: 255 }
    
    assert(Color_comparable.compare(red, blue) == 1)
    assert(Color_hashable.hash(red) != Color_hashable.hash(blue))
}