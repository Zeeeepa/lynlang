// Ultra hardening test for generic type system
{ io, Result, Option, DynVec } = @std

// Test 1: Quad-nested generics
test_quad_nested = () void {
    io.println("=== Quad-Nested Generics Test ===")
    
    // Result<Result<Result<Result<i32, string>, string>, string>, string>
    create_quad = () Result<Result<Result<Result<i32, string>, string>, string>, string> {
        innermost = Result.Ok(42)
        level3 = Result.Ok(innermost)
        level2 = Result.Ok(level3)
        level1 = Result.Ok(level2)
        return level1
    }
    
    quad = create_quad()
    
    quad ?
        | Result.Ok(l1) {
            l1 ?
                | Result.Ok(l2) {
                    l2 ?
                        | Result.Ok(l3) {
                            l3 ?
                                | Result.Ok(val) {
                                    io.println("Quad nested value: ${val}")
                                }
                                | Result.Err(e) { io.println("L3 err: ${e}") }
                        }
                        | Result.Err(e) { io.println("L2 err: ${e}") }
                }
                | Result.Err(e) { io.println("L1 err: ${e}") }
        }
        | Result.Err(e) { io.println("L0 err: ${e}") }
}

// Test 2: Mixed nested generics with alternating types
test_mixed_alternating = () void {
    io.println("=== Mixed Alternating Nested Generics ===")
    
    // Option<Result<Option<Result<i32, string>>, string>>
    create_mixed = () Option<Result<Option<Result<i32, string>>, string>> {
        inner = Result.Ok(999)
        opt_inner = Option.Some(inner)
        res_opt = Result.Ok(opt_inner)
        return Option.Some(res_opt)
    }
    
    mixed = create_mixed()
    
    mixed ?
        | Option.Some(res) {
            res ?
                | Result.Ok(opt) {
                    opt ?
                        | Option.Some(inner_res) {
                            inner_res ?
                                | Result.Ok(v) {
                                    io.println("Mixed alternating value: ${v}")
                                }
                                | Result.Err(e) { io.println("Inner error: ${e}") }
                        }
                        | Option.None { io.println("Inner None") }
                }
                | Result.Err(e) { io.println("Middle error: ${e}") }
        }
        | Option.None { io.println("Outer None") }
}

// Test 3: Generic functions with deep nesting and raise()
test_deep_raise = () void {
    io.println("=== Deep Nested with raise() ===")
    
    create_deep = () Result<Result<Result<i32, string>, string>, string> {
        return Result.Ok(Result.Ok(Result.Ok(777)))
    }
    
    // Chain of raises
    outer = create_deep()
    middle = outer.raise()  // Result<Result<i32, string>, string>
    inner = middle.raise()  // Result<i32, string>
    value = inner.raise()   // i32
    
    io.println("Triple raise extracted: ${value}")
}

// Test 4: Collections with nested generics (skipped for now)
test_collections_nested = () void {
    io.println("=== Collections with Nested Generics ===")
    io.println("(Collections with complex nested generics not yet fully supported)")
}

// Test 5: Type inference stress test
test_type_inference_stress = () void {
    io.println("=== Type Inference Stress Test ===")
    
    // Let the compiler figure out these deeply nested types
    auto1 = Result.Ok(Option.Some(Result.Ok(Option.Some(42))))
    auto2 = Option.Some(Result.Ok(Option.Some(Result.Ok(99))))
    auto3 = Result.Ok(Result.Ok(Result.Ok(Result.Ok(Result.Ok(7)))))
    
    // Extract from auto1: Result<Option<Result<Option<i32>, E>>, E>
    auto1 ?
        | Result.Ok(opt1) {
            opt1 ?
                | Option.Some(res1) {
                    res1 ?
                        | Result.Ok(opt2) {
                            opt2 ?
                                | Option.Some(v) {
                                    io.println("Auto1 extracted: ${v}")
                                }
                                | Option.None { io.println("Auto1 inner None") }
                        }
                        | Result.Err(e) { io.println("Auto1 inner err") }
                }
                | Option.None { io.println("Auto1 None") }
        }
        | Result.Err(e) { io.println("Auto1 err") }
    
    // Extract from auto3: 5 levels of Result
    auto3 ?
        | Result.Ok(l1) {
            l1 ?
                | Result.Ok(l2) {
                    l2 ?
                        | Result.Ok(l3) {
                            l3 ?
                                | Result.Ok(l4) {
                                    l4 ?
                                        | Result.Ok(v) {
                                            io.println("Auto3 (5 levels) extracted: ${v}")
                                        }
                                        | Result.Err(e) { io.println("L4 err") }
                                }
                                | Result.Err(e) { io.println("L3 err") }
                        }
                        | Result.Err(e) { io.println("L2 err") }
                }
                | Result.Err(e) { io.println("L1 err") }
        }
        | Result.Err(e) { io.println("L0 err") }
}

// Test 6: Edge cases with void and unit types in generics
test_edge_cases = () void {
    io.println("=== Edge Cases with void/unit ===")
    
    // Result<Option<void>, string>
    void_nested = Result.Ok(Option.Some(void))
    void_nested ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(_) {
                    io.println("Got Some(void) inside Ok")
                }
                | Option.None {
                    io.println("Got None")
                }
        }
        | Result.Err(e) {
            io.println("Error: ${e}")
        }
    
    // Option<Result<void, void>>
    double_void = Option.Some(Result.Ok(void))
    double_void ?
        | Option.Some(res) {
            res ?
                | Result.Ok(_) {
                    io.println("Got Ok(void) inside Some")
                }
                | Result.Err(_) {
                    io.println("Got Err(void)")
                }
        }
        | Option.None {
            io.println("Was None")
        }
}

// Test 7: Generic type preservation through variables
test_type_preservation = () void {
    io.println("=== Type Preservation Test ===")
    
    // Create complex nested type
    original = Result.Ok(Option.Some(Result.Ok(555)))
    
    // Store in intermediate variables
    step1 = original
    step2 = step1
    final = step2
    
    // Extract through the chain
    final ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(res) {
                    res ?
                        | Result.Ok(v) {
                            io.println("Preserved through variables: ${v}")
                        }
                        | Result.Err(e) { io.println("Err") }
                }
                | Option.None { io.println("None") }
        }
        | Result.Err(e) { io.println("Err") }
}

main = () void {
    io.println("==== Ultra Generic Type System Hardening ====")
    io.println("")
    
    test_quad_nested()
    io.println("")
    
    test_mixed_alternating()
    io.println("")
    
    test_deep_raise()
    io.println("")
    
    test_collections_nested()
    io.println("")
    
    test_type_inference_stress()
    io.println("")
    
    test_edge_cases()
    io.println("")
    
    test_type_preservation()
    io.println("")
    
    io.println("==== All Ultra Hardening Tests Complete ====")
}