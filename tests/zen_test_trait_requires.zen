// Test .requires() for enum trait constraints
{ io, math } = @std

// Define a trait
Geometric: {
    area: (self) f64,
    perimeter: (self) f64,
}

// Define Point first
Point: {
    x: f64,
    y: f64,
}

// Circle type
Circle: {
    center: Point,
    radius: f64,
}

// Implement trait for Circle
Circle.implements(Geometric, {
    area = (self) f64 {
        return math.pi * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * math.pi * self.radius
    },
})

// Rectangle type
Rectangle: {
    width: f64,
    height: f64,
}

// Implement trait for Rectangle
Rectangle.implements(Geometric, {
    area = (self) f64 {
        return self.width * self.height
    },
    perimeter = (self) f64 {
        return 2.0 * (self.width + self.height)
    },
})

// Enum that requires all variants to implement Geometric
Shape: Circle | Rectangle
Shape.requires(Geometric)

main = () void {
    // Create a circle
    circle = Circle { 
        center: Point { x: 0.0, y: 0.0 }, 
        radius: 5.0 
    }
    
    // Create a rectangle
    rect = Rectangle {
        width: 10.0,
        height: 20.0
    }
    
    // Both should work as Shape since they implement Geometric
    shape1: Shape = circle
    shape2: Shape = rect
    
    io.println("Circle area: ${circle.area()}")
    io.println("Rectangle area: ${rect.area()}")
    
    // Pattern match on Shape
    shape1 ?
        | Circle { io.println("Shape1 is a Circle") }
        | Rectangle { io.println("Shape1 is a Rectangle") }
    
    shape2 ?
        | Circle { io.println("Shape2 is a Circle") }
        | Rectangle { io.println("Shape2 is a Rectangle") }
}