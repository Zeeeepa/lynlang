// Comprehensive test aligned with LANGUAGE_SPEC.zen
// Tests all core working features from the spec

{ io, math } = @std

// Option type definition (line 109-110)
Option<T>: Some(T) | None

// Result type definition (line 112-113)
Result<T, E>: Ok(T) | Err(E)

// Point struct (line 117-120)
Point: {
    x:: f64,  // mutable field
    y:: f64 = 0  // with default
}

// Test all variable declaration forms (lines 298-306)
test_variables = () void {
    io.println("=== Testing Variable Declarations ===")
    
    // Forward declaration and assignment
    x: i32
    x = 10
    io.println("  Forward decl: x = ${x}")
    
    // Immutable assignment
    y = 20
    io.println("  Immutable: y = ${y}")
    
    // Mutable assignment
    z ::= 30
    z = z + 5
    io.println("  Mutable: z = ${z}")
    
    // With type annotations
    a: i32 = 40
    b:: i32 = 50
    b = b + 10
    io.println("  Typed: a = ${a}, b = ${b}")
}

// Test pattern matching (lines 352-361, 408-412, 454-459)
test_pattern_matching = () void {
    io.println("=== Testing Pattern Matching ===")
    
    // Boolean pattern matching
    is_ready: bool = true
    is_ready ? {
        io.println("  Simple bool: Ready!")
    }
    
    value: i32 = 42
    is_positive: bool = value > 0
    is_positive ?
        | true { io.println("  Bool pattern: ${value} is positive") }
        | false { io.println("  Bool pattern: ${value} is not positive") }
    
    // Option pattern matching
    maybe: Option<i32> = Some(100)
    maybe ?
        | Some(v) { io.println("  Option: Some(${v})") }
        | None { io.println("  Option: None") }
    
    // Result pattern matching
    result: Result<i32, string> = Ok(200)
    result ?
        | Ok(v) { io.println("  Result: Ok(${v})") }
        | Err(e) { io.println("  Result: Err(${e})") }
}

// Test UFC (Uniform Function Call) (line 5)
double = (n: i32) i32 {
    return n * 2
}

add = (x: i32, y: i32) i32 {
    return x + y
}

test_ufc = () void {
    io.println("=== Testing UFC ===")
    
    num: i32 = 10
    
    // Traditional call
    result1: i32 = add(double(num), 5)
    io.println("  Traditional: add(double(10), 5) = ${result1}")
    
    // UFC method call
    result2: i32 = num.double().add(5)
    io.println("  UFC: 10.double().add(5) = ${result2}")
    
    // Mixed style
    result3: i32 = double(num).add(5)
    io.println("  Mixed: double(10).add(5) = ${result3}")
}

// Test loops and ranges (lines 431-439, 85-92, 443-450)
test_loops = () void {
    io.println("=== Testing Loops and Ranges ===")
    
    // Range iteration
    io.println("  Range (0..3):")
    (0..3).loop((i) {
        io.println("    ${i}")
    })
    
    // Infinite loop with break (simplified version)
    io.println("  Counter loop:")
    counter ::= 0
    // Note: Full loop() implementation requires more work
    // For now, just demonstrate with range
    (1..4).loop((i) {
        io.println("    Count ${i}")
    })
    
    // Array literal with loop
    arr = [10, 20, 30]
    io.println("  Array loop:")
    arr.loop((val) {
        io.println("    Value: ${val}")
    })
}

// Test structs (lines 364-376)
test_structs = () void {
    io.println("=== Testing Structs ===")
    
    // Create struct with mutable fields
    p ::= Point { x: 10.5, y: 20.5 }
    io.println("  Initial point: (${p.x}, ${p.y})")
    
    // Mutate fields
    p.x = 15.5
    p.y = 25.5
    io.println("  After mutation: (${p.x}, ${p.y})")
}

// Test math constants (line 138, 690)
test_math_constants = () void {
    io.println("=== Testing Math Constants ===")
    
    pi_val: f64 = math.pi
    io.println("  math.pi = ${pi_val}")
    
    radius: f64 = 5.0
    area: f64 = math.pi * radius * radius
    io.println("  Circle area (r=5): ${area}")
}

// Test string interpolation
test_string_interpolation = () void {
    io.println("=== Testing String Interpolation ===")
    
    name = "Zen"
    version: i32 = 1
    pi_val: f64 = 3.14159
    
    message = "Language: ${name}, Version: ${version}, Pi: ${pi_val}"
    io.println("  ${message}")
    
    // Complex expressions in interpolation
    result: i32 = 10 + 20
    io.println("  10 + 20 = ${result}")
}

main = () void {
    io.println("==== LANGUAGE_SPEC.zen Alignment Test ====")
    io.println("")
    
    test_variables()
    io.println("")
    
    test_pattern_matching()
    io.println("")
    
    test_ufc()
    io.println("")
    
    test_loops()
    io.println("")
    
    test_structs()
    io.println("")
    
    test_math_constants()
    io.println("")
    
    test_string_interpolation()
    io.println("")
    
    io.println("==== All Core Features Validated ====")
}