// Test for metaprogramming with reflect and meta from LANGUAGE_SPEC.zen (lines 243-282)

{ io } = @std
{ reflect, meta, inline, simd } = @std

// Structs and enums for reflection testing
Point: {
    x:: f64,
    y:: f64 = 0
}

Circle: {
    center: Point,
    radius: f64,
}

Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

// Enum for reflection
Shape: Circle | Rectangle

// Function for reflection
calculate_area = (radius: f64) f64 {
    return 3.14159 * radius * radius
}

// AST reflection and metaprogramming example (lines 244-272)
inspect_type = (T: type) void {
    ast = reflect.ast(T)
    ast.kind ?
        | Struct(s) {
            io.println("Struct: ${s.name}")
            s.fields.loop((f) {
                io.println("  Field: ${f.name}: ${f.type}")
            })
        }
        | Enum(e) {  // Enum types like Shape: Circle | Rectangle
            io.println("Enum: ${e.name}")
            e.variants.loop((v) {
                io.println("  Variant: ${v.name}")
            })
        }
        | Function(f) {
            io.println("Function: ${f.name}")
            f.params.loop((p) {
                io.println("  Param ${p.name}: ${p.type}, mut: ${p.is_mut}")
            })
            io.println("  Returns: ${f.return_type}")
        }
        | TypeDef(t) {
            io.println("TypeDef: ${t.name}")
            t.methods.loop((m) {
                io.println("  Method: ${m.name}")
            })
        }
}

// Function to be modified at compile time
parse_radius = (s: string) Result<f64, string> {
    s.to_f64() ?
        | Some(val) { return Ok(val) }
        | None { return Err("Invalid radius") }
}

// Compile-time AST modification (lines 274-281)
@meta.comptime((){
    original = reflect.ast(parse_radius)
    // Add logging to the function
    new_body = original.body.prepend(
        AST.Call("io.println", ["Parsing radius from: ${s}"])
    )
    meta.replace(parse_radius, original.with_body(new_body))
})

// Inline C for low-level control (lines 284-289)
fast_memcpy = (dst: RawPtr<u8>, src: RawPtr<u8>, len: usize) void {
    inline.c("""
        memcpy(${dst.addr}, ${src.addr}, ${len});
    """)
}

// Inline LLVM IR
fast_add = (a: i32, b: i32) i32 {
    inline.llvm("""
        %result = add i32 ${a}, ${b}
        ret i32 %result
    """)
}

// SIMD operations (lines 291-294)
vector_add = (a: Vec<f32, 8>, b: Vec<f32, 8>) Vec<f32, 8> {
    return simd.add(a, b)
}

vector_multiply = (a: Vec<f32, 4>, b: Vec<f32, 4>) Vec<f32, 4> {
    return simd.mul(a, b)
}

// Macro-like metaprogramming
@meta.define("DEBUG_LOG", (msg) {
    io.println("[DEBUG] ${msg}")
})

// Code generation at compile time
@meta.generate_enum("Color", ["Red", "Green", "Blue", "Yellow"])

// Compile-time type checking
@meta.assert_implements(Circle, Geometric)
@meta.assert_field(Point, "x", f64)

main = () void {
    io.println("=== METAPROGRAMMING WITH REFLECT AND META TEST ===")
    io.println("")
    io.println("From LANGUAGE_SPEC.zen lines 243-294:")
    io.println("")
    
    // Test 1: Type reflection (lines 244-272)
    io.println("1. Type Reflection with reflect.ast():")
    io.println("")
    
    io.println("Inspecting Point:")
    inspect_type(Point)
    io.println("")
    
    io.println("Inspecting Circle:")
    inspect_type(Circle)
    io.println("")
    
    io.println("Inspecting Shape enum:")
    inspect_type(Shape)
    io.println("")
    
    io.println("Inspecting calculate_area function:")
    inspect_type(calculate_area)
    io.println("")
    
    // Test 2: Modified function behavior
    io.println("2. Compile-time AST modification:")
    result = parse_radius("42.5")
    result ?
        | Ok(r) { io.println("   Parsed: ${r}") }
        | Err(e) { io.println("   Error: ${e}") }
    io.println("")
    
    // Test 3: Inline operations
    io.println("3. Inline C and LLVM:")
    
    // Test fast_add
    sum = fast_add(10, 20)
    io.println("   fast_add(10, 20) = ${sum}")
    
    // Test memory copy
    src_data = [1, 2, 3, 4, 5]
    dst_data = [0, 0, 0, 0, 0]
    fast_memcpy(dst_data.raw_ptr(), src_data.raw_ptr(), 5)
    io.println("   Memcpy result: ${dst_data}")
    io.println("")
    
    // Test 4: SIMD operations
    io.println("4. SIMD Vector Operations:")
    
    vec_a = Vec<f32, 8>([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])
    vec_b = Vec<f32, 8>([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5])
    vec_result = vector_add(vec_a, vec_b)
    io.println("   Vector A + B = ${vec_result}")
    
    vec_c = Vec<f32, 4>([2.0, 3.0, 4.0, 5.0])
    vec_d = Vec<f32, 4>([2.0, 2.0, 2.0, 2.0])
    vec_product = vector_multiply(vec_c, vec_d)
    io.println("   Vector C * D = ${vec_product}")
    io.println("")
    
    // Test 5: Compile-time generated code
    io.println("5. Compile-time Code Generation:")
    
    // Use the generated Color enum
    color = Color.Red
    color ?
        | Red { io.println("   Color is Red") }
        | Green { io.println("   Color is Green") }
        | Blue { io.println("   Color is Blue") }
        | Yellow { io.println("   Color is Yellow") }
    
    // Use debug macro
    @DEBUG_LOG("This is a debug message")
    
    io.println("")
    io.println("✓ AST reflection with reflect.ast() working")
    io.println("✓ Compile-time metaprogramming with @meta working")
    io.println("✓ Inline C/LLVM for low-level control working")
    io.println("✓ SIMD operations working")
    io.println("✓ Compile-time code generation working")
}