// Complete Result type test
{ io } = @std

Result<T, E>: Ok(T) | Err(E)

// Parse a number from string - demonstrates Result<i32, string>
parse_int = (s: string) Result<i32, string> {
    // For now, hardcoded examples
    s ?
        | "42" { return Ok(42) }
        | "100" { return Ok(100) }
        | "-5" { return Ok(-5) }
        | _ { return Err("Invalid number: ${s}") }
}

// Chain operations that can fail
divide = (a: i32, b: i32) Result<i32, string> {
    b ?
        | 0 { return Err("Division by zero") }
        | _ { return Ok(a / b) }
}

main = () i32 {
    io.println("=== Result Type Test ===")
    
    // Test successful parsing
    result1 = parse_int("42")
    result1 ?
        | Ok(n) { io.println("Parsed: ${n}") }
        | Err(e) { io.println("Error: ${e}") }
    
    // Test error case
    result2 = parse_int("abc")
    result2 ?
        | Ok(n) { io.println("Parsed: ${n}") }
        | Err(e) { io.println("Error: ${e}") }
    
    // Test division
    div_result = divide(10, 2)
    div_result ?
        | Ok(n) { io.println("10 / 2 = ${n}") }
        | Err(e) { io.println("Error: ${e}") }
    
    // Test division by zero
    div_by_zero = divide(10, 0)
    div_by_zero ?
        | Ok(n) { io.println("10 / 0 = ${n}") }
        | Err(e) { io.println("Error: ${e}") }
    
    io.println("=== Test Complete ===")
    return 0
}