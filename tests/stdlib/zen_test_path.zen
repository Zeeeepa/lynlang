// Tests for the path module

core := @std.core
test := @std.test
path := @std.path
string := @std.string

test_is_absolute: () bool  = {
    test.assert(path.is_absolute("/home/user"), "Should recognize absolute path")
    test.assert(path.is_absolute("/"), "Root should be absolute")
    test.assert(!path.is_absolute("relative/path"), "Should recognize relative path")
    test.assert(!path.is_absolute("./file"), "Should recognize relative path with dot")
    test.assert(!path.is_absolute(""), "Empty path is not absolute")
    return true
}

test_is_relative: () bool  = {
    test.assert(path.is_relative("relative/path"), "Should recognize relative path")
    test.assert(path.is_relative("./file"), "Should recognize relative path with dot")
    test.assert(path.is_relative("../parent"), "Should recognize relative path with parent")
    test.assert(!path.is_relative("/absolute"), "Should recognize absolute path")
    test.assert(path.is_relative(""), "Empty path is relative")
    return true
}

test_join: () bool  = {
    result1 := path.join("dir", "subdir", "file.txt")
    test.assert_eq(result1, "dir/subdir/file.txt", "Should join path components")
    
    result2 := path.join("/root", "dir", "file")
    test.assert_eq(result2, "/root/dir/file", "Should join with absolute path")
    
    result3 := path.join("dir/", "/subdir")
    test.assert_eq(result3, "dir/subdir", "Should handle separators correctly")
    
    result4 := path.join("", "file")
    test.assert_eq(result4, "file", "Should handle empty component")
    
    result5 := path.join("dir", "", "file")
    test.assert_eq(result5, "dir/file", "Should skip empty components")
    
    return true
}

test_dirname: () bool  = {
    test.assert_eq(path.dirname("/home/user/file.txt"), "/home/user", "Should get directory")
    test.assert_eq(path.dirname("dir/file.txt"), "dir", "Should get relative directory")
    test.assert_eq(path.dirname("file.txt"), ".", "File in current dir")
    test.assert_eq(path.dirname("/"), "/", "Root directory")
    test.assert_eq(path.dirname(""), ".", "Empty path")
    return true
}

test_basename: () bool  = {
    test.assert_eq(path.basename("/home/user/file.txt"), "file.txt", "Should get filename")
    test.assert_eq(path.basename("dir/file.txt"), "file.txt", "Should get filename from relative")
    test.assert_eq(path.basename("file.txt"), "file.txt", "Just filename")
    test.assert_eq(path.basename("/home/user/"), "user", "Should handle trailing slash")
    test.assert_eq(path.basename("/"), "/", "Root basename")
    test.assert_eq(path.basename(""), "", "Empty path")
    return true
}

test_extension: () bool  = {
    test.assert_eq(path.extension("file.txt"), ".txt", "Should get extension")
    test.assert_eq(path.extension("archive.tar.gz"), ".gz", "Should get last extension")
    test.assert_eq(path.extension("README"), "", "No extension")
    test.assert_eq(path.extension(".hidden"), "", "Hidden file without extension")
    test.assert_eq(path.extension(".hidden.txt"), ".txt", "Hidden file with extension")
    test.assert_eq(path.extension("dir/file.rs"), ".rs", "Extension from path")
    return true
}

test_stem: () bool  = {
    test.assert_eq(path.stem("file.txt"), "file", "Should get stem")
    test.assert_eq(path.stem("archive.tar.gz"), "archive.tar", "Should remove last extension")
    test.assert_eq(path.stem("README"), "README", "No extension to remove")
    test.assert_eq(path.stem(".hidden"), ".hidden", "Hidden file without extension")
    test.assert_eq(path.stem(".hidden.txt"), ".hidden", "Hidden file with extension")
    return true
}

test_split: () bool  = {
    parts1 := path.split("/home/user/file.txt")
    test.assert_eq(parts1.len(), 4, "Should have 4 components")
    test.assert_eq(parts1[0], "/", "First component is root")
    test.assert_eq(parts1[1], "home", "Second component")
    test.assert_eq(parts1[2], "user", "Third component")
    test.assert_eq(parts1[3], "file.txt", "Fourth component")
    
    parts2 := path.split("dir/subdir/file")
    test.assert_eq(parts2.len(), 3, "Should have 3 components")
    test.assert_eq(parts2[0], "dir", "First component")
    
    parts3 := path.split("")
    test.assert_eq(parts3.len(), 0, "Empty path has no components")
    
    return true
}

test_normalize: () bool  = {
    test.assert_eq(path.normalize("/home/./user/../user/file.txt"), "/home/user/file.txt", "Should normalize path")
    test.assert_eq(path.normalize("./dir/./subdir"), "dir/subdir", "Should remove current dir refs")
    test.assert_eq(path.normalize("dir/../other"), "other", "Should resolve parent refs")
    test.assert_eq(path.normalize("/../root"), "/root", "Can't go above root")
    test.assert_eq(path.normalize(""), ".", "Empty path normalizes to current")
    test.assert_eq(path.normalize("./"), ".", "Current dir only")
    test.assert_eq(path.normalize("dir/.."), ".", "Back to current")
    return true
}

test_relative: () bool  = {
    rel1 := path.relative("/home/user", "/home/user/documents/file.txt")
    test.assert(rel1.is_ok(), "Should compute relative path")
    test.assert_eq(rel1.unwrap(), "documents/file.txt", "Correct relative path")
    
    rel2 := path.relative("/home/user/docs", "/home/user/pics")
    test.assert(rel2.is_ok(), "Should compute sibling relative path")
    test.assert_eq(rel2.unwrap(), "../pics", "Correct sibling path")
    
    rel3 := path.relative("/home", "/")
    test.assert(rel3.is_ok(), "Should compute parent relative path")
    test.assert_eq(rel3.unwrap(), "..", "Correct parent path")
    
    rel4 := path.relative("dir", "/absolute")
    test.assert(rel4.is_err(), "Should fail for mixed absolute/relative")
    
    return true
}

test_is_hidden: () bool  = {
    test.assert(path.is_hidden(".hidden"), "Dotfile is hidden")
    test.assert(path.is_hidden("/home/.config"), "Hidden directory")
    test.assert(path.is_hidden("dir/.file"), "Hidden file in directory")
    test.assert(!path.is_hidden("normal.txt"), "Normal file not hidden")
    test.assert(!path.is_hidden("/home/user"), "Normal directory not hidden")
    return true
}

test_matches: () bool  = {
    test.assert(path.matches("file.txt", "*"), "Star matches everything")
    test.assert(path.matches("file.txt", "file.txt"), "Exact match")
    test.assert(path.matches("file.txt", "*.txt"), "Extension match")
    test.assert(path.matches("test_file.txt", "test_*"), "Prefix match")
    test.assert(path.matches("file_test.txt", "*_test.txt"), "Middle match")
    test.assert(!path.matches("file.rs", "*.txt"), "Wrong extension")
    return true
}

test_path_builder: () bool  = {
    built := path.builder()
        .add("home")
        .add("user")
        .add("documents")
        .add("file.txt")
        .build()
    
    test.assert_eq(built, "home/user/documents/file.txt", "Builder creates correct path")
    
    empty_built := path.builder().build()
    test.assert_eq(empty_built, "", "Empty builder returns empty string")
    
    return true
}

// Run all tests
main: () i32  = {
    runner := test.TestRunner.new("Path Module Tests")
    
    runner.add_test("is_absolute", test_is_absolute)
    runner.add_test("is_relative", test_is_relative)
    runner.add_test("join", test_join)
    runner.add_test("dirname", test_dirname)
    runner.add_test("basename", test_basename)
    runner.add_test("extension", test_extension)
    runner.add_test("stem", test_stem)
    runner.add_test("split", test_split)
    runner.add_test("normalize", test_normalize)
    runner.add_test("relative", test_relative)
    runner.add_test("is_hidden", test_is_hidden)
    runner.add_test("matches", test_matches)
    runner.add_test("path_builder", test_path_builder)
    
    return runner.run()
}