// Comprehensive tests for Zen stdlib vec (vector) module

{ vec } = @std.vec
{ test } = @std.test
{ io } = @std.io
{ assert } = @std.assert

// Test vector creation
test_vec_creation = () void   {
    suite := test.suite_new("Vector Creation Tests")
    
    test.suite_add_test(&suite, "Create empty vector", () void {
        v := vec.new<i32>()
        assert.equal(v.len(), 0)
        assert.ok(v.is_empty())
        assert.ok(v.capacity() >= 0)
    })
    
    test.suite_add_test(&suite, "Create vector with capacity", () void {
        v := vec.with_capacity<i32>(10)
        assert.equal(v.len(), 0)
        assert.ok(v.capacity() >= 10)
    })
    
    test.suite_add_test(&suite, "Create vector from array", () void {
        arr := [1, 2, 3, 4, 5]
        v := vec.from(arr)
        assert.equal(v.len(), 5)
        assert.equal(v[0], 1)
        assert.equal(v[4], 5)
    })
    
    test.suite_add_test(&suite, "Create vector with fill", () void {
        v := vec.fill(10, 42)
        assert.equal(v.len(), 10)
        for i in 0..10 {
            assert.equal(v[i], 42)
        }
    })
    
    test.suite_add_test(&suite, "Clone vector", () void {
        v1 := vec.from([1, 2, 3])
        v2 := v1.clone()
        assert.equal(v1.len(), v2.len())
        for i in 0..v1.len() {
            assert.equal(v1[i], v2[i])
        }
    })
    
    test.run_suite(&suite)
}

// Test vector push/pop operations
test_vec_push_pop = () void   {
    suite := test.suite_new("Vector Push/Pop Tests")
    
    test.suite_add_test(&suite, "Push elements", () void {
        v := vec.new<i32>()
        v.push(1)
        v.push(2)
        v.push(3)
        
        assert.equal(v.len(), 3)
        assert.equal(v[0], 1)
        assert.equal(v[1], 2)
        assert.equal(v[2], 3)
    })
    
    test.suite_add_test(&suite, "Pop elements", () void {
        v := vec.from([1, 2, 3])
        
        assert.equal(v.pop(), Some(3))
        assert.equal(v.len(), 2)
        assert.equal(v.pop(), Some(2))
        assert.equal(v.len(), 1)
        assert.equal(v.pop(), Some(1))
        assert.equal(v.len(), 0)
        assert.equal(v.pop(), None)
    })
    
    test.suite_add_test(&suite, "Push and grow", () void {
        v := vec.with_capacity<i32>(2)
        initial_cap := v.capacity()
        
        v.push(1)
        v.push(2)
        v.push(3)  // Should trigger growth
        
        assert.equal(v.len(), 3)
        assert.ok(v.capacity() > initial_cap)
    })
    
    test.run_suite(&suite)
}

// Test vector insertion and removal
test_vec_insert_remove = () void   {
    suite := test.suite_new("Vector Insert/Remove Tests")
    
    test.suite_add_test(&suite, "Insert at index", () void {
        v := vec.from([1, 2, 4, 5])
        v.insert(2, 3)
        
        assert.equal(v.len(), 5)
        assert.equal(v[0], 1)
        assert.equal(v[1], 2)
        assert.equal(v[2], 3)
        assert.equal(v[3], 4)
        assert.equal(v[4], 5)
    })
    
    test.suite_add_test(&suite, "Insert at beginning", () void {
        v := vec.from([2, 3, 4])
        v.insert(0, 1)
        
        assert.equal(v[0], 1)
        assert.equal(v.len(), 4)
    })
    
    test.suite_add_test(&suite, "Insert at end", () void {
        v := vec.from([1, 2, 3])
        v.insert(3, 4)
        
        assert.equal(v[3], 4)
        assert.equal(v.len(), 4)
    })
    
    test.suite_add_test(&suite, "Remove at index", () void {
        v := vec.from([1, 2, 3, 4, 5])
        removed := v.remove(2)
        
        assert.equal(removed, 3)
        assert.equal(v.len(), 4)
        assert.equal(v[0], 1)
        assert.equal(v[1], 2)
        assert.equal(v[2], 4)
        assert.equal(v[3], 5)
    })
    
    test.suite_add_test(&suite, "Swap remove", () void {
        v := vec.from([1, 2, 3, 4, 5])
        removed := v.swap_remove(1)
        
        assert.equal(removed, 2)
        assert.equal(v.len(), 4)
        assert.equal(v[0], 1)
        assert.equal(v[1], 5)  // Last element moved here
        assert.equal(v[2], 3)
        assert.equal(v[3], 4)
    })
    
    test.suite_add_test(&suite, "Clear vector", () void {
        v := vec.from([1, 2, 3, 4, 5])
        cap := v.capacity()
        v.clear()
        
        assert.equal(v.len(), 0)
        assert.ok(v.is_empty())
        assert.equal(v.capacity(), cap)  // Capacity unchanged
    })
    
    test.suite_add_test(&suite, "Truncate vector", () void {
        v := vec.from([1, 2, 3, 4, 5])
        v.truncate(3)
        
        assert.equal(v.len(), 3)
        assert.equal(v[0], 1)
        assert.equal(v[1], 2)
        assert.equal(v[2], 3)
    })
    
    test.run_suite(&suite)
}

// Test vector access and bounds checking
test_vec_access = () void   {
    suite := test.suite_new("Vector Access Tests")
    
    test.suite_add_test(&suite, "Index access", () void {
        v := vec.from([10, 20, 30, 40])
        
        assert.equal(v[0], 10)
        assert.equal(v[1], 20)
        assert.equal(v[2], 30)
        assert.equal(v[3], 40)
    })
    
    test.suite_add_test(&suite, "Get with bounds check", () void {
        v := vec.from([1, 2, 3])
        
        assert.equal(v.get(0), Some(1))
        assert.equal(v.get(1), Some(2))
        assert.equal(v.get(2), Some(3))
        assert.equal(v.get(3), None)
        assert.equal(v.get(100), None)
    })
    
    test.suite_add_test(&suite, "First and last", () void {
        v := vec.from([1, 2, 3])
        
        assert.equal(v.first(), Some(1))
        assert.equal(v.last(), Some(3))
        
        empty := vec.new<i32>()
        assert.equal(empty.first(), None)
        assert.equal(empty.last(), None)
    })
    
    test.suite_add_test(&suite, "Slice access", () void {
        v := vec.from([1, 2, 3, 4, 5])
        slice := v.slice(1, 4)
        
        assert.equal(slice.len(), 3)
        assert.equal(slice[0], 2)
        assert.equal(slice[1], 3)
        assert.equal(slice[2], 4)
    })
    
    test.suite_add_panic_test(&suite, "Panic on out of bounds", () void {
        v := vec.from([1, 2, 3])
        _ := v[10]  // Should panic
    })
    
    test.run_suite(&suite)
}

// Test vector iteration
test_vec_iteration = () void   {
    suite := test.suite_new("Vector Iteration Tests")
    
    test.suite_add_test(&suite, "Iterate values", () void {
        v := vec.from([1, 2, 3, 4, 5])
        sum := 0
        
        for val in v.iter() {
            sum += val
        }
        
        assert.equal(sum, 15)
    })
    
    test.suite_add_test(&suite, "Iterate with index", () void {
        v := vec.from([10, 20, 30])
        
        for (i, val) in v.enumerate() {
            assert.equal(val, (i + 1) * 10)
        }
    })
    
    test.suite_add_test(&suite, "Reverse iteration", () void {
        v := vec.from([1, 2, 3, 4, 5])
        result := vec.new<i32>()
        
        for val in v.rev_iter() {
            result.push(val)
        }
        
        assert.equal(result[0], 5)
        assert.equal(result[1], 4)
        assert.equal(result[2], 3)
        assert.equal(result[3], 2)
        assert.equal(result[4], 1)
    })
    
    test.run_suite(&suite)
}

// Test vector algorithms
test_vec_algorithms = () void   {
    suite := test.suite_new("Vector Algorithm Tests")
    
    test.suite_add_test(&suite, "Sort vector", () void {
        v := vec.from([3, 1, 4, 1, 5, 9, 2, 6])
        v.sort()
        
        assert.equal(v[0], 1)
        assert.equal(v[1], 1)
        assert.equal(v[2], 2)
        assert.equal(v[3], 3)
        assert.equal(v[4], 4)
        assert.equal(v[5], 5)
        assert.equal(v[6], 6)
        assert.equal(v[7], 9)
    })
    
    test.suite_add_test(&suite, "Sort with comparator", () void {
        v := vec.from([3, 1, 4, 1, 5])
        v.sort_by((a, b) bool { a > b })  // Reverse sort
        
        assert.equal(v[0], 5)
        assert.equal(v[1], 4)
        assert.equal(v[2], 3)
        assert.equal(v[3], 1)
        assert.equal(v[4], 1)
    })
    
    test.suite_add_test(&suite, "Reverse vector", () void {
        v := vec.from([1, 2, 3, 4, 5])
        v.reverse()
        
        assert.equal(v[0], 5)
        assert.equal(v[1], 4)
        assert.equal(v[2], 3)
        assert.equal(v[3], 2)
        assert.equal(v[4], 1)
    })
    
    test.suite_add_test(&suite, "Contains element", () void {
        v := vec.from([1, 2, 3, 4, 5])
        
        assert.ok(v.contains(3))
        assert.ok(v.contains(1))
        assert.ok(v.contains(5))
        assert.ok(!v.contains(10))
    })
    
    test.suite_add_test(&suite, "Find element", () void {
        v := vec.from([1, 2, 3, 4, 5])
        
        assert.equal(v.find((x) bool { x > 3 }), Some(4))
        assert.equal(v.find((x) bool { x > 10 }), None)
    })
    
    test.suite_add_test(&suite, "Binary search", () void {
        v := vec.from([1, 3, 5, 7, 9, 11])
        
        assert.equal(v.binary_search(5), Ok(2))
        assert.equal(v.binary_search(9), Ok(4))
        assert.ok(v.binary_search(4).is_err())
    })
    
    test.suite_add_test(&suite, "Dedup vector", () void {
        v := vec.from([1, 1, 2, 2, 3, 3, 3, 4])
        v.dedup()
        
        assert.equal(v.len(), 4)
        assert.equal(v[0], 1)
        assert.equal(v[1], 2)
        assert.equal(v[2], 3)
        assert.equal(v[3], 4)
    })
    
    test.run_suite(&suite)
}

// Test vector functional operations
test_vec_functional = () void   {
    suite := test.suite_new("Vector Functional Tests")
    
    test.suite_add_test(&suite, "Map operation", () void {
        v := vec.from([1, 2, 3, 4, 5])
        mapped := v.map((x) i32 { x * 2 })
        
        assert.equal(mapped[0], 2)
        assert.equal(mapped[1], 4)
        assert.equal(mapped[2], 6)
        assert.equal(mapped[3], 8)
        assert.equal(mapped[4], 10)
    })
    
    test.suite_add_test(&suite, "Filter operation", () void {
        v := vec.from([1, 2, 3, 4, 5, 6])
        filtered := v.filter((x) bool { x % 2 == 0 })
        
        assert.equal(filtered.len(), 3)
        assert.equal(filtered[0], 2)
        assert.equal(filtered[1], 4)
        assert.equal(filtered[2], 6)
    })
    
    test.suite_add_test(&suite, "Fold/Reduce operation", () void {
        v := vec.from([1, 2, 3, 4, 5])
        sum := v.fold(0, (acc, x) i32 { acc + x })
        
        assert.equal(sum, 15)
    })
    
    test.suite_add_test(&suite, "All predicate", () void {
        v1 := vec.from([2, 4, 6, 8])
        v2 := vec.from([2, 4, 5, 8])
        
        assert.ok(v1.all((x) bool { x % 2 == 0 }))
        assert.ok(!v2.all((x) bool { x % 2 == 0 }))
    })
    
    test.suite_add_test(&suite, "Any predicate", () void {
        v1 := vec.from([1, 3, 5, 7])
        v2 := vec.from([1, 3, 4, 7])
        
        assert.ok(!v1.any((x) bool { x % 2 == 0 }))
        assert.ok(v2.any((x) bool { x % 2 == 0 }))
    })
    
    test.suite_add_test(&suite, "Partition", () void {
        v := vec.from([1, 2, 3, 4, 5, 6])
        (evens, odds) := v.partition((x) bool { x % 2 == 0 })
        
        assert.equal(evens.len(), 3)
        assert.equal(odds.len(), 3)
        assert.ok(evens.all((x) bool { x % 2 == 0 }))
        assert.ok(odds.all((x) bool { x % 2 != 0 }))
    })
    
    test.run_suite(&suite)
}

// Test vector concatenation and extension
test_vec_concat = () void   {
    suite := test.suite_new("Vector Concatenation Tests")
    
    test.suite_add_test(&suite, "Extend with another vector", () void {
        v1 := vec.from([1, 2, 3])
        v2 := vec.from([4, 5, 6])
        v1.extend(v2)
        
        assert.equal(v1.len(), 6)
        assert.equal(v1[3], 4)
        assert.equal(v1[4], 5)
        assert.equal(v1[5], 6)
    })
    
    test.suite_add_test(&suite, "Append vector", () void {
        v1 := vec.from([1, 2, 3])
        v2 := vec.from([4, 5, 6])
        v3 := v1.append(v2)
        
        assert.equal(v3.len(), 6)
        assert.equal(v3[0], 1)
        assert.equal(v3[5], 6)
    })
    
    test.suite_add_test(&suite, "Split vector", () void {
        v := vec.from([1, 2, 3, 4, 5, 6])
        (left, right) := v.split_at(3)
        
        assert.equal(left.len(), 3)
        assert.equal(right.len(), 3)
        assert.equal(left[0], 1)
        assert.equal(left[2], 3)
        assert.equal(right[0], 4)
        assert.equal(right[2], 6)
    })
    
    test.suite_add_test(&suite, "Chunks", () void {
        v := vec.from([1, 2, 3, 4, 5, 6, 7, 8])
        chunks := v.chunks(3)
        
        assert.equal(chunks.len(), 3)
        assert.equal(chunks[0].len(), 3)
        assert.equal(chunks[1].len(), 3)
        assert.equal(chunks[2].len(), 2)
    })
    
    test.run_suite(&suite)
}

// Test vector memory management
test_vec_memory = () void   {
    suite := test.suite_new("Vector Memory Tests")
    
    test.suite_add_test(&suite, "Reserve capacity", () void {
        v := vec.new<i32>()
        v.reserve(100)
        
        assert.ok(v.capacity() >= 100)
        assert.equal(v.len(), 0)
    })
    
    test.suite_add_test(&suite, "Shrink to fit", () void {
        v := vec.with_capacity<i32>(100)
        v.push(1)
        v.push(2)
        v.push(3)
        
        v.shrink_to_fit()
        
        assert.equal(v.len(), 3)
        assert.ok(v.capacity() >= 3)
        assert.ok(v.capacity() < 100)
    })
    
    test.suite_add_test(&suite, "Resize vector", () void {
        v := vec.from([1, 2, 3])
        
        v.resize(5, 0)
        assert.equal(v.len(), 5)
        assert.equal(v[3], 0)
        assert.equal(v[4], 0)
        
        v.resize(2, 0)
        assert.equal(v.len(), 2)
        assert.equal(v[0], 1)
        assert.equal(v[1], 2)
    })
    
    test.run_suite(&suite)
}

// Main test runner
main = () i32   {
    io.println("=== Running Vector Module Tests ===\n")
    
    test_vec_creation()
    test_vec_push_pop()
    test_vec_insert_remove()
    test_vec_access()
    test_vec_iteration()
    test_vec_algorithms()
    test_vec_functional()
    test_vec_concat()
    test_vec_memory()
    
    io.println("\n=== All Vector Tests Completed ===")
    return 0
}