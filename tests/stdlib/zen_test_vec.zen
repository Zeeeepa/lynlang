// Comprehensive tests for Zen stdlib Vec and DynVec modules

{ Vec, DynVec } = @std.collections
{ test, assert } = @std.testing
{ io } = @std

// Test DynVec creation
test_dynvec_creation = () void   {
    suite := test.suite_new("DynVec Creation Tests")
    
    test.suite_add_test(&suite, "Create empty DynVec", () void {
        v := DynVec<i32>.new()
        assert.equal(v.len(), 0)
        assert.ok(v.is_empty())
        assert.equal(v.capacity(), 0)
    })
    
    test.suite_add_test(&suite, "Create DynVec with capacity", () void {
        result := DynVec<i32>.with_capacity(10)
        result ? 
            | core.Result:Ok(v) {
                assert.equal(v.len(), 0)
                assert.ok(v.capacity() >= 10)
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec with capacity")
            }
    })
    
    test.suite_add_test(&suite, "Create DynVec from array", () void {
        arr := [1, 2, 3, 4, 5]
        result := DynVec<i32>.from_array(arr, 5)
        result ?
            | core.Result:Ok(v) {
                assert.equal(v.len(), 5)
                assert.equal(v.get(0).unwrap(), 1)
                assert.equal(v.get(4).unwrap(), 5)
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec from array")
            }
    })
    
    test.suite_add_test(&suite, "Clone DynVec", () void {
        arr := [1, 2, 3]
        result1 := DynVec<i32>.from_array(arr, 3)
        result1 ?
            | core.Result:Ok(v1) {
                result2 := v1.clone()
                result2 ?
                    | core.Result:Ok(v2) {
                        assert.equal(v1.len(), v2.len())
                        for i in 0..v1.len() {
                            assert.equal(v1.get(i).unwrap(), v2.get(i).unwrap())
                        }
                    }
                    | core.Result:Err(_) {
                        assert.fail("Failed to clone DynVec")
                    }
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create initial DynVec")
            }
    })
    
    test.run_suite(&suite)
}

// Test Vec (fixed-size) creation
test_vec_creation = () void   {
    suite := test.suite_new("Vec Creation Tests")
    
    test.suite_add_test(&suite, "Create empty Vec", () void {
        v := Vec<i32, 10>.new()
        assert.equal(v.len(), 0)
        assert.ok(v.is_empty())
        assert.equal(v.capacity(), 10)
    })
    
    test.suite_add_test(&suite, "Create Vec from array", () void {
        arr := [1, 2, 3, 4, 5]
        v := Vec<i32, 5>.from_array(arr)
        assert.equal(v.len(), 5)
        assert.equal(v.get(0).unwrap(), 1)
        assert.equal(v.get(4).unwrap(), 5)
    })
    
    test.run_suite(&suite)
}

// Test DynVec push/pop operations
test_dynvec_push_pop = () void   {
    suite := test.suite_new("DynVec Push/Pop Tests")
    
    test.suite_add_test(&suite, "Push elements", () void {
        v := DynVec<i32>.new()
        v.push(1).unwrap()
        v.push(2).unwrap()
        v.push(3).unwrap()
        
        assert.equal(v.len(), 3)
        assert.equal(v.get(0).unwrap(), 1)
        assert.equal(v.get(1).unwrap(), 2)
        assert.equal(v.get(2).unwrap(), 3)
    })
    
    test.suite_add_test(&suite, "Pop elements", () void {
        arr := [1, 2, 3]
        result := DynVec<i32>.from_array(arr, 3)
        result ?
            | core.Result:Ok(v) {
                assert.equal(v.pop(), core.Option:Some(3))
                assert.equal(v.len(), 2)
                assert.equal(v.pop(), core.Option:Some(2))
                assert.equal(v.len(), 1)
                assert.equal(v.pop(), core.Option:Some(1))
                assert.equal(v.len(), 0)
                assert.equal(v.pop(), core.Option:None)
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec")
            }
    })
    
    test.suite_add_test(&suite, "Push and grow", () void {
        result := DynVec<i32>.with_capacity(2)
        result ?
            | core.Result:Ok(v) {
                initial_cap := v.capacity()
                
                v.push(1).unwrap()
                v.push(2).unwrap()
                v.push(3).unwrap()  // Should trigger growth
                
                assert.equal(v.len(), 3)
                assert.ok(v.capacity() > initial_cap)
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec with capacity")
            }
    })
    
    test.run_suite(&suite)
}

// Test Vec push/pop operations
test_vec_push_pop = () void   {
    suite := test.suite_new("Vec Push/Pop Tests")
    
    test.suite_add_test(&suite, "Push elements to Vec", () void {
        v := Vec<i32, 5>.new()
        v.push(1).unwrap()
        v.push(2).unwrap()
        v.push(3).unwrap()
        
        assert.equal(v.len(), 3)
        assert.equal(v.get(0).unwrap(), 1)
        assert.equal(v.get(1).unwrap(), 2)
        assert.equal(v.get(2).unwrap(), 3)
    })
    
    test.suite_add_test(&suite, "Pop elements from Vec", () void {
        arr := [1, 2, 3]
        v := Vec<i32, 5>.from_array(arr)
        
        assert.equal(v.pop(), core.Option:Some(3))
        assert.equal(v.len(), 2)
        assert.equal(v.pop(), core.Option:Some(2))
        assert.equal(v.len(), 1)
        assert.equal(v.pop(), core.Option:Some(1))
        assert.equal(v.len(), 0)
        assert.equal(v.pop(), core.Option:None)
    })
    
    test.suite_add_test(&suite, "Vec capacity limit", () void {
        v := Vec<i32, 3>.new()
        v.push(1).unwrap()
        v.push(2).unwrap()
        v.push(3).unwrap()
        
        // This should fail due to capacity limit
        result := v.push(4)
        result ?
            | core.Result:Ok(_) {
                assert.fail("Expected capacity error")
            }
            | core.Result:Err(_) {
                // Expected behavior
            }
    })
    
    test.run_suite(&suite)
}

// Test DynVec insertion and removal
test_dynvec_insert_remove = () void   {
    suite := test.suite_new("DynVec Insert/Remove Tests")
    
    test.suite_add_test(&suite, "Insert at index", () void {
        arr := [1, 2, 4, 5]
        result := DynVec<i32>.from_array(arr, 4)
        result ?
            | core.Result:Ok(v) {
                v.insert(2, 3).unwrap()
                
                assert.equal(v.len(), 5)
                assert.equal(v.get(0).unwrap(), 1)
                assert.equal(v.get(1).unwrap(), 2)
                assert.equal(v.get(2).unwrap(), 3)
                assert.equal(v.get(3).unwrap(), 4)
                assert.equal(v.get(4).unwrap(), 5)
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec")
            }
    })
    
    test.suite_add_test(&suite, "Remove at index", () void {
        arr := [1, 2, 3, 4, 5]
        result := DynVec<i32>.from_array(arr, 5)
        result ?
            | core.Result:Ok(v) {
                removed := v.remove(2).unwrap()
                
                assert.equal(removed, 3)
                assert.equal(v.len(), 4)
                assert.equal(v.get(0).unwrap(), 1)
                assert.equal(v.get(1).unwrap(), 2)
                assert.equal(v.get(2).unwrap(), 4)
                assert.equal(v.get(3).unwrap(), 5)
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec")
            }
    })
    
    test.suite_add_test(&suite, "Clear DynVec", () void {
        arr := [1, 2, 3, 4, 5]
        result := DynVec<i32>.from_array(arr, 5)
        result ?
            | core.Result:Ok(v) {
                cap := v.capacity()
                v.clear()
                
                assert.equal(v.len(), 0)
                assert.ok(v.is_empty())
                assert.equal(v.capacity(), cap)  // Capacity unchanged
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec")
            }
    })
    
    test.run_suite(&suite)
}

// Test DynVec memory management
test_dynvec_memory = () void   {
    suite := test.suite_new("DynVec Memory Tests")
    
    test.suite_add_test(&suite, "Reserve capacity", () void {
        v := DynVec<i32>.new()
        v.reserve(100).unwrap()
        
        assert.ok(v.capacity() >= 100)
        assert.equal(v.len(), 0)
    })
    
    test.suite_add_test(&suite, "Shrink to fit", () void {
        result := DynVec<i32>.with_capacity(100)
        result ?
            | core.Result:Ok(v) {
                v.push(1).unwrap()
                v.push(2).unwrap()
                v.push(3).unwrap()
                
                v.shrink_to_fit().unwrap()
                
                assert.equal(v.len(), 3)
                assert.ok(v.capacity() >= 3)
                assert.ok(v.capacity() < 100)
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec with capacity")
            }
    })
    
    test.run_suite(&suite)
}

// Test DynVec functional operations
test_dynvec_functional = () void   {
    suite := test.suite_new("DynVec Functional Tests")
    
    test.suite_add_test(&suite, "Map operation", () void {
        arr := [1, 2, 3, 4, 5]
        result := DynVec<i32>.from_array(arr, 5)
        result ?
            | core.Result:Ok(v) {
                mapped_result := v.map((x) i32 { x * 2 })
                mapped_result ?
                    | core.Result:Ok(mapped) {
                        assert.equal(mapped.get(0).unwrap(), 2)
                        assert.equal(mapped.get(1).unwrap(), 4)
                        assert.equal(mapped.get(2).unwrap(), 6)
                        assert.equal(mapped.get(3).unwrap(), 8)
                        assert.equal(mapped.get(4).unwrap(), 10)
                    }
                    | core.Result:Err(_) {
                        assert.fail("Failed to map DynVec")
                    }
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec")
            }
    })
    
    test.suite_add_test(&suite, "Filter operation", () void {
        arr := [1, 2, 3, 4, 5, 6]
        result := DynVec<i32>.from_array(arr, 6)
        result ?
            | core.Result:Ok(v) {
                filtered_result := v.filter((x) bool { x % 2 == 0 })
                filtered_result ?
                    | core.Result:Ok(filtered) {
                        assert.equal(filtered.len(), 3)
                        assert.equal(filtered.get(0).unwrap(), 2)
                        assert.equal(filtered.get(1).unwrap(), 4)
                        assert.equal(filtered.get(2).unwrap(), 6)
                    }
                    | core.Result:Err(_) {
                        assert.fail("Failed to filter DynVec")
                    }
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec")
            }
    })
    
    test.suite_add_test(&suite, "Fold operation", () void {
        arr := [1, 2, 3, 4, 5]
        result := DynVec<i32>.from_array(arr, 5)
        result ?
            | core.Result:Ok(v) {
                sum := v.fold(0, (acc, x) i32 { acc + x })
                assert.equal(sum, 15)
            }
            | core.Result:Err(_) {
                assert.fail("Failed to create DynVec")
            }
    })
    
    test.run_suite(&suite)
}

// Main test runner
main = () i32   {
    io.println("=== Running Vec and DynVec Module Tests ===\n")
    
    test_dynvec_creation()
    test_vec_creation()
    test_dynvec_push_pop()
    test_vec_push_pop()
    test_dynvec_insert_remove()
    test_dynvec_memory()
    test_dynvec_functional()
    
    io.println("\n=== All Vec and DynVec Tests Completed ===")
    return 0
}