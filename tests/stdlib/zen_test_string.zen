// Comprehensive tests for Zen stdlib string module

string := @std.string
test := @std.test
io := @std.io
assert := @std.assert
vec := @std.vec

// Test string creation and basic operations
test_string_creation: () void  = {
    suite := test.suite_new("String Creation Tests")
    
    test.suite_add_test(&suite, "String from literal", () void {
        s := string.from("hello")
        assert.equal(s.len(), 5)
        assert.equal(s.as_str(), "hello")
    })
    
    test.suite_add_test(&suite, "String from chars", () void {
        chars := ['h', 'e', 'l', 'l', 'o']
        s := string.from_chars(chars)
        assert.equal(s.as_str(), "hello")
    })
    
    test.suite_add_test(&suite, "String from bytes", () void {
        bytes := [72u8, 101u8, 108u8, 108u8, 111u8]  // "Hello" in ASCII
        s := string.from_bytes(bytes)
        assert.equal(s.as_str(), "Hello")
    })
    
    test.suite_add_test(&suite, "Empty string", () void {
        s := string.empty()
        assert.equal(s.len(), 0)
        assert.ok(s.is_empty())
    })
    
    test.suite_add_test(&suite, "String clone", () void {
        s1 := string.from("hello")
        s2 := s1.clone()
        assert.equal(s1.as_str(), s2.as_str())
        // Verify they're different objects (when mutability is added)
    })
    
    test.run_suite(&suite)
}

// Test string manipulation
test_string_manipulation: () void  = {
    suite := test.suite_new("String Manipulation Tests")
    
    test.suite_add_test(&suite, "String concatenation", () void {
        s1 := string.from("hello")
        s2 := string.from(" world")
        s3 := s1.concat(s2)
        assert.equal(s3.as_str(), "hello world")
    })
    
    test.suite_add_test(&suite, "String append", () void {
        s := string.from("hello")
        s.append(" world")
        assert.equal(s.as_str(), "hello world")
    })
    
    test.suite_add_test(&suite, "String push char", () void {
        s := string.from("hell")
        s.push('o')
        assert.equal(s.as_str(), "hello")
    })
    
    test.suite_add_test(&suite, "String pop char", () void {
        s := string.from("hello")
        c := s.pop()
        assert.equal(c, Some('o'))
        assert.equal(s.as_str(), "hell")
    })
    
    test.suite_add_test(&suite, "String insert", () void {
        s := string.from("hllo")
        s.insert(1, 'e')
        assert.equal(s.as_str(), "hello")
    })
    
    test.suite_add_test(&suite, "String remove", () void {
        s := string.from("hello")
        c := s.remove(1)
        assert.equal(c, 'e')
        assert.equal(s.as_str(), "hllo")
    })
    
    test.suite_add_test(&suite, "String clear", () void {
        s := string.from("hello")
        s.clear()
        assert.ok(s.is_empty())
        assert.equal(s.len(), 0)
    })
    
    test.run_suite(&suite)
}

// Test string searching
test_string_searching: () void  = {
    suite := test.suite_new("String Searching Tests")
    
    test.suite_add_test(&suite, "Contains substring", () void {
        s := string.from("hello world")
        assert.ok(s.contains("world"))
        assert.ok(s.contains("lo wo"))
        assert.ok(!s.contains("xyz"))
    })
    
    test.suite_add_test(&suite, "Starts with", () void {
        s := string.from("hello world")
        assert.ok(s.starts_with("hello"))
        assert.ok(s.starts_with(""))
        assert.ok(!s.starts_with("world"))
    })
    
    test.suite_add_test(&suite, "Ends with", () void {
        s := string.from("hello world")
        assert.ok(s.ends_with("world"))
        assert.ok(s.ends_with(""))
        assert.ok(!s.ends_with("hello"))
    })
    
    test.suite_add_test(&suite, "Find substring", () void {
        s := string.from("hello world")
        assert.equal(s.find("world"), Some(6))
        assert.equal(s.find("lo"), Some(3))
        assert.equal(s.find("xyz"), None)
    })
    
    test.suite_add_test(&suite, "Find char", () void {
        s := string.from("hello world")
        assert.equal(s.find_char('o'), Some(4))
        assert.equal(s.find_char('w'), Some(6))
        assert.equal(s.find_char('z'), None)
    })
    
    test.suite_add_test(&suite, "Rfind substring", () void {
        s := string.from("hello hello")
        assert.equal(s.rfind("hello"), Some(6))
        assert.equal(s.rfind("lo"), Some(9))
    })
    
    test.run_suite(&suite)
}

// Test string transformation
test_string_transformation: () void  = {
    suite := test.suite_new("String Transformation Tests")
    
    test.suite_add_test(&suite, "To uppercase", () void {
        s := string.from("Hello World!")
        upper := s.to_uppercase()
        assert.equal(upper.as_str(), "HELLO WORLD!")
    })
    
    test.suite_add_test(&suite, "To lowercase", () void {
        s := string.from("Hello World!")
        lower := s.to_lowercase()
        assert.equal(lower.as_str(), "hello world!")
    })
    
    test.suite_add_test(&suite, "Trim whitespace", () void {
        s := string.from("  hello world  \n")
        trimmed := s.trim()
        assert.equal(trimmed.as_str(), "hello world")
    })
    
    test.suite_add_test(&suite, "Trim start", () void {
        s := string.from("  hello world  ")
        trimmed := s.trim_start()
        assert.equal(trimmed.as_str(), "hello world  ")
    })
    
    test.suite_add_test(&suite, "Trim end", () void {
        s := string.from("  hello world  ")
        trimmed := s.trim_end()
        assert.equal(trimmed.as_str(), "  hello world")
    })
    
    test.suite_add_test(&suite, "Replace substring", () void {
        s := string.from("hello world")
        replaced := s.replace("world", "zen")
        assert.equal(replaced.as_str(), "hello zen")
    })
    
    test.suite_add_test(&suite, "Replace all occurrences", () void {
        s := string.from("hello hello hello")
        replaced := s.replace_all("hello", "hi")
        assert.equal(replaced.as_str(), "hi hi hi")
    })
    
    test.run_suite(&suite)
}

// Test string splitting and joining
test_string_split_join: () void  = {
    suite := test.suite_new("String Split/Join Tests")
    
    test.suite_add_test(&suite, "Split by delimiter", () void {
        s := string.from("hello,world,zen")
        parts := s.split(",")
        assert.equal(parts.len(), 3)
        assert.equal(parts[0].as_str(), "hello")
        assert.equal(parts[1].as_str(), "world")
        assert.equal(parts[2].as_str(), "zen")
    })
    
    test.suite_add_test(&suite, "Split by whitespace", () void {
        s := string.from("hello world  zen\tlang")
        parts := s.split_whitespace()
        assert.equal(parts.len(), 4)
        assert.equal(parts[0].as_str(), "hello")
        assert.equal(parts[1].as_str(), "world")
        assert.equal(parts[2].as_str(), "zen")
        assert.equal(parts[3].as_str(), "lang")
    })
    
    test.suite_add_test(&suite, "Split lines", () void {
        s := string.from("hello\nworld\r\nzen")
        lines := s.lines()
        assert.equal(lines.len(), 3)
        assert.equal(lines[0].as_str(), "hello")
        assert.equal(lines[1].as_str(), "world")
        assert.equal(lines[2].as_str(), "zen")
    })
    
    test.suite_add_test(&suite, "Join strings", () void {
        strings := vec.from(["hello", "world", "zen"])
        joined := string.join(strings, ", ")
        assert.equal(joined.as_str(), "hello, world, zen")
    })
    
    test.run_suite(&suite)
}

// Test string parsing
test_string_parsing: () void  = {
    suite := test.suite_new("String Parsing Tests")
    
    test.suite_add_test(&suite, "Parse integer", () void {
        s := string.from("42")
        n := s.parse_i32()
        assert.equal(n, Ok(42))
        
        s2 := string.from("-123")
        n2 := s2.parse_i32()
        assert.equal(n2, Ok(-123))
        
        s3 := string.from("abc")
        n3 := s3.parse_i32()
        assert.ok(n3.is_err())
    })
    
    test.suite_add_test(&suite, "Parse float", () void {
        s := string.from("3.14")
        f := s.parse_f64()
        match f {
            | Ok(val) => assert.approx_equal(val, 3.14, 0.001)
            | Err(_) => assert.fail("Failed to parse float")
        }
        
        s2 := string.from("-2.5")
        f2 := s2.parse_f64()
        match f2 {
            | Ok(val) => assert.approx_equal(val, -2.5, 0.001)
            | Err(_) => assert.fail("Failed to parse negative float")
        }
    })
    
    test.suite_add_test(&suite, "Parse bool", () void {
        assert.equal(string.from("true").parse_bool(), Ok(true))
        assert.equal(string.from("false").parse_bool(), Ok(false))
        assert.ok(string.from("yes").parse_bool().is_err())
    })
    
    test.run_suite(&suite)
}

// Test string formatting
test_string_formatting: () void  = {
    suite := test.suite_new("String Formatting Tests")
    
    test.suite_add_test(&suite, "Format with placeholders", () void {
        s := string.format("Hello, {}!", "world")
        assert.equal(s.as_str(), "Hello, world!")
        
        s2 := string.format("{} + {} = {}", 2, 3, 5)
        assert.equal(s2.as_str(), "2 + 3 = 5")
    })
    
    test.suite_add_test(&suite, "Pad left", () void {
        s := string.from("hello")
        padded := s.pad_left(10, ' ')
        assert.equal(padded.as_str(), "     hello")
        assert.equal(padded.len(), 10)
    })
    
    test.suite_add_test(&suite, "Pad right", () void {
        s := string.from("hello")
        padded := s.pad_right(10, ' ')
        assert.equal(padded.as_str(), "hello     ")
        assert.equal(padded.len(), 10)
    })
    
    test.suite_add_test(&suite, "Repeat string", () void {
        s := string.from("abc")
        repeated := s.repeat(3)
        assert.equal(repeated.as_str(), "abcabcabc")
    })
    
    test.run_suite(&suite)
}

// Test string iteration
test_string_iteration: () void  = {
    suite := test.suite_new("String Iteration Tests")
    
    test.suite_add_test(&suite, "Iterate chars", () void {
        s := string.from("hello")
        chars := vec.new<char>()
        
        for c in s.chars() {
            chars.push(c)
        }
        
        assert.equal(chars.len(), 5)
        assert.equal(chars[0], 'h')
        assert.equal(chars[4], 'o')
    })
    
    test.suite_add_test(&suite, "Iterate bytes", () void {
        s := string.from("hello")
        bytes := vec.new<u8>()
        
        for b in s.bytes() {
            bytes.push(b)
        }
        
        assert.equal(bytes.len(), 5)
        assert.equal(bytes[0], 104u8)  // 'h'
        assert.equal(bytes[4], 111u8)  // 'o'
    })
    
    test.suite_add_test(&suite, "Char indices", () void {
        s := string.from("hello")
        indices := vec.new<(usize, char)>()
        
        for (i, c) in s.char_indices() {
            indices.push((i, c))
        }
        
        assert.equal(indices.len(), 5)
        assert.equal(indices[0], (0, 'h'))
        assert.equal(indices[4], (4, 'o'))
    })
    
    test.run_suite(&suite)
}

// Main test runner
main: () i32  = {
    io.println("=== Running String Module Tests ===\n")
    
    test_string_creation()
    test_string_manipulation()
    test_string_searching()
    test_string_transformation()
    test_string_split_join()
    test_string_parsing()
    test_string_formatting()
    test_string_iteration()
    
    io.println("\n=== All String Tests Completed ===")
    return 0
}