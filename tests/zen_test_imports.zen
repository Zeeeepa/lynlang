// Import tests from LANGUAGE_SPEC.zen lines 91-107
// Tests @std imports and destructuring

// Destructuring imports (lines 91-94)
{ io, maths } = @std
{ String, StringBuilder } = @std

// Meta imports (line 97)
{ requires, implements, reflect, meta, inline, simd } = @std

// Memory/allocator imports (line 99)
{ GPA, AsyncPool, Allocator} = @std

// Collection imports (line 101)
{ Vec, DynVec} = @std

// Concurrency imports (line 103)
{ Actor, Channel, Mutex, AtomicU32 } = @std

// External module imports (lines 105-106)
sdl2 = @std.import("sdl2")
ecs = @std.import("ecs")

main = () void {
    // Use imported io
    io.println("Testing imports")
    
    // Use math functions
    pi = maths.pi
    sqrt_two = maths.sqrt(2.0)
    
    // Use StringBuilder
    sb = StringBuilder()
    sb.append("Hello")
      .append(" ")
      .append("World")
    result = sb.build()
    
    // Use Vec (static sized)
    numbers = Vec<i32, 10>()
    numbers.push(1)
    numbers.push(2)
    numbers.push(3)
    
    // Use allocator for DynVec
    alloc = GPA.init()
    @this.defer(alloc.deinit())
    
    dynamic_vec = DynVec<i32>(alloc)
    @this.defer(dynamic_vec.deinit())
    
    dynamic_vec.push(10)
    dynamic_vec.push(20)
    dynamic_vec.push(30)
    
    // Use Channel for concurrency
    chan = Channel<string>(5)
    @this.defer(chan.close())
    
    chan.send("Message 1")
    chan.send("Message 2")
    
    // Receive messages
    msg1 = chan.receive()
    msg1 ?
        | Some(m) { io.println("Got: ${m}") }
        | None { io.println("Channel closed") }
    
    // Use Mutex
    counter = Mutex<i32>(0)
    @this.defer(counter.deinit())
    
    counter.lock() ?
        | Ok(val) {
            val = val + 1
            counter.unlock()
        }
        | Err(e) {
            io.println("Lock failed: ${e}")
        }
    
    // Use AtomicU32
    atomic = AtomicU32(0)
    atomic.fetch_add(1)
    current = atomic.load()
    io.println("Atomic value: ${current}")
}