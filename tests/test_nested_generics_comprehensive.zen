// Comprehensive test for nested generic type handling
{ io, Result, Option } = @std

// Test 1: Result<Result<T, E1>, E2>
nested_result_result = () Result<Result<i32, string>, string> {
    inner = Result.Ok(42)
    Result.Ok(inner)
}

// Test 2: Result<Option<T>, E>
nested_result_option = () Result<Option<i32>, string> {
    some_val = Option.Some(100)
    Result.Ok(some_val)
}

// Test 3: Option<Result<T, E>>
nested_option_result = () Option<Result<i32, string>> {
    ok_val = Result.Ok(200)
    Option.Some(ok_val)
}

// Test 4: Triple nesting - Result<Option<Result<T, E1>>, E2>
triple_nested = () Result<Option<Result<i32, string>>, string> {
    inner_result = Result.Ok(300)
    middle_option = Option.Some(inner_result)
    Result.Ok(middle_option)
}

// Test raise() with nested Result<Result<T, E1>, E2>
test_nested_raise = () Result<i32, string> {
    // Extract Result<i32, string> from Result<Result<i32, string>, string>
    inner = nested_result_result().raise()
    // Extract i32 from Result<i32, string>
    val = inner.raise()
    Result.Ok(val + 8) // Should be 50
}

// Test pattern matching with nested types
test_nested_patterns = () i32 {
    result = nested_result_option()
    
    result ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(v) { v }
                | Option.None { 0 - 1 }
        }
        | Result.Err(_) { 0 - 2 }
}

// Test with function composition
compose_nested = (x: i32) Result<Option<i32>, string> {
    x > 0 ?
        | true { Result.Ok(Option.Some(x * 2)) }
        | false { Result.Ok(Option.None) }
}

test_composition = () i32 {
    result = compose_nested(25)
    result ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(v) { v }  // Should be 50
                | Option.None { 0 }
        }
        | Result.Err(_) { 0 - 1 }
}

main = () i32 {
    // Test 1: nested raise
    test1 = test_nested_raise()
    test1 ?
        | Result.Ok(v) {
            v == 50 ?
                | true { io.println("Test 1 passed: nested raise") }
                | false { io.println("Test 1 failed: expected 50, got ${v}") }
        }
        | Result.Err(e) { io.println("Test 1 failed with error: ${e}") }
    
    // Test 2: nested patterns
    test2 = test_nested_patterns()
    test2 == 100 ?
        | true { io.println("Test 2 passed: nested patterns") }
        | false { io.println("Test 2 failed: expected 100, got ${test2}") }
    
    // Test 3: composition
    test3 = test_composition()
    test3 == 50 ?
        | true { io.println("Test 3 passed: composition") }
        | false { io.println("Test 3 failed: expected 50, got ${test3}") }
    
    // Test 4: Option<Result<T,E>>
    opt_res = nested_option_result()
    opt_res ?
        | Option.Some(res) {
            res ?
                | Result.Ok(v) {
                    v == 200 ?
                        | true { io.println("Test 4 passed: Option<Result>") }
                        | false { io.println("Test 4 failed: expected 200, got ${v}") }
                }
                | Result.Err(e) { io.println("Test 4 failed with error: ${e}") }
        }
        | Option.None { io.println("Test 4 failed: got None") }
    
    // All tests passed
    0
}