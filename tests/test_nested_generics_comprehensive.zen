// Comprehensive test for nested generic types
{ io, Result, Option , get_default_allocator} = @std

// Test 1: Double nested Result<Result<T,E>,E>
test_double_nested_result = () i32 {
    io.println("Test 1: Double nested Result<Result<T,E>,E>")
    
    // Function that returns nested result
    get_double_nested = () Result<Result<i32, string>, string> {
        Result.Ok(Result.Ok(100))
    }
    
    outer_result = get_double_nested()
    inner_result = outer_result.raise()
    value = inner_result.raise()
    
    io.println("  Expected: 100, Got: ${value}")
    value == 100 ? 
        | true { io.println("  ✓ Double nesting works") }
        | false { io.println("  ✗ Double nesting failed") }
    
    return 0
}

// Test 2: Triple nested Result<Result<Result<T,E>,E>,E>
test_triple_nested_result = () void {
    io.println("\nTest 2: Triple nested Result<Result<Result<T,E>,E>,E>")
    
    get_triple_nested = () Result<Result<Result<i32, string>, string>, string> {
        Result.Ok(Result.Ok(Result.Ok(200)))
    }
    
    level1 = get_triple_nested()
    level2 = level1.raise()
    level3 = level2.raise()
    value = level3.raise()
    
    io.println("  Expected: 200, Got: ${value}")
    value == 200 ? 
        | true { io.println("  ✓ Triple nesting works") }
        | false { io.println("  ✗ Triple nesting failed: got ${value}") }
}

// Test 3: Result<Option<T>, E>
test_result_option = () void {
    io.println("\nTest 3: Result<Option<T>, E>")
    
    get_result_option = () Result<Option<i32>, string> {
        Result.Ok(Option.Some(300))
    }
    
    result = get_result_option()
    opt = result.raise()
    
    opt ?
        | Option.Some(v) { 
            io.println("  Expected: 300, Got: ${v}")
            v == 300 ? 
                | true { io.println("  ✓ Result<Option<T>, E> works") }
                | false { io.println("  ✗ Result<Option<T>, E> failed") }
        }
        | Option.None { io.println("  ✗ Got None unexpectedly") }
}

// Test 4: Option<Result<T, E>>
test_option_result = () void {
    io.println("\nTest 4: Option<Result<T, E>>")
    
    get_option_result = () Option<Result<i32, string>> {
        Option.Some(Result.Ok(400))
    }
    
    opt = get_option_result()
    
    opt ?
        | Option.Some(result) {
            val = result.raise()
            io.println("  Expected: 400, Got: ${val}")
            val == 400 ? 
                | true { io.println("  ✓ Option<Result<T, E>> works") }
                | false { io.println("  ✗ Option<Result<T, E>> failed") }
        }
        | Option.None { io.println("  ✗ Got None unexpectedly") }
}

// Test 5: Mixed with different payload types
test_mixed_payloads = () void {
    io.println("\nTest 5: Mixed payload types")
    
    // Result<Result<string, i32>, f64>
    get_string_nested = () Result<Result<string, i32>, f64> {
        Result.Ok(Result.Ok("Hello"))
    }
    
    outer = get_string_nested()
    inner = outer.raise()
    value = inner.raise()
    
    io.println("  Expected: 'Hello', Got: '${value}'")
    value == "Hello" ? 
        | true { io.println("  ✓ String payloads in nested work") }
        | false { io.println("  ✗ String payloads failed") }
}

// Test 6: Method chaining on nested results
test_method_chaining = () void {
    io.println("\nTest 6: Method chaining")
    
    get_chained = () Result<Result<i32, string>, string> {
        Result.Ok(Result.Ok(500))
    }
    
    // Chain multiple raise() calls
    value = get_chained().raise().raise()
    
    io.println("  Expected: 500, Got: ${value}")
    value == 500 ? 
        | true { io.println("  ✓ Method chaining works") }
        | false { io.println("  ✗ Method chaining failed") }
}

// Test 7: Variables holding nested generics
test_variable_type_inference = () void {
    io.println("\nTest 7: Variable type inference")
    
    // Store nested result in variable
    nested_result = Result.Ok(Result.Ok(600))
    
    // Extract through variable
    inner = nested_result.raise()
    value = inner.raise()
    
    io.println("  Expected: 600, Got: ${value}")
    value == 600 ? 
        | true { io.println("  ✓ Variable type inference works") }
        | false { io.println("  ✗ Variable type inference failed") }
}

// Test 8: Complex nesting with closures
test_closure_nested = () void {
    io.println("\nTest 8: Closures returning nested generics")
    
    make_nested = () Result<Result<i32, string>, string> {
        // Simplified to avoid nested closure issue
        Result.Ok(Result.Ok(700))
    }
    
    result = make_nested()
    inner = result.raise()
    value = inner.raise()
    
    io.println("  Expected: 700, Got: ${value}")
    value == 700 ? 
        | true { io.println("  ✓ Closures with nested generics work") }
        | false { io.println("  ✗ Closures with nested generics failed") }
}

// Test 9: Error cases in nested Results  
test_error_propagation = () void {
    io.println("\nTest 9: Error propagation in nested")
    
    get_nested_err = () Result<Result<i32, string>, string> {
        Result.Ok(Result.Err("inner error"))
    }
    
    outer = get_nested_err()
    inner = outer.raise()  // Gets Result.Err("inner error")
    
    inner ?
        | Result.Ok(v) { io.println("  ✗ Should have gotten error") }
        | Result.Err(e) { 
            io.println("  Expected: 'inner error', Got: '${e}'")
            e == "inner error" ?
                | true { io.println("  ✓ Error propagation works") }
                | false { io.println("  ✗ Wrong error message") }
        }
}

// Test 10: Option<Option<T>>
test_double_option = () void {
    io.println("\nTest 10: Option<Option<T>>")
    
    get_double_opt = () Option<Option<i32>> {
        Option.Some(Option.Some(800))
    }
    
    outer = get_double_opt()
    
    outer ?
        | Option.Some(inner) {
            inner ?
                | Option.Some(v) {
                    io.println("  Expected: 800, Got: ${v}")
                    v == 800 ?
                        | true { io.println("  ✓ Option<Option<T>> works") }
                        | false { io.println("  ✗ Option<Option<T>> failed") }
                }
                | Option.None { io.println("  ✗ Inner was None") }
        }
        | Option.None { io.println("  ✗ Outer was None") }
}

main = () void {
    alloc = get_default_allocator()
    io.println("=== Comprehensive Nested Generics Test ===\n")
    
    test_double_nested_result()
    test_triple_nested_result()
    test_result_option()
    test_option_result()
    test_mixed_payloads()
    test_method_chaining()
    test_variable_type_inference()
    test_closure_nested()
    test_error_propagation()
    test_double_option()
    
    io.println("\n=== Test Complete ===")
}