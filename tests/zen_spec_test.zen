// Test file to verify LANGUAGE_SPEC.zen features are working

// Import syntax from spec (line 92-94)
{ io, math } = @std

// Option type from spec (line 109-110)
Option<T>: Some(T) | None

// Result type from spec (line 112-113)
Result<T, E>: Ok(T) | Err(E)

// Simple struct from spec (line 116-120)
Point: {
    x:: f64,     // mutable field
    y:: f64 = 0  // with default value
}

// Function with explicit types from spec
main = () void {
    io.println("=== Testing Zen Language Spec Features ===")
    
    // Test 1: Variable declarations from spec (lines 299-306)
    io.println("\n1. Variable Declarations:")
    x: i32            // forward declaration
    x = 10           // immutable assignment
    io.println("x (forward declared) = ${x}")
    
    y = 20           // immutable inferred
    io.println("y (immutable inferred) = ${y}")
    
    z: i32 = 30      // immutable with type
    io.println("z (immutable typed) = ${z}")
    
    w:: i32          // mutable forward declaration
    w = 40
    w = 45           // can reassign
    io.println("w (mutable forward) = ${w}")
    
    v ::= 50         // mutable inferred
    v = 55           // can reassign
    io.println("v (mutable inferred) = ${v}")
    
    u :: i32 = 60    // mutable with type
    u = 65           // can reassign
    io.println("u (mutable typed) = ${u}")
    
    // Test 2: Pattern matching from spec (lines 352-361)
    io.println("\n2. Pattern Matching:")
    is_ready = true
    is_ready ? {
        io.println("Pattern match on boolean (short form)")
    }
    
    has_data = false
    has_data ?
        | true { io.println("Has data") }
        | false { io.println("No data (matched!)") }
    
    // Test 3: Option handling from spec (lines 462-473)
    io.println("\n3. Option Handling:")
    maybe_radius: Option<f64> = Some(5.5)
    maybe_radius ?
        | Some(r) {
            io.println("Radius is Some(${r})")
        }
        | None {
            io.println("No radius")
        }
    
    // Test 4: @this.defer from spec (line 217)
    io.println("\n4. @this special symbol:")
    io.println("@this is a special symbol for current scope")
    
    // Test 5: Range iterations from spec (lines 431-439)
    io.println("\n5. Range Iterations:")
    (0..3).loop((i) {
        io.println("Range 0..3: ${i}")
    })
    
    // Test 6: Break in loop from spec (lines 453-459)
    io.println("\n6. Loop with break:")
    counter ::= 0
    loop(() {
        counter = counter + 1
        io.println("Loop counter: ${counter}")
        counter >= 2 ?
            | true { break }
            | false { }
    })
    
    // Test 7: Structs with mutable fields
    io.println("\n7. Structs with mutable fields:")
    point ::= Point { x: 1.0, y: 2.0 }
    io.println("Point: x=${point.x}, y=${point.y}")
    point.x = 3.0  // can mutate x because it's declared with ::
    point.y = 4.0  // can mutate y because it's declared with ::
    io.println("After mutation: x=${point.x}, y=${point.y}")
    
    io.println("\n=== All Spec Tests Complete ===")
}