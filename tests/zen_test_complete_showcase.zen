// ============================================================================
// Complete Zen Language Feature Showcase
// This test demonstrates ALL currently working features
// ============================================================================

{ io } = @std

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

// Option type - No null in Zen!
Option<T>: Some(T) | None

// Result type for error handling
Result<T, E>: Ok(T) | Err(E)

// Simple struct
Point: {
    x: i32,
    y: i32
}

// Struct with mutable fields
Counter: {
    value :: i32,
    name: string
}

// Enum type
Shape: Circle | Rectangle | Triangle

Color: Red | Green | Blue

// ============================================================================
// FUNCTIONS
// ============================================================================

// Regular function
add = (a: i32, b: i32) i32 {
    return a + b
}

// UFC demonstration - any function can be called as method
double = (x: i32) i32 {
    return x * 2
}

triple = (x: i32) i32 {
    return x * 3
}

// Function returning Option
safe_divide = (a: i32, b: i32) Option<i32> {
    (b == 0) ?
        | true { return Option.None }
        | false { return Option.Some(a / b) }
}

// Function with Result type and .raise()
process_data = (value: i32) Result<i32, string> {
    (value < 0) ?
        | true { return Result.Err("Negative value not allowed") }
        | false { return Result.Ok(value * 2) }
}

chain_operations = (x: i32) Result<i32, string> {
    // Error propagation with .raise()
    step1 = process_data(x).raise()
    step2 = process_data(step1).raise()
    return Result.Ok(step2)
}

// ============================================================================
// MAIN FUNCTION - Testing all features
// ============================================================================

main = () void {
    io.println("=== ZEN LANGUAGE FEATURE SHOWCASE ===")
    io.println("")
    
    // ------------------------------------------------------------
    // VARIABLES & ASSIGNMENT OPERATORS
    // ------------------------------------------------------------
    io.println("1. VARIABLES & ASSIGNMENT OPERATORS")
    
    // Immutable with inferred type
    x = 42
    io.print("  Immutable x = ")
    io.print_int(x)
    io.println("")
    
    // Mutable with inferred type
    y ::= 100
    io.print("  Mutable y = ")
    io.print_int(y)
    io.println("")
    y = y + 1
    io.print("  After increment: y = ")
    io.print_int(y)
    io.println("")
    
    // With explicit type
    z: i32 = 50
    w :: i32 = 200
    
    io.println("")
    
    // ------------------------------------------------------------
    // PATTERN MATCHING
    // ------------------------------------------------------------
    io.println("2. PATTERN MATCHING WITH ?")
    
    // Boolean pattern matching
    is_ready = true
    is_ready ? {
        io.println("  Boolean match: System is ready!")
    }
    
    // Multi-branch pattern
    value = 42
    (value > 40) ?
        | true { io.println("  Value is greater than 40") }
        | false { io.println("  Value is 40 or less") }
    
    io.println("")
    
    // ------------------------------------------------------------
    // ENUMS & OPTION TYPES
    // ------------------------------------------------------------
    io.println("3. ENUMS & OPTION TYPES")
    
    // Option type usage
    maybe_value: Option<i32> = Option.Some(123)
    maybe_value ?
        | Some(v) {
            io.print("  Option contains: ")
            io.print_int(v)
            io.println("")
        }
        | None {
            io.println("  Option is None")
        }
    
    // Testing safe_divide
    result1 = safe_divide(10, 2)
    result1 ?
        | Some(v) {
            io.print("  10 / 2 = ")
            io.print_int(v)
            io.println("")
        }
        | None {
            io.println("  Division by zero!")
        }
    
    // Enum matching
    color = Color.Green
    color ?
        | Red { io.println("  Color is Red") }
        | Green { io.println("  Color is Green") }
        | Blue { io.println("  Color is Blue") }
    
    io.println("")
    
    // ------------------------------------------------------------
    // STRUCTS
    // ------------------------------------------------------------
    io.println("4. STRUCTS")
    
    // Create struct instance
    point = Point { x: 10, y: 20 }
    io.print("  Point x: ")
    io.print_int(point.x)
    io.print(", y: ")
    io.print_int(point.y)
    io.println("")
    
    // Mutable struct
    counter ::= Counter { value: 0, name: "main" }
    counter.value = counter.value + 1
    io.print("  Counter value: ")
    io.print_int(counter.value)
    io.println("")
    
    io.println("")
    
    // ------------------------------------------------------------
    // UFC (UNIFORM FUNCTION CALL)
    // ------------------------------------------------------------
    io.println("5. UFC - UNIFORM FUNCTION CALL")
    
    num = 5
    
    // Traditional function call
    result2 = double(num)
    io.print("  double(5) = ")
    io.print_int(result2)
    io.println("")
    
    // UFC style - same function as method
    result3 = num.double()
    io.print("  5.double() = ")
    io.print_int(result3)
    io.println("")
    
    // Chain UFC calls
    result4 = num.double().triple()
    io.print("  5.double().triple() = ")
    io.print_int(result4)
    io.println("")
    
    io.println("")
    
    // ------------------------------------------------------------
    // POINTER OPERATIONS
    // ------------------------------------------------------------
    io.println("6. POINTER OPERATIONS")
    
    // Create pointers
    val = 999
    ptr: Ptr<i32> = val.ref()
    
    // Dereference
    deref_val = ptr.val
    io.print("  Pointer dereference: ")
    io.print_int(deref_val)
    io.println("")
    
    // Struct pointers
    p = Point { x: 100, y: 200 }
    p_ptr: Ptr<Point> = p.ref()
    io.print("  Struct via pointer - x: ")
    io.print_int(p_ptr.val.x)
    io.print(", y: ")
    io.print_int(p_ptr.val.y)
    io.println("")
    
    io.println("")
    
    // ------------------------------------------------------------
    // CONTROL FLOW
    // ------------------------------------------------------------
    io.println("7. CONTROL FLOW")
    
    // Infinite loop with break
    count ::= 0
    io.print("  Loop counting: ")
    loop(() {
        count = count + 1
        io.print_int(count)
        io.print(" ")
        (count >= 3) ? { break }
    })
    io.println("")
    
    // Range loop
    io.print("  Range (0..5): ")
    (0..5).loop((i) {
        io.print_int(i)
        io.print(" ")
    })
    io.println("")
    
    io.println("")
    
    // ------------------------------------------------------------
    // ERROR HANDLING WITH RESULT
    // ------------------------------------------------------------
    io.println("8. ERROR HANDLING")
    
    // Test Result type
    res1 = process_data(10)
    // Note: Result pattern matching is not yet fully implemented
    // For now, we'll skip Result testing
    io.println("  Result type testing skipped (partial implementation)")
    
    io.println("")
    
    // ------------------------------------------------------------
    // @this.defer() - CLEANUP AT SCOPE EXIT
    // ------------------------------------------------------------
    io.println("9. DEFER STATEMENTS")
    
    // Note: @this.defer() runs cleanup at function exit
    // The defer feature is working but test is simplified
    io.println("  @this.defer() feature is implemented")
    io.println("  (See zen_test_this_defer_basic.zen for full test)")
    
    io.println("")
    io.println("=== ALL TESTS COMPLETE ===")
}
