// Comprehensive FFI Tests for Zen
// Tests Foreign Function Interface with Builder Pattern per Language Spec v1.1.0

test := @std.testing.test
assert := @std.testing.assert
assert_eq := @std.testing.assert_eq

// Test FFI builder pattern for basic C library
test("ffi builder basic") {
    // Test the builder pattern API
    math_lib := FFI.lib("m")
        .path("/usr/lib/libm.so")
        .function("sin", {
            params: [f64],
            returns: f64,
        })
        .function("cos", {
            params: [f64],
            returns: f64,
        })
        .function("sqrt", {
            params: [f64],
            returns: f64,
        })
        .constant("M_PI", f64)
        .build()
    
    // Test function calls
    result := math_lib.sin(0.0)
    assert(result >= -0.001 && result <= 0.001, "sin(0) should be ~0")
    
    result2 := math_lib.cos(0.0)
    assert(result2 >= 0.999 && result2 <= 1.001, "cos(0) should be ~1")
    
    result3 := math_lib.sqrt(4.0)
    assert(result3 >= 1.999 && result3 <= 2.001, "sqrt(4) should be ~2")
}

// Test SQLite FFI with more complex API
test("ffi sqlite example") {
    sqlite := FFI.lib("sqlite3")
        .path("/usr/lib/libsqlite3.so")
        .function("sqlite3_open", {
            params: [string, Ptr<RawPtr<void>>],
            returns: i32,
        })
        .function("sqlite3_close", {
            params: [RawPtr<void>],
            returns: i32,
        })
        .function("sqlite3_exec", {
            params: [RawPtr<void>, string, RawPtr<void>, RawPtr<void>, Ptr<string>],
            returns: i32,
        })
        .function("sqlite3_errmsg", {
            params: [RawPtr<void>],
            returns: string,
        })
        .constant("SQLITE_OK", i32)
        .constant("SQLITE_ERROR", i32)
        .constant("SQLITE_BUSY", i32)
        .build()
    
    // Test database operations
    db_ptr:: RawPtr<void>
    result := sqlite.sqlite3_open(":memory:", Ptr::new(db_ptr))
    
    assert_eq(result, sqlite.SQLITE_OK)
    
    // Create table
    create_sql := "CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)"
    error_msg:: string
    exec_result := sqlite.sqlite3_exec(
        db_ptr, 
        create_sql, 
        RawPtr::null(), 
        RawPtr::null(), 
        Ptr::new(error_msg)
    )
    
    assert_eq(exec_result, sqlite.SQLITE_OK)
    
    // Close database
    close_result := sqlite.sqlite3_close(db_ptr)
    assert_eq(close_result, sqlite.SQLITE_OK)
}

// Test platform-specific configuration
test("ffi platform specific") {
    // Test platform detection and configuration
    lib := FFI.lib("test")
        .platform_config(Platform::Linux, {
            path_override: Some("/usr/lib/libtest.so"),
            calling_convention_override: Some(CallingConvention::C),
        })
        .platform_config(Platform::Windows, {
            path_override: Some("C:\\Windows\\System32\\test.dll"),
            calling_convention_override: Some(CallingConvention::Stdcall),
        })
        .platform_config(Platform::MacOS, {
            path_override: Some("/usr/lib/libtest.dylib"),
            calling_convention_override: Some(CallingConvention::C),
        })
        .auto_configure()
        .build()
    
    // Verify platform was configured
    assert(lib != null, "Library should be configured for current platform")
}

// Test struct definitions for FFI
test("ffi struct definitions") {
    lib := FFI.lib("custom")
        .struct_def("Point", [
            ("x", f64),
            ("y", f64),
        ])
        .struct_def("Rectangle", [
            ("top_left", Point),
            ("width", f64),
            ("height", f64),
        ])
        .function("calculate_area", {
            params: [Rectangle],
            returns: f64,
        })
        .build()
    
    // Test struct usage
    point := Point{ x: 0.0, y: 0.0 }
    rect := Rectangle{
        top_left: point,
        width: 10.0,
        height: 5.0,
    }
    
    // Would call the C function if library was loaded
    // area := lib.calculate_area(rect)
    // assert_eq(area, 50.0)
    
    assert(true, "Struct definitions created successfully")
}

// Test enum definitions for FFI
test("ffi enum definitions") {
    lib := FFI.lib("status")
        .enum_def("StatusCode", [
            "SUCCESS",
            "ERROR",
            "PENDING",
            "CANCELLED",
        ])
        .function("get_status", {
            params: [],
            returns: StatusCode,
        })
        .function("set_status", {
            params: [StatusCode],
            returns: void,
        })
        .build()
    
    // Test enum usage
    assert(true, "Enum definitions created successfully")
}

// Test callback definitions
test("ffi callbacks") {
    lib := FFI.lib("events")
        .callback("EventHandler", {
            params: [i32, string],
            returns: void,
        })
        .function("register_handler", {
            params: [EventHandler],
            returns: void,
        })
        .function("trigger_event", {
            params: [i32, string],
            returns: void,
        })
        .build()
    
    // Define a callback function
    my_handler = (code: i32, msg: string) void {
        io := @std.build.import("io")
        io.print("Event $(code): $(msg)")
    }
    
    // Would register the callback if library was loaded
    // lib.register_handler(my_handler)
    // lib.trigger_event(42, "Test event")
    
    assert(true, "Callback definitions created successfully")
}

// Test opaque pointer types
test("ffi opaque types") {
    lib := FFI.lib("handles")
        .opaque_type("FileHandle")
        .opaque_type("WindowHandle")
        .function("open_file", {
            params: [string],
            returns: RawPtr<FileHandle>,
        })
        .function("close_file", {
            params: [RawPtr<FileHandle>],
            returns: void,
        })
        .function("create_window", {
            params: [i32, i32],
            returns: RawPtr<WindowHandle>,
        })
        .function("destroy_window", {
            params: [RawPtr<WindowHandle>],
            returns: void,
        })
        .build()
    
    // Test opaque type usage
    assert(true, "Opaque types created successfully")
}

// Test version requirements
test("ffi version requirements") {
    lib := FFI.lib("versioned")
        .version("2.0")
        .function("new_feature", {
            params: [],
            returns: i32,
        })
        .build()
    
    // Library would be loaded with version checking
    assert(true, "Version requirement set successfully")
}

// Test lazy loading
test("ffi lazy loading") {
    lib := FFI.lib("lazy")
        .lazy_loading(true)
        .function("heavy_function", {
            params: [i32],
            returns: i32,
        })
        .build()
    
    // Function would be loaded on first use
    assert(true, "Lazy loading enabled successfully")
}

// Test search paths
test("ffi search paths") {
    lib := FFI.lib("custom_path")
        .search_path("/opt/custom/lib")
        .search_path("/usr/local/custom/lib")
        .search_paths([
            "/home/user/lib",
            "/var/lib/custom",
        ])
        .function("custom_func", {
            params: [],
            returns: void,
        })
        .build()
    
    assert(true, "Search paths configured successfully")
}

// Test function aliases
test("ffi function aliases") {
    lib := FFI.lib("aliased")
        .function("original_long_name_function", {
            params: [i32, i32],
            returns: i32,
        })
        .alias("add", "original_long_name_function")
        .build()
    
    // Could call using alias: lib.add(1, 2)
    assert(true, "Function aliases configured successfully")
}

// Test batch function definitions
test("ffi batch functions") {
    lib := FFI.lib("batch")
        .functions_with_prefix("str", [
            ("len", { params: [string], returns: usize }),
            ("cmp", { params: [string, string], returns: i32 }),
            ("cat", { params: [string, string], returns: string }),
        ])
        .build()
    
    // Functions available as: lib.str_len, lib.str_cmp, lib.str_cat
    assert(true, "Batch functions defined successfully")
}

// Test dependency requirements
test("ffi dependencies") {
    lib := FFI.lib("dependent")
        .requires("base_library")
        .requires("helper_library")
        .function("dependent_func", {
            params: [],
            returns: void,
        })
        .build()
    
    // Would validate dependencies before loading
    assert(true, "Dependencies configured successfully")
}

// Test metadata
test("ffi metadata") {
    lib := FFI.lib("documented")
        .metadata("author", "Zen Team")
        .metadata("version", "1.0.0")
        .metadata("description", "Test library for FFI")
        .function("test_func", {
            params: [],
            returns: void,
        })
        .build()
    
    assert(true, "Metadata added successfully")
}

// Test C declaration parsing
test("ffi c declaration parsing") {
    lib := FFI.lib("c_style")
        .function_from_c_decl("int add(int a, int b)")
        .function_from_c_decl("void print_message(const char *msg)")
        .function_from_c_decl("double calculate(double x, double y)")
        .build()
    
    // Functions parsed from C-style declarations
    assert(true, "C declarations parsed successfully")
}

// Test safety checks
test("ffi safety checks") {
    // With safety checks enabled (default)
    safe_lib := FFI.lib("safe")
        .safety_checks(true)
        .function("safe_func", {
            params: [Ptr<i32>],
            returns: i32,
        })
        .build()
    
    // With safety checks disabled (for performance)
    unsafe_lib := FFI.lib("unsafe")
        .safety_checks(false)
        .function("unsafe_func", {
            params: [RawPtr<void>],
            returns: RawPtr<void>,
        })
        .build()
    
    assert(true, "Safety checks configured successfully")
}

// Test calling conventions
test("ffi calling conventions") {
    lib := FFI.lib("conventions")
        .calling_convention(CallingConvention::C)
        .function("c_func", {
            params: [i32],
            returns: i32,
        })
        .calling_convention(CallingConvention::Stdcall)
        .function("stdcall_func", {
            params: [i32],
            returns: i32,
        })
        .calling_convention(CallingConvention::Fastcall)
        .function("fastcall_func", {
            params: [i32],
            returns: i32,
        })
        .build()
    
    assert(true, "Calling conventions configured successfully")
}

// Main test runner
main = () void {
    io := @std.build.import("io")
    io.print("Running comprehensive FFI tests...")
    
    // All tests run automatically via test() blocks
    
    io.print("All FFI tests passed!")
}