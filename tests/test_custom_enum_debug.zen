// Debug custom enum payload loss in generics
{ io, Option , get_default_allocator} = @std

// Simple custom enum
MyEnum : .Value(n: i32) | .Empty

main = () void {
    alloc = get_default_allocator()
    io.println("=== Debugging Custom Enum in Generics ===")
    
    // Test 1: Direct custom enum - should work
    io.println("\n1. Direct custom enum:")
    direct = MyEnum.Value(100)
    direct ? | MyEnum.Value(n) => io.println("  Direct value: ${n}")
            | MyEnum.Empty => io.println("  Direct empty")
    
    // Test 2: Custom enum in variable, then in Option
    io.println("\n2. Custom enum via variable in Option:")
    my_val = MyEnum.Value(200)
    opt = Option.Some(my_val)
    opt ? | Option.Some(inner) => {
        io.println("  Got inner from Option")
        inner ? | MyEnum.Value(n) => io.println("  Variable value: ${n}")
                | MyEnum.Empty => io.println("  Variable empty")
    } | Option.None => io.println("  None")
    
    // Test 3: Custom enum directly in Option
    io.println("\n3. Custom enum directly in Option:")
    opt2 = Option.Some(MyEnum.Value(300))
    opt2 ? | Option.Some(inner) => {
        io.println("  Got inner from Option")
        inner ? | MyEnum.Value(n) => io.println("  Direct Option value: ${n}")
                 | MyEnum.Empty => io.println("  Direct Option empty")
    } | Option.None => io.println("  None")
    
    // Test 4: Function returning Option<MyEnum>
    io.println("\n4. Function returning Option<MyEnum>:")
    make_opt = () Option<MyEnum> {
        return Option.Some(MyEnum.Value(400))
    }
    
    result = make_opt()
    result ? | Option.Some(e) => {
        e ? | MyEnum.Value(n) => io.println("  Function value: ${n}")
            | MyEnum.Empty => io.println("  Function empty")
    } | Option.None => io.println("  None")
    
    io.println("\n=== Debug Complete ===")
}