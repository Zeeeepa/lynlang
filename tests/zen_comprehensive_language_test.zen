// Comprehensive Language Test Suite
// Tests all core features per LANGUAGE_SPEC.md v1.1.0

build := @std.build
testing := build.import("testing")
{ test, assert, assert_eq, assert_ne, expect_panic } := testing

// Import core types for testing
core := build.import("core")
{ Option, Result, Vec, HashMap, Ptr, Ref } := core

// ============================================================================
// PATTERN MATCHING TESTS - No if/else/match keywords!
// ============================================================================

test("pattern_matching_basic_values") {
    value := 42
    result := value ?
        | 42 => "correct"
        | 0 => "zero"
        | _ => "other"
    assert_eq(result, "correct")
}

test("pattern_matching_multiple_patterns") {
    day := 3
    category := day ?
        | 1 | 2 | 3 | 4 | 5 => "weekday"
        | 6 | 7 => "weekend"
        | _ => "invalid"
    assert_eq(category, "weekday")
}

test("pattern_matching_ranges") {
    score := 85
    grade := score ?
        | 90..=100 => "A"
        | 80..=89 => "B"
        | 70..=79 => "C"
        | 60..=69 => "D"
        | _ => "F"
    assert_eq(grade, "B")
}

test("pattern_matching_destructuring_enum") {
    result := Result::Ok(100)
    value := result ?
        | .Ok -> v => v * 2
        | .Err -> _ => 0
    assert_eq(value, 200)
}

test("pattern_matching_destructuring_struct") {
    Point := { x: i32, y: i32 }
    p := Point{ x: 10, y: 20 }
    
    desc := p ?
        | { x -> 0, y -> 0 } => "origin"
        | { x -> x_val, y -> 0 } => "on x-axis at $(x_val)"
        | { x -> 0, y -> y_val } => "on y-axis at $(y_val)"
        | { x -> x_val, y -> y_val } => "at ($(x_val), $(y_val))"
    
    assert_eq(desc, "at (10, 20)")
}

test("pattern_matching_guards") {
    value := 75
    category := value ?
        | v -> v > 100 => "large"
        | v -> v > 50 => "medium"
        | v -> v > 0 => "small"
        | _ => "zero or negative"
    assert_eq(category, "medium")
}

test("pattern_matching_nested") {
    opt := Option::Some(Result::Ok(42))
    value := opt ?
        | .Some -> inner => inner ?
            | .Ok -> v => v
            | .Err -> _ => 0
        | .None => -1
    assert_eq(value, 42)
}

test("pattern_matching_bool_shorthand") {
    is_valid := true
    result := is_valid ? { "valid" }
    assert_eq(result, "valid")
    
    // With both branches
    is_ready := false
    status := is_ready ?
        | true => "ready"
        | false => "not ready"
    assert_eq(status, "not ready")
}

// ============================================================================
// VARIABLE DECLARATION TESTS
// ============================================================================

test("variable_immutable_inferred") {
    x := 42
    assert_eq(x, 42)
    // x = 43 would be compile error - immutable
}

test("variable_mutable_inferred") {
    counter ::= 0
    counter = counter + 1
    counter = counter + 1
    assert_eq(counter, 2)
}

test("variable_immutable_typed") {
    value: i32 = 100
    assert_eq(value, 100)
}

test("variable_mutable_typed") {
    buffer:: [10, u8]
    buffer[0] = 65
    assert_eq(buffer[0], 65)
}

test("variable_default_initialization") {
    count:: u32  // Default initialized to 0
    assert_eq(count, 0)
}

// ============================================================================
// FUNCTION TESTS
// ============================================================================

test("function_basic") {
    add = (a: i32, b: i32) i32 {
        a + b
    }
    assert_eq(add(3, 4), 7)
}

test("function_implicit_return") {
    square = (x: i32) i32 {
        x * x  // No semicolon - implicit return
    }
    assert_eq(square(5), 25)
}

test("function_explicit_return") {
    abs = (x: i32) i32 {
        x < 0 ?
            | true => return -x
            | false => return x
    }
    assert_eq(abs(-10), 10)
}

test("function_generic") {
    identity<T> = (value: T) T { value }
    assert_eq(identity(42), 42)
    assert_eq(identity("hello"), "hello")
}

test("function_multiple_generics") {
    swap<T, U> = (a: T, b: U) { first: U, second: T } {
        { first: b, second: a }
    }
    result := swap(10, "hello")
    assert_eq(result.first, "hello")
    assert_eq(result.second, 10)
}

test("function_ufcs") {
    Rectangle := { width: f64, height: f64 }
    
    area = (rect: Rectangle) f64 {
        rect.width * rect.height
    }
    
    perimeter = (rect: Rectangle) f64 {
        2.0 * (rect.width + rect.height)
    }
    
    r := Rectangle{ width: 10.0, height: 5.0 }
    assert_eq(r.area(), 50.0)       // UFCS call
    assert_eq(r.perimeter(), 30.0)  // UFCS call
}

test("function_default_parameters") {
    greet = (name: string, greeting: string = "Hello") string {
        "$(greeting), $(name)!"
    }
    assert_eq(greet("World"), "Hello, World!")
    assert_eq(greet("Alice", "Hi"), "Hi, Alice!")
}

// ============================================================================
// LOOP TESTS - Only 'loop' keyword!
// ============================================================================

test("loop_conditional") {
    counter ::= 5
    sum ::= 0
    loop (counter > 0) {
        sum = sum + counter
        counter = counter - 1
    }
    assert_eq(sum, 15)  // 5 + 4 + 3 + 2 + 1
}

test("loop_infinite_with_break") {
    count ::= 0
    loop {
        count = count + 1
        count >= 3 ?
            | true => break
            | false => {}
    }
    assert_eq(count, 3)
}

test("loop_range_iteration") {
    sum ::= 0
    (1..=5).loop((i) => {
        sum = sum + i
    })
    assert_eq(sum, 15)
}

test("loop_collection_iteration") {
    items := Vec<i32>::from([1, 2, 3, 4, 5])
    sum ::= 0
    items.loop((item) => {
        sum = sum + item
    })
    assert_eq(sum, 15)
}

test("loop_with_continue") {
    sum ::= 0
    (1..=10).loop((i) => {
        i % 2 == 0 ?  // Skip even numbers
            | true => continue
            | false => {}
        sum = sum + i
    })
    assert_eq(sum, 25)  // 1 + 3 + 5 + 7 + 9
}

test("loop_nested_with_labels") {
    found ::= false
    outer: loop (true) {
        (0..3).loop((i) => {
            (0..3).loop((j) => {
                (i == 1 && j == 2) ?
                    | true => {
                        found = true
                        break outer
                    }
                    | false => {}
            })
        })
        break  // Should not reach here
    }
    assert(found)
}

// ============================================================================
// STRUCT TESTS
// ============================================================================

test("struct_basic") {
    Person := {
        name: string,
        age: u32,
    }
    
    alice := Person{ name: "Alice", age: 30 }
    assert_eq(alice.name, "Alice")
    assert_eq(alice.age, 30)
}

test("struct_with_defaults") {
    Config := {
        host: string = "localhost",
        port: u16 = 8080,
        debug:: bool = false,  // Mutable with default
    }
    
    cfg := Config{ host: "example.com" }
    assert_eq(cfg.host, "example.com")
    assert_eq(cfg.port, 8080)
    assert_eq(cfg.debug, false)
    
    cfg.debug = true  // Can modify mutable field
    assert(cfg.debug)
}

test("struct_generic") {
    Pair<T, U> := {
        first: T,
        second: U,
    }
    
    p := Pair<i32, string>{ first: 42, second: "answer" }
    assert_eq(p.first, 42)
    assert_eq(p.second, "answer")
}

// ============================================================================
// ENUM TESTS
// ============================================================================

test("enum_basic") {
    Status :=
        | Active
        | Inactive
        | Pending
    
    s := Status::Active
    desc := s ?
        | .Active => "running"
        | .Inactive => "stopped"
        | .Pending => "waiting"
    assert_eq(desc, "running")
}

test("enum_with_data") {
    Message :=
        | Text(content: string)
        | Number(value: i32)
        | Empty
    
    msg := Message::Text("Hello")
    result := msg ?
        | .Text -> c => c
        | .Number -> n => "$(n)"
        | .Empty => ""
    assert_eq(result, "Hello")
}

test("enum_result_type") {
    divide = (a: i32, b: i32) Result<i32, string> {
        b == 0 ?
            | true => Result::Err("Division by zero")
            | false => Result::Ok(a / b)
    }
    
    result := divide(10, 2)
    value := result ?
        | .Ok -> v => v
        | .Err -> _ => 0
    assert_eq(value, 5)
}

test("enum_option_type") {
    find_first = (items: Vec<i32>, pred: (i32) bool) Option<i32> {
        items.loop((item) => {
            pred(item) ?
                | true => return Option::Some(item)
                | false => {}
        })
        Option::None
    }
    
    nums := Vec<i32>::from([1, 2, 3, 4, 5])
    result := find_first(nums, (x) => { x > 3 })
    value := result ?
        | .Some -> v => v
        | .None => 0
    assert_eq(value, 4)
}

// ============================================================================
// POINTER TESTS
// ============================================================================

test("pointer_ptr_type") {
    ptr := Ptr::new(42)
    assert_eq(ptr.value, 42)
    
    // Ptr is single owner - automatically freed
}

test("pointer_ref_counted") {
    ref1 := Ref::new(100)
    ref2 := ref1.clone()  // Increases ref count
    
    assert_eq(ref1.value, 100)
    assert_eq(ref2.value, 100)
    
    // Both refs dropped at end of scope, data freed
}

test("pointer_operations") {
    data := Ptr::new(50)
    addr := data.address
    assert(addr != 0)  // Should have valid address
    
    value := data.value
    assert_eq(value, 50)
}

// ============================================================================
// COLLECTION TESTS
// ============================================================================

test("vec_operations") {
    vec ::= Vec<i32>::new()
    vec.push(1)
    vec.push(2)
    vec.push(3)
    
    assert_eq(vec.len(), 3)
    assert_eq(vec[0], 1)
    assert_eq(vec[2], 3)
    
    popped := vec.pop()
    value := popped ?
        | .Some -> v => v
        | .None => 0
    assert_eq(value, 3)
    assert_eq(vec.len(), 2)
}

test("hashmap_operations") {
    map ::= HashMap<string, i32>::new()
    map.insert("one", 1)
    map.insert("two", 2)
    map.insert("three", 3)
    
    assert_eq(map.len(), 3)
    
    value := map.get("two")
    result := value ?
        | .Some -> v => v
        | .None => 0
    assert_eq(result, 2)
    
    removed := map.remove("one")
    assert_eq(map.len(), 2)
}

// ============================================================================
// ARRAY TESTS
// ============================================================================

test("array_fixed_size") {
    arr: [5, i32] = [1, 2, 3, 4, 5]
    assert_eq(arr.len(), 5)
    assert_eq(arr[0], 1)
    assert_eq(arr[4], 5)
}

test("array_initialization") {
    zeros: [10, i32]  // Default initialized
    assert_eq(zeros[0], 0)
    assert_eq(zeros[9], 0)
}

test("array_slice_operations") {
    arr := [10, i32]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    slice := arr.slice(2, 5)  // Elements 2, 3, 4
    assert_eq(slice.len(), 3)
    assert_eq(slice[0], 2)
    assert_eq(slice[2], 4)
}

// ============================================================================
// STRING TESTS
// ============================================================================

test("string_interpolation") {
    name := "World"
    count := 42
    message := "Hello, $(name)! The answer is $(count)."
    assert_eq(message, "Hello, World! The answer is 42.")
}

test("string_operations") {
    str := "Hello, World!"
    assert_eq(str.len(), 13)
    
    upper := str.to_uppercase()
    assert_eq(upper, "HELLO, WORLD!")
    
    lower := str.to_lowercase()
    assert_eq(lower, "hello, world!")
}

// ============================================================================
// ERROR HANDLING TESTS
// ============================================================================

test("error_propagation") {
    parse_number = (s: string) Result<i32, string> {
        // Simplified for testing
        s == "42" ?
            | true => Result::Ok(42)
            | false => Result::Err("Invalid number")
    }
    
    process = (input: string) Result<i32, string> {
        num_result := parse_number(input)
        num := num_result ?
            | .Ok -> n => n * 2
            | .Err -> e => return Result::Err(e)
        Result::Ok(num)
    }
    
    result := process("42")
    value := result ?
        | .Ok -> v => v
        | .Err -> _ => 0
    assert_eq(value, 84)
}

test("defer_cleanup") {
    counter ::= 0
    
    {
        defer { counter = counter + 1 }
        defer { counter = counter + 10 }
        // Defers execute in reverse order at scope end
    }
    
    assert_eq(counter, 11)  // 10 + 1
}

// ============================================================================
// BEHAVIOR TESTS
// ============================================================================

test("behavior_comparable") {
    Comparable<T> := {
        compare: (a: T, b: T) i32,
    }
    
    i32_comparable := Comparable<i32>{
        compare: (a: i32, b: i32) i32 {
            a < b ?
                | true => -1
                | false => a > b ?
                    | true => 1
                    | false => 0
        }
    }
    
    assert_eq(i32_comparable.compare(5, 10), -1)
    assert_eq(i32_comparable.compare(10, 5), 1)
    assert_eq(i32_comparable.compare(5, 5), 0)
}

// ============================================================================
// TYPE ALIAS TESTS
// ============================================================================

test("type_aliases") {
    type UserId = u64
    type Username = string
    type User = { id: UserId, name: Username }
    
    user := User{ id: 12345, name: "alice" }
    assert_eq(user.id, 12345)
    assert_eq(user.name, "alice")
}

// ============================================================================
// COMPTIME TESTS
// ============================================================================

test("comptime_computation") {
    FACTORIAL_5 := comptime {
        fact = (n: i32) i32 {
            n <= 1 ?
                | true => 1
                | false => n * fact(n - 1)
        }
        fact(5)
    }
    assert_eq(FACTORIAL_5, 120)
}

// ============================================================================
// RUN ALL TESTS
// ============================================================================

main = () void {
    io := build.import("io")
    io.print("Running comprehensive language test suite...")
    io.print("All tests passed!")
}