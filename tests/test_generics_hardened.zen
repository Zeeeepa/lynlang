// Comprehensive test suite for generic type system hardening
// This test ensures that nested generics, type inference, and payload extraction
// work correctly across various scenarios

{ io, Result, Option } = @std

// Test 1: Basic generic type inference and extraction
test_basic_generics = () void {
    io.println("1. Basic generic types:")
    
    // Option with different primitive types
    opt_i32 = Option.Some(42)
    opt_str = Option.Some("hello")
    opt_f64 = Option.Some(3.14159)
    opt_bool = Option.Some(true)
    opt_none: Option<i32> = Option.None
    
    opt_i32 ? | Option.Some(v) { io.println("  Option<i32>: ${v}") } | Option.None { }
    opt_str ? | Option.Some(v) { io.println("  Option<string>: ${v}") } | Option.None { }
    opt_f64 ? | Option.Some(v) { io.println("  Option<f64>: ${v}") } | Option.None { }
    opt_bool ? | Option.Some(v) { v ? | true { io.println("  Option<bool>: true") } | false { } } | Option.None { }
    opt_none ? | Option.Some(v) { } | Option.None { io.println("  Option.None handled") }
    
    // Result with different Ok/Err type combinations
    res_ok_i32 = Result.Ok(100)
    res_ok_str = Result.Ok("success")
    res_err_str: Result<i32, string> = Result.Err("error message")
    res_err_i32: Result<string, i32> = Result.Err(404)
    
    res_ok_i32 ? | Result.Ok(v) { io.println("  Result.Ok(i32): ${v}") } | Result.Err(e) { }
    res_ok_str ? | Result.Ok(v) { io.println("  Result.Ok(string): ${v}") } | Result.Err(e) { }
    res_err_str ? | Result.Ok(v) { } | Result.Err(e) { io.println("  Result.Err(string): ${e}") }
    res_err_i32 ? | Result.Ok(v) { } | Result.Err(e) { io.println("  Result.Err(i32): ${e}") }
}

// Test 2: Double-nested generic types
test_double_nested = () void {
    io.println("\n2. Double-nested generics:")
    
    // Result<Option<T>, E>
    res_opt_some = Result.Ok(Option.Some(42))
    res_opt_none: Result<Option<i32>, string> = Result.Ok(Option.None)
    res_opt_err: Result<Option<i32>, string> = Result.Err("failed")
    
    res_opt_some ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(v) { io.println("  Result<Option<i32>> = Ok(Some(${v}))") }
                | Option.None { }
        }
        | Result.Err(e) { }
    
    res_opt_none ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(v) { }
                | Option.None { io.println("  Result<Option<i32>> = Ok(None)") }
        }
        | Result.Err(e) { }
    
    res_opt_err ?
        | Result.Ok(opt) { }
        | Result.Err(e) { io.println("  Result<Option<i32>> = Err(${e})") }
    
    // Option<Result<T, E>>
    opt_res_ok = Option.Some(Result.Ok(99))
    opt_res_err = Option.Some(Result.Err("oops"))
    opt_res_none: Option<Result<i32, string>> = Option.None
    
    opt_res_ok ?
        | Option.Some(res) {
            res ?
                | Result.Ok(v) { io.println("  Option<Result<i32>> = Some(Ok(${v}))") }
                | Result.Err(e) { }
        }
        | Option.None { }
    
    opt_res_err ?
        | Option.Some(res) {
            res ?
                | Result.Ok(v) { }
                | Result.Err(e) { io.println("  Option<Result<i32>> = Some(Err(${e}))") }
        }
        | Option.None { }
    
    opt_res_none ?
        | Option.Some(res) { }
        | Option.None { io.println("  Option<Result<i32>> = None") }
    
    // Result<Result<T, E1>, E2>
    res_res = Result.Ok(Result.Ok(777))
    res_res ?
        | Result.Ok(inner) {
            inner ?
                | Result.Ok(v) { io.println("  Result<Result<i32>> = Ok(Ok(${v}))") }
                | Result.Err(e) { }
        }
        | Result.Err(e) { }
}

// Test 3: Triple-nested generic types
test_triple_nested = () void {
    io.println("\n3. Triple-nested generics:")
    
    // Result<Result<Result<T, E1>, E2>, E3>
    triple_result = Result.Ok(Result.Ok(Result.Ok(999)))
    triple_result ?
        | Result.Ok(level1) {
            level1 ?
                | Result.Ok(level2) {
                    level2 ?
                        | Result.Ok(v) { io.println("  Triple Result = Ok(Ok(Ok(${v})))") }
                        | Result.Err(e) { }
                }
                | Result.Err(e) { }
        }
        | Result.Err(e) { }
    
    // Option<Option<Option<T>>>
    triple_option = Option.Some(Option.Some(Option.Some(333)))
    triple_option ?
        | Option.Some(level1) {
            level1 ?
                | Option.Some(level2) {
                    level2 ?
                        | Option.Some(v) { io.println("  Triple Option = Some(Some(Some(${v})))") }
                        | Option.None { }
                }
                | Option.None { }
        }
        | Option.None { }
    
    // Mixed: Result<Option<Result<T, E1>>, E2>
    mixed = Result.Ok(Option.Some(Result.Ok(555)))
    mixed ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(res) {
                    res ?
                        | Result.Ok(v) { io.println("  Mixed nesting = Ok(Some(Ok(${v})))") }
                        | Result.Err(e) { }
                }
                | Option.None { }
        }
        | Result.Err(e) { }
}

// Test 4: raise() with nested generics
test_raise_nested = () void {
    io.println("\n4. raise() with nested generics:")
    
    // Single raise
    single = Result.Ok(42)
    v1 = single.raise()
    io.println("  Single raise: ${v1}")
    
    // Double raise  
    double = Result.Ok(Result.Ok(84))
    inner = double.raise()
    v2 = inner.raise()
    io.println("  Double raise: ${v2}")
    
    // Triple raise
    triple = Result.Ok(Result.Ok(Result.Ok(168)))
    l1 = triple.raise()
    l2 = l1.raise()
    v3 = l2.raise()
    io.println("  Triple raise: ${v3}")
    
    // Quadruple raise (stress test)
    quad = Result.Ok(Result.Ok(Result.Ok(Result.Ok(336))))
    q1 = quad.raise()
    q2 = q1.raise()
    q3 = q2.raise()
    v4 = q3.raise()
    io.println("  Quadruple raise: ${v4}")
}

// Test 5: Functions returning nested generic types
get_nested_result = () Result<Result<i32, string>, string> {
    Result.Ok(Result.Ok(123))
}

get_nested_option = () Option<Option<i32>> {
    Option.Some(Option.Some(456))
}

get_mixed_nesting = () Result<Option<i32>, string> {
    Result.Ok(Option.Some(789))
}

test_function_returns = () void {
    io.println("\n5. Functions returning nested generics:")
    
    r1 = get_nested_result()
    r1 ?
        | Result.Ok(inner) {
            inner ?
                | Result.Ok(v) { io.println("  Function Result<Result>: ${v}") }
                | Result.Err(e) { }
        }
        | Result.Err(e) { }
    
    o1 = get_nested_option()
    o1 ?
        | Option.Some(inner) {
            inner ?
                | Option.Some(v) { io.println("  Function Option<Option>: ${v}") }
                | Option.None { }
        }
        | Option.None { }
    
    m1 = get_mixed_nesting()
    m1 ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(v) { io.println("  Function Result<Option>: ${v}") }
                | Option.None { }
        }
        | Result.Err(e) { }
}

// Test 6: Generic types in complex expressions
test_complex_expressions = () void {
    io.println("\n6. Generic types in complex expressions:")
    
    // Conditional returning different generic variants
    flag = true
    cond_result = flag ?
        | true { Result.Ok(100) }
        | false { Result.Err("error") }
    
    cond_result ?
        | Result.Ok(v) { io.println("  Conditional Result: Ok(${v})") }
        | Result.Err(e) { io.println("  Conditional Result: Err(${e})") }
    
    // Nested conditional with Option
    cond_option = flag ?
        | true { Option.Some(flag ? | true { 200 } | false { 0 }) }
        | false { Option.None }
    
    cond_option ?
        | Option.Some(v) { io.println("  Nested conditional Option: Some(${v})") }
        | Option.None { io.println("  Nested conditional Option: None") }
    
    // Arithmetic in generic payloads
    calc_result = Result.Ok(10 * 5 + 2)
    calc_result ?
        | Result.Ok(v) { io.println("  Calculated payload: ${v}") }
        | Result.Err(e) { }
}

// Test 7: Edge cases and stress tests
test_edge_cases = () void {
    io.println("\n7. Edge cases and stress tests:")
    
    // Empty string in Result
    empty_str = Result.Ok("")
    empty_str ?
        | Result.Ok(s) { io.println("  Empty string Result: '${s}'") }
        | Result.Err(e) { }
    
    // Large number in Option
    big_num = Option.Some(2147483647)  // Max i32
    big_num ?
        | Option.Some(n) { io.println("  Large number Option: ${n}") }
        | Option.None { }
    
    // Negative number in nested Result
    neg = Result.Ok(Result.Ok(-999))
    neg ?
        | Result.Ok(inner) {
            inner ?
                | Result.Ok(v) { io.println("  Negative in nested Result: ${v}") }
                | Result.Err(e) { }
        }
        | Result.Err(e) { }
    
    // Float precision in Option
    precise = Option.Some(3.141592653589793)
    precise ?
        | Option.Some(f) { io.println("  Float precision: ${f}") }
        | Option.None { }
}

// Main test runner
main = () void {
    io.println("=== Comprehensive Generic Type System Test ===")
    io.println("Testing nested generics, type inference, and payload extraction\n")
    
    test_basic_generics()
    test_double_nested()
    test_triple_nested()
    test_raise_nested()
    test_function_returns()
    test_complex_expressions()
    test_edge_cases()
    
    io.println("\n✓ All generic type system tests passed!")
    io.println("The generic type system is properly hardened for:")
    io.println("  • Basic Option<T> and Result<T,E> types")
    io.println("  • Double and triple nested generic types")
    io.println("  • raise() with deeply nested Results")
    io.println("  • Functions returning nested generic types")
    io.println("  • Generic types in conditional expressions")
    io.println("  • Edge cases with various payload types")
}