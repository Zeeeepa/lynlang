// Showcase of Zen Language features that work
// Based on LANGUAGE_SPEC.zen

{ io } = @std

// Structs with mutable fields
Point: {
    x:: f64,
    y:: f64
}

// Enums (sum types)
Status: Success | Failure
Option<T>: Some(T) | None

// Functions for UFC demo
double = (n: i32) i32 { return n * 2 }
square = (n: i32) i32 { return n * n }

main = () void {
    io.println("=== ZEN LANGUAGE SHOWCASE ===\n")
    
    // 1. Variables
    io.println("1. Variables:")
    immut = 10
    mutable ::= 20
    mutable = mutable + 5
    io.println("  Immutable: ${immut}, Mutable: ${mutable}")
    
    // 2. Pattern matching (no if/else!)
    io.println("\n2. Pattern Matching:")
    flag = true
    flag ? { io.println("  Flag is true") }
    
    value = false
    value ?
        | true { io.println("  Value is true") }
        | false { io.println("  Value is false") }
    
    // 3. Structs
    io.println("\n3. Structs:")
    p = Point { x: 1.5, y: 2.5 }
    io.println("  Point: (${p.x}, ${p.y})")
    
    // 4. Enums
    io.println("\n4. Enums:")
    status = Status.Success
    status ?
        | Success { io.println("  Operation succeeded") }
        | Failure { io.println("  Operation failed") }
    
    // 5. Option (no null!)
    io.println("\n5. Option Type:")
    maybe: Option<i32> = Some(42)
    maybe ?
        | Some(v) { io.println("  Got value: ${v}") }
        | None { io.println("  No value") }
    
    // 6. UFC (Uniform Function Call)
    io.println("\n6. UFC:")
    num = 5
    io.println("  ${num}.double() = ${num.double()}")
    io.println("  ${num}.square() = ${num.square()}")
    
    // 7. Loops and Ranges
    io.println("\n7. Ranges:")
    (0..3).loop((i) {
        io.println("  Item ${i}")
    })
    
    // 8. Defer
    io.println("\n8. Defer:")
    test_defer()
    
    io.println("\n=== END SHOWCASE ===")
}

test_defer = () void {
    io.println("  Start")
    @this.defer(io.println("  Cleanup"))
    io.println("  Middle")
}
