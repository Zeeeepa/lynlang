// Comprehensive Language Tests
// Tests all features from Language Spec v1.1.0

test = @std.test
assert = @std.assert
expect_panic = @std.expect_panic

// Test Pattern Matching (NO if/else/match keywords)
test("pattern matching - basic value patterns") {
    score := 100
    result := score ? | 100 { "Perfect" }
                      | 0 { "Failed" }
                      | _ { "In progress" }
    assert(result == "Perfect")
}

test("pattern matching - range patterns") {
    age := 25
    category := age ? | 0..=12 => "Child"
                      | 13..=19 => "Teen"
                      | 20..=64 => "Adult"
                      | _ { "Senior" }
    assert(category == "Adult")
}

test("pattern matching - destructuring") {
    result := Result:Ok(42)
    value := result ? | .Ok -> v { v }
                      | .Err -> _ { 0 }
    assert(value == 42)
}

test("pattern matching - guards") {
    value := 75
    size := value ? | v -> v > 100 { "Large" }
                    | v -> v > 50 { "Medium" }
                    | v -> v > 0 { "Small" }
                    | _ { "Zero" }
    assert(size == "Medium")
}

test("pattern matching - multiple patterns") {
    day := 3
    type := day ? | 1 | 2 | 3 | 4 | 5 { "Weekday" }
                  | 6 | 7 { "Weekend" }
                  | _ { "Invalid" }
    assert(type == "Weekday")
}

test("pattern matching - bool patterns") {
    is_ready := true
    is_ready ? { assert(true) }
    
    is_valid := false
    is_valid ? | true { assert(false) }
               | false { assert(true) }
}

// Test Variable Declarations
test("variable declarations - immutable") {
    x := 42  // Immutable, inferred
    y: i32 = 10  // Immutable, explicit
    assert(x == 42)
    assert(y == 10)
}

test("variable declarations - mutable") {
    counter := 0  // Mutable, inferred
    counter = counter + 1
    assert(counter == 1)
    
    buffer: [10, u8]  // Mutable, default initialized
    buffer[0] = 255
    assert(buffer[0] == 255)
}

// Test Functions
test("functions - basic") {
    add = (a: i32, b: i32) i32   { a + b }
    result := add(3, 4)
    assert(result == 7)
}

test("functions - default parameters") {
    format = (value: i32, base: u8 = 10) string   {
        base == 10 ? | true { "decimal: $(value)" }
                     | false { "other base" }
    }
    assert(format(42) == "decimal: 42")
    assert(format(42, 16) == "other base")
}

test("functions - UFCS") {
    Rectangle: { width: f64, height: f64 }
    
    area = (rect: Rectangle) f64   {
        rect.width * rect.height
    }
    
    rect := Rectangle{ width: 10.0, height: 5.0 }
    result := rect.area()  // UFCS call
    assert(result == 50.0)
}

// Test Loops (only ONE loop keyword)
test("loops - conditional") {
    counter := 3
    sum := 0
    loop (counter > 0) {
        sum = sum + counter
        counter = counter - 1
    }
    assert(sum == 6)
}

test("loops - infinite with break") {
    counter := 0
    loop {
        counter = counter + 1
        counter == 5 ? | true { break }
    }
    assert(counter == 5)
}

test("loops - range iteration") {
    sum := 0
    (0..5).loop((i) => {
        sum = sum + i
    })
    assert(sum == 10)
}

test("loops - with continue") {
    sum := 0
    (0..10).loop((i) => {
        i % 2 == 0 ? | true { continue }
        sum = sum + i
    })
    assert(sum == 25)  // 1 + 3 + 5 + 7 + 9
}

// Test Data Structures
test("structs - basic") {
    Person: {
        name: string,
        age: u32,
        email: Option<string> = None,
    }
    
    alice := Person{ 
        name: "Alice",
        age: 30,
        email: Some("alice@example.com")
    }
    assert(alice.name == "Alice")
    assert(alice.age == 30)
}

test("structs - generic") {
    Point<T> = {
        x: T,
        y: T,
    }
    
    point := Point<f64>{ x: 1.5, y: 2.5 }
    assert(point.x == 1.5)
}

test("enums - basic") {
    Result<T, E> =
        | Ok(value: T)
        | Err(error: E)
    
    success := Result:Ok(42)
    failure := Result:Err("Not found")
    
    success ? | .Ok -> v { assert(v == 42) }
              | .Err -> _ { assert(false) }
}

// Test Behaviors
test("behaviors - comparable") {
    Comparable<T> = {
        compare: (a: T, b: T) i32,
    }
    
    i32_comparable := Comparable<i32>{
        compare: (a: i32, b: i32) i32 {
            a < b ? | true { -1 }
                    | false { a > b ? | true => 1 }
                                       | false { 0 }
        }
    }
    
    result := i32_comparable.compare(5, 10)
    assert(result == -1)
}

// Test Pointer Types (NO raw & or *)
test("pointers - smart pointers") {
    // Ptr<T> for single ownership
    ptr := Ptr:new(42)
    value := ptr.value
    assert(value == 42)
    
    // Ref<T> for shared ownership
    ref1 := Ref:new(100)
    ref2 := ref1.clone()
    assert(ref1.value == 100)
    assert(ref2.value == 100)
}

// Test Error Handling (NO exceptions)
test("error handling - result type") {
    divide = (a: i32, b: i32) Result<i32, string>   {
        b == 0 ? | true { .Err("Division by zero") }
                 | false { .Ok(a / b) }
    }
    
    result := divide(10, 2)
    result ? | .Ok -> v { assert(v == 5) }
             | .Err -> _ { assert(false) }
    
    error := divide(10, 0)
    error ? | .Ok -> _ { assert(false) }
            | .Err -> e { assert(e == "Division by zero") }
}

test("error handling - option type") {
    find = (arr: [5, i32], target: i32) Option<usize>   {
        (0..5).loop((i) => {
            arr[i] == target ? | true { return Some(i) }
        })
        None
    }
    
    arr := [5, i32]{ 10, 20, 30, 40, 50 }
    result := find(arr, 30)
    result ? | .Some -> i { assert(i == 2) }
             | .None { assert(false) }
}

// Test Arrays and Slices
test("arrays - fixed size") {
    arr: [5, i32] = [5, i32]{ 1, 2, 3, 4, 5 }
    assert(arr[0] == 1)
    assert(arr[4] == 5)
    assert(arr.len() == 5)
}

test("slices - dynamic views") {
    arr := [10, i32]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    slice := arr.slice(2, 5)  // Elements 2, 3, 4
    assert(slice.len() == 3)
    assert(slice[0] == 2)
}

// Test String Interpolation
test("string interpolation") {
    name := "Zen"
    version := 1.1
    message := "Welcome to $(name) v$(version)!"
    assert(message == "Welcome to Zen v1.1!")
}

// Test Defer
test("defer - cleanup") {
    executed := false
    {
        defer { executed = true }
        // defer block executes at end of scope
    }
    assert(executed == true)
}

// Test Compile-time execution
test("comptime - basic") {
    CONSTANT := @comptime {
        result := 1
        (1..5).loop((i) => {
            result = result * i
        })
        result  // 4! = 24
    }
    assert(CONSTANT == 24)
}

// Test Type Reflection
test("type reflection") {
    Point: { x: f64, y: f64 }
    
    size := size_of(Point)
    assert(size == 16)  // 2 * 8 bytes
    
    align := align_of(Point)
    assert(align == 8)
    
    name := type_name(Point)
    assert(name == "Point")
}

// Test Platform-specific code
test("platform specific") {
    { os_name } = @std ?
        | .linux { "Linux" }
        | .windows { "Windows" }
        | .macos { "macOS" }
        | _ { "Unknown" }
    
    // Should be Linux on current system
    assert(os_name == "Linux")
}

// Main test runner
main = () void   {
    { io } = @std("io")
    io.print("Running Comprehensive Language Tests\n")
    io.print("=====================================\n")
    
    // All tests are registered with the test framework
    // They will be executed by the test runner
    
    io.print("All language feature tests completed!\n")
}