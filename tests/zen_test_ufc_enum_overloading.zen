// Test for UFC overloading based on enum variants from LANGUAGE_SPEC.zen (lines 172-182)

{ io } = @std

// Enum type with variants (line 172)
GameEntity: Player | Enemy | Powerup

// UFC overloaded functions for each variant (lines 175-181)
// Different implementations based on enum variant type
get_health = (e: GameEntity.Player) u32 { return 100 }
get_health = (e: GameEntity.Enemy) u32 { return 50 }
get_health = (e: GameEntity.Powerup) u32 { return 0 }

get_speed = (e: GameEntity.Player) f64 { return 5.0 }
get_speed = (e: GameEntity.Enemy) f64 { return 3.0 }
get_speed = (e: GameEntity.Powerup) f64 { return 0.0 }

// Additional overloaded functions for testing
get_damage = (e: GameEntity.Player) u32 { return 25 }
get_damage = (e: GameEntity.Enemy) u32 { return 15 }
get_damage = (e: GameEntity.Powerup) u32 { return 0 }

get_description = (e: GameEntity.Player) string { return "Heroic player character" }
get_description = (e: GameEntity.Enemy) string { return "Dangerous enemy" }
get_description = (e: GameEntity.Powerup) string { return "Helpful powerup" }

// Function that works with any GameEntity variant
process_entity = (entity: GameEntity) void {
    // Pattern match to determine variant and call appropriate overload
    entity ?
        | Player { 
            io.println("Player:")
            io.println("  Health: ${entity.get_health()}")
            io.println("  Speed: ${entity.get_speed()}")
            io.println("  Damage: ${entity.get_damage()}")
            io.println("  Desc: ${entity.get_description()}")
        }
        | Enemy { 
            io.println("Enemy:")
            io.println("  Health: ${entity.get_health()}")
            io.println("  Speed: ${entity.get_speed()}")
            io.println("  Damage: ${entity.get_damage()}")
            io.println("  Desc: ${entity.get_description()}")
        }
        | Powerup {
            io.println("Powerup:")
            io.println("  Health: ${entity.get_health()}")
            io.println("  Speed: ${entity.get_speed()}")
            io.println("  Damage: ${entity.get_damage()}")
            io.println("  Desc: ${entity.get_description()}")
        }
}

main = () void {
    io.println("=== UFC OVERLOADING FOR ENUM VARIANTS TEST ===")
    io.println("")
    io.println("From LANGUAGE_SPEC.zen lines 172-182:")
    io.println("")
    
    // Create instances of each variant
    player = GameEntity.Player
    enemy = GameEntity.Enemy
    powerup = GameEntity.Powerup
    
    // Test UFC with each variant - direct calls
    io.println("1. Direct UFC calls on enum variants:")
    io.println("")
    
    // Player variant
    io.println("Player stats:")
    io.println("  Health: ${player.get_health()}")   // Should return 100
    io.println("  Speed: ${player.get_speed()}")     // Should return 5.0
    io.println("  Damage: ${player.get_damage()}")   // Should return 25
    io.println("")
    
    // Enemy variant
    io.println("Enemy stats:")
    io.println("  Health: ${enemy.get_health()}")    // Should return 50
    io.println("  Speed: ${enemy.get_speed()}")      // Should return 3.0
    io.println("  Damage: ${enemy.get_damage()}")    // Should return 15
    io.println("")
    
    // Powerup variant
    io.println("Powerup stats:")
    io.println("  Health: ${powerup.get_health()}")  // Should return 0
    io.println("  Speed: ${powerup.get_speed()}")    // Should return 0.0
    io.println("  Damage: ${powerup.get_damage()}")  // Should return 0
    io.println("")
    
    // Test with pattern matching
    io.println("2. Pattern matching with UFC calls:")
    io.println("")
    
    process_entity(player)
    io.println("")
    process_entity(enemy)
    io.println("")
    process_entity(powerup)
    
    io.println("")
    io.println("✓ UFC overloading based on enum variants working")
    io.println("✓ Each variant has its own function implementations")
}