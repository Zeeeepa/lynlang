// Test file to verify Vec/DynVec migration is working correctly

{ Vec, DynVec } = @std.collections
{ core } = @std
{ io } = @std

test_fixed_vec = () void {
    io.println("Testing Fixed-Size Vec...")
    
    // Create a fixed-size vector with capacity 10
    v := Vec<i32, 10>.new()
    
    // Push some elements
    v.push(1).unwrap()
    v.push(2).unwrap()
    v.push(3).unwrap()
    
    // Check length
    assert(v.len() == 3, "Fixed vec should have 3 elements")
    assert(v.capacity() == 10, "Fixed vec capacity should be 10")
    
    // Get elements
    assert(v.get(0).unwrap() == 1, "First element should be 1")
    assert(v.get(1).unwrap() == 2, "Second element should be 2")
    assert(v.get(2).unwrap() == 3, "Third element should be 3")
    
    // Pop element
    popped := v.pop().unwrap()
    assert(popped == 3, "Popped element should be 3")
    assert(v.len() == 2, "Length should be 2 after pop")
    
    // Test is_full when at capacity
    i ::= 0
    loop {
        i >= 8 ? { break }
        v.push(i).unwrap()
        i = i + 1
    }
    assert(v.is_full(), "Vec should be full at capacity")
    
    // Try to push when full should fail
    result := v.push(100)
    result ?
        | core.Result:Ok(_) { assert(false, "Push should fail when full") }
        | core.Result:Err(_) { } // Expected
    
    io.println("Fixed-Size Vec tests passed!")
}

test_dynamic_vec = () void {
    io.println("Testing Dynamic Vec...")
    
    // Create a dynamic vector
    v := DynVec<i32>.new()
    
    // Push many elements (will cause growth)
    i ::= 0
    loop {
        i >= 100 ? { break }
        v.push(i).unwrap()
        i = i + 1
    }
    
    // Check length
    assert(v.len() == 100, "DynVec should have 100 elements")
    assert(v.capacity() >= 100, "DynVec capacity should be >= 100")
    
    // Get elements
    assert(v.get(0).unwrap() == 0, "First element should be 0")
    assert(v.get(50).unwrap() == 50, "Middle element should be 50")
    assert(v.get(99).unwrap() == 99, "Last element should be 99")
    
    // Remove element
    removed := v.remove(50).unwrap()
    assert(removed == 50, "Removed element should be 50")
    assert(v.len() == 99, "Length should be 99 after remove")
    assert(v.get(50).unwrap() == 51, "Element at index 50 should now be 51")
    
    // Clear
    v.clear()
    assert(v.is_empty(), "DynVec should be empty after clear")
    assert(v.capacity() >= 100, "Capacity should be maintained after clear")
    
    // Free memory
    v.free()
    assert(v.capacity() == 0, "Capacity should be 0 after free")
    
    io.println("Dynamic Vec tests passed!")
}

test_vec_conversion = () void {
    io.println("Testing Vec conversion...")
    
    // Create a fixed vec with some data
    fixed := Vec<i32, 5>.new()
    fixed.push(10).unwrap()
    fixed.push(20).unwrap()
    fixed.push(30).unwrap()
    
    // Convert to dynamic
    dynamic := fixed.to_dynamic()
    assert(dynamic.len() == 3, "Dynamic vec should have same length")
    assert(dynamic.get(0).unwrap() == 10, "First element should match")
    assert(dynamic.get(1).unwrap() == 20, "Second element should match")
    assert(dynamic.get(2).unwrap() == 30, "Third element should match")
    
    // Dynamic can grow beyond fixed size
    dynamic.push(40).unwrap()
    dynamic.push(50).unwrap()
    dynamic.push(60).unwrap()
    assert(dynamic.len() == 6, "Dynamic vec should have grown")
    
    dynamic.free()
    io.println("Vec conversion tests passed!")
}

test_functional_operations = () void {
    io.println("Testing functional operations...")
    
    // Test with fixed vec
    fixed := Vec<i32, 10>.new()
    fixed.push(1).unwrap()
    fixed.push(2).unwrap()
    fixed.push(3).unwrap()
    fixed.push(4).unwrap()
    fixed.push(5).unwrap()
    
    // Map operation
    doubled := fixed.map((x) => x * 2)
    assert(doubled.get(0).unwrap() == 2, "First mapped element should be 2")
    assert(doubled.get(4).unwrap() == 10, "Last mapped element should be 10")
    
    // Filter operation (returns DynVec)
    evens := fixed.filter((x) => x % 2 == 0)
    assert(evens.len() == 2, "Should have 2 even numbers")
    assert(evens.get(0).unwrap() == 2, "First even should be 2")
    assert(evens.get(1).unwrap() == 4, "Second even should be 4")
    
    // Fold operation
    sum := fixed.fold(0, (acc, x) => acc + x)
    assert(sum == 15, "Sum should be 15")
    
    // Test with dynamic vec
    dynamic := DynVec<i32>.new()
    dynamic.push(10).unwrap()
    dynamic.push(20).unwrap()
    dynamic.push(30).unwrap()
    
    // Find operation
    found := dynamic.find((x) => x > 15)
    found ?
        | core.Option:Some(val) => assert(val == 20, "Should find 20")
        | core.Option:None => assert(false, "Should find a value")
    
    // Any/All operations
    assert(dynamic.any((x) => x > 25), "Should have element > 25")
    assert(dynamic.all((x) => x >= 10), "All elements should be >= 10")
    assert(!dynamic.all((x) => x > 20), "Not all elements > 20")
    
    evens.free()
    dynamic.free()
    io.println("Functional operations tests passed!")
}

assert = (condition: bool, message: string) void {
    !condition ? {
            io.println("ASSERTION FAILED: ${message}")
            panic("Test failed")
        }
}

panic = (msg: string) void {
    io.println("PANIC: ${msg}")
    // In a real implementation, this would exit the program
}

main = () void {
    io.println("=== Vec/DynVec Migration Test Suite ===")
    io.println("")
    
    test_fixed_vec()
    test_dynamic_vec()
    test_vec_conversion()
    test_functional_operations()
    
    io.println("")
    io.println("=== All tests passed! ===")
}