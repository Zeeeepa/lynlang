// Test custom enum generic type inference and payload extraction
{ io, Result, Option } = @std

// Custom enum similar to Result but with different names
MyResult : .Success(val: i32) | .Error(msg: string)

// Custom enum with generic-like behavior
Container : .Full(data: i32) | .Empty

// Function returning custom enum
get_custom_result = () MyResult {
    return MyResult.Success(42)
}

// Function accepting and returning custom enum
transform_custom = (input: MyResult) MyResult {
    input ? | MyResult.Success(v) => MyResult.Success(v * 2)
            | MyResult.Error(e) => MyResult.Error(e)
}

// Test custom enum in nested structure
test_nested_custom = () Option<MyResult> {
    return Option.Some(MyResult.Success(100))
}

main = () void {
    io.println("=== Custom Enum Generic Tests ===")
    
    // Test 1: Basic custom enum
    io.println("\n1. Basic custom enum:")
    res1 = get_custom_result()
    res1 ? | MyResult.Success(v) => io.println("  Success: ${v}")
           | MyResult.Error(e) => io.println("  Error: ${e}")
    
    // Test 2: Transform custom enum
    io.println("\n2. Transform custom enum:")
    input = MyResult.Success(21)
    output = transform_custom(input)
    output ? | MyResult.Success(v) => io.println("  Transformed: ${v}")
             | MyResult.Error(e) => io.println("  Error: ${e}")
    
    // Test 3: Custom enum in Option
    io.println("\n3. Custom enum in Option:")
    nested = test_nested_custom()
    nested ? | Option.Some(inner) => {
        inner ? | MyResult.Success(v) => io.println("  Nested Success: ${v}")
                | MyResult.Error(e) => io.println("  Nested Error: ${e}")
    } | Option.None => io.println("  None")
    
    // Test 4: Container enum
    io.println("\n4. Container enum:")
    container = Container.Full(999)
    container ? | Container.Full(d) => io.println("  Container has data: ${d}")
                | Container.Empty => io.println("  Container is empty")
    
    // Test 5: Custom enum in Result
    io.println("\n5. Custom enum in Result<MyResult, string>:")
    wrap_custom = () Result<MyResult, string> {
        return Result.Ok(MyResult.Success(777))
    }
    
    wrapped = wrap_custom()
    wrapped ? | Result.Ok(custom) => {
        custom ? | MyResult.Success(v) => io.println("  Wrapped Success: ${v}")
                 | MyResult.Error(e) => io.println("  Wrapped Error: ${e}")
    } | Result.Err(e) => io.println("  Result Error: ${e}")
    
    io.println("\n=== All Custom Enum Tests Complete ===")
}