// Test for nested generic types
{ io } = @std
{ Option, Result } = @std

// Test 1: Result<Option<i32>, String>
test_result_option = () Result<Option<i32>, string> {
    // Create a nested generic value
    value = Option.Some(42)
    return Result.Ok(value)
}

// Test 2: Option<Result<i32, String>>
test_option_result = () Option<Result<i32, string>> {
    result = Result.Ok(100)
    return Option.Some(result)
}

// Test 3: Pattern matching on nested generics
test_nested_matching = () void {
    // Test Result<Option<i32>, String>
    result1 = test_result_option()
    result1 ? | Result.Ok(opt) => {
        opt ? | Option.Some(n) => io.println("Got nested value: ${n}")
              | Option.None => io.println("Got None")
    } | Result.Err(msg) => {
        io.println("Error: ${msg}")
    }
    
    // Test Option<Result<i32, String>>
    opt2 = test_option_result()
    opt2 ? | Option.Some(res) => {
        res ? | Result.Ok(n) => io.println("Got nested result: ${n}")
              | Result.Err(e) => io.println("Got error: ${e}")
    } | Option.None => {
        io.println("Got None")
    }
}

main = () void {
    io.println("Testing nested generic types...")
    test_nested_matching()
}