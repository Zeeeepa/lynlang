// Test to debug nested generic payload extraction
{ io } = @std
{ Option, Result } = @std

// Test 1: Simple non-nested Result - this should work
test_simple = () Result<i32, string> {
    Result.Ok(42)
}

// Test 2: Result containing Option - this is what's broken
test_result_option = () Result<Option<i32>, string> {
    inner = Option.Some(42)
    Result.Ok(inner)
}

// Test 3: Option containing Result - also broken
test_option_result = () Option<Result<i32, string>> {
    inner = Result.Ok(100)
    Option.Some(inner)
}

main = () void {
    // Test simple Result (should work)
    simple = test_simple()
    simple ? | Result.Ok(n) => io.println("Simple Result.Ok: ${n}")
            | Result.Err(e) => io.println("Simple Result.Err: ${e}")
    
    // Test Result<Option<i32>, string> 
    result_opt = test_result_option()
    result_opt ? | Result.Ok(opt) => {
        // The issue is here - opt is an Option<i32> but we can't extract its payload
        opt ? | Option.Some(n) => io.println("Result<Option>: ${n}")
              | Option.None => io.println("Result<Option>: None")
    } | Result.Err(e) => io.println("Error: ${e}")
    
    // Test Option<Result<i32, string>>
    opt_result = test_option_result()
    opt_result ? | Option.Some(res) => {
        // The issue is also here - res is a Result but we can't extract its payload
        res ? | Result.Ok(n) => io.println("Option<Result>: ${n}")
              | Result.Err(e) => io.println("Option<Result> error: ${e}")
    } | Option.None => io.println("Option was None")
}