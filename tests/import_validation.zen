// Import validation test suite
// Tests that imports work correctly at module level and are rejected in invalid contexts

core := @std.core
test := @std.test
io := @std.io
mem := @std.mem
string := @std.string
vec := @std.vec

// Test 1: Module-level imports work correctly
test_module_level_imports = () void {
    // These imports are at module level (defined above)
    // They should be accessible throughout the module
    test.assert(core != null, "core import should be available")
    test.assert(io != null, "io import should be available")
    test.assert(test != null, "test import should be available")
}

// Test 2: Imports are accessible in functions
test_imports_in_functions = () void {
    // Should be able to use module-level imports
    io.println("Testing import accessibility in functions")
    test.assert(true, "Function should have access to module imports")
}

// Test 3: Imports are accessible in nested blocks
test_imports_in_nested_blocks = () void {
    if (true) {
        // Should still have access to imports
        io.println("Imports work in nested blocks")
        
        for (i := 0; i < 1; i += 1) {
            // Even deeper nesting
            test.assert(true, "Imports work in deeply nested blocks")
        }
    }
}

// Test 4: Multiple import styles
test_multiple_import_styles = () void {
    // All these imports should work
    buffer := mem.allocate(u8, 100)
    test.assert(buffer != null, "mem.allocate should work")
    mem.deallocate(buffer)
    
    s := "Hello"
    len := string.length(s)
    test.assert(len == 5, "string.length should work")
    
    v := vec.new(i32)
    vec.push(i32, &v, 42)
    test.assert(v.len == 1, "vec operations should work")
    vec.free(i32, &v)
}

// Test 5: Imports work with type definitions
MyStruct = struct {
    data: vec.Vec(i32),  // Using imported type
    name: string,        // Built-in type (not an import)
}

test_imports_with_types = () void {
    s := MyStruct {
        data: vec.new(i32),
        name: "test"
    }
    
    vec.push(i32, &s.data, 100)
    test.assert(s.data.len == 1, "Import-based types should work in structs")
    vec.free(i32, &s.data)
}

// Test 6: Imports in match expressions
test_imports_in_match = () void {
    value := 42
    
    result := match value {
        0 => {
            io.println("Zero")
            0
        }
        _ => {
            io.println("Non-zero")
            1
        }
    }
    
    test.assert(result == 1, "Imports should work in match arms")
}

// Test 7: Imports with generics
test_imports_with_generics = () void {
    // Create vectors of different types
    int_vec := vec.new(i32)
    string_vec := vec.new(string)
    
    vec.push(i32, &int_vec, 42)
    vec.push(string, &string_vec, "hello")
    
    test.assert(int_vec.len == 1, "Generic vec should work with i32")
    test.assert(string_vec.len == 1, "Generic vec should work with string")
    
    vec.free(i32, &int_vec)
    vec.free(string, &string_vec)
}

// Run all tests
main = () i32 {
    io.println("Running import validation tests...")
    
    test_module_level_imports()
    io.println("✓ Module-level imports test passed")
    
    test_imports_in_functions()
    io.println("✓ Imports in functions test passed")
    
    test_imports_in_nested_blocks()
    io.println("✓ Imports in nested blocks test passed")
    
    test_multiple_import_styles()
    io.println("✓ Multiple import styles test passed")
    
    test_imports_with_types()
    io.println("✓ Imports with types test passed")
    
    test_imports_in_match()
    io.println("✓ Imports in match test passed")
    
    test_imports_with_generics()
    io.println("✓ Imports with generics test passed")
    
    io.println("\n✨ All import validation tests passed!")
    return 0
}