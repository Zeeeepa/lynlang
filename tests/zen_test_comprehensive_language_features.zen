// Comprehensive test suite for Zenlang features
// Tests all major language features according to LANGUAGE_SPEC.md v1.1.0

// ====================================
// Test 1: Variable Declarations
// ====================================

test_variable_declarations = () void   {
    // Immutable bindings
    x := 42
    name := "Zen"
    pi: f64 = 3.14159
    
    // Mutable bindings
    counter := 0
    buffer: [1024, u8]
    value: i32 = 100
    
    // Test mutation (only on mutable)
    counter = counter + 1
    value = value * 2
    
    // Verify immutability would cause error if uncommented:
    // x = 43  // ERROR: Cannot assign to immutable
    
    assert(x == 42)
    assert(counter == 1)
    assert(value == 200)
}

// ====================================
// Test 2: Pattern Matching (NO if/else/match)
// ====================================

test_pattern_matching = () void   {
    // Basic value patterns
    score := 100
    result := score ? 
        | 100 { "Perfect" }
        | 0 { "Failed" }
        | _ { "In progress" }
    assert(result == "Perfect")
    
    // Range patterns
    age := 25
    category := age ?
        | 0..=12 { "Child" }
        | 13..=19 { "Teen" }
        | 20..=64 { "Adult" }
        | _ { "Senior" }
    assert(category == "Adult")
    
    // Guards with pattern matching
    value := 75
    size := value ?
        | v { v > 100 ? | true { "Large" } | false {
            v > 50 ? | true { "Medium" } | false {
                v > 0 ? | true { "Small" } | false { "Zero or negative" }
            }
        } }
    assert(size == "Medium")
    
    // Multiple patterns (or-patterns)
    day := 6
    day_type := day ?
        | 1 | 2 | 3 | 4 | 5 { "Weekday" }
        | 6 | 7 { "Weekend" }
        | _ { "Invalid" }
    assert(day_type == "Weekend")
    
    // Bool patterns
    is_ready := true
    is_ready ? { 
        assert(true)
    }
    
    // Alternative bool syntax
    condition := false
    condition ?
        | true { assert(false) }
        | false { assert(true) }
}

// ====================================
// Test 3: Functions and UFCS
// ====================================

// Basic function
add = (a: i32, b: i32) i32   {
    a + b
}

// Generic function
identity<T>: (value: T) T  = {
    value
}

// Function with default parameter
greet = (name: string, greeting: string = "Hello") string   {
    "$(greeting), $(name)!"
}

// Struct for UFCS testing
Rectangle: {
    width: f64,
    height: f64,
}

// UFCS-style function
area = (rect: Rectangle) f64   {
    rect.width * rect.height
}

test_functions_and_ufcs = () void   {
    // Test basic function
    sum := add(10, 20)
    assert(sum == 30)
    
    // Test generic function
    x := identity(42)
    s := identity("test")
    assert(x == 42)
    assert(s == "test")
    
    // Test default parameters
    msg1 := greet("Alice")
    msg2 := greet("Bob", "Hi")
    assert(msg1 == "Hello, Alice!")
    assert(msg2 == "Hi, Bob!")
    
    // Test UFCS
    rect := Rectangle{ width: 10.0, height: 5.0 }
    a := rect.area()  // UFCS call
    assert(a == 50.0)
}

// ====================================
// Test 4: Loops (only 'loop' keyword)
// ====================================

test_loops = () void   {
    // Conditional loop (while-like)
    counter := 5
    sum := 0
    loop(() {
        counter > 0 ?
            | true {
                sum = sum + counter
                counter = counter - 1
            }
            | false { break }
    })
    assert(sum == 15)  // 5+4+3+2+1
    
    // Infinite loop with break
    value := 0
    loop(() {
        value = value + 1
        value >= 10 ? | true { break }
    })
    assert(value == 10)
    
    // Range iteration
    total := 0
    (0..5).loop((i) {
        total = total + i
    })
    assert(total == 10)  // 0+1+2+3+4
    
    // Collection iteration
    items := [3, i32]{ 10, 20, 30 }
    product := 1
    items.to_slice().loop((item) {
        product = product * item
    })
    assert(product == 6000)
    
    // Loop with continue
    even_sum := 0
    (0..10).loop((i) {
        i % 2 != 0 ? | true { continue }
        even_sum = even_sum + i
    })
    assert(even_sum == 20)  // 0+2+4+6+8
}

// ====================================
// Test 5: Structs and Enums
// ====================================

// Struct definition
Person: {
    name: string,
    age: u32,
    email: Option<string> = None,
}

// Enum definition
Status: Active
    | Inactive(reason: string)
    | Pending(since: u64)

Result<T, E> =
    | Ok(value: T)
    | Err(error: E)

Option<T> =
    | Some(value: T)
    | None

test_structs_and_enums = () void   {
    // Test struct creation and field access
    alice := Person{
        name: "Alice",
        age: 30,
        email: Some("alice@example.com")
    }
    assert(alice.name == "Alice")
    assert(alice.age == 30)
    
    // Test mutable field
    alice.email = Some("newemail@example.com")
    
    // Test enum creation and pattern matching
    status := Status:Active
    msg := status ?
        | .Active { "System is active" }
        | .Inactive -> reason { "Inactive: $(reason)" }
        | .Pending -> since { "Pending since $(since)" }
    assert(msg == "System is active")
    
    // Test Result type
    divide = (a: i32, b: i32) Result<i32, string>   {
        b == 0 ?
            | true { Result:Err("Division by zero") }
            | false { Result:Ok(a / b) }
    }
    
    result := divide(10, 2)
    value := result ?
        | .Ok -> v { v }
        | .Err -> _ { -1 }
    assert(value == 5)
}

// ====================================
// Test 6: Error Handling (No exceptions)
// ====================================

test_error_handling = () void   {
    // Function that returns Result
    parse_int = (s: string) Result<i32, string>   {
        // Simplified - would actually parse
        s == "42" ?
            | true { Result:Ok(42) }
            | false { Result:Err("Invalid number") }
    }
    
    // Handle Result
    result1 := parse_int("42")
    result1 ?
        | .Ok -> n { assert(n == 42) }
        | .Err -> _ { assert(false) }
    
    result2 := parse_int("invalid")
    result2 ?
        | .Ok -> _ { assert(false) }
        | .Err -> e { assert(e == "Invalid number") }
    
    // Option handling
    find_value = (key: string) Option<i32>   {
        key == "exists" ?
            | true { Option:Some(100) }
            | false { Option:None }
    }
    
    opt1 := find_value("exists")
    opt1 ?
        | .Some -> v { assert(v == 100) }
        | .None { assert(false) }
    
    opt2 := find_value("missing")
    opt2 ?
        | .Some -> _ { assert(false) }
        | .None { assert(true) }
}

// ====================================
// Test 7: Behaviors (Structural contracts)
// ====================================

// Define a behavior
Comparable<T> = {
    compare: (a: T, b: T) i32,
}

// Provide implementation for i32
i32_comparable := Comparable<i32>{
    compare: (a: i32, b: i32) i32 {
        a < b ? | true { -1 }
                | false { a > b ? | true => 1 }
                                   | false { 0 }
    }
}

// Generic sort using behavior
sort_pair<T>: (a: T, b: T, cmp: Comparable<T>)   = { first: T, second: T } {
    cmp.compare(a, b) <= 0 ?
        | true { { first: a, second: b  }}
        | false { { first: b, second: a  }}
}

test_behaviors = () void   {
    // Test behavior usage
    sorted := sort_pair(5, 3, i32_comparable)
    assert(sorted.first == 3)
    assert(sorted.second == 5)
    
    // Test comparison
    result := i32_comparable.compare(10, 20)
    assert(result == -1)
}

// ====================================
// Test 8: Pointers and Memory
// ====================================

test_pointers = () void   {
    // Smart pointer creation
    ptr := Ptr:new(42)
    assert(ptr.value == 42)
    
    // Reference counting
    ref1 := Ref:new(100)
    ref2 := ref1.clone()
    assert(ref1.value == 100)
    assert(ref2.value == 100)
    
    // Array allocation
    arr := [5, i32]{ 1, 2, 3, 4, 5 }
    assert(arr[0] == 1)
    assert(arr[4] == 5)
    
    // Slice operations
    slice := arr.to_slice()
    assert(slice.len() == 5)
}

// ====================================
// Test 9: String Interpolation
// ====================================

test_string_interpolation = () void   {
    name := "Zen"
    version := 1
    
    // Basic interpolation
    msg := "Welcome to $(name) v$(version)!"
    assert(msg == "Welcome to Zen v1!")
    
    // Expression interpolation
    x := 10
    y := 20
    result := "$(x) + $(y) = $(x + y)"
    assert(result == "10 + 20 = 30")
}

// ====================================
// Test 10: Defer and Cleanup
// ====================================

test_defer = () void   {
    counter := Ref:new(0)
    
    process = () void   {
        counter.value = counter.value + 1
        defer {
            counter.value = counter.value * 2
        }
        counter.value = counter.value + 10
    }
    
    process()
    // Should be (0 + 1 + 10) * 2 = 22
    assert(counter.value == 22)
}

// ====================================
// Main Test Runner
// ====================================

main = () void   {
    { io } = @std.build.import("io")
    
    io.print("Running Zenlang Comprehensive Test Suite...")
    
    test_variable_declarations()
    io.print("✓ Variable declarations")
    
    test_pattern_matching()
    io.print("✓ Pattern matching (no if/else/match)")
    
    test_functions_and_ufcs()
    io.print("✓ Functions and UFCS")
    
    test_loops()
    io.print("✓ Loops (only 'loop' keyword)")
    
    test_structs_and_enums()
    io.print("✓ Structs and enums")
    
    test_error_handling()
    io.print("✓ Error handling (no exceptions)")
    
    test_behaviors()
    io.print("✓ Behaviors")
    
    test_pointers()
    io.print("✓ Pointers and memory")
    
    test_string_interpolation()
    io.print("✓ String interpolation")
    
    test_defer()
    io.print("✓ Defer and cleanup")
    
    io.print("\n🎉 All tests passed!")
}

// ====================================
// Helper: Assert function
// ====================================

assert = (condition: bool, message: string = "") void   {
    condition ? | false {
        msg := message == "" ? 
            | true { "Assertion failed" }
            | false { message }
        panic(msg)
    }
}

panic = (message: string) void   {
    // In real implementation, would terminate with error
    // For testing, we'd use @std.core.panic
    @std.core.panic(message)
}