// Comprehensive Standard Library Test Suite
// Tests all major stdlib modules and their integration

core = @std
string = @std
vec = @std
hashmap = @std
math = @std
mem = @std
result = @std
io = @std
file = @std
network = @std
concurrency = @std
test = @std

// Test runner
main = () i32   {
    io.print("Running Zen Standard Library Comprehensive Tests\n")
    io.print("================================================\n\n")
    
    mut passed := 0
    mut failed := 0
    
    // Core module tests
    io.print("Testing Core Module...\n")
    if test_core() {
        io.print("  ✓ Core tests passed\n")
        passed += 1
    } | false {
        io.print("  ✗ Core tests failed\n")
        failed += 1
    }
    
    // String module tests
    io.print("Testing String Module...\n")
    if test_string() {
        io.print("  ✓ String tests passed\n")
        passed += 1
    } | false {
        io.print("  ✗ String tests failed\n")
        failed += 1
    }
    
    // Vector module tests
    io.print("Testing Vector Module...\n")
    if test_vec() {
        io.print("  ✓ Vector tests passed\n")
        passed += 1
    } | false {
        io.print("  ✗ Vector tests failed\n")
        failed += 1
    }
    
    // HashMap module tests
    io.print("Testing HashMap Module...\n")
    if test_hashmap() {
        io.print("  ✓ HashMap tests passed\n")
        passed += 1
    } | false {
        io.print("  ✗ HashMap tests failed\n")
        failed += 1
    }
    
    // Math module tests
    io.print("Testing Math Module...\n")
    if test_math() {
        io.print("  ✓ Math tests passed\n")
        passed += 1
    } | false {
        io.print("  ✗ Math tests failed\n")
        failed += 1
    }
    
    // Memory module tests
    io.print("Testing Memory Module...\n")
    if test_memory() {
        io.print("  ✓ Memory tests passed\n")
        passed += 1
    } | false {
        io.print("  ✗ Memory tests failed\n")
        failed += 1
    }
    
    // File I/O module tests
    io.print("Testing File I/O Module...\n")
    if test_file_io() {
        io.print("  ✓ File I/O tests passed\n")
        passed += 1
    } | false {
        io.print("  ✗ File I/O tests failed\n")
        failed += 1
    }
    
    // Network module tests
    io.print("Testing Network Module...\n")
    if test_network() {
        io.print("  ✓ Network tests passed\n")
        passed += 1
    } | false {
        io.print("  ✗ Network tests failed\n")
        failed += 1
    }
    
    // Concurrency module tests
    io.print("Testing Concurrency Module...\n")
    if test_concurrency() {
        io.print("  ✓ Concurrency tests passed\n")
        passed += 1
    } | false {
        io.print("  ✗ Concurrency tests failed\n")
        failed += 1
    }
    
    // Print summary
    io.print("\n================================================\n")
    io.print("Test Summary:\n")
    io.print_fmt("  Passed: {}\n", passed)
    io.print_fmt("  Failed: {}\n", failed)
    io.print_fmt("  Total:  {}\n", passed + failed)
    
    if failed == 0 {
        io.print("\n✓ All tests passed!\n")
        return 0
    } | false {
        io.print("\n✗ Some tests failed\n")
        return 1
    }
}

// Core module tests
test_core = () bool   {
    mut all_passed := true
    
    // Test min/max
    if core.min(i32, 10, 20) != 10 {
        all_passed = false
    }
    if core.max(i32, 10, 20) != 20 {
        all_passed = false
    }
    
    // Test swap
    mut a := 5
    mut b := 10
    core.swap(&mut a, &mut b)
    if a != 10 || b != 5 {
        all_passed = false
    }
    
    // Test clamp
    if core.clamp(i32, 15, 10, 20) != 15 {
        all_passed = false
    }
    if core.clamp(i32, 5, 10, 20) != 10 {
        all_passed = false
    }
    if core.clamp(i32, 25, 10, 20) != 20 {
        all_passed = false
    }
    
    return all_passed
}

// String module tests
test_string = () bool   {
    mut all_passed := true
    
    // Test string creation and comparison
    s1 := core.String{ data: "hello", len: 5 }
    s2 := core.String{ data: "world", len: 5 }
    s3 := core.String{ data: "hello", len: 5 }
    
    if !string.equals(s1, s3) {
        all_passed = false
    }
    if string.equals(s1, s2) {
        all_passed = false
    }
    
    // Test string concatenation
    s4 := string.concat(s1, " ")
    s5 := string.concat(s4, s2)
    expected := core.String{ data: "hello world", len: 11 }
    if !string.equals(s5, expected) {
        all_passed = false
    }
    
    // Test substring
    sub := string.substring(s5, 6, 11)
    if !string.equals(sub, s2) {
        all_passed = false
    }
    
    // Test string utilities
    if !string.starts_with(s5, "hello") {
        all_passed = false
    }
    if !string.ends_with(s5, "world") {
        all_passed = false
    }
    if !string.contains(s5, " ") {
        all_passed = false
    }
    
    // Test split
    parts := string.split(s5, " ")
    if parts.len() != 2 {
        all_passed = false
    }
    if !string.equals(parts[0], s1) {
        all_passed = false
    }
    if !string.equals(parts[1], s2) {
        all_passed = false
    }
    
    return all_passed
}

// Vector module tests
test_vec = () bool   {
    mut all_passed := true
    
    // Create vector
    mut v := DynVec.new<i32>(10)
    
    // Test push
    vec.push(&mut v, 1)
    vec.push(&mut v, 2)
    vec.push(&mut v, 3)
    
    if vec.len(v) != 3 {
        all_passed = false
    }
    
    // Test get
    if vec.get(v, 0) != 1 {
        all_passed = false
    }
    if vec.get(v, 1) != 2 {
        all_passed = false
    }
    if vec.get(v, 2) != 3 {
        all_passed = false
    }
    
    // Test set
    vec.set(&mut v, 1, 42)
    if vec.get(v, 1) != 42 {
        all_passed = false
    }
    
    // Test pop
    val := vec.pop(&mut v)
    if val != 3 {
        all_passed = false
    }
    if vec.len(v) != 2 {
        all_passed = false
    }
    
    // Test insert
    vec.insert(&mut v, 1, 10)
    if vec.get(v, 1) != 10 {
        all_passed = false
    }
    if vec.get(v, 2) != 42 {
        all_passed = false
    }
    
    // Test remove
    removed := vec.remove(&mut v, 1)
    if removed != 10 {
        all_passed = false
    }
    if vec.len(v) != 2 {
        all_passed = false
    }
    
    // Test clear
    vec.clear(&mut v)
    if vec.len(v) != 0 {
        all_passed = false
    }
    if !vec.is_empty(v) {
        all_passed = false
    }
    
    return all_passed
}

// HashMap module tests
test_hashmap = () bool   {
    mut all_passed := true
    
    // Create hashmap
    mut map := hashmap.new<core.String, i32>(16)
    
    // Test insert
    key1 := core.String{ data: "one", len: 3 }
    key2 := core.String{ data: "two", len: 3 }
    key3 := core.String{ data: "three", len: 5 }
    
    hashmap.insert(&mut map, key1, 1)
    hashmap.insert(&mut map, key2, 2)
    hashmap.insert(&mut map, key3, 3)
    
    if hashmap.len(map) != 3 {
        all_passed = false
    }
    
    // Test get
    val1 := hashmap.get(map, key1)
    if val1.is_none() || val1.unwrap() != 1 {
        all_passed = false
    }
    
    val2 := hashmap.get(map, key2)
    if val2.is_none() || val2.unwrap() != 2 {
        all_passed = false
    }
    
    // Test contains
    if !hashmap.contains(map, key1) {
        all_passed = false
    }
    
    key_missing := core.String{ data: "four", len: 4 }
    if hashmap.contains(map, key_missing) {
        all_passed = false
    }
    
    // Test remove
    removed := hashmap.remove(&mut map, key2)
    if removed.is_none() || removed.unwrap() != 2 {
        all_passed = false
    }
    if hashmap.len(map) != 2 {
        all_passed = false
    }
    if hashmap.contains(map, key2) {
        all_passed = false
    }
    
    // Test clear
    hashmap.clear(&mut map)
    if hashmap.len(map) != 0 {
        all_passed = false
    }
    if !hashmap.is_empty(map) {
        all_passed = false
    }
    
    return all_passed
}

// Math module tests
test_math = () bool   {
    mut all_passed := true
    
    // Test basic math functions
    if math.abs(-10) != 10 {
        all_passed = false
    }
    if math.abs(10) != 10 {
        all_passed = false
    }
    
    // Test power
    if math.pow(2, 3) != 8 {
        all_passed = false
    }
    if math.pow(5, 2) != 25 {
        all_passed = false
    }
    
    // Test sqrt (approximate)
    sqrt_val := math.sqrt(16.0)
    if sqrt_val < 3.99 || sqrt_val > 4.01 {
        all_passed = false
    }
    
    // Test min/max
    if math.min(5.0, 3.0) != 3.0 {
        all_passed = false
    }
    if math.max(5.0, 3.0) != 5.0 {
        all_passed = false
    }
    
    // Test floor/ceil
    if math.floor(3.7) != 3.0 {
        all_passed = false
    }
    if math.ceil(3.2) != 4.0 {
        all_passed = false
    }
    
    // Test round
    if math.round(3.4) != 3.0 {
        all_passed = false
    }
    if math.round(3.6) != 4.0 {
        all_passed = false
    }
    
    // Test trigonometric (basic checks)
    sin_0 := math.sin(0.0)
    if sin_0 < -0.01 || sin_0 > 0.01 {
        all_passed = false
    }
    
    cos_0 := math.cos(0.0)
    if cos_0 < 0.99 || cos_0 > 1.01 {
        all_passed = false
    }
    
    return all_passed
}

// Memory module tests
test_memory = () bool   {
    mut all_passed := true
    
    // Test allocation
    ptr := mem.alloc<i32>(10)
    if ptr .== .None {
        all_passed = false
        return false
    }
    
    // Test write and read
    mem.write(ptr, 0, 42)
    if mem.read<i32>(ptr, 0) != 42 {
        all_passed = false
    }
    
    // Test array allocation
    arr := mem.alloc_array<i32>(5)
    if arr.data .== .None {
        all_passed = false
    }
    if arr.len != 5 {
        all_passed = false
    }
    
    // Write to array
    i := 0
    loop i < 5 {
        arr[i] = i * 10
        i += 1
    }
    
    // Read from array
    i = 0
    loop i < 5 {
        if arr[i] != i * 10 {
            all_passed = false
        }
        i += 1
    }
    
    // Test copy
    ptr2 := mem.alloc<i32>(10)
    mem.copy(ptr2, ptr, 10 * sizeof(i32))
    if mem.read<i32>(ptr2, 0) != 42 {
        all_passed = false
    }
    
    // Test set
    mem.set(ptr, 0, 10 * sizeof(i32))
    if mem.read<i32>(ptr, 0) != 0 {
        all_passed = false
    }
    
    // Free memory
    mem.free(ptr)
    mem.free(ptr2)
    mem.free(arr.data)
    
    return all_passed
}

// File I/O module tests
test_file_io = () bool   {
    mut all_passed := true
    
    test_file_path := "/tmp/zen_test_file.txt"
    test_content := "Hello, Zen!\nThis is a test file.\n"
    
    // Test file creation and writing
    file_res := file.create(test_file_path)
    if file_res.is_err() {
        io.print_fmt("  Failed to create file: {}\n", file_res.unwrap_err())
        return false
    }
    
    mut f := file_res.unwrap()
    
    // Write content
    write_res := file.write_string(&mut f, test_content)
    if write_res.is_err() {
        io.print_fmt("  Failed to write: {}\n", write_res.unwrap_err())
        all_passed = false
    }
    
    // Close file
    close_res := file.close(&mut f)
    if close_res.is_err() {
        all_passed = false
    }
    
    // Test file reading
    read_file_res := file.open(test_file_path, file.FileMode.Read)
    if read_file_res.is_err() {
        io.print_fmt("  Failed to open for reading: {}\n", read_file_res.unwrap_err())
        return false
    }
    
    mut read_f := read_file_res.unwrap()
    
    // Read content
    read_res := file.read_to_string(&mut read_f)
    if read_res.is_err() {
        io.print_fmt("  Failed to read: {}\n", read_res.unwrap_err())
        all_passed = false
    } | false {
        content := read_res.unwrap()
        if !string.equals(content, test_content) {
            io.print("  Read content doesn't match written content\n")
            all_passed = false
        }
    }
    
    file.close(&mut read_f)
    
    // Test file existence
    if !file.exists(test_file_path) {
        io.print("  File existence check failed\n")
        all_passed = false
    }
    
    // Test file deletion
    delete_res := file.delete(test_file_path)
    if delete_res.is_err() {
        io.print_fmt("  Failed to delete: {}\n", delete_res.unwrap_err())
        all_passed = false
    }
    
    if file.exists(test_file_path) {
        io.print("  File still exists after deletion\n")
        all_passed = false
    }
    
    return all_passed
}

// Network module tests
test_network = () bool   {
    mut all_passed := true
    
    // Test IP address parsing
    ip_res := network.parse_ip("127.0.0.1")
    if ip_res.is_err() {
        io.print("  Failed to parse IPv4 address\n")
        all_passed = false
    } | false {
        ip := ip_res.unwrap()
        ip ?
            network.IpAddr.V4(octets) => {
                if octets[0] != 127 || octets[1] != 0 || 
                   octets[2] != 0 || octets[3] != 1 {
                    io.print("  IPv4 address parsed incorrectly\n")
                    all_passed = false
                }
            },
            _ => {
                io.print("  Expected IPv4 address\n")
                all_passed = false
            },
        }
    }
    
    // Test socket address creation
    addr := network.socket_addr(ip_res.unwrap(), 8080)
    if addr.port != 8080 {
        io.print("  Socket address port incorrect\n")
        all_passed = false
    }
    
    // Test HTTP method conversion
    method_str := network.method_to_string(network.HttpMethod.GET)
    if !string.equals(method_str, "GET") {
        io.print("  HTTP method to string failed\n")
        all_passed = false
    }
    
    method := network.string_to_method("POST")
    method ?
        network.HttpMethod.POST => {},
        _ => {
            io.print("  String to HTTP method failed\n")
            all_passed = false
        },
    }
    
    // Test URL parsing
    host, port, path := network.parse_url("http://example.com:8080/test/path")
    if !string.equals(host, "example.com") {
        io.print("  URL host parsing failed\n")
        all_passed = false
    }
    if port != 8080 {
        io.print("  URL port parsing failed\n")
        all_passed = false
    }
    if !string.equals(path, "/test/path") {
        io.print("  URL path parsing failed\n")
        all_passed = false
    }
    
    return all_passed
}

// Concurrency module tests
test_concurrency = () bool   {
    mut all_passed := true
    
    // Test mutex creation and locking
    mut mtx := concurrency.new_mutex()
    
    // Try lock should succeed
    if !concurrency.try_lock(&mut mtx) {
        io.print("  Failed to acquire mutex\n")
        all_passed = false
    }
    
    // Second attempt to lock should fail (already locked)
    if concurrency.try_lock(&mut mtx) {
        io.print("  Mutex double-lock succeeded (should fail)\n")
        all_passed = false
    }
    
    // Unlock
    concurrency.unlock(&mut mtx)
    
    // Now attempt to lock should succeed again
    if !concurrency.try_lock(&mut mtx) {
        io.print("  Failed to re-acquire mutex after unlock\n")
        all_passed = false
    }
    concurrency.unlock(&mut mtx)
    
    // Test channel creation
    mut chan := concurrency.new_channel<i32>(10)
    
    // Send values
    if !concurrency.send(&mut chan, 42) {
        io.print("  Failed to send to channel\n")
        all_passed = false
    }
    if !concurrency.send(&mut chan, 100) {
        io.print("  Failed to send second value to channel\n")
        all_passed = false
    }
    
    // Receive values
    val1_opt := concurrency.try_receive(&mut chan)
    if val1_opt.is_none() || val1_opt.unwrap() != 42 {
        io.print("  Failed to receive first value from channel\n")
        all_passed = false
    }
    
    val2_opt := concurrency.try_receive(&mut chan)
    if val2_opt.is_none() || val2_opt.unwrap() != 100 {
        io.print("  Failed to receive second value from channel\n")
        all_passed = false
    }
    
    // Channel should be empty now
    val3_opt := concurrency.try_receive(&mut chan)
    if val3_opt.is_some() {
        io.print("  Received value from empty channel\n")
        all_passed = false
    }
    
    // Test atomic operations
    mut atomic_val := concurrency.AtomicI32{ value: 10 }
    
    old_val := concurrency.atomic_add(&mut atomic_val, 5)
    if old_val != 10 {
        io.print("  Atomic add returned wrong old value\n")
        all_passed = false
    }
    
    new_val := concurrency.atomic_load(&atomic_val)
    if new_val != 15 {
        io.print("  Atomic value incorrect after add\n")
        all_passed = false
    }
    
    concurrency.atomic_store(&mut atomic_val, 20)
    if concurrency.atomic_load(&atomic_val) != 20 {
        io.print("  Atomic store/load failed\n")
        all_passed = false
    }
    
    // Test barrier
    mut barrier := concurrency.new_barrier(3)
    // Note: Full barrier test would require multiple threads
    
    // Test read-write lock
    mut rwlock := concurrency.new_rwlock()
    
    // Acquire read lock
    concurrency.read_lock(&mut rwlock)
    concurrency.read_unlock(&mut rwlock)
    
    // Acquire write lock
    concurrency.write_lock(&mut rwlock)
    concurrency.write_unlock(&mut rwlock)
    
    return all_passed
}