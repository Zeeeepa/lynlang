// Comprehensive test for generic type system hardening
{ io, Option, Result, Array, HashMap, HashSet } = @std

// Simple hash function for strings
string_hash = (s: string) i64 {
    hash ::= 5381 as i64
    i ::= 0 as i64
    loop {
        i >= s.len() ? { break }
        char_val = s.char_at(i as i32)
        temp ::= hash * 32
        char_int = char_val as i64
        hash = temp + hash + char_int
        i = i + 1
    }
    return hash
}

// Equality function for strings
string_eq = (a: string, b: string) i64 {
    a == b ? 
        | true { return 1 as i64 }
        | false { return 0 as i64 }
}

// Test 1: Basic generic type instantiation
test_basic_generics = () void {
    io.println("=== Test 1: Basic Generic Type Instantiation ===")
    
    // Option with different types
    opt_i32: Option<i32> = Option.Some(42)
    opt_i64: Option<i64> = Option.Some(9999999999)
    opt_f64: Option<f64> = Option.Some(3.14159)
    opt_string: Option<string> = Option.Some("Hello")
    
    opt_i32 ?
        | Option.Some(v) { io.println("Option<i32> value: ${v}") }
        | Option.None { io.println("Option<i32> is None") }
    
    opt_string ?
        | Option.Some(v) { io.println("Option<string> value: ${v}") }
        | Option.None { io.println("Option<string> is None") }
    
    // Result with different type combinations
    res_i32_str: Result<i32, string> = Result.Ok(100)
    res_f64_str: Result<f64, string> = Result.Err("Math error")
    res_str_i32: Result<string, i32> = Result.Ok("Success")
    
    res_i32_str ?
        | Result.Ok(v) { io.println("Result<i32,string> Ok: ${v}") }
        | Result.Err(e) { io.println("Result<i32,string> Err: ${e}") }
    
    res_f64_str ?
        | Result.Ok(v) { io.println("Result<f64,string> Ok: ${v}") }
        | Result.Err(e) { io.println("Result<f64,string> Err: ${e}") }
}

// Test 2: Nested generic types (simple nesting)
test_nested_generics_simple = () void {
    io.println("=== Test 2: Simple Nested Generics ===")
    
    // Option<Option<T>>
    nested_opt: Option<Option<i32>> = Option.Some(Option.Some(42))
    nested_opt ?
        | Option.Some(inner) {
            inner ?
                | Option.Some(v) { io.println("Option<Option<i32>>: ${v}") }
                | Option.None { io.println("Inner Option is None") }
        }
        | Option.None { io.println("Outer Option is None") }
    
    // Result<Option<T>, E>
    res_opt: Result<Option<i32>, string> = Result.Ok(Option.Some(123))
    res_opt ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(v) { io.println("Result<Option<i32>,string> value: ${v}") }
                | Option.None { io.println("Result contains None") }
        }
        | Result.Err(e) { io.println("Result error: ${e}") }
}

// Test 3: Double nested generics
test_double_nested_generics = () void {
    io.println("=== Test 3: Double Nested Generics ===")
    
    // Result<Result<T,E1>,E2>
    double_res: Result<Result<i32, string>, string> = Result.Ok(Result.Ok(42))
    double_res ?
        | Result.Ok(inner_res) {
            inner_res ?
                | Result.Ok(v) { io.println("Result<Result<i32,string>,string> value: ${v}") }
                | Result.Err(e) { io.println("Inner Result error: ${e}") }
        }
        | Result.Err(e) { io.println("Outer Result error: ${e}") }
}

// Test 4: Triple nested generics
test_triple_nested_generics = () void {
    io.println("=== Test 4: Triple Nested Generics ===")
    
    // Result<Result<Result<T,E>,E>,E>
    triple_res: Result<Result<Result<i32, string>, string>, string> = 
        Result.Ok(Result.Ok(Result.Ok(999)))
    
    triple_res ?
        | Result.Ok(level2) {
            level2 ?
                | Result.Ok(level3) {
                    level3 ?
                        | Result.Ok(v) { io.println("Triple nested value: ${v}") }
                        | Result.Err(e) { io.println("Level 3 error: ${e}") }
                }
                | Result.Err(e) { io.println("Level 2 error: ${e}") }
        }
        | Result.Err(e) { io.println("Level 1 error: ${e}") }
}

// Test 5: Generic collections
test_generic_collections = () void {
    io.println("=== Test 5: Generic Collections ===")
    
    // Array<T> with different types
    arr_i32: Array<i32> = Array.new(10, 0)
    arr_i32.push(10)
    arr_i32.push(20)
    arr_i32.push(30)
    
    io.println("Array<i32> length: ${arr_i32.len()}")
    io.println("Array<i32> element[0]: ${arr_i32.get(0)}")
    io.println("Array<i32> element[1]: ${arr_i32.get(1)}")
    io.println("Array<i32> element[2]: ${arr_i32.get(2)}")
    
    // HashMap<K,V> with different type combinations  
    map_str_i32: HashMap<string, i32> = HashMap<string, i32>.new()
    map_str_i32.insert("one", 1, string_hash, string_eq)
    map_str_i32.insert("two", 2, string_hash, string_eq)
    map_str_i32.insert("three", 3, string_hash, string_eq)
    
    // Test retrieval with pattern matching
    val1 = map_str_i32.get("one", string_hash, string_eq)
    val1 ?
        | Option.Some(v) { io.println("HashMap<string,i32> key='one': ${v}") }
        | Option.None { io.println("Key 'one' not found") }
    
    val2 = map_str_i32.get("two", string_hash, string_eq)
    val2 ?
        | Option.Some(v) { io.println("HashMap<string,i32> key='two': ${v}") }
        | Option.None { io.println("Key 'two' not found") }
}

// Test 6: Generic function return types with raise
test_generic_raise = () void {
    io.println("=== Test 6: Generic Function Return Types with raise ===")
    
    // Function returning Result<T,E>
    get_value = (flag: bool) Result<i32, string> {
        flag ?
            | true { Result.Ok(42) }
            | false { Result.Err("Value not available") }
    }
    
    // Test with raise
    test_raise = () Result<i32, string> {
        val = get_value(true).raise()
        Result.Ok(val * 2)
    }
    
    result = test_raise()
    result ?
        | Result.Ok(v) { io.println("Raised and doubled: ${v}") }
        | Result.Err(e) { io.println("Error: ${e}") }
}

// Test 7: Mixed nested generics with collections
test_mixed_nested = () void {
    io.println("=== Test 7: Mixed Nested Generics ===")
    
    // Array<Option<T>>
    arr_opt: Array<Option<i32>> = Array.new(5, Option.None)
    arr_opt.set(0, Option.Some(100))
    arr_opt.set(1, Option.Some(200))
    arr_opt.set(2, Option.None)
    
    elem0 = arr_opt.get(0)
    elem0 ?
        | Option.Some(v) { io.println("Array<Option<i32>>[0]: ${v}") }
        | Option.None { io.println("Array<Option<i32>>[0]: None") }
    
    elem2 = arr_opt.get(2)
    elem2 ?
        | Option.Some(v) { io.println("Array<Option<i32>>[2]: ${v}") }
        | Option.None { io.println("Array<Option<i32>>[2]: None") }
}

// Test 8: Complex type inference
test_type_inference = () void {
    io.println("=== Test 8: Complex Type Inference ===")
    
    // Chained operations with generics
    process_option = (opt: Option<i32>) Option<i32> {
        opt ?
            | Option.Some(v) { Option.Some(v * 2) }
            | Option.None { Option.None }
    }
    
    original = Option.Some(21)
    processed = process_option(original)
    processed ?
        | Option.Some(v) { io.println("Processed Option value: ${v}") }
        | Option.None { io.println("Processed Option is None") }
    
    // Nested function calls with generics
    wrap_in_result = (opt: Option<i32>) Result<Option<i32>, string> {
        Result.Ok(opt)
    }
    
    wrapped = wrap_in_result(Option.Some(33))
    wrapped ?
        | Result.Ok(opt) {
            opt ?
                | Option.Some(v) { io.println("Wrapped value: ${v}") }
                | Option.None { io.println("Wrapped None") }
        }
        | Result.Err(e) { io.println("Wrapped error: ${e}") }
}

// Test 9: Generic type parameters in closures
test_generic_closures = () void {
    io.println("=== Test 9: Generic Type Parameters in Closures ===")
    
    // Closure returning Option<T>
    make_option = (val: i32) Option<i32> {
        val > 0 ?
            | true { Option.Some(val) }
            | false { Option.None }
    }
    
    opt1 = make_option(10)
    opt1 ?
        | Option.Some(v) { io.println("Closure Option(10): ${v}") }
        | Option.None { io.println("Closure Option(10): None") }
    
    opt2 = make_option(-5)
    opt2 ?
        | Option.Some(v) { io.println("Closure Option(-5): ${v}") }
        | Option.None { io.println("Closure Option(-5): None") }
    
    // Closure returning Result<T,E>
    safe_divide = (a: i32, b: i32) Result<i32, string> {
        b == 0 ?
            | true { Result.Err("Division by zero") }
            | false { Result.Ok(a / b) }
    }
    
    div1 = safe_divide(100, 5)
    div1 ?
        | Result.Ok(v) { io.println("100 / 5 = ${v}") }
        | Result.Err(e) { io.println("Error: ${e}") }
    
    div2 = safe_divide(100, 0)
    div2 ?
        | Result.Ok(v) { io.println("100 / 0 = ${v}") }
        | Result.Err(e) { io.println("Error: ${e}") }
}

// Test 10: Generic type consistency
test_type_consistency = () void {
    io.println("=== Test 10: Generic Type Consistency ===")
    
    // Ensure types are properly tracked through operations
    start: Option<i32> = Option.Some(10)
    
    // Chain of operations maintaining type
    step1 = start ?
        | Option.Some(v) { Option.Some(v + 5) }
        | Option.None { Option.None }
    
    step2 = step1 ?
        | Option.Some(v) { Option.Some(v * 2) }
        | Option.None { Option.None }
    
    step3 = step2 ?
        | Option.Some(v) { Option.Some(v - 3) }
        | Option.None { Option.None }
    
    step3 ?
        | Option.Some(v) { io.println("Final value after chain: ${v}") }
        | Option.None { io.println("Chain resulted in None") }
    
    // Type consistency with Result
    res_start: Result<i32, string> = Result.Ok(100)
    
    res_chain = res_start ?
        | Result.Ok(v) { Result.Ok(v / 2) }
        | Result.Err(e) { Result.Err(e) }
    
    res_chain ?
        | Result.Ok(v) { io.println("Result chain value: ${v}") }
        | Result.Err(e) { io.println("Result chain error: ${e}") }
}

main = () void {
    io.println("========================================")
    io.println("Generic Type System Hardening Test Suite")
    io.println("========================================")
    
    test_basic_generics()
    test_nested_generics_simple()
    test_double_nested_generics()
    test_triple_nested_generics()
    test_generic_collections()
    test_generic_raise()
    test_mixed_nested()
    test_type_inference()
    test_generic_closures()
    test_type_consistency()
    
    io.println("========================================")
    io.println("All generic type tests completed!")
    io.println("========================================")
}