// Consolidated test for raise() edge cases - still broken
// Issue: Complex error propagation scenarios fail
{ io, Result , get_default_allocator} = @std

// Test 1: Chained raise() calls
test_chained_raise = () void {
    io.println("Test 1: Chained raise()")
    
    // Multiple levels of nesting
    deeply_nested = Result.Ok(Result.Ok(Result.Ok(42)))
    
    // Should be able to chain raise calls
    level2 = deeply_nested.raise()
    level1 = level2.raise()  
    value = level1.raise()
    
    io.println("  Expected: 42, Got: ${value}")
}

// Test 2: raise() with different error types
test_mixed_errors = () void {
    io.println("Test 2: Mixed error types")
    
    // Result<Result<i32, StaticString>, i32>
    mixed = Result.Ok(Result.Err("inner error"))
    
    inner = mixed.raise()
    inner ?
        | Result.Ok(v) { io.println("  Got value: ${v}"); {} }
        | Result.Err(e) { io.println("  Got error: ${e}"); {} }
}

// Test 3: raise() in expressions
test_raise_in_expressions = () void {
    io.println("Test 3: raise() in expressions")
    
    get_result = () Result<i32, StaticString> { Result.Ok(10) }
    
    // Use raise() directly in arithmetic
    value = get_result().raise() + 5
    io.println("  10 + 5 = ${value}")
    
    // Use raise() in conditionals
    get_result().raise() > 5 ?
        | true { io.println("  Conditional works"); {} }
        | false { io.println("  Conditional failed"); {} }
}

main = () void {
    alloc = get_default_allocator()
    io.println("=== Consolidated raise() Edge Cases ===\n")
    
    test_chained_raise()
    test_mixed_errors()
    test_raise_in_expressions()
    
    io.println("\n=== All tests complete ===")
}