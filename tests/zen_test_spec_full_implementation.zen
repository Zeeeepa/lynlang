// Full test suite for LANGUAGE_SPEC.zen
// Tests ALL features defined in the spec

{ io, math } = @std

// Simple struct from spec (line 117-120)
Point: {
    x:: f64,  // mutable field
    y:: f64 = 0  // with default value
}

// Option type (line 109-110)
Option<T>: Some(T) | None

// Result type (line 113-114)
Result<T, E>: Ok(T) | Err(E)

// Test UFC (Uniform Function Call)
double = (x: i32) i32 { return x * 2 }

// Test function that returns Result
parse_number = (s: i32) Result<i32, i32> {
    s > 0 ?
        | true { return Ok(s) }
        | false { return Err(-1) }
}

main = () void {
    io.println("=== LANGUAGE_SPEC.zen Full Feature Test Suite ===")
    
    // ======================================================================
    // 1. VARIABLE DECLARATIONS (lines 298-306)
    // ======================================================================
    io.println("\n1. Variable Declarations (all forms):")
    
    // Forward declaration 
    x: i32
    x = 10
    io.println("  x (forward decl): ${x}")
    
    // Immutable assignment
    y = 20  
    io.println("  y (immutable): ${y}")
    
    // Immutable with type
    z: i32 = 30
    io.println("  z (immutable typed): ${z}")
    
    // Mutable forward declaration
    w:: i32
    w = 40
    io.println("  w (mut forward): ${w}")
    w = 45
    io.println("  w (after mutation): ${w}")
    
    // Mutable assignment
    v ::= 50
    io.println("  v (mutable): ${v}")
    v = 60
    io.println("  v (after change): ${v}")
    
    // Mutable with type
    u:: i32 = 70
    io.println("  u (mut typed): ${u}")
    u = 80
    io.println("  u (after change): ${u}")
    
    // ======================================================================
    // 2. PATTERN MATCHING WITH ? (lines 352-361, 29-43)
    // ======================================================================
    io.println("\n2. Pattern Matching with ? operator:")
    
    // Boolean pattern - simple form
    is_ready = true
    is_ready ? {
        io.println("  Simple pattern: is_ready is true")
    }
    
    // Boolean pattern - if-else form
    has_data = false
    has_data ?
        | true { io.println("  Has data: processing...") }
        | false { io.println("  Has data: false - waiting...") }
    
    // Conditional compilation style pattern (lines 29-37)
    is_release = false
    is_release ?
        | true {
            io.println("  Build mode: Release (optimized)")
        }
        | false {
            io.println("  Build mode: Debug (with symbols)")
        }
    
    // ======================================================================
    // 3. STRUCTS (lines 117-120, 363-372)
    // ======================================================================
    io.println("\n3. Structs with mutable fields:")
    
    // Create struct with mutable fields
    point ::= Point { x: 10.5, y: 20.5 }
    io.println("  Point: x=${point.x}, y=${point.y}")
    
    // Mutate fields
    point.x = 30.5
    io.println("  After mutation: x=${point.x}, y=${point.y}")
    
    // Use default value
    point2 = Point { x: 5.0 }  // y gets default value of 0
    io.println("  Point with default: x=${point2.x}, y=${point2.y}")
    
    // ======================================================================  
    // 4. OPTION TYPES - NO NULL (lines 109-110, 462-473)
    // ======================================================================
    io.println("\n4. Option types (no null/nil):")
    
    maybe_value: Option<i32> = Some(42)
    maybe_value ?
        | Some(val) { io.println("  Option has value: ${val}") }
        | None { io.println("  Option is None") }
    
    empty: Option<i32> = None
    empty ?
        | Some(val) { io.println("  Should not print: ${val}") }
        | None { io.println("  Option is None (as expected)") }
    
    // ======================================================================
    // 5. RESULT TYPES (lines 113-114, 199-203)
    // ======================================================================
    io.println("\n5. Result type for error handling:")
    
    result1 = parse_number(10)
    result1 ?
        | Ok(val) { io.println("  Result Ok: ${val}") }
        | Err(e) { io.println("  Result Err: ${e}") }
    
    result2 = parse_number(-5)
    result2 ?
        | Ok(val) { io.println("  Should not print: ${val}") }
        | Err(e) { io.println("  Result Err (as expected): ${e}") }
    
    // ======================================================================
    // 6. RANGES AND LOOPS (lines 432-439)
    // ======================================================================
    io.println("\n6. Ranges and loops:")
    
    // Basic range
    io.println("  Range (0..5):")
    (0..5).loop((i) {
        io.println("    ${i}")
    })
    
    // Range used for sum
    sum ::= 0
    (1..11).loop((i) {
        sum = sum + i
    })
    io.println("  Sum of (1..11): ${sum}")
    
    // ======================================================================
    // 7. UFC (Uniform Function Call) (line 4, 174-182)
    // ======================================================================
    io.println("\n7. UFC (Uniform Function Call):")
    
    // Function can be called as method
    num = 7
    doubled = num.double()  // UFC: calling double as method
    io.println("  7.double() = ${doubled}")
    
    // Also works as regular function
    doubled2 = double(8)
    io.println("  double(8) = ${doubled2}")
    
    // ======================================================================
    // 8. ARITHMETIC OPERATIONS
    // ======================================================================
    io.println("\n8. Arithmetic operations:")
    
    a = 100
    b = 25
    io.println("  ${a} + ${b} = ${a + b}")
    io.println("  ${a} - ${b} = ${a - b}")
    io.println("  ${a} * ${b} = ${a * b}")
    io.println("  ${a} / ${b} = ${a / b}")
    
    // ======================================================================
    // 9. COMPARISONS
    // ======================================================================
    io.println("\n9. Comparison operations:")
    
    val1 = 10
    val2 = 20
    
    (val1 < val2) ? {
        io.println("  ${val1} < ${val2}: true")
    }
    
    (val1 > val2) ?
        | true { io.println("  ${val1} > ${val2}: true") }
        | false { io.println("  ${val1} > ${val2}: false") }
    
    (val1 == 10) ? {
        io.println("  ${val1} == 10: true")
    }
    
    // ======================================================================
    // 10. LOOP CONTROL (lines 453-459)
    // ======================================================================
    io.println("\n10. Loop control with break:")
    
    counter ::= 0
    loop(() {
        counter = counter + 1
        io.println("  Loop counter: ${counter}")
        (counter >= 3) ?
            | true { break }
            | false { }
    })
    
    io.println("\n=== All LANGUAGE_SPEC.zen Features Tested Successfully ===")
}