// Test file to verify LANGUAGE_SPEC.zen implementation
// This test covers all key features from the spec

// ============================================================================
// Core Language Features Test
// ============================================================================

// Imports - only @std and @this are special (Lines 92-107)
{ io, math } = @std
{ String, StringBuilder } = @std

// Option type - No null! (Lines 109-110)
Option<T>: Some(T) | None

// Result type for error handling (Lines 112-113)
Result<T, E>: Ok(T) | Err(E)

// Simple struct (Lines 117-120)
Point: {
    x:: f64,  // mutable field
    y:: f64 = 0  // with default value
}

// Trait definition (Lines 123-128)
Geometric: {
    area: (self) f64,
    perimeter: (self) f64,
}

// Circle struct (Lines 130-133)
Circle: {
    center: Point,
    radius: f64,
}

// Trait implementation using .implements() (Lines 135-143)
Circle.implements(Geometric, {
    area = (self) f64 {
        return math.pi * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * math.pi * self.radius
    },
})

// Rectangle struct (Lines 145-149)
Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

// Rectangle trait implementation (Lines 151-162)
Rectangle.implements(Geometric, {
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return width * height
    },
    perimeter = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return 2.0 * (width + height)
    },
})

// Enum type (Line 165)
Shape: Circle | Rectangle

// Enforce Shape variants must implement Geometric (Line 168)
Shape.requires(Geometric)

// UFC overloading for enum variants (Lines 171-181)
GameEntity: Player | Enemy | Powerup

get_health = (e: GameEntity.Player) u32 { return 100 }
get_health = (e: GameEntity.Enemy) u32 { return 50 }
get_health = (e: GameEntity.Powerup) u32 { return 0 }

// Parse shape from string with Result type (Lines 199-203)
parse_radius = (s: string) Result<f64, string> {
    s.to_f64() ?
        | Some(val) { return Ok(val) }
        | None { return Err("Invalid radius") }
}

// Error propagation with .raise() (Lines 206-211)
load_config = (path: string) Result<Config, Error> {
    file = File.open(path).raise()  // If Err, returns early
    contents = file.read_all().raise()
    config = json.parse(contents).raise()
    return Ok(config)
}

// Main function demonstrating all features
main = () void {
    io.println("Testing LANGUAGE_SPEC.zen Implementation")
    io.println("=========================================")
    
    // Variable declarations (Lines 298-306)
    x: i32  // forward declaration
    x = 10
    y = 20  // Immutable assignment
    z: i32 = 30  // Immutable with type
    w:: i32  // mutable forward declaration
    w = 40
    v ::= 50  // Mutable assignment
    u:: i32 = 60  // mutable with type
    
    io.println("Variables: x=${x}, y=${y}, z=${z}, w=${w}, v=${v}, u=${u}")
    
    // Pattern matching with ? operator (Lines 352-361)
    is_ready = true
    is_ready ? { 
        io.println("System is ready!") 
    }
    
    has_data = false
    has_data ?
        | true { io.println("Processing data...") }
        | false { io.println("Waiting for data...") }
    
    // Option handling - no null! (Lines 462-473)
    maybe_radius: Option<f64> = Some(5.5)
    maybe_radius ?
        | Some(r) {
            circle = Circle {
                center: Point { x: 100.0, y: 100.0 },
                radius: r,
            }
            io.println("Created circle with radius: ${r}")
            io.println("Circle area: ${circle.area()}")  // UFC call
            io.println("Circle perimeter: ${circle.perimeter()}")  // UFC call
        }
        | None {
            io.println("No radius provided")
        }
    
    // Result type handling
    result = parse_radius("3.14")
    result ?
        | Ok(val) { io.println("Parsed radius: ${val}") }
        | Err(msg) { io.println("Parse error: ${msg}") }
    
    // Enum with pattern matching (Lines 322-335)
    entity: GameEntity = Player
    entity ?
        | Player { 
            io.println("Player health: ${get_health(entity)}")
        }
        | Enemy { 
            io.println("Enemy health: ${get_health(entity)}")
        }
        | Powerup {
            io.println("Powerup has no health")
        }
    
    // Range iterations (Lines 432-434)
    io.println("Counting from 0 to 4:")
    (0..5).loop((i) {
        io.println("  Count: ${i}")
    })
    
    // Step ranges (Lines 437-439)
    io.println("Counting by 10s:")
    (0..50).step(10).loop((i) {
        io.println("  Step: ${i}")
    })
    
    // UFC - any function can be called as method
    shapes = [
        Circle { center: Point { x: 0, y: 0 }, radius: 10 },
        Circle { center: Point { x: 5, y: 5 }, radius: 5 }
    ]
    
    total_area ::= 0.0
    shapes.loop((shape) {
        total_area = total_area + shape.area()  // UFC method call
    })
    io.println("Total area of shapes: ${total_area}")
    
    // Loop with index
    shapes.loop((shape, i) {
        io.println("Shape ${i} area: ${shape.area()}")
    })
    
    // Infinite loop with break (Lines 453-460)
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter > 3 ?
            | true { break }
            | false { io.println("Loop iteration: ${counter}") }
    })
    
    // Pointer types (Lines 364-372)
    original_circle = Circle { 
        center: Point { x: 50, y: 50 }, 
        radius: 25 
    }
    circle_ptr: Ptr<Circle> = original_circle.ref()
    circle_mut: MutPtr<Circle> = original_circle.mut_ref()
    
    io.println("Circle area via pointer: ${circle_ptr.val.area()}")
    circle_mut.val.radius = 30
    io.println("Modified circle area: ${circle_mut.val.area()}")
    io.println("Pointer address: ${circle_ptr.addr}")
    
    io.println("=========================================")
    io.println("All tests completed successfully!")
}