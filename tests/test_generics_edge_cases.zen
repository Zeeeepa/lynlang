// Test edge cases and complex scenarios for generic types
{ io, Result, Option , get_default_allocator} = @std

// Custom enum to test generic instantiation with user-defined types
CustomResult : .Success(value: i32) | .Failure(msg: StaticString)

// Helper functions for testing
create_nested_custom = () CustomResult {
    return CustomResult.Success(100)
}

create_deep_option = () Option<Option<Option<i32>>> {
    return Option.Some(Option.Some(Option.Some(42)))
}

// Test returning Result from inline closure
test_closure_result = () Result<i32, StaticString> {
    compute = () Result<i32, StaticString> { Result.Ok(123) }
    return compute()
}

// Test generic type inference in variable assignment
test_type_inference = () void {
    // Simple inference
    opt1 = Option.Some(42)
    opt1 ? | Option.Some(v) => io.println("Inferred Some: ${v}")
           | Option.None => io.println("Inferred None")
    
    // Nested inference
    opt2 = Option.Some(Option.Some(84))
    opt2 ? | Option.Some(inner) => {
        inner ? | Option.Some(v) => io.println("Nested inferred: ${v}")
               | Option.None => io.println("Inner None")
    } | Option.None => io.println("Outer None")
}

// Test generic payload extraction with different types
test_mixed_payloads = () void {
    // i32 in Result
    r1 = Result.Ok(100)
    v1 = r1.raise()
    io.println("i32 payload: ${v1}")
    
    // String in Result
    r2 = Result.Err("error message")
    r2 ? | Result.Ok(_) => io.println("Unexpected Ok")
         | Result.Err(msg) => io.println("String payload: ${msg}")
    
    // Float in Option  
    opt = Option.Some(3.14)
    opt ? | Option.Some(f) => io.println("Float payload: ${f}")
          | Option.None => io.println("None")
}

// Test generic type preservation through function calls
pass_through_generic = (opt: Option<i32>) Option<i32> {
    return opt
}

test_passthrough = () void {
    input = Option.Some(222)
    output = pass_through_generic(input)
    output ? | Option.Some(v) => io.println("Passthrough value: ${v}")
            | Option.None => io.println("Passthrough None")
}

// Main test driver
main = () void {
    alloc = get_default_allocator()
    io.println("=== Testing Generic Edge Cases ===")
    
    io.println("\n1. Custom enum with generics:")
    custom = create_nested_custom()
    custom ? | CustomResult.Success(v) => io.println("  Custom Success: ${v}")
            | CustomResult.Failure(msg) => io.println("  Custom Failure: ${msg}")
    
    io.println("\n2. Triple nested Option:")
    deep = create_deep_option()
    deep ? | Option.Some(l1) => {
        l1 ? | Option.Some(l2) => {
            l2 ? | Option.Some(v) => io.println("  Deep value: ${v}")
                 | Option.None => io.println("  L2 None")
        } | Option.None => io.println("  L1 None")
    } | Option.None => io.println("  L0 None")
    
    io.println("\n3. Closure returning Result:")
    closure_res = test_closure_result()
    closure_val = closure_res.raise()
    io.println("  Closure result: ${closure_val}")
    
    io.println("\n4. Type inference:")
    test_type_inference()
    
    io.println("\n5. Mixed payload types:")
    test_mixed_payloads()
    
    io.println("\n6. Generic passthrough:")
    test_passthrough()
    
    io.println("\n=== All Tests Complete ===")
}