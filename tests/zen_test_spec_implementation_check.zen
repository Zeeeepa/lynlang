// Test file to check LANGUAGE_SPEC.zen implementation status
// Based directly on examples from LANGUAGE_SPEC.zen

{ io } = @std

// Test 1: Basic variable declarations (lines 299-306 of spec)
test_variables = () void {
    io.println("=== Testing Variable Declarations ===")
    
    // All 6 forms of variable declaration from spec
    x: i32              // forward declaration
    x = 10              // immutable assignment
    y = 20              // immutable inference
    z: i32 = 30         // immutable with type
    w:: i32             // mutable forward declaration
    w = 40              // mutable assignment
    v ::= 50            // mutable inference  
    u:: i32 = 60        // mutable with type
    
    io.println("✓ All variable forms compiled")
}

// Test 2: UFC (Uniform Function Call)
double = (n: i32) i32 { return n * 2 }
triple = (n: i32) i32 { return n * 3 }

test_ufc = () void {
    io.println("=== Testing UFC ===")
    
    // Direct function call
    result1 = double(5)
    io.println("double(5) = ")
    io.println(result1)
    
    // UFC style - CRITICAL TEST
    // result2 = 5.double()  // This should work per spec
    // io.println("5.double() = ")
    // io.println(result2)
    
    io.println("UFC test needs implementation")
}

// Test 3: Pattern matching with ?
test_pattern_matching = () void {
    io.println("=== Testing Pattern Matching ===")
    
    // Boolean short form
    is_ready = true
    is_ready ? { 
        io.println("✓ Boolean short form works") 
    }
    
    // Full pattern matching
    has_data = false
    has_data ?
        | true { io.println("Has data") }
        | false { io.println("✓ Full pattern match works") }
}

// Test 4: Option types (no null!)
Option<T>: Some(T) | None

test_option = () void {
    io.println("=== Testing Option Types ===")
    
    maybe: Option<i32> = Some(42)
    maybe ?
        | Some(n) { 
            io.println("✓ Option Some variant works: ")
            io.println(n)
        }
        | None { io.println("Empty") }
    
    nothing: Option<i32> = None
    nothing ?
        | Some(n) { io.println("Has value") }
        | None { io.println("✓ Option None variant works") }
}

// Test 5: Structs
Point: {
    x: f64,
    y: f64
}

test_structs = () void {
    io.println("=== Testing Structs ===")
    
    p = Point { x: 10.0, y: 20.0 }
    io.println("✓ Struct literal works")
    io.println("Point.x = ")
    io.println(p.x)
    io.println("Point.y = ")
    io.println(p.y)
}

// Test 6: Loops and ranges
test_loops = () void {
    io.println("=== Testing Loops ===")
    
    // Infinite loop with break
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter > 3 ?
            | true { break }
            | false { 
                io.println("Loop iteration: ")
                io.println(counter)
            }
    })
    io.println("✓ Infinite loop with break works")
    
    // Range iteration - Critical test
    // (0..3).loop((i) {
    //     io.println("Range: ")
    //     io.println(i)
    // })
    io.println("Range iteration needs implementation")
}

// Test 7: @this.defer
test_defer = () void {
    io.println("=== Testing @this.defer ===")
    
    io.println("Start of scope")
    @this.defer(io.println("✓ Deferred cleanup executed"))
    io.println("Middle of scope")
    // Should print "Deferred cleanup executed" at end
}

// Test 8: Result type for error handling
Result<T, E>: Ok(T) | Err(E)

divide = (a: f64, b: f64) Result<f64, string> {
    b == 0.0 ?
        | true { return Err("Division by zero") }
        | false { return Ok(a / b) }
}

test_error_handling = () void {
    io.println("=== Testing Error Handling ===")
    
    result = divide(10.0, 2.0)
    result ?
        | Ok(val) { 
            io.println("✓ Result Ok works: ")
            io.println(val)
        }
        | Err(e) { io.println("Error") }
    
    error = divide(10.0, 0.0)
    error ?
        | Ok(val) { io.println("Value") }
        | Err(e) { io.println("✓ Result Err works: Division by zero") }
}

// Main test runner
main = () void {
    io.println("==================================")
    io.println("LANGUAGE_SPEC.zen Implementation Test")
    io.println("==================================")
    io.println("")
    
    test_variables()
    io.println("")
    
    test_ufc()
    io.println("")
    
    test_pattern_matching()
    io.println("")
    
    test_option()
    io.println("")
    
    test_structs()
    io.println("")
    
    test_loops()
    io.println("")
    
    test_defer()
    io.println("")
    
    test_error_handling()
    io.println("")
    
    io.println("==================================")
    io.println("Test Summary:")
    io.println("✓ Variable declarations work")
    io.println("✓ Pattern matching works")
    io.println("✓ Option types work")
    io.println("✓ Structs work")
    io.println("✓ Basic loops work")
    io.println("✓ @this.defer works")
    io.println("✓ Result types work")
    io.println("✗ UFC needs implementation")
    io.println("✗ Range iteration needs implementation")
    io.println("✗ .raise() error propagation needs work")
    io.println("✗ Traits (.implements/.requires) need work")
    io.println("==================================")
}