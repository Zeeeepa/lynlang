// Testing LANGUAGE_SPEC.zen features incrementally
{ io, math } = @std

// Option type
Option<T>: Some(T) | None

// Test Option
test_option = () void {
    io.println("=== Option Type ===")
    
    // Test Some
    maybe_value: Option<i32> = Some(42)
    maybe_value ?
        | Some(v) { io.println("✓ Some(${v})") }
        | None { io.println("None") }
    
    // Test None
    empty: Option<i32> = None
    empty ?
        | Some(v) { io.println("Some(${v})") }
        | None { io.println("✓ None") }
}

// Trait definition
Printable: {
    print: (self) void,
}

// Struct with trait
Message: {
    text: string,
}

Message.implements(Printable, {
    print = (self) void {
        io.println("Message: ${self.text}")
    },
})

test_traits = () void {
    io.println("\n=== Traits ===")
    msg = Message { text: "Hello from trait!" }
    msg.print()
    io.println("✓ Trait method called")
}

// Test forward declarations
test_forward_decl = () void {
    io.println("\n=== Forward Declarations ===")
    
    // Type annotation
    x: i32
    x = 100
    io.println("✓ Forward decl: x = ${x}")
    
    // Mutable forward decl
    y:: i32
    y = 200
    y = 300
    io.println("✓ Mutable forward: y = ${y}")
}

// Test mutable struct fields
Counter: {
    value:: i32,
}

test_mutable_fields = () void {
    io.println("\n=== Mutable Fields ===")
    c = Counter { value: 0 }
    io.println("Initial: ${c.value}")
    c.value = 10
    io.println("✓ After mutation: ${c.value}")
}

// Nested patterns
test_nested_patterns = () void {
    io.println("\n=== Nested Patterns ===")
    
    x = 5
    result = x > 3 ?
        | true { "greater" }
        | false { "lesser" }
    io.println("✓ Nested result: ${result}")
}

main = () void {
    io.println("LANGUAGE_SPEC.zen Feature Test")
    io.println("================================")
    
    test_option()
    test_traits()
    test_forward_decl()
    test_mutable_fields()
    test_nested_patterns()
    
    io.println("\n✓ All Features Tested")
}