// Simple Language Spec Compliance Test
// Tests core features according to LANGUAGE_SPEC.md v1.1.0

// Test pattern matching - NO if/else/match keywords
test_pattern_matching = () bool {
    value := 42
    result := value ?
        | 42 => true
        | _ => false
    result
}

// Test mutable variables
test_mutable_vars = () bool {
    counter ::= 0
    counter = counter + 1
    counter == 1
}

// Test struct definition (no struct keyword)
Point = {
    x: f64,
    y: f64,
}

// Test enum definition  
Result<T, E> =
    | Ok(value: T)
    | Err(error: E)

// Test function with generics
identity<T> = (value: T) T {
    value
}

// Test loop (only one loop keyword)
test_loop = () bool {
    sum ::= 0
    counter ::= 3
    loop (counter > 0) {
        sum = sum + counter
        counter = counter - 1
    }
    sum == 6
}

// Test range iteration
test_range = () bool {
    sum ::= 0
    (0..5).loop((i) => {
        sum = sum + i
    })
    sum == 10
}

// Test pointer usage (no raw & or *)
test_pointer = () bool {
    ptr := Ptr::new(42)
    ptr.value == 42
}

// Test FFI builder pattern
test_ffi_builder = () bool {
    sqlite := FFI.lib("sqlite3")
        .set_path("/usr/lib/libsqlite3.so")
        .add_function("sqlite3_open", FnSignature{
            params: Vec::new(),
            returns: Type::I32,
        })
        .build_library()
    
    sqlite.name == "sqlite3"
}

// Main entry point
main = () void {
    test_pattern_matching() ?
        | true => print("✓ Pattern matching works")
        | false => print("✗ Pattern matching failed")
    
    test_mutable_vars() ?
        | true => print("✓ Mutable variables work")
        | false => print("✗ Mutable variables failed")
    
    test_loop() ?
        | true => print("✓ Loops work")
        | false => print("✗ Loops failed")
    
    test_range() ?
        | true => print("✓ Range iteration works")
        | false => print("✗ Range iteration failed")
    
    print("All basic tests completed")
}

// Helper functions
print = (msg: string) void {
    @intrinsic("print", msg)
}

// Core types needed for tests
Ptr<T> = {
    value: T,
    address: usize,
    
    new: (value: T) Ptr<T> {
        @intrinsic("ptr_new", value)
    },
}

Vec<T> = {
    data: Ptr<[?, T]>,
    len: usize,
    capacity: usize,
    
    new: () Vec<T> {
        @intrinsic("vec_new")
    },
}

FnSignature = {
    params: Vec<Type>,
    returns: Type,
}

Type =
    | I32
    | I64
    | F32
    | F64
    | Void

FFI = {
    lib: (name: string) LibBuilder {
        @intrinsic("ffi_lib", name)
    },
}

LibBuilder = {
    name: string,
    path:: Option<string>,
    
    set_path: (self: Ptr<LibBuilder>, p: string) Ptr<LibBuilder> {
        self.value.path = Some(p)
        self
    },
    
    add_function: (self: Ptr<LibBuilder>, name: string, sig: FnSignature) Ptr<LibBuilder> {
        self
    },
    
    build_library: (self: Ptr<LibBuilder>) Library {
        Library{ name: self.value.name }
    },
}

Library = {
    name: string,
}

Option<T> =
    | Some(value: T)
    | None