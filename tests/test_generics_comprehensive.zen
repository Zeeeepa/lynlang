// Comprehensive test of working generic features
{ io, Result, Option, HashMap, HashSet, DynVec, Array } = @std

main = () void {
    io.println("=== Comprehensive Generic Types Test ===")
    
    // 1. Result<T,E> with different types
    io.println("\n1. Result<T,E> Tests:")
    
    int_result = Result.Ok(42)
    int_result ? | Result.Ok(v) => io.println("  Int result: ${v}")
                 | Result.Err(e) => io.println("  Error: ${e}")
    
    string_result = Result.Ok("hello")
    string_result ? | Result.Ok(v) => io.println("  String result: ${v}")
                    | Result.Err(e) => io.println("  Error: ${e}")
    
    float_result = Result.Ok(3.14)
    float_result ? | Result.Ok(v) => io.println("  Float result: ${v}")
                   | Result.Err(e) => io.println("  Error: ${e}")
    
    error_result = Result.Err("something went wrong")
    error_result ? | Result.Ok(v) => io.println("  Value: ${v}")
                   | Result.Err(e) => io.println("  Error result: ${e}")
    
    // 2. Option<T> with different types
    io.println("\n2. Option<T> Tests:")
    
    int_option = Option.Some(99)
    int_option ? | Option.Some(v) => io.println("  Int option: ${v}")
                 | Option.None => io.println("  None")
    
    string_option = Option.Some("world")
    string_option ? | Option.Some(v) => io.println("  String option: ${v}")
                    | Option.None => io.println("  None")
    
    none_option = Option.None
    none_option ? | Option.Some(v) => io.println("  Value: ${v}")
                  | Option.None => io.println("  None option")
    
    // 3. raise() expression
    io.println("\n3. raise() Expression Tests:")
    
    val1 = Result.Ok(100).raise()
    io.println("  Direct raise: ${val1}")
    
    stored_result = Result.Ok(200)
    val2 = stored_result.raise()
    io.println("  Variable raise: ${val2}")
    
    // 4. Generic type inference in closures
    io.println("\n4. Closure Type Inference:")
    
    make_result = () { Result.Ok(555) }
    closure_result = make_result()
    closure_result ? | Result.Ok(v) => io.println("  Closure result: ${v}")
                     | Result.Err(e) => io.println("  Error: ${e}")
    
    make_option = () { Option.Some(666) }
    closure_option = make_option()
    io.println("  DEBUG: Got closure option")
    closure_option ? | Option.Some(v) => io.println("  Closure option: ${v}")
                     | Option.None => io.println("  None")
    
    // 5. Mixed generic operations
    io.println("\n5. Mixed Operations:")
    
    // Convert Option to Result
    opt1 = Option.Some(50)
    res1 = opt1 ? | Option.Some(v) => Result.Ok(v * 2)
                  | Option.None => Result.Err("no value")
    res1 ? | Result.Ok(v) => io.println("  Converted Some(50): ${v}")
           | Result.Err(e) => io.println("  Error: ${e}")
    
    opt2 = Option.None
    res2 = opt2 ? | Option.Some(v) => Result.Ok(v)
                  | Option.None => Result.Err("was none")
    res2 ? | Result.Ok(v) => io.println("  Value: ${v}")
           | Result.Err(e) => io.println("  Converted None: ${e}")
    
    io.println("\n=== All Generic Tests Passed ===")
}