// Complete test of LANGUAGE_SPEC.zen features
// This test validates all features from the specification

{ io, math } = @std

// ============================================================================
// CORE LANGUAGE FEATURES - No keywords!
// ============================================================================

main = () void {
    io.println("=== Testing Zen Language Spec Features ===")
    io.println("")
    
    // ------------------------------------------------------------------------
    // 1. Variables - All 6 forms from spec lines 298-306
    // ------------------------------------------------------------------------
    io.println("1. Variable Declarations:")
    
    // Forward declaration (immutable)
    x: i32
    x = 10
    io.println("  Forward decl: x = ${x}")
    
    // Immutable assignment
    y = 20
    io.println("  Immutable: y = ${y}")
    
    // Immutable with type
    z: i32 = 30
    io.println("  Immutable typed: z = ${z}")
    
    // Mutable forward declaration
    w:: i32
    w = 40
    io.println("  Mutable forward: w = ${w}")
    w = 45  // Can reassign
    io.println("  After reassign: w = ${w}")
    
    // Mutable assignment
    v ::= 50
    io.println("  Mutable assign: v = ${v}")
    v = 55
    io.println("  After reassign: v = ${v}")
    
    // Mutable with type
    u:: i32 = 60
    io.println("  Mutable typed: u = ${u}")
    u = 65
    io.println("  After reassign: u = ${u}")
    
    io.println("")
    
    // ------------------------------------------------------------------------
    // 2. Structs with nested fields and defaults
    // ------------------------------------------------------------------------
    io.println("2. Structs:")
    
    // Point struct with mutable fields
    Point: {
        x:: f64,
        y:: f64 = 0.0
    }
    
    p1 = Point { x: 3.5, y: 4.5 }
    io.println("  Point: (${p1.x}, ${p1.y})")
    
    // Using default value
    p2 = Point { x: 7.0 }
    io.println("  Point with default: (${p2.x}, ${p2.y})")
    
    // Nested structs
    Circle: {
        center: Point,
        radius: f64
    }
    
    c = Circle {
        center: Point { x: 10.0, y: 20.0 },
        radius: 5.0
    }
    io.println("  Circle center: (${c.center.x}, ${c.center.y}), radius: ${c.radius}")
    
    // Rectangle with nested Points
    Rectangle: {
        top_left: Point,
        bottom_right: Point
    }
    
    rect = Rectangle {
        top_left: Point { x: 0.0, y: 10.0 },
        bottom_right: Point { x: 20.0, y: 0.0 }
    }
    io.println("  Rectangle: top_left=(${rect.top_left.x}, ${rect.top_left.y})")
    io.println("            bottom_right=(${rect.bottom_right.x}, ${rect.bottom_right.y})")
    
    io.println("")
    
    // ------------------------------------------------------------------------
    // 3. Enums and Pattern Matching
    // ------------------------------------------------------------------------
    io.println("3. Enums and Pattern Matching:")
    
    // Option type - No null!
    Option<T>: Some(T) | None
    
    maybe_value: Option<i32> = Option<i32>.Some(42)
    maybe_value ?
        | Some(val) { io.println("  Option has value: ${val}") }
        | None { io.println("  Option is None") }
    
    empty: Option<i32> = Option<i32>.None
    empty ?
        | Some(val) { io.println("  Should not print: ${val}") }
        | None { io.println("  Option is None (correct!)") }
    
    // Result type for error handling
    Result<T, E>: Ok(T) | Err(E)
    
    success: Result<i32, string> = Result<i32, string>.Ok(100)
    success ?
        | Ok(val) { io.println("  Result success: ${val}") }
        | Err(e) { io.println("  Result error: ${e}") }
    
    failure: Result<i32, string> = Result<i32, string>.Err("Something went wrong")
    failure ?
        | Ok(val) { io.println("  Should not print: ${val}") }
        | Err(e) { io.println("  Result error: ${e}") }
    
    // Custom enum
    Shape: Circle | Rectangle
    
    shape1: Shape = Shape.Circle
    shape1 ?
        | Circle { io.println("  Shape is a Circle") }
        | Rectangle { io.println("  Shape is a Rectangle") }
    
    shape2: Shape = Shape.Rectangle
    shape2 ?
        | Circle { io.println("  Shape is a Circle") }
        | Rectangle { io.println("  Shape is a Rectangle") }
    
    io.println("")
    
    // ------------------------------------------------------------------------
    // 4. Boolean Pattern Matching (no if/else!)
    // ------------------------------------------------------------------------
    io.println("4. Boolean Pattern Matching:")
    
    is_ready = true
    is_ready ? {
        io.println("  Single branch: Ready to go!")
    }
    
    has_data = false
    has_data ?
        | true { io.println("  Should not print") }
        | false { io.println("  Full match: No data available") }
    
    io.println("")
    
    // ------------------------------------------------------------------------
    // 5. Traits with .implements()
    // ------------------------------------------------------------------------
    io.println("5. Traits:")
    
    // Define a trait
    Geometric: {
        area: (self) f64,
        perimeter: (self) f64
    }
    
    // Implement for Circle
    Circle.implements(Geometric, {
        area = (self) f64 {
            return math.pi * self.radius * self.radius
        },
        perimeter = (self) f64 {
            return 2.0 * math.pi * self.radius
        }
    })
    
    // Implement for Rectangle  
    Rectangle.implements(Geometric, {
        area = (self) f64 {
            width = self.bottom_right.x - self.top_left.x
            height = self.top_left.y - self.bottom_right.y
            return width * height
        },
        perimeter = (self) f64 {
            width = self.bottom_right.x - self.top_left.x
            height = self.top_left.y - self.bottom_right.y
            return 2.0 * (width + height)
        }
    })
    
    circle_area = c.area()
    io.println("  Circle area: ${circle_area}")
    
    rect_area = rect.area()
    io.println("  Rectangle area: ${rect_area}")
    
    io.println("")
    
    // ------------------------------------------------------------------------
    // 6. UFC (Uniform Function Call) and Overloading
    // ------------------------------------------------------------------------
    io.println("6. UFC and Function Overloading:")
    
    // Define enum with variants
    GameEntity: Player | Enemy | Powerup
    
    // Overload functions for each variant
    get_health = (e: GameEntity.Player) u32 { return 100 }
    get_health = (e: GameEntity.Enemy) u32 { return 50 }
    get_health = (e: GameEntity.Powerup) u32 { return 0 }
    
    player = GameEntity.Player
    enemy = GameEntity.Enemy
    powerup = GameEntity.Powerup
    
    io.println("  Player health: ${player.get_health()}")
    io.println("  Enemy health: ${enemy.get_health()}")
    io.println("  Powerup health: ${powerup.get_health()}")
    
    io.println("")
    
    // ------------------------------------------------------------------------
    // 7. Loops and Ranges (no for/while!)
    // ------------------------------------------------------------------------
    io.println("7. Loops and Ranges:")
    
    // Range loop
    io.print("  Range (0..5): ")
    (0..5).loop((i) {
        io.print("${i} ")
    })
    io.println("")
    
    // Infinite loop with break
    io.print("  Infinite with break: ")
    counter ::= 0
    loop(() {
        io.print("${counter} ")
        counter = counter + 1
        counter >= 5 ?
            | true { break }
            | false { }
    })
    io.println("")
    
    io.println("")
    
    // ------------------------------------------------------------------------
    // 8. Error Propagation with .raise()
    // ------------------------------------------------------------------------
    io.println("8. Error Propagation:")
    
    parse_number = (s: string) Result<i32, string> {
        // Simulate parsing
        s == "42" ?
            | true { return Result<i32, string>.Ok(42) }
            | false { return Result<i32, string>.Err("Invalid number") }
    }
    
    process_input = (input: string) Result<i32, string> {
        // This would use .raise() in full implementation
        num = parse_number(input)
        num ?
            | Ok(n) { return Result<i32, string>.Ok(n * 2) }
            | Err(e) { return Result<i32, string>.Err(e) }
    }
    
    result1 = process_input("42")
    result1 ?
        | Ok(val) { io.println("  Processed: ${val}") }
        | Err(e) { io.println("  Error: ${e}") }
    
    result2 = process_input("invalid")
    result2 ?
        | Ok(val) { io.println("  Processed: ${val}") }
        | Err(e) { io.println("  Error: ${e}") }
    
    io.println("")
    
    // ------------------------------------------------------------------------
    // 9. String Interpolation
    // ------------------------------------------------------------------------
    io.println("9. String Interpolation:")
    
    name = "Zen"
    version = 1
    io.println("  Welcome to ${name} v${version}!")
    
    // Complex interpolation
    opt: Option<string> = Option<string>.Some("present")
    io.println("  Option value: ${opt}")
    
    none_opt: Option<string> = Option<string>.None
    io.println("  None value: ${none_opt}")
    
    io.println("")
    
    // ------------------------------------------------------------------------
    // 10. @std imports and modules
    // ------------------------------------------------------------------------
    io.println("10. Standard Library:")
    io.println("  Math.pi = ${math.pi}")
    io.println("  Used io.println throughout!")
    
    io.println("")
    io.println("=== All tests complete! ===")
}