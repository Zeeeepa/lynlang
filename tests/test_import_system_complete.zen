// Comprehensive test for the new import system
// Verifies that imports work at module level without comptime

// Module-level imports (correct way)
core := @std.core
io := @std.io
fs := @std.fs
math := @std.math
string := @std.string
vec := @std.vec
result := @std.result
option := @std.option

// Test importing with build.import syntax
build := @std.build
json := build.import("json")
http := build.import("http")
net := build.import("net")

// Test basic import usage
test_basic_imports = () bool {
    io.print("Testing basic imports...\n")
    
    // Math operations
    abs_val := math.abs(-100)
    if abs_val != 100 {
        io.print("Math import failed\n")
        return false
    }
    
    // String operations
    str := string.new("Hello")
    str = string.append(str, " World")
    if string.len(str) != 11 {
        io.print("String import failed\n")
        return false
    }
    
    // Vector operations
    v := vec.new()
    v = vec.push(v, 1)
    v = vec.push(v, 2)
    if vec.len(v) != 2 {
        io.print("Vec import failed\n")
        return false
    }
    
    io.print("✓ Basic imports passed\n")
    return true
}

// Test that imports can be used in functions
process_data = (data: string) result.Result<i32, string> {
    // Use result type from import
    if string.is_empty(data) {
        return result.err("Empty data")
    }
    
    // Parse and process
    len := string.len(data)
    return result.ok(len)
}

// Test that imports work in struct methods
DataProcessor = {
    buffer: vec.Vec<u8>,
    
    new = () DataProcessor {
        return DataProcessor {
            buffer: vec.new()
        }
    },
    
    add_byte = (self: DataProcessor, byte: u8) DataProcessor {
        return DataProcessor {
            buffer: vec.push(self.buffer, byte)
        }
    },
    
    size = (self: DataProcessor) i32 {
        return vec.len(self.buffer)
    }
}

// Test comptime for meta-programming (not imports)
comptime {
    // This is correct - comptime for compile-time computation
    BUFFER_SIZE := 1024
    MAX_CONNECTIONS := 100
    
    // Generate constants
    generate_constants = () void {
        // Meta-programming logic here
    }
}

// Test that imports are available globally
test_global_availability = () bool {
    io.print("Testing global import availability...\n")
    
    // Create a processor using imported types
    processor := DataProcessor.new()
    processor = processor.add_byte(65)
    processor = processor.add_byte(66)
    
    if processor.size() != 2 {
        io.print("Global import usage failed\n")
        return false
    }
    
    io.print("✓ Global availability passed\n")
    return true
}

// Test error handling with imported types
test_error_handling = () bool {
    io.print("Testing error handling with imports...\n")
    
    // Test with valid data
    result1 := process_data("test data")
    match result1 {
        result.Ok(len) => {
            if len != 9 {
                io.print("Unexpected length\n")
                return false
            }
        },
        result.Err(_) => {
            io.print("Unexpected error\n")
            return false
        }
    }
    
    // Test with empty data
    result2 := process_data("")
    match result2 {
        result.Ok(_) => {
            io.print("Should have failed\n")
            return false
        },
        result.Err(msg) => {
            if msg != "Empty data" {
                io.print("Wrong error message\n")
                return false
            }
        }
    }
    
    io.print("✓ Error handling passed\n")
    return true
}

// Main test runner
main = () i32 {
    io.print("=== Comprehensive Import System Test ===\n\n")
    
    mut all_passed := true
    
    if !test_basic_imports() {
        all_passed = false
    }
    
    if !test_global_availability() {
        all_passed = false
    }
    
    if !test_error_handling() {
        all_passed = false
    }
    
    io.print("\n=== Test Summary ===\n")
    if all_passed {
        io.print("✓✓✓ All import system tests passed!\n")
        return 0
    } else {
        io.print("✗✗✗ Some tests failed\n")
        return 1
    }
}