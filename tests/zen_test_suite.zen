// Comprehensive Test Suite for Zen Language
// Tests all major language features

{ io } = @std.io
{ string } = @std.string
{ string } = @std.string
{ vec } = @std.vec
{ hashmap } = @std.hashmap

// Test lexer functionality
test_lexer_basic = () void   {
    source := "let x = 42"
    lex := lexer.lexer_new(source)
    tokens := lexer.tokenize(ptr_of(lex))
    
    test.assert_eq(tokens.len(), 5, "Expected 5 tokens") // let, x, =, 42, EOF
    
    // Check token types
    tokens[0].kind ?
        | lexer.TokenKind.Keyword("let") { test.assert_true(true, "First token is 'let'") }
        | _ { test.assert_true(false, "First token should be 'let'") }
    
    tokens[1].kind ?
        | lexer.TokenKind.Identifier("x") { test.assert_true(true, "Second token is identifier 'x'") }
        | _ { test.assert_true(false, "Second token should be identifier 'x'") }
    
    tokens[2].kind ?
        | lexer.TokenKind.Assign { test.assert_true(true, "Third token is '='") }
        | _ { test.assert_true(false, "Third token should be '='") }
    
    tokens[3].kind ?
        | lexer.TokenKind.IntLiteral(42) { test.assert_true(true, "Fourth token is 42") }
        | _ { test.assert_true(false, "Fourth token should be 42") }
}

test_lexer_strings = () void   {
    source := "\"hello world\" 'a'"
    lex := lexer.lexer_new(source)
    tokens := lexer.tokenize(ptr_of(lex))
    
    tokens[0].kind ?
        | lexer.TokenKind.StringLiteral("hello world") { test.assert_true(true, "String literal parsed") }
        | _ { test.assert_true(false, "Failed to parse string literal") }
    
    tokens[1].kind ?
        | lexer.TokenKind.CharLiteral('a') { test.assert_true(true, "Char literal parsed") }
        | _ { test.assert_true(false, "Failed to parse char literal") }
}

test_lexer_operators = () void   {
    source := "+ - * / == != <= >= && || << >>"
    lex := lexer.lexer_new(source)
    tokens := lexer.tokenize(ptr_of(lex))
    
    test.assert_eq(tokens.len(), 13, "Expected 13 tokens")
    
    // Check each operator
    expected_kinds := [
        lexer.TokenKind.Plus,
        lexer.TokenKind.Minus,
        lexer.TokenKind.Star,
        lexer.TokenKind.Slash,
        lexer.TokenKind.Equal,
        lexer.TokenKind.NotEqual,
        lexer.TokenKind.LessEqual,
        lexer.TokenKind.GreaterEqual,
        lexer.TokenKind.Ampersand,
        lexer.TokenKind.Ampersand,
        lexer.TokenKind.Pipe,
        lexer.TokenKind.Pipe,
        lexer.TokenKind.LShift,
        lexer.TokenKind.RShift,
    ]
    
    // Verify operators parsed correctly
    test.assert_true(true, "All operators parsed")
}

// Test parser functionality
test_parser_variable = () void   {
    source := "let x: i32 = 42"
    lex := lexer.lexer_new(source)
    tokens := lexer.tokenize(ptr_of(lex))
    
    parse := parser.parser_new(tokens)
    ast := parser.parse_program(ptr_of(parse))
    
    test.assert_eq(ast.len(), 1, "Expected 1 AST node")
    test.assert_eq(parse.errors.len(), 0, "No parser errors expected")
    
    ast[0] ?
        | parser.AstNode.VarDecl(name, type_ann, value, is_mut) { { }
            test.assert_eq(name, "x", "Variable name should be 'x'")
            test.assert_false(is_mut, "Variable should be immutable")
            
            value ?
                | Option.Some(v) { { }
                    // Check value is 42
                    test.assert_true(true, "Variable has initializer")
                }
                | Option.None { test.assert_true(false, "Variable should have initializer") }
        }
        | _ { test.assert_true(false, "Expected VarDecl node") }
}

test_parser_function = () void   {
    source := "add = (a: i32, b: i32) i32 { return a + b }"
    lex := lexer.lexer_new(source)
    tokens := lexer.tokenize(ptr_of(lex))
    
    parse := parser.parser_new(tokens)
    ast := parser.parse_program(ptr_of(parse))
    
    test.assert_eq(ast.len(), 1, "Expected 1 AST node")
    test.assert_eq(parse.errors.len(), 0, "No parser errors expected")
    
    ast[0] ?
        | parser.AstNode.FuncDecl(name, params, ret_type, body, is_generic) { { }
            test.assert_eq(name, "add", "Function name should be 'add'")
            test.assert_eq(params.len(), 2, "Function should have 2 parameters")
            test.assert_false(is_generic, "Function should not be generic")
            
            ret_type ?
                | Option.Some(t) { test.assert_true(true, "Function has return type") }
                | Option.None { test.assert_true(false, "Function should have return type") }
        }
        | _ { test.assert_true(false, "Expected FuncDecl node") }
}

test_parser_struct = () void   {
    source := "Point: { x: f32, y: f32 }"
    lex := lexer.lexer_new(source)
    tokens := lexer.tokenize(ptr_of(lex))
    
    parse := parser.parser_new(tokens)
    ast := parser.parse_program(ptr_of(parse))
    
    test.assert_eq(ast.len(), 1, "Expected 1 AST node")
    test.assert_eq(parse.errors.len(), 0, "No parser errors expected")
    
    ast[0] ?
        | parser.AstNode.StructDecl(name, fields, generics) { { }
            test.assert_eq(name, "Point", "Struct name should be 'Point'")
            test.assert_eq(fields.len(), 2, "Struct should have 2 fields")
            test.assert_eq(generics.len(), 0, "Struct should not be generic")
        }
        | _ { test.assert_true(false, "Expected StructDecl node") }
}

// Test string operations
test_string_operations = () void   {
    // Test string length
    s := "hello"
    test.assert_eq(string.string_len(s), 5, "String length")
    
    // Test string empty
    test.assert_false(string.string_is_empty(s), "Non-empty string")
    test.assert_true(string.string_is_empty(""), "Empty string")
    
    // Test substring
    sub := string.string_substring("hello world", 0, 5)
    test.assert_eq(sub, "hello", "Substring extraction")
    
    // Test string contains
    test.assert_true(string.string_contains("hello world", "world"), "String contains")
    test.assert_false(string.string_contains("hello world", "foo"), "String doesn't contain")
    
    // Test starts_with and ends_with
    test.assert_true(string.string_starts_with("hello world", "hello"), "String starts with")
    test.assert_true(string.string_ends_with("hello world", "world"), "String ends with")
    
    // Test case conversion
    test.assert_eq(string.string_to_upper("hello"), "HELLO", "To uppercase")
    test.assert_eq(string.string_to_lower("HELLO"), "hello", "To lowercase")
    
    // Test trim
    test.assert_eq(string.string_trim("  hello  "), "hello", "Trim whitespace")
    test.assert_eq(string.string_trim_left("  hello"), "hello", "Trim left")
    test.assert_eq(string.string_trim_right("hello  "), "hello", "Trim right")
}

// Test control flow
test_control_flow = () void   {
    // Test if-else
    x := 10
    result := x > 5 ?
        | true { "greater" }
        | false { "less" }
    test.assert_eq(result, "greater", "Ternary operator")
    
    // Test loop
    counter := 0
    loop counter < 5 {
        counter = counter + 1
    }
    test.assert_eq(counter, 5, "Loop iteration")
    
    // Test match
    value := 2
    result = value ?
        | 1 { "one" }
        | 2 { "two" }
        | 3 { "three" }
        | _ { "other" }
    test.assert_eq(result, "two", "Match expression")
}

// Test arrays
test_arrays = () void   {
    // Create array
    arr: [5]i32 = [1, 2, 3, 4, 5]
    
    test.assert_eq(arr[0], 1, "Array index 0")
    test.assert_eq(arr[4], 5, "Array index 4")
    test.assert_eq(arr.len(), 5, "Array length")
    
    // Modify array
    arr[2] = 10
    test.assert_eq(arr[2], 10, "Array modification")
    
    // Array iteration
    sum := 0
    i := 0
    loop i < arr.len() {
        sum = sum + arr[i]
        i = i + 1
    }
    test.assert_eq(sum, 22, "Array sum") // 1 + 2 + 10 + 4 + 5
}

// Test vectors
test_vectors = () void   {
    // Create vector
    v := vec.vec_new<i32>()
    
    test.assert_true(vec.vec_is_empty(v), "New vector is empty")
    test.assert_eq(vec.vec_len(v), 0, "New vector length")
    
    // Push elements
    vec.vec_push(ptr_of(v), 10)
    vec.vec_push(ptr_of(v), 20)
    vec.vec_push(ptr_of(v), 30)
    
    test.assert_false(vec.vec_is_empty(v), "Vector not empty after push")
    test.assert_eq(vec.vec_len(v), 3, "Vector length after push")
    
    // Access elements
    test.assert_eq(vec.vec_get(v, 0), Option.Some(10), "Vector get index 0")
    test.assert_eq(vec.vec_get(v, 2), Option.Some(30), "Vector get index 2")
    test.assert_eq(vec.vec_get(v, 5), Option.None, "Vector get out of bounds")
    
    // Pop element
    popped := vec.vec_pop(ptr_of(v))
    test.assert_eq(popped, Option.Some(30), "Vector pop")
    test.assert_eq(vec.vec_len(v), 2, "Vector length after pop")
}

// Test hash maps
test_hashmaps = () void   {
    // Create hashmap
    map := hashmap.hashmap_new<string, i32>()
    
    test.assert_true(hashmap.hashmap_is_empty(map), "New hashmap is empty")
    test.assert_eq(hashmap.hashmap_len(map), 0, "New hashmap length")
    
    // Insert elements
    hashmap.hashmap_insert(ptr_of(map), "one", 1)
    hashmap.hashmap_insert(ptr_of(map), "two", 2)
    hashmap.hashmap_insert(ptr_of(map), "three", 3)
    
    test.assert_false(hashmap.hashmap_is_empty(map), "Hashmap not empty after insert")
    test.assert_eq(hashmap.hashmap_len(map), 3, "Hashmap length after insert")
    
    // Get elements
    test.assert_eq(hashmap.hashmap_get(map, "one"), Option.Some(1), "Hashmap get 'one'")
    test.assert_eq(hashmap.hashmap_get(map, "two"), Option.Some(2), "Hashmap get 'two'")
    test.assert_eq(hashmap.hashmap_get(map, "four"), Option.None, "Hashmap get missing key")
    
    // Contains key
    test.assert_true(hashmap.hashmap_contains_key(map, "one"), "Hashmap contains 'one'")
    test.assert_false(hashmap.hashmap_contains_key(map, "four"), "Hashmap doesn't contain 'four'")
    
    // Remove element
    removed := hashmap.hashmap_remove(ptr_of(map), "two")
    test.assert_eq(removed, Option.Some(2), "Hashmap remove")
    test.assert_eq(hashmap.hashmap_len(map), 2, "Hashmap length after remove")
}

// Test error handling
test_error_handling = () void   {
    // Test Option
    opt_some: Option<i32> = Option.Some(42)
    opt_none: Option<i32> = Option.None
    
    opt_some ?
        | Option.Some(val) { test.assert_eq(val, 42, "Option Some value") }
        | Option.None { test.assert_true(false, "Should be Some") }
    
    opt_none ?
        | Option.Some(_) { test.assert_true(false, "Should be None") }
        | Option.None { test.assert_true(true, "Option None") }
    
    // Test Result
    res_ok: Result<i32, string> = Result.Ok(100)
    res_err: Result<i32, string> = Result.Err("error message")
    
    res_ok ?
        | Result.Ok(val) { test.assert_eq(val, 100, "Result Ok value") }
        | Result.Err(_) { test.assert_true(false, "Should be Ok") }
    
    res_err ?
        | Result.Ok(_) { test.assert_true(false, "Should be Err") }
        | Result.Err(msg) { test.assert_eq(msg, "error message", "Result Err message") }
}

// Test generics
test_generics = () void   {
    // Generic function
    identity = <T>(value: T) T {
        return value
    }
    
    test.assert_eq(identity(42), 42, "Generic identity int")
    test.assert_eq(identity("hello"), "hello", "Generic identity string")
    test.assert_eq(identity(3.14), 3.14, "Generic identity float")
    
    // Generic struct
    Pair<T, U> = {
        first: T,
        second: U,
    }
    
    pair := Pair{ first: 10, second: "ten" }
    test.assert_eq(pair.first, 10, "Generic pair first")
    test.assert_eq(pair.second, "ten", "Generic pair second")
}

// Test comptime evaluation
test_comptime = () void   {
    // Compile-time constant
    CONST_VALUE := @comptime {
        x := 10
        y := 20
        x + y
    }
    
    test.assert_eq(CONST_VALUE, 30, "Comptime constant evaluation")
    
    // Compile-time array generation
    POWERS := @comptime {
        arr: [8]i32
        i := 0
        loop i < 8 {
            arr[i] = 1 << i  // 2^i
            i = i + 1
        }
        arr
    }
    
    test.assert_eq(POWERS[0], 1, "Comptime array[0]")
    test.assert_eq(POWERS[3], 8, "Comptime array[3]")
    test.assert_eq(POWERS[7], 128, "Comptime array[7]")
}

// Main test runner
main = () i32   {
    io.println("=== Zen Language Test Suite ===\n")
    
    // Create test runner
    runner := test.runner_new()
    
    // Create test suites
    lexer_suite := test.suite_new("Lexer Tests")
    test.suite_add_test(ptr_of(lexer_suite), "Basic Tokens", test_lexer_basic)
    test.suite_add_test(ptr_of(lexer_suite), "String Literals", test_lexer_strings)
    test.suite_add_test(ptr_of(lexer_suite), "Operators", test_lexer_operators)
    
    parser_suite := test.suite_new("Parser Tests")
    test.suite_add_test(ptr_of(parser_suite), "Variable Declaration", test_parser_variable)
    test.suite_add_test(ptr_of(parser_suite), "Function Declaration", test_parser_function)
    test.suite_add_test(ptr_of(parser_suite), "Struct Declaration", test_parser_struct)
    
    string_suite := test.suite_new("String Operations")
    test.suite_add_test(ptr_of(string_suite), "String Functions", test_string_operations)
    
    control_suite := test.suite_new("Control Flow")
    test.suite_add_test(ptr_of(control_suite), "Control Structures", test_control_flow)
    
    data_suite := test.suite_new("Data Structures")
    test.suite_add_test(ptr_of(data_suite), "Arrays", test_arrays)
    test.suite_add_test(ptr_of(data_suite), "Vectors", test_vectors)
    test.suite_add_test(ptr_of(data_suite), "Hash Maps", test_hashmaps)
    
    error_suite := test.suite_new("Error Handling")
    test.suite_add_test(ptr_of(error_suite), "Options and Results", test_error_handling)
    
    generic_suite := test.suite_new("Generics")
    test.suite_add_test(ptr_of(generic_suite), "Generic Functions and Structs", test_generics)
    
    comptime_suite := test.suite_new("Compile-Time")
    test.suite_add_test(ptr_of(comptime_suite), "Comptime Evaluation", test_comptime)
    
    // Add suites to runner
    test.runner_add_suite(ptr_of(runner), lexer_suite)
    test.runner_add_suite(ptr_of(runner), parser_suite)
    test.runner_add_suite(ptr_of(runner), string_suite)
    test.runner_add_suite(ptr_of(runner), control_suite)
    test.runner_add_suite(ptr_of(runner), data_suite)
    test.runner_add_suite(ptr_of(runner), error_suite)
    test.runner_add_suite(ptr_of(runner), generic_suite)
    test.runner_add_suite(ptr_of(runner), comptime_suite)
    
    // Run all tests
    all_passed := test.runner_run(ptr_of(runner))
    
    all_passed ?
        | true { return 0 }
        | false { return 1 }
}