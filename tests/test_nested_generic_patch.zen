// Test potential workaround for nested generic issue
{ io, Result , get_default_allocator} = @std

// Helper to create a heap-allocated value
make_value = (v: i32) i32 { v }

// Test if explicit function calls help
test_with_helper = () Result<Result<Result<i32, string>, string>, string> {
    val = make_value(999)
    inner = Result.Ok(val)
    middle = Result.Ok(inner)
    outer = Result.Ok(middle)
    outer
}

main = () void {
    alloc = get_default_allocator()
    io.println("Testing nested generic workarounds")
    
    // Test with helper function
    r1 = test_with_helper()
    r1 ?
        | Result.Ok(l2) {
            l2 ?
                | Result.Ok(l3) {
                    l3 ?
                        | Result.Ok(v) {
                            io.println("With helper: ${v}")
                            v == 999 ?
                                | true { io.println("✓ Helper works!") }
                                | false { io.println("✗ Got ${v}") }
                        }
                        | Result.Err(e) { io.println("L3 err") }
                }
                | Result.Err(e) { io.println("L2 err") }
        }
        | Result.Err(e) { io.println("L1 err") }
    
    // Try with explicit typing
    io.println("\nWith explicit intermediate values:")
    v2 = 888
    inner2 = Result.Ok(v2)
    middle2 = Result.Ok(inner2)
    outer2 = Result.Ok(middle2)
    
    outer2 ?
        | Result.Ok(l2) {
            l2 ?
                | Result.Ok(l3) {
                    l3 ?
                        | Result.Ok(v) {
                            io.println("Explicit: ${v}")
                            v == 888 ?
                                | true { io.println("✓ Explicit works!") }
                                | false { io.println("✗ Got ${v}") }
                        }
                        | Result.Err(e) { io.println("L3 err") }
                }
                | Result.Err(e) { io.println("L2 err") }
        }
        | Result.Err(e) { io.println("L1 err") }
}