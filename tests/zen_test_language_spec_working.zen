// Test of currently working features from LANGUAGE_SPEC.zen
{ io, math } = @std

// Option and Result types
Option<T>: Some(T) | None
Result<T, E>: Ok(T) | Err(E)

main = () void {
    io.println("=== Zen Language Working Features ===")
    
    // 1. Variable declarations (SPEC lines 298-306)
    a: i32
    a = 10
    b = 20
    c ::= 30
    io.println("Variables: a=${a}, b=${b}, c=${c}")
    
    // 2. Math.pi constant (SPEC line 138)
    io.println("math.pi = ${math.pi}")
    circle_area = math.pi * 5.0 * 5.0
    io.println("Circle area (r=5): ${circle_area}")
    
    // 3. Boolean pattern matching (SPEC lines 352-361)
    is_ready = true
    is_ready ? {
        io.println("System ready!")
    }
    
    has_data = false
    has_data ?
        | true { io.println("Has data") }
        | false { io.println("No data") }
    
    // 4. Option type (SPEC lines 462-473)
    maybe: Option<i32> = Some(42)
    maybe ?
        | Some(v) { io.println("Value: ${v}") }
        | None { io.println("No value") }
    
    // 5. Result type
    result: Result<i32, String> = Ok(100)
    result ?
        | Ok(v) { io.println("Success: ${v}") }
        | Err(e) { io.println("Error: ${e}") }
    
    // 6. Range loops (SPEC lines 432-434)
    io.println("Range 0..3:")
    (0..3).loop((i) {
        io.println("  ${i}")
    })
    
    // 7. Infinite loop with break (SPEC lines 453-459)
    counter ::= 0
    loop(() {
        counter = counter + 1
        counter > 2 ?
            | true { break }
            | false { io.println("Loop: ${counter}") }
    })
    
    // 8. String interpolation
    x = 42
    y = 3.14
    z = true
    io.println("Interpolation: x=${x}, y=${y}, z=${z}")
    
    io.println("=== All tests passed! ===")
}
