// Basic test of LANGUAGE_SPEC.zen features that should work
// This file tests only confirmed working features

{ io, math } = @std

// Option type - No null!
Option<T>: Some(T) | None

// Result type for error handling  
Result<T, E>: Ok(T) | Err(E)

// Simple struct
Point: {
    x:: f64, // mutable field
    y:: f64 = 0 // with default
}

// Trait definition
Geometric: {
    area: (self) f64,
    perimeter: (self) f64,
}

Circle: {
    center: Point,
    radius: f64,
}

// Implement trait for Circle
Circle.implements(Geometric, {
    area = (self) f64 {
        return math.pi * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * math.pi * self.radius
    },
})

Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

Rectangle.implements(Geometric, {
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return width * height
    },
    perimeter = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return 2.0 * (width + height)
    },
})

main = () void {
    io.println("Testing LANGUAGE_SPEC.zen features:")
    io.println("=====================================")
    
    // Test all variable forms from spec (lines 298-306)
    x: i32
    x = 10
    y = 10
    z : i32 = 20
    w :: i32
    w = 20  
    v ::= 30
    u :: i32 = 40
    
    io.println("Variables: x=${x}, y=${y}, z=${z}, w=${w}, v=${v}, u=${u}")
    
    // Test boolean pattern (lines 352-361)
    is_ready = true
    is_ready ? { 
        io.println("Boolean pattern: Ready!") 
    }
    
    has_data = false
    has_data ?
        | true { io.println("Has data") }
        | false { io.println("No data") }
    
    // Test struct with trait
    circle = Circle { 
        center: Point { x: 0, y: 0 }, 
        radius: 5 
    }
    io.println("Circle area: ${circle.area()}")
    io.println("Circle perimeter: ${circle.perimeter()}")
    
    rect = Rectangle {
        top_left: Point { x: 0, y: 0 },
        bottom_right: Point { x: 10, y: 10 }
    }
    io.println("Rectangle area: ${rect.area()}")
    io.println("Rectangle perimeter: ${rect.perimeter()}")
    
    // Test Option (lines 462-473)
    maybe: Option<f64> = Some(5.5)
    maybe ?
        | Some(r) {
            io.println("Option Some: ${r}")
        }
        | None {
            io.println("Option None")
        }
    
    none_val: Option<f64> = None
    none_val ?
        | Some(v) { io.println("Should not print") }
        | None { io.println("Got None") }
    
    // Test Result
    ok_result: Result<i32, string> = Ok(42)
    ok_result ?
        | Ok(val) { io.println("Result Ok: ${val}") }
        | Err(e) { io.println("Result Err: ${e}") }
    
    err_result: Result<i32, string> = Err("Error message")
    err_result ?
        | Ok(val) { io.println("Should not print") }
        | Err(e) { io.println("Result Err: ${e}") }
    
    // Test range loop (lines 431-434)
    io.println("Range loop (0..5):")
    (0..5).loop((i) {
        io.println("  i=${i}")
    })
    
    // Test infinite loop with break (lines 453-459)
    counter ::= 0
    io.println("Loop with break:")
    loop(() {
        counter = counter + 1
        io.println("  count=${counter}")
        counter >= 3 ?
            | true { break }
            | false { }
    })
    
    // Test mutable fields
    point ::= Point { x: 1.0, y: 2.0 }
    io.println("Point before: x=${point.x}, y=${point.y}")
    point.x = 5.0
    point.y = 10.0
    io.println("Point after: x=${point.x}, y=${point.y}")
    
    io.println("=====================================")
    io.println("All tests completed successfully!")
}