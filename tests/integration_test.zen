// Comprehensive Integration Tests for Zen Language
// Tests all major language features and stdlib modules

core := @std.core
io := @std.io
string := @std.string
math := @std.math
collections := @std.collections
fs := @std.fs

// Test result tracking
TestResult = struct {
    name: string
    passed: bool
    message: string
}

// Test suite
TestSuite = struct {
    name: string
    tests: Vec<TestResult>
    passed: u32
    failed: u32
}

// Create new test suite
suite_new = (name: string) TestSuite {
    return TestSuite {
        name: name
        tests: collections.vec_new<TestResult>()
        passed: 0
        failed: 0
    }
}

// Add test result
suite_add = (suite: *TestSuite, name: string, passed: bool, message: string) void {
    result := TestResult {
        name: name
        passed: passed
        message: message
    }
    
    collections.vec_push(&suite.tests, result)
    
    if passed {
        suite.passed = suite.passed + 1
    } else {
        suite.failed = suite.failed + 1
    }
}

// Assert helper
assert = (suite: *TestSuite, name: string, condition: bool, message: string) void {
    suite_add(suite, name, condition, message)
}

// Assert equal helper
assert_eq = <T>(suite: *TestSuite, name: string, expected: T, actual: T) void {
    passed := expected == actual
    message := passed ? "OK" : string.format("Expected {}, got {}", expected, actual)
    suite_add(suite, name, passed, message)
}

// Print test results
print_results = (suite: TestSuite) void {
    io.print("\n")
    io.print("=" * 60)
    io.print("\n")
    io.print(string.format("Test Suite: {}\n", suite.name))
    io.print("=" * 60)
    io.print("\n\n")
    
    for test in suite.tests {
        status := test.passed ? "✓ PASS" : "✗ FAIL"
        color := test.passed ? "\x1b[32m" : "\x1b[31m"
        reset := "\x1b[0m"
        
        io.print(string.format("{}{}{}: {} - {}\n", 
            color, status, reset, test.name, test.message))
    }
    
    io.print("\n")
    io.print("-" * 60)
    io.print("\n")
    io.print(string.format("Results: {} passed, {} failed\n", 
        suite.passed, suite.failed))
    
    if suite.failed == 0 {
        io.print("\x1b[32m✓ All tests passed!\x1b[0m\n")
    } else {
        io.print("\x1b[31m✗ Some tests failed\x1b[0m\n")
    }
}

// Test basic language features
test_basics = () TestSuite {
    suite := suite_new("Basic Language Features")
    
    // Variables and bindings
    x := 42
    assert_eq(&suite, "Immutable binding", 42, x)
    
    y ::= 10
    y = 20
    assert_eq(&suite, "Mutable binding", 20, y)
    
    // Arithmetic
    assert_eq(&suite, "Addition", 15, 10 + 5)
    assert_eq(&suite, "Subtraction", 5, 10 - 5)
    assert_eq(&suite, "Multiplication", 50, 10 * 5)
    assert_eq(&suite, "Division", 2, 10 / 5)
    assert_eq(&suite, "Modulo", 1, 10 % 3)
    
    // Comparisons
    assert(&suite, "Less than", 5 < 10, "5 < 10")
    assert(&suite, "Greater than", 10 > 5, "10 > 5")
    assert(&suite, "Equal", 10 == 10, "10 == 10")
    assert(&suite, "Not equal", 10 != 5, "10 != 5")
    
    // Logical operations
    assert(&suite, "AND true", true && true, "true && true")
    assert(&suite, "AND false", !(true && false), "!(true && false)")
    assert(&suite, "OR true", true || false, "true || false")
    assert(&suite, "OR false", !(false || false), "!(false || false)")
    
    return suite
}

// Test control flow
test_control_flow = () TestSuite {
    suite := suite_new("Control Flow")
    
    // If expressions
    result := if 10 > 5 { 1 } else { 2 }
    assert_eq(&suite, "If expression true", 1, result)
    
    result = if 5 > 10 { 1 } else { 2 }
    assert_eq(&suite, "If expression false", 2, result)
    
    // Match expressions
    value := 2
    result = match value {
        1 => 10
        2 => 20
        3 => 30
        _ => 0
    }
    assert_eq(&suite, "Match expression", 20, result)
    
    // Loops
    sum := 0
    i := 0
    loop i < 5 {
        sum = sum + i
        i = i + 1
    }
    assert_eq(&suite, "Loop sum", 10, sum)
    
    // For loops
    sum = 0
    for n in [1, 2, 3, 4, 5] {
        sum = sum + n
    }
    assert_eq(&suite, "For loop sum", 15, sum)
    
    return suite
}

// Test functions
test_functions = () TestSuite {
    suite := suite_new("Functions")
    
    // Simple function
    add = (a: i32, b: i32) i32 {
        return a + b
    }
    assert_eq(&suite, "Function call", 15, add(10, 5))
    
    // Recursive function
    factorial = (n: i32) i32 {
        if n <= 1 {
            return 1
        }
        return n * factorial(n - 1)
    }
    assert_eq(&suite, "Recursive factorial", 120, factorial(5))
    
    // Higher-order function
    apply = (f: fn(i32) i32, x: i32) i32 {
        return f(x)
    }
    double = (x: i32) i32 { return x * 2 }
    assert_eq(&suite, "Higher-order function", 20, apply(double, 10))
    
    // Closures
    make_adder = (x: i32) fn(i32) i32 {
        return (y: i32) i32 { return x + y }
    }
    add5 := make_adder(5)
    assert_eq(&suite, "Closure", 15, add5(10))
    
    return suite
}

// Test arrays and slices
test_arrays = () TestSuite {
    suite := suite_new("Arrays and Slices")
    
    // Fixed arrays
    arr := [1, 2, 3, 4, 5]
    assert_eq(&suite, "Array length", 5, arr.len())
    assert_eq(&suite, "Array index", 3, arr[2])
    
    // Array iteration
    sum := 0
    for x in arr {
        sum = sum + x
    }
    assert_eq(&suite, "Array sum", 15, sum)
    
    // Slices
    slice := arr[1..4]
    assert_eq(&suite, "Slice length", 3, slice.len())
    assert_eq(&suite, "Slice first", 2, slice[0])
    assert_eq(&suite, "Slice last", 4, slice[2])
    
    return suite
}

// Test strings
test_strings = () TestSuite {
    suite := suite_new("String Operations")
    
    // String basics
    s := "Hello, World!"
    assert_eq(&suite, "String length", 13, string.len(s))
    
    // String concatenation
    s1 := "Hello"
    s2 := "World"
    s3 := string.concat(s1, ", ")
    s3 = string.concat(s3, s2)
    s3 = string.concat(s3, "!")
    assert_eq(&suite, "String concat", "Hello, World!", s3)
    
    // String comparison
    assert(&suite, "String equal", "abc" == "abc", "String equality")
    assert(&suite, "String not equal", "abc" != "xyz", "String inequality")
    
    // Substring
    sub := string.substring(s, 7, 12)
    assert_eq(&suite, "Substring", "World", sub)
    
    // String search
    idx := string.index_of(s, "World")
    assert_eq(&suite, "Index of", 7, idx)
    
    assert(&suite, "Contains", string.contains(s, "World"), "Contains World")
    assert(&suite, "Starts with", string.starts_with(s, "Hello"), "Starts with Hello")
    assert(&suite, "Ends with", string.ends_with(s, "!"), "Ends with !")
    
    // String manipulation
    upper := string.to_upper("hello")
    assert_eq(&suite, "To upper", "HELLO", upper)
    
    lower := string.to_lower("HELLO")
    assert_eq(&suite, "To lower", "hello", lower)
    
    trimmed := string.trim("  hello  ")
    assert_eq(&suite, "Trim", "hello", trimmed)
    
    // String split
    parts := string.split("a,b,c", ",")
    assert_eq(&suite, "Split length", 3, parts.len())
    assert_eq(&suite, "Split first", "a", parts[0])
    assert_eq(&suite, "Split last", "c", parts[2])
    
    return suite
}

// Test math module
test_math = () TestSuite {
    suite := suite_new("Math Module")
    
    // Basic math
    assert_eq(&suite, "Abs positive", 10, math.abs(10))
    assert_eq(&suite, "Abs negative", 10, math.abs(-10))
    
    assert_eq(&suite, "Min", 5, math.min(5, 10))
    assert_eq(&suite, "Max", 10, math.max(5, 10))
    
    assert_eq(&suite, "Clamp low", 5, math.clamp(3, 5, 10))
    assert_eq(&suite, "Clamp mid", 7, math.clamp(7, 5, 10))
    assert_eq(&suite, "Clamp high", 10, math.clamp(15, 5, 10))
    
    // Power and factorial
    assert_eq(&suite, "Power", 125, math.pow(5, 3))
    assert_eq(&suite, "Factorial", 120, math.factorial(5))
    
    // Number theory
    assert_eq(&suite, "GCD", 6, math.gcd(18, 24))
    assert_eq(&suite, "LCM", 72, math.lcm(18, 24))
    
    assert(&suite, "Is prime 7", math.is_prime(7), "7 is prime")
    assert(&suite, "Is prime 8", !math.is_prime(8), "8 is not prime")
    
    // Rounding
    assert_eq(&suite, "Floor", 3, math.floor(3.7))
    assert_eq(&suite, "Ceil", 4, math.ceil(3.2))
    assert_eq(&suite, "Round", 4, math.round(3.6))
    assert_eq(&suite, "Trunc", 3, math.trunc(3.9))
    
    // Approximations
    pi_approx := math.abs_f64(math.PI - 3.14159)
    assert(&suite, "PI constant", pi_approx < 0.001, "PI approximation")
    
    sqrt_approx := math.abs_f64(math.sqrt(9.0) - 3.0)
    assert(&suite, "Square root", sqrt_approx < 0.001, "sqrt(9) ≈ 3")
    
    return suite
}

// Test collections module
test_collections = () TestSuite {
    suite := suite_new("Collections Module")
    
    // Vector operations
    vec := collections.vec_new<i32>()
    
    collections.vec_push(&vec, 10)
    collections.vec_push(&vec, 20)
    collections.vec_push(&vec, 30)
    
    assert_eq(&suite, "Vec length", 3, vec.len)
    assert_eq(&suite, "Vec get", some(20), collections.vec_get(vec, 1))
    
    popped := collections.vec_pop(&vec)
    assert_eq(&suite, "Vec pop", some(30), popped)
    assert_eq(&suite, "Vec length after pop", 2, vec.len)
    
    // Stack operations
    stack := collections.stack_new<i32>()
    
    collections.stack_push(&stack, 1)
    collections.stack_push(&stack, 2)
    collections.stack_push(&stack, 3)
    
    assert_eq(&suite, "Stack size", 3, collections.stack_size(stack))
    assert_eq(&suite, "Stack peek", some(3), collections.stack_peek(stack))
    
    stack_val := collections.stack_pop(&stack)
    assert_eq(&suite, "Stack pop", some(3), stack_val)
    assert_eq(&suite, "Stack size after pop", 2, collections.stack_size(stack))
    
    // Queue operations
    queue := collections.queue_new<i32>()
    
    collections.queue_push(&queue, 1)
    collections.queue_push(&queue, 2)
    collections.queue_push(&queue, 3)
    
    assert_eq(&suite, "Queue size", 3, collections.queue_size(queue))
    
    queue_val := collections.queue_pop(&queue)
    assert_eq(&suite, "Queue pop FIFO", some(1), queue_val)
    assert_eq(&suite, "Queue size after pop", 2, collections.queue_size(queue))
    
    // Clean up
    collections.vec_free(&vec)
    collections.stack_free(&stack)
    collections.queue_free(&queue)
    
    return suite
}

// Test structs and enums
test_structs_enums = () TestSuite {
    suite := suite_new("Structs and Enums")
    
    // Struct definition and usage
    Point = struct {
        x: i32
        y: i32
    }
    
    p := Point { x: 10, y: 20 }
    assert_eq(&suite, "Struct field x", 10, p.x)
    assert_eq(&suite, "Struct field y", 20, p.y)
    
    // Struct methods
    distance = (p: Point) f64 {
        return math.sqrt((p.x * p.x + p.y * p.y) as f64)
    }
    
    d := distance(Point { x: 3, y: 4 })
    assert(&suite, "Struct method", math.approx_equal(d, 5.0, 0.001), "distance(3,4) ≈ 5")
    
    // Enum definition and usage
    Color = enum {
        Red
        Green
        Blue
        RGB(r: u8, g: u8, b: u8)
    }
    
    c := Color.Red
    is_red := match c {
        Color.Red => true
        _ => false
    }
    assert(&suite, "Enum match", is_red, "Color is Red")
    
    rgb := Color.RGB(255, 128, 0)
    is_rgb := match rgb {
        Color.RGB(_, _, _) => true
        _ => false
    }
    assert(&suite, "Enum with data", is_rgb, "Color is RGB")
    
    return suite
}

// Test error handling
test_error_handling = () TestSuite {
    suite := suite_new("Error Handling")
    
    // Option type
    divide = (a: i32, b: i32) Option<i32> {
        if b == 0 {
            return none
        }
        return some(a / b)
    }
    
    result := divide(10, 2)
    assert_eq(&suite, "Option Some", some(5), result)
    
    result = divide(10, 0)
    is_none := match result {
        none => true
        some(_) => false
    }
    assert(&suite, "Option None", is_none, "Division by zero returns None")
    
    // Result type
    parse_int = (s: string) Result<i32> {
        // Simplified - would actually parse
        if s == "42" {
            return Result.Ok(42)
        }
        return Result.Err("Invalid integer")
    }
    
    parse_result := parse_int("42")
    is_ok := match parse_result {
        Result.Ok(_) => true
        Result.Err(_) => false
    }
    assert(&suite, "Result Ok", is_ok, "Parse success")
    
    parse_result = parse_int("abc")
    is_err := match parse_result {
        Result.Ok(_) => false
        Result.Err(_) => true
    }
    assert(&suite, "Result Err", is_err, "Parse failure")
    
    return suite
}

// Test generics
test_generics = () TestSuite {
    suite := suite_new("Generic Programming")
    
    // Generic function
    swap = <T>(a: *T, b: *T) void {
        temp := *a
        *a = *b
        *b = temp
    }
    
    x ::= 10
    y ::= 20
    swap(&x, &y)
    assert_eq(&suite, "Generic swap x", 20, x)
    assert_eq(&suite, "Generic swap y", 10, y)
    
    // Generic struct
    Pair<T, U> = struct {
        first: T
        second: U
    }
    
    pair := Pair<i32, string> {
        first: 42
        second: "answer"
    }
    assert_eq(&suite, "Generic struct first", 42, pair.first)
    assert_eq(&suite, "Generic struct second", "answer", pair.second)
    
    // Generic with constraints
    max_generic = <T: Ord>(a: T, b: T) T {
        return if a > b { a } else { b }
    }
    
    assert_eq(&suite, "Generic max i32", 20, max_generic(10, 20))
    assert_eq(&suite, "Generic max f64", 3.14, max_generic(2.71, 3.14))
    
    return suite
}

// Main test runner
main = () i32 {
    io.print("\n")
    io.print("╔════════════════════════════════════════════════════════╗\n")
    io.print("║         Zen Language Integration Test Suite           ║\n")
    io.print("╚════════════════════════════════════════════════════════╝\n")
    
    // Run all test suites
    suites := [
        test_basics(),
        test_control_flow(),
        test_functions(),
        test_arrays(),
        test_strings(),
        test_math(),
        test_collections(),
        test_structs_enums(),
        test_error_handling(),
        test_generics()
    ]
    
    total_passed := 0
    total_failed := 0
    
    for suite in suites {
        print_results(suite)
        total_passed = total_passed + suite.passed
        total_failed = total_failed + suite.failed
    }
    
    // Print summary
    io.print("\n")
    io.print("╔════════════════════════════════════════════════════════╗\n")
    io.print("║                    FINAL SUMMARY                      ║\n")
    io.print("╚════════════════════════════════════════════════════════╝\n")
    io.print("\n")
    io.print(string.format("Total Tests: {}\n", total_passed + total_failed))
    io.print(string.format("Passed: {}\n", total_passed))
    io.print(string.format("Failed: {}\n", total_failed))
    io.print("\n")
    
    if total_failed == 0 {
        io.print("\x1b[32m✓ ALL INTEGRATION TESTS PASSED!\x1b[0m\n")
        return 0
    } else {
        io.print("\x1b[31m✗ SOME TESTS FAILED\x1b[0m\n")
        return 1
    }
}