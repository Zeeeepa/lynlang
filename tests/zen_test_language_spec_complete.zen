// Test for LANGUAGE_SPEC.zen features
// This file tests the core features required by the language specification

// 1. Imports using @std
{ io } = @std
{ Option } = @std.option

// 2. Simple enum with variants
GameEntity: .Player | Enemy | Powerup

// 3. Option type - using stdlib

// 4. Result type
Result<T, E>: Ok(T) | Err(E)

// 5. Simple struct
Point: {
    x: f64,
    y: f64,
}

// 6. Function with pattern matching using ?
get_health = (e: GameEntity) u32 {
    e ?
        | Player { return 100 }
        | Enemy { return 50 }
        | Powerup { return 0 }
}

// 7. Main function with various features
main = () void {
    // Immutable assignment
    x = 42
    
    // Mutable assignment
    counter ::= 0
    
    // Enum variant constructor
    player = GameEntity.Player
    enemy = GameEntity.Enemy
    
    // Pattern matching with ?
    player ?
        | Player { io.println("It's a player!") }
        | Enemy { io.println("It's an enemy!") }
        | Powerup { io.println("It's a powerup!") }
    
    // Option type usage
    maybe_value: Option<i32> = Some(42)
    maybe_value ?
        | Some(val) { io.println("Got value") }
        | None { io.println("No value") }
    
    // Result type usage
    result: Result<i32, string> = Ok(100)
    result ?
        | Ok(val) { io.println("Success") }
        | Err(msg) { io.println("Error") }
    
    // Range loop
    (0..5).loop((i) {
        counter = counter + 1
    })
    
    // Infinite loop with break
    loop(() {
        counter = counter + 1
        is_done = counter > 10
        is_done ?
            | true { break }
            | false { }
    })
    
    // Boolean pattern matching
    is_ready = true
    is_ready ? {
        io.println("Ready!")
    }
    
    // Struct literal
    point = Point { x: 10.0, y: 20.0 }
    
    // @this.defer for cleanup (if supported)
    // @this.defer(io.println("Cleanup"))
    
    io.println("All tests passed!")
}