// Direct test of LANGUAGE_SPEC.zen main features
// This file tests the actual code from the spec

// Imports - only @std and @this are special
{ io, math } = @std

// Option type - No null! Only Option types
Option<T>: Some(T) | None

// Result type for error handling
Result<T, E>: Ok(T) | Err(E)

// Simple struct
Point: {
    x:: f64, // mutable field
    y:: f64 = 0 // with default value
}

// Trait definition - methods that types can implement
Geometric: {
    area: (self) f64,
    perimeter: (self) f64,
}

Circle: {
    center: Point,
    radius: f64,
}

// Implement trait for type using .implements()
Circle.implements(Geometric, {
    area = (self) f64 {
        return math.pi * self.radius * self.radius
    },
    perimeter = (self) f64 {
        return 2.0 * math.pi * self.radius
    },
})

Rectangle: {
    top_left: Point,
    bottom_right: Point,
}

Rectangle.implements(Geometric, {
    area = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return width * height
    },
    perimeter = (self) f64 {
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        return 2.0 * (width + height)
    },
})

// Enum type (sum type)
Shape: Circle | Rectangle
// Enforce all Shape variants must implement Geometric
Shape.requires(Geometric)

main = () void {
    // Test all variable declaration forms from spec
    x: i32 // forward declaration must be declared in the same scope 
    x = 10
    y = 10    // Immutable assignment 
    z : i32 = 20 // Immutable assignment with type
    w :: i32 // mutable forward declaration must be declared in the same scope
    w = 20
    v ::= 30 // Mutable assignment
    u :: i32 = 40 // mutable assignment with type
    
    io.println("Variables: x=${x}, y=${y}, z=${z}, w=${w}, v=${v}, u=${u}")
    
    // Test boolean pattern matching
    is_ready = true
    is_ready ? { 
        io.println("Starting game!") 
    }
    
    // For if-else, use full pattern match
    has_data = false
    has_data ?
        | true { io.println("Has data") }
        | false { io.println("Waiting for data...") }
    
    // Test structs with trait implementations
    circle = Circle { center: Point { x: 0, y: 0 }, radius: 5 }
    io.println("Circle area: ${circle.area()}")
    io.println("Circle perimeter: ${circle.perimeter()}")
    
    rect = Rectangle { 
        top_left: Point { x: 0, y: 0 },
        bottom_right: Point { x: 10, y: 10 }
    }
    io.println("Rectangle area: ${rect.area()}")
    io.println("Rectangle perimeter: ${rect.perimeter()}")
    
    // Test Option handling - no null!
    maybe_radius: Option<f64> = Some(5.5)
    maybe_radius ?
        | Some(r) {
            circle2 = Circle {
                center: Point { x: 100.0, y: 100.0 },
                radius: r,
            }
            io.println("Created circle with area: ${circle2.area()}")
        }
        | None {
            io.println("No radius provided")
        }
    
    // Test None case
    no_value: Option<f64> = None
    no_value ?
        | Some(v) { io.println("Got value: ${v}") }
        | None { io.println("Got None as expected") }
    
    // Test Result type
    good_result: Result<i32, string> = Ok(42)
    good_result ?
        | Ok(val) { io.println("Success: ${val}") }
        | Err(e) { io.println("Error: ${e}") }
    
    bad_result: Result<i32, string> = Err("Something went wrong")
    bad_result ?
        | Ok(val) { io.println("Success: ${val}") }
        | Err(e) { io.println("Error as expected: ${e}") }
    
    // Test ranges and loops
    io.println("Counting from 0 to 4:")
    (0..5).loop((i) {
        io.println("  Count: ${i}")
    })
    
    // Test step ranges
    io.println("Counting by 10s:")
    (0..50).step(10).loop((i) {
        io.println("  Step: ${i}")
    })
    
    // Test infinite loop with break
    counter ::= 0
    io.println("Loop with break:")
    loop(() {
        counter = counter + 1
        io.println("  Loop count: ${counter}")
        counter >= 3 ?
            | true { break }
            | false { }
    })
    
    // Test mutable field updates
    point ::= Point { x: 1.0, y: 2.0 }
    io.println("Original point: x=${point.x}, y=${point.y}")
    point.x = 5.0
    point.y = 10.0
    io.println("Updated point: x=${point.x}, y=${point.y}")
    
    io.println("All tests completed!")
}