// LSP Test File - Demonstrates proper position tracking and features

// Standard library imports
io {  } = @std;
math {  } = @std;

// Type definitions
Point: {
    x: f64,
    y: f64,
}

Result<T, E>:
    Ok: T,
    Err: E

// Function definitions
distance = (p1: Point, p2: Point) f64   {
    dx := p2.x - p1.x;
    dy := p2.y - p1.y;
    return math.sqrt(dx * dx + dy * dy);
}

// Generic function with type parameters
map<T, U> = (items: []T, transform: (T) U) []U {
    result := []U{};
    items.loop((item) => {
        result.push(transform(item));
    });
    return result;
}

// Main entry point
main = () void   {
    // Variable declarations with type inference
    p1 := Point { x: 0.0, y: 0.0 };
    p2 := Point { x: 3.0, y: 4.0 };
    
    // Function call
    dist := distance(p1, p2);
    io.println("Distance: " + dist.to_string());
    
    // Pattern matching
    result := compute_something();
    result ? 
        | Ok(value) { io.println("Success: " + value.to_string()) }
        | Err(error) { io.println("Error: " + error); }
    
    // Loop constructs
    count := 0;
    loop (count < 10) {
        io.println("Count: " + count.to_string());
        count = count + 1;
    }
    
    // Range iteration
    (0..5).loop((i) => {
        io.println("Index: " + i.to_string());
    });
    
    // Defer statement
    defer io.println("Cleanup done");
    
    // Comptime evaluation
    @comptime {
        const_value := 42;
        static_assert(const_value == 42);
    }
}

// Helper function returning Result
compute_something = () Result<i32, string>   {
    condition := true;
    condition ? {
        return Ok(42);
    };
    return Err("Something went wrong");
}

// Behavior definition
behavior Drawable {
    draw = (self: Self) void;
    get_bounds = (self: Self) Rectangle;
}

// Implementation for Point
impl Point for Drawable {
    draw = (self: Point) void   {
        io.println("Drawing point at (" + self.x.to_string() + ", " + self.y.to_string() + ")");
    }
    
    get_bounds = (self: Point) Rectangle   {
        return Rectangle { 
            x: self.x, 
            y: self.y, 
            width: 0.0, 
            height: 0.0 
        };
    }
}

Rectangle: {
    x: f64,
    y: f64,
    width: f64,
    height: f64,
}

// Colorless function - allocator determines sync/concurrent behavior
fetch_data = (url: string, alloc: *Allocator) Result<string, string> {
    // Delay using allocator-based approach
    delay(1000, alloc);
    return Ok("Data from " + url);
}

delay = (ms: i32, alloc: *Allocator) void {
    // Platform-specific delay implementation
    // In concurrent mode, this would yield to scheduler
    // In sync mode, this blocks
    alloc.is_concurrent ? 
        | true {
            // Concurrent path: suspend and resume after delay
            cont := alloc.suspend();
            schedule_resume(cont, ms);
        }
        | false {
            // Sync path: just sleep
            @ffi("sleep", ms / 1000);
        }
}