// Test the refactored string type system:
// - StaticString for compile-time static strings
// - String for runtime dynamic strings with allocator

{ get_default_allocator } = @std.memory_unified
{ String } = @std.string

main = () i32 {
    // StaticString - compile-time, no allocator needed
    static1: StaticString = "Hello"
    static2: StaticString = ", World!"

    // String literals are always StaticString
    literal := "This is a literal"  // Type: StaticString

    // Get allocator for dynamic strings
    allocator := get_default_allocator()

    // Create dynamic String from StaticString
    dynamic1 := String.from_static(static1, allocator)
    dynamic2 := String.from_static(static2, allocator)

    // Append to dynamic string
    result := dynamic1.append(static2)
    result.is_ok() ? {} : {
        return 1
    }

    // Create a new empty String
    empty_string := String.new(allocator)
    empty_string.is_empty() ? {} : {
        return 2
    }

    // Clone a String
    cloned := dynamic1.clone()
    cloned.len() == dynamic1.len() ? {} : {
        return 3
    }

    // Substring operation
    substr_result := dynamic1.substr(0, 3)
    substr_result.is_ok() ? {} : {
        return 4
    }

    // Concatenate two Strings
    concatenated := String.concat(dynamic1, dynamic2, allocator)
    concatenated.len() > 0 ? {} : {
        return 5
    }

    // Clean up (free memory)
    dynamic1.free()
    dynamic2.free()
    empty_string.free()
    cloned.free()
    substr_result.is_ok() ? {
        substr_result.unwrap().free()
    }
    concatenated.free()

    return 0
}