// Zen Language Server Protocol Implementation
// Provides IDE support for Zen language

io = @std
json = @std
net = @std
string = @std
{ Vec, DynVec } = @std
hashmap = @std
thread = @std
fs = @std
result = @std

// Import compiler components
lexer = @std
parser = @std
type_checker = @std

// LSP message types
MessageType : 
    Request,
    Response,
    Notification

// LSP request methods
RequestMethod: 
    | Initialize,
    | Initialized,
    | Shutdown,
    | Exit,
    | TextDocumentDidOpen,
    | TextDocumentDidChange,
    | TextDocumentDidSave,
    | TextDocumentDidClose,
    | TextDocumentCompletion,
    | TextDocumentHover,
    | TextDocumentDefinition,
    | TextDocumentReferences,
    | TextDocumentDocumentSymbol,
    | TextDocumentFormatting,
    | TextDocumentRangeFormatting,
    | TextDocumentCodeAction,
    | WorkspaceSymbol,
    | WorkspaceExecuteCommand

// Position in a text document
Position : {
    line: u32,
    character: u32
}

// Range in a text document
Range : {
    start: Position,
    end: Position
}

// Location in a text document
Location : {
    uri: string,
    range: Range
}

// Diagnostic severity
DiagnosticSeverity: 
    | Error = 1,
    | Warning = 2,
    | Information = 3,
    | Hint = 4

// Diagnostic information
Diagnostic : {
    range: Range,
    severity: DiagnosticSeverity,
    code: ?string,
    source: string,
    message: string,
    related_information: DynVec<DiagnosticRelatedInformation>
}

// Related diagnostic information
DiagnosticRelatedInformation : {
    location: Location,
    message: string
}

// Text document item
TextDocumentItem : {
    uri: string,
    language_id: string,
    version: i32,
    text: string
}

// Text document identifier
TextDocumentIdentifier : {
    uri: string
}

// Versioned text document identifier
VersionedTextDocumentIdentifier : {
    uri: string,
    version: i32
}

// Text document position params
TextDocumentPositionParams : {
    text_document: TextDocumentIdentifier,
    position: Position
}

// Completion item kind
CompletionItemKind : 
    | Text = 1,
    | Method = 2,
    | Function = 3,
    | Constructor = 4,
    | Field = 5,
    | Variable = 6,
    | Class = 7,
    | Interface = 8,
    | Module = 9,
    | Property = 10,
    | Unit = 11,
    | Value = 12,
    | Enum = 13,
    | Keyword = 14,
    | Snippet = 15,
    | Color = 16,
    | File = 17,
    | Reference = 18,
    | Folder = 19,
    | EnumMember = 20,
    | Constant = 21,
    | Struct = 22,
    | Event = 23,
    | Operator = 24,
    | TypeParameter = 25

// Completion item  
CompletionItem : {
    label: string,
    kind: CompletionItemKind,
    detail: ?string,
    documentation: ?string,
    insert_text: ?string,
    insert_text_format: ?i32,
    filter_text: ?string,
    sort_text: ?string
}

// Symbol kind
SymbolKind: 
    | File = 1,
    | Module = 2,
    | Namespace = 3,
    | Package = 4,
    | Class = 5,
    | Method = 6,
    | Property = 7,
    | Field = 8,
    | Constructor = 9,
    | Enum = 10,
    | Interface = 11,
    | Function = 12,
    | Variable = 13,
    | Constant = 14,
    | String = 15,
    | Number = 16,
    | Boolean = 17,
    | Array = 18,
    | Object = 19,
    | Key = 20,
    | Null = 21,
    | EnumMember = 22,
    | Struct = 23,
    | Event = 24,
    | Operator = 25,
    | TypeParameter = 26

// Document symbol
DocumentSymbol := {
    name: string,
    detail: ?string,
    kind: SymbolKind,
    deprecated: bool,
    range: Range,
    selection_range: Range,
    children: DynVec<DocumentSymbol>
}

// Hover information
Hover : {
    contents: string,
    range: ?Range
}

// Server capabilities
ServerCapabilities : {
    text_document_sync: i32,
    hover_provider: bool,
    completion_provider: bool,
    definition_provider: bool,
    references_provider: bool,
    document_symbol_provider: bool,
    workspace_symbol_provider: bool,
    code_action_provider: bool,
    document_formatting_provider: bool,
    document_range_formatting_provider: bool,
    execute_command_provider: ?ExecuteCommandOptions
}

// Execute command options
ExecuteCommandOptions : {
    commands: DynVec<string>
}

// Language server state
LanguageServer : {
    initialized: bool,
    root_uri: ?string,
    documents: hashmap.HashMap<string, TextDocumentItem>,
    diagnostics: hashmap.HashMap<string, DynVec<Diagnostic>>,
    symbols: hashmap.HashMap<string, DynVec<DocumentSymbol>>,
    capabilities: ServerCapabilities
}

// Create a new language server
new_server = () RawPtr<LanguageServer>   {
    server := LanguageServer{
        initialized: false,
        root_uri: null,
        documents: hashmap.new<string, TextDocumentItem>(),
        diagnostics: hashmap.new<string, DynVec<Diagnostic>>(),
        symbols: hashmap.new<string, DynVec<DocumentSymbol>>(),
        capabilities: ServerCapabilities{
            text_document_sync: 1,  // Full sync
            hover_provider: true,
            completion_provider: true,
            definition_provider: true,
            references_provider: true,
            document_symbol_provider: true,
            workspace_symbol_provider: true,
            code_action_provider: true,
            document_formatting_provider: true,
            document_range_formatting_provider: true,
            execute_command_provider: ExecuteCommandOptions{
                commands: DynVec.from_slice(["zen.compile", "zen.format", "zen.check"])
            }
        }
    }
    
    return &server
}

// Handle initialize request
handle_initialize = (server: *LanguageServer, params: json.Value) json.Value {
    // Extract root URI
    params.has("rootUri") ? {
        server.root_uri = params.get("rootUri").as_string()
    }
    
    server.initialized = true
    
    // Return server capabilities
    return json.object([
        ("capabilities", json.object([
            ("textDocumentSync", json.number(1)),
            ("hoverProvider", json.bool(true)),
            ("completionProvider", json.object([
                ("triggerCharacters", json.array([json.string("."), json.string(":")])
            ])),
            ("definitionProvider", json.bool(true)),
            ("referencesProvider", json.bool(true)),
            ("documentSymbolProvider", json.bool(true)),
            ("workspaceSymbolProvider", json.bool(true)),
            ("codeActionProvider", json.bool(true)),
            ("documentFormattingProvider", json.bool(true)),
            ("documentRangeFormattingProvider", json.bool(true)),
            ("executeCommandProvider", json.object([
                ("commands", json.array([
                    json.string("zen.compile"),
                    json.string("zen.format"),
                    json.string("zen.check")
                ]))
            ]))
        ]))
    ])
}

// Handle text document did open
handle_did_open = (server: *LanguageServer, params: json.Value) void   {
    doc := extract_text_document(params)
    server.documents.insert(doc.uri, doc)
    
    // Analyze document
    analyze_document(server, doc.uri)
}

// Handle text document did change
handle_did_change = (server: *LanguageServer, params: json.Value) void   {
    uri := params.get("textDocument").get("uri").as_string()
    version := params.get("textDocument").get("version").as_i32()
    
    server.documents.contains(uri) ? {
        doc := server.documents.get(uri)
        doc.version = version
        
        // Update text from content changes
        changes := params.get("contentChanges")
        changes.is_array() && changes.len() > 0 ? {
            // For simplicity, we only handle full document updates
            new_text := changes.get(0).get("text").as_string()
            doc.text = new_text
            server.documents.insert(uri, doc)
        }
        
        // Re-analyze document
        analyze_document(server, uri)
    }
}

// Analyze a document and generate diagnostics
analyze_document = (server: *LanguageServer, uri: string) void   {
    !server.documents.contains(uri) ? {
        return
    }
    
    doc := server.documents.get(uri)
    diagnostics := DynVec.new<Diagnostic>()
    
    // Tokenize
    tokens_result := lexer.tokenize(doc.text)
    tokens_result.is_error() ? {
        // Add lexer error as diagnostic
        diagnostic := Diagnostic{
            range: Range{
                start: Position{line: 0, character: 0},
                end: Position{line: 0, character: 0}
            },
            severity: DiagnosticSeverity.Error,
            code: null,
            source: "zen-lexer",
            message: tokens_result.unwrap_error(),
            related_information: DynVec.new()
        }
        diagnostics.push(diagnostic)
    } | false {
        tokens := tokens_result.unwrap()
        
        // Parse
        ast_result := parser.parse(tokens)
        ast_result.is_error() ? {
            // Add parser error as diagnostic
            diagnostic := Diagnostic{
                range: Range{
                    start: Position{line: 0, character: 0},
                    end: Position{line: 0, character: 0}
                },
                severity: DiagnosticSeverity.Error,
                code: null,
                source: "zen-parser",
                message: ast_result.unwrap_error(),
                related_information: DynVec.new()
            }
            diagnostics.push(diagnostic)
        } | false {
            ast := ast_result.unwrap()
            
            // Type check
            type_result := type_checker.check(ast)
            type_result.is_error() ? {
                // Add type error as diagnostic
                diagnostic := Diagnostic{
                    range: Range{
                        start: Position{line: 0, character: 0},
                        end: Position{line: 0, character: 0}
                    },
                    severity: DiagnosticSeverity.Error,
                    code: null,
                    source: "zen-type-checker",
                    message: type_result.unwrap_error(),
                    related_information: DynVec.new()
                }
                diagnostics.push(diagnostic)
            }
            
            // Extract symbols
            symbols := extract_symbols(ast)
            server.symbols.insert(uri, symbols)
        }
    }
    
    // Check for style issues
    check_style(doc.text, &diagnostics)
    
    // Store diagnostics
    server.diagnostics.insert(uri, diagnostics)
    
    // Send diagnostics notification
    publish_diagnostics(uri, diagnostics)
}

// Check style issues
check_style = (text: string, diagnostics: *DynVec<Diagnostic>) void   {
    lines := string.split(text, "\n")
    
    lines.loop((line_num, line) {
        // Check line length
        line.len() > 100 ? {
            diagnostic := Diagnostic{
                range: Range{
                    start: Position{line: line_num, character: 100},
                    end: Position{line: line_num, character: line.len()}
                },
                severity: DiagnosticSeverity.Warning,
                code: "line-too-long",
                source: "zen-style",
                message: "Line exceeds 100 characters",
                related_information: DynVec.new()
            }
            diagnostics.push(diagnostic)
        }
        
        // Check for tabs vs spaces
        string.contains(line, "\t") && string.contains(line, "    ") ? {
            diagnostic := Diagnostic{
                range: Range{
                    start: Position{line: line_num, character: 0},
                    end: Position{line: line_num, character: line.len()}
                },
                severity: DiagnosticSeverity.Warning,
                code: "mixed-indentation",
                source: "zen-style",
                message: "Mixed tabs and spaces for indentation",
                related_information: DynVec.new()
            }
            diagnostics.push(diagnostic)
        }
        
        // Check for TODO comments
        string.contains(line, "TODO") || string.contains(line, "FIXME") ? {
            start_col := string.index_of(line, "TODO")
            start_col == -1 ? {
                start_col = string.index_of(line, "FIXME")
            }
            
            diagnostic := Diagnostic{
                range: Range{
                    start: Position{line: line_num, character: start_col},
                    end: Position{line: line_num, character: line.len()}
                },
                severity: DiagnosticSeverity.Information,
                code: "todo-comment",
                source: "zen-style",
                message: "TODO comment found",
                related_information: DynVec.new()
            }
            diagnostics.push(diagnostic)
        }
    }
}

// Extract symbols from AST
extract_symbols = (ast: ASTNode) DynVec<DocumentSymbol> {
    symbols := DynVec.new<DocumentSymbol>()
    
    // Walk AST and extract symbols
    ast.children.loop((node) {
        (node.type) ?
            Function => {
                symbol := DocumentSymbol{
                    name: node.name,
                    detail: node.signature,
                    kind: SymbolKind.Function,
                    deprecated: false,
                    range: node_to_range(node),
                    selection_range: node_to_range(node),
                    children: DynVec.new()
                }
                symbols.push(symbol)
            },
            Struct => {
                symbol := DocumentSymbol{
                    name: node.name,
                    detail: "struct",
                    kind: SymbolKind.Struct,
                    deprecated: false,
                    range: node_to_range(node),
                    selection_range: node_to_range(node),
                    children: extract_struct_fields(node)
                }
                symbols.push(symbol)
            },
            Enum => {
                symbol := DocumentSymbol{
                    name: node.name,
                    detail: "enum",
                    kind: SymbolKind.Enum,
                    deprecated: false,
                    range: node_to_range(node),
                    selection_range: node_to_range(node),
                    children: extract_enum_members(node)
                }
                symbols.push(symbol)
            },
            Variable => {
                symbol := DocumentSymbol{
                    name: node.name,
                    detail: node.type_str,
                    kind: SymbolKind.Variable,
                    deprecated: false,
                    range: node_to_range(node),
                    selection_range: node_to_range(node),
                    children: DynVec.new()
                }
                symbols.push(symbol)
            },
            _ => {}
        }
    }
    
    return symbols
}

// Handle completion request
handle_completion = (server: *LanguageServer, params: json.Value) json.Value {
    uri := params.get("textDocument").get("uri").as_string()
    position := extract_position(params.get("position"))
    
    !server.documents.contains(uri) ? {
        return json.array([])
    }
    
    doc := server.documents.get(uri)
    
    // Get context at position
    context := get_context_at_position(doc.text, position)
    
    // Generate completions
    items := DynVec.new<json.Value>()
    
    // Add keywords
    keywords := ["if", "else", "while", "for", "return", "struct", "enum", "fn", "const", "let", "match", "comptime"]
    keywords.loop((keyword) {
        item := json.object([
            ("label", json.string(keyword)),
            ("kind", json.number(CompletionItemKind.Keyword)),
            ("detail", json.string("Keyword")),
            ("insertText", json.string(keyword))
        ])
        items.push(item)
    }
    
    // Add types
    types := ["i8", "i16", "i32", "i64", "u8", "u16", "u32", "u64", "f32", "f64", "bool", "string", "void"]
    types.loop((type_name) {
        item := json.object([
            ("label", json.string(type_name)),
            ("kind", json.number(CompletionItemKind.Class)),
            ("detail", json.string("Built-in type")),
            ("insertText", json.string(type_name))
        ])
        items.push(item)
    }
    
    // Add standard library modules
    string.starts_with(context, "@std.") ? {
        modules := ["core", "io", "math", "string", "vec", "fs", "net", "thread", "json"]
        modules.loop((module) {
            item := json.object([
                ("label", json.string(module)),
                ("kind", json.number(CompletionItemKind.Module)),
                ("detail", json.string("Standard library module")),
                ("insertText", json.string(module))
            ])
            items.push(item)
        }
    }
    
    // Add document symbols
    server.symbols.contains(uri) ? {
        symbols := server.symbols.get(uri)
        symbols.loop((symbol) {
            item := json.object([
                ("label", json.string(symbol.name)),
                ("kind", json.number(symbol_kind_to_completion_kind(symbol.kind))),
                ("detail", json.string(symbol.detail)),
                ("insertText", json.string(symbol.name))
            ])
            items.push(item)
        }
    }
    
    return json.array(items.to_slice())
}

// Handle hover request
handle_hover = (server: *LanguageServer, params: json.Value) json.Value {
    uri := params.get("textDocument").get("uri").as_string()
    position := extract_position(params.get("position"))
    
    !server.documents.contains(uri) ? {
        return json.null()
    }
    
    doc := server.documents.get(uri)
    
    // Get word at position
    word := get_word_at_position(doc.text, position)
    
    // Look up symbol information
    hover_text := ""
    type_info := ""
    
    // Check if it's a keyword
    is_keyword(word) ? {
        hover_text = "**Keyword**: `" + word + "`"
        hover_text += "\n\n" + get_keyword_documentation(word)
    }
    // Check if it's a type
    else if (is_builtin_type(word)) {
        hover_text = "**Built-in type**: `" + word + "`"
        hover_text += "\n\n" + get_type_documentation(word)
    }
    // Check if it's a symbol in the document
    else if (server.symbols.contains(uri)) {
        symbols := server.symbols.get(uri)
        symbols.loop((symbol) {
            symbol.name == word ? {
                // Get type information if available
                type_info = infer_symbol_type(server, doc, symbol)
                
                hover_text = "**" + symbol_kind_to_string(symbol.kind) + "**: `" + symbol.name + "`"
                
                type_info != "" ? {
                    hover_text += "\n\n**Type**: `" + type_info + "`"
                }
                
                symbol.detail != null ? {
                    hover_text += "\n\n" + symbol.detail
                }
                break
            }
        }
    }
    
    // If not found locally, check imports
    hover_text == "" ? {
        import_info := find_symbol_in_imports(server, doc, word)
        import_info != null ? {
            hover_text = import_info
        }
    }
    
    hover_text == "" ? {
        return json.null()
    }
    
    return json.object([
        ("contents", json.object([
            ("kind", json.string("markdown")),
            ("value", json.string(hover_text))
        ]))
    ])
}

// Handle go-to-definition request
handle_definition = (server: *LanguageServer, params: json.Value) json.Value  {
    uri := params.get("textDocument").get("uri").as_string()
    position := extract_position(params.get("position"))
    
    !server.documents.contains(uri) ? {
        return json.null()
    }
    
    doc := server.documents.get(uri)
    
    // Get word at position
    word := get_word_at_position(doc.text, position)
    
    // Search for definition in current document
    server.symbols.contains(uri) ? {
        symbols := server.symbols.get(uri)
        symbols.loop((symbol) {
            symbol.name == word ? {
                // Found definition in current file
                return json.object([
                    ("uri", json.string(uri)),
                    ("range", range_to_json(symbol.range))
                ])
            }
        }
    }
    
    // Search in imported modules
    definition := find_definition_in_imports(server, doc, word)
    definition != null ? {
        return definition
    }
    
    // Search in standard library
    std_definition := find_definition_in_stdlib(word)
    std_definition != null ? {
        return std_definition
    }
    
    return json.null()
}

// Publish diagnostics notification
publish_diagnostics = (uri: string, diagnostics: DynVec<Diagnostic>) void   {
    diag_array := DynVec.new<json.Value>()
    
    diagnostics.loop((diagnostic) {
        diag_json := json.object([
            ("range", range_to_json(diagnostic.range)),
            ("severity", json.number(diagnostic.severity as i32)),
            ("source", json.string(diagnostic.source)),
            ("message", json.string(diagnostic.message))
        ])
        
        diagnostic.code != null ? {
            diag_json.set("code", json.string(diagnostic.code))
        }
        
        diag_array.push(diag_json)
    }
    
    notification := json.object([
        ("jsonrpc", json.string("2.0")),
        ("method", json.string("textDocument/publishDiagnostics")),
        ("params", json.object([
            ("uri", json.string(uri)),
            ("diagnostics", json.array(diag_array.to_slice()))
        ]))
    ])
    
    send_message(notification)
}

// Helper functions
extract_text_document = (params: json.Value) TextDocumentItem   {
    doc_json := params.get("textDocument")
    return TextDocumentItem{
        uri: doc_json.get("uri").as_string(),
        language_id: doc_json.get("languageId").as_string(),
        version: doc_json.get("version").as_i32(),
        text: doc_json.get("text").as_string()
    }
}

extract_position = (pos_json: json.Value) Position   {
    return Position{
        line: pos_json.get("line").as_u32(),
        character: pos_json.get("character").as_u32()
    }
}

range_to_json = (range: Range) json.Value {
    return json.object([
        ("start", json.object([
            ("line", json.number(range.start.line)),
            ("character", json.number(range.start.character))
        ])),
        ("end", json.object([
            ("line", json.number(range.end.line)),
            ("character", json.number(range.end.character))
        ]))
    ])
}

node_to_range = (node: ASTNode) Range   {
    return Range{
        start: Position{
            line: node.start_line,
            character: node.start_column
        },
        end: Position{
            line: node.end_line,
            character: node.end_column
        }
    }
}

symbol_kind_to_completion_kind = (kind: SymbolKind) CompletionItemKind   {
    (kind) ?
        SymbolKind.Function => CompletionItemKind.Function,
        SymbolKind.Struct => CompletionItemKind.Struct,
        SymbolKind.Enum => CompletionItemKind.Enum,
        SymbolKind.Variable => CompletionItemKind.Variable,
        SymbolKind.Constant => CompletionItemKind.Constant,
        _ => CompletionItemKind.Text
    }
}

symbol_kind_to_string = (kind: SymbolKind) string   {
    (kind) ?
        SymbolKind.Function => "Function",
        SymbolKind.Struct => "Struct",
        SymbolKind.Enum => "Enum",
        SymbolKind.Variable => "Variable",
        SymbolKind.Constant => "Constant",
        _ => "Symbol"
    }
}

is_keyword = (word: string) bool   {
    keywords := ["if", "else", "while", "for", "return", "struct", "enum", "fn", "const", "let", "match", "comptime"]
    keywords.loop((kw) {
        if (word == kw) return true
    }
    return false
}

is_builtin_type = (word: string) bool   {
    types := ["i8", "i16", "i32", "i64", "u8", "u16", "u32", "u64", "f32", "f64", "bool", "string", "void"]
    types.loop((t) {
        if (word == t) return true
    }
    return false
}

get_word_at_position = (text: string, pos: Position) string   {
    lines := string.split(text, "\n")
    pos.line >= lines.len() ? {
        return ""
    }
    
    line := lines[pos.line]
    pos.character >= line.len() ? {
        return ""
    }
    
    // Find word boundaries
    start := pos.character
    while (start > 0 && is_word_char(line[start - 1])) {
        start -= 1
    }
    
    end := pos.character
    while (end < line.len() && is_word_char(line[end])) {
        end += 1
    }
    
    return string.slice(line, start, end)
}

get_context_at_position = (text: string, pos: Position) string   {
    lines := string.split(text, "\n")
    pos.line >= lines.len() ? {
        return ""
    }
    
    line := lines[pos.line]
    pos.character > line.len() ? {
        return ""
    }
    
    return string.slice(line, 0, pos.character)
}

is_word_char = (c: u8) bool   {
    return (c >= 'a' && c <= 'z') ||
           (c >= 'A' && c <= 'Z') ||
           (c >= '0' && c <= '9') ||
           c == '_'
}

extract_struct_fields = (node: ASTNode) DynVec<DocumentSymbol> {
    fields := DynVec.new<DocumentSymbol>()
    // Implementation would extract fields from struct AST node
    return fields
}

extract_enum_members = (node: ASTNode) DynVec<DocumentSymbol> {
    members := DynVec.new<DocumentSymbol>()
    // Implementation would extract members from enum AST node
    return members
}

// Find definition in imported modules
find_definition_in_imports = (server: *LanguageServer, doc: Document, word: string) json.Value? {
    // Parse imports from document
    imports := extract_imports(doc.text)
    
    imports.loop((import_path) {
        // Load imported file if not already loaded
        import_uri := resolve_import_uri(import_path)
        server.documents.contains(import_uri) ? {
            import_doc := server.documents.get(import_uri)
            server.symbols.contains(import_uri) ? {
                symbols := server.symbols.get(import_uri)
                symbols.loop((symbol) {
                    symbol.name == word ? {
                        return json.object([
                            ("uri", json.string(import_uri)),
                            ("range", range_to_json(symbol.range))
                        ])
                    }
                }
            }
        }
    }
    
    return null
}

// Find definition in standard library
find_definition_in_stdlib = (word: string) json.Value? {
    // Map of standard library symbols to their locations
    stdlib_symbols := hashmap.new<string, (string, u32, u32)>()
    stdlib_symbols.insert("DynVec", ("stdlib/collections.zen", 10, 0))
    stdlib_symbols.insert("Option", ("stdlib/option.zen", 5, 0))
    stdlib_symbols.insert("Result", ("stdlib/result.zen", 5, 0))
    stdlib_symbols.insert("io", ("stdlib/io.zen", 1, 0))
    stdlib_symbols.insert("string", ("stdlib/string.zen", 1, 0))
    stdlib_symbols.insert("math", ("stdlib/math.zen", 1, 0))
    
    stdlib_symbols.contains(word) ? {
        location := stdlib_symbols.get(word)
        return json.object([
            ("uri", json.string("file://" + location.0)),
            ("range", json.object([
                ("start", json.object([
                    ("line", json.number(location.1)),
                    ("character", json.number(location.2))
                ])),
                ("end", json.object([
                    ("line", json.number(location.1)),
                    ("character", json.number(location.2 + word.len()))
                ]))
            ]))
        ])
    }
    
    return null
}

// Extract import statements from document
extract_imports = (text: string) DynVec<string> {
    imports := DynVec.new<string>()
    lines := string.split(text, "\n")
    
    lines.loop((line) {
        trimmed := string.trim(line)
        // Check for import pattern: name := @path
        string.contains(trimmed, ":=") && string.contains(trimmed, "@") ? {
            parts := string.split(trimmed, ":=")
            parts.len() == 2 ? {
                import_part := string.trim(parts[1])
                string.starts_with(import_part, "@") ? {
                    import_path := string.slice(import_part, 1, import_part.len())
                    imports.push(import_path)
                }
            }
        }
    }
    
    return imports
}

// Resolve import path to file URI
resolve_import_uri = (import_path: string) string {
    // Convert import path to file path
    file_path := string.replace(import_path, ".", "/") + ".zen"
    
    // Check if it's a standard library import
    string.starts_with(import_path, "std.") ? {
        return "file://stdlib/" + string.slice(file_path, 4, file_path.len())
    }
    
    // Otherwise assume it's a relative import
    return "file://" + file_path
}

// Infer type of a symbol
infer_symbol_type = (server: *LanguageServer, doc: Document, symbol: DocumentSymbol) string {
    // Basic type inference based on symbol kind and context
    (symbol.kind) ?
        SymbolKind.Function => {
            // Try to extract function signature
            return extract_function_signature(doc.text, symbol.range)
        },
        SymbolKind.Variable | SymbolKind.Constant => {
            // Try to infer type from initialization
            return infer_variable_type(doc.text, symbol.range)
        },
        SymbolKind.Struct => {
            return "struct " + symbol.name
        },
        SymbolKind.Enum => {
            return "enum " + symbol.name
        },
        _ => {
            return ""
        }
    }
}

// Extract function signature
extract_function_signature = (text: string, range: Range) string {
    lines := string.split(text, "\n")
    range.start.line < lines.len() ? {
        line := lines[range.start.line]
        // Simple pattern matching for function signature
        string.contains(line, "(") && string.contains(line, ")") ? {
            start := string.index_of(line, "(")
            end := string.index_of(line, ")")
            start >= 0 && end > start ? {
                return string.slice(line, start, end + 1)
            }
        }
    }
    return ""
}

// Infer variable type from initialization
infer_variable_type = (text: string, range: Range) string {
    lines := string.split(text, "\n")
    range.start.line < lines.len() ? {
        line := lines[range.start.line]
        
        // Check for explicit type annotation
        string.contains(line, ":") ? {
            parts := string.split(line, ":")
            parts.len() >= 2 ? {
                type_part := string.trim(parts[1])
                // Extract type before assignment operator
                string.contains(type_part, "=") ? {
                    type_parts := string.split(type_part, "=")
                    return string.trim(type_parts[0])
                }
                return type_part
            }
        }
        
        // Try to infer from literal
        string.contains(line, "=") ? {
            parts := string.split(line, "=")
            parts.len() >= 2 ? {
                value := string.trim(parts[1])
                
                // Check for common literals
                string.starts_with(value, "\"") || string.starts_with(value, "'") ? {
                    return "string"
                }
                string.contains(value, ".") && is_numeric(value) ? {
                    return "f64"
                }
                is_numeric(value) ? {
                    return "i32"
                }
                value == "true" || value == "false" ? {
                    return "bool"
                }
            }
        }
    }
    return ""
}

// Check if string is numeric
is_numeric = (s: string) bool {
    s.len() == 0 ? {
        return false
    }
    
    (0..s.len()).loop ((i) {
        c := s.char_at(i)
        (c >= '0' && c <= '9') || c == '.' || c == '-' ? {
            return true
        }
        return false
    })
    
    return true
}

// Find symbol in imports
find_symbol_in_imports = (server: *LanguageServer, doc: Document, word: string) string? {
    imports := extract_imports(doc.text)
    
    imports.loop((import_path) {
        import_uri := resolve_import_uri(import_path)
        server.documents.contains(import_uri) ? {
            server.symbols.contains(import_uri) ? {
                symbols := server.symbols.get(import_uri)
                symbols.loop((symbol) {
                    symbol.name == word ? {
                        hover_text := "**Imported " + symbol_kind_to_string(symbol.kind) + "**: `" + symbol.name + "`"
                        hover_text += "\n\n*From*: `" + import_path + "`"
                        symbol.detail != null ? {
                            hover_text += "\n\n" + symbol.detail
                        }
                        return hover_text
                    }
                }
            }
        }
    }
    
    return null
}

// Get keyword documentation
get_keyword_documentation = (keyword: string) string {
    docs := hashmap.new<string, string>()
    docs.insert("fn", "Declares a function")
    docs.insert("struct", "Declares a structure type (deprecated, use Name: {...} instead)")
    docs.insert("enum", "Declares an enumeration type (deprecated, use Name: ... | .. instead)")
    docs.insert("if", "Conditional statement (deprecated, use ? operator instead)")
    docs.insert("else", "Alternative branch (deprecated, use ? operator instead)")
    docs.insert("while", "While loop")
    docs.insert("for", "For loop")
    docs.insert("loop", "Infinite loop")
    docs.insert("return", "Returns a value from a function")
    docs.insert("let", "Immutable binding")
    docs.insert("const", "Compile-time constant")
    docs.insert("match", "Pattern matching (deprecated, use ? operator instead)")
    docs.insert("comptime", "Compile-time execution")
    
    return docs.get(keyword).unwrap_or("No documentation available")
}

// Get type documentation
get_type_documentation = (type_name: string) string {
    docs := hashmap.new<string, string>()
    docs.insert("i8", "8-bit signed integer (-128 to 127)")
    docs.insert("i16", "16-bit signed integer (-32,768 to 32,767)")
    docs.insert("i32", "32-bit signed integer (-2,147,483,648 to 2,147,483,647)")
    docs.insert("i64", "64-bit signed integer")
    docs.insert("u8", "8-bit unsigned integer (0 to 255)")
    docs.insert("u16", "16-bit unsigned integer (0 to 65,535)")
    docs.insert("u32", "32-bit unsigned integer (0 to 4,294,967,295)")
    docs.insert("u64", "64-bit unsigned integer")
    docs.insert("f32", "32-bit floating point")
    docs.insert("f64", "64-bit floating point")
    docs.insert("bool", "Boolean value (true or false)")
    docs.insert("string", "UTF-8 encoded string")
    docs.insert("void", "No return value")
    
    return docs.get(type_name).unwrap_or("Custom type")
}

// Message handling
send_message = (msg: json.Value) void   {
    content := json.stringify(msg)
    header := "Content-Length: " + content.len().to_string() + "\r\n\r\n"
    io.print(header + content)
    io.flush()
}

// Main server loop
main = () i32   {
    server := new_server()
    
    io.eprintln("Zen Language Server starting...")
    
    // Main message loop
    while (true) {
        // Read message header
        header := io.read_line()
        header .== None ? {
            break
        }
        
        // Parse content length
        !string.starts_with(header, "Content-Length: ") ? {
            continue
        }
        
        length_str := string.slice(header, 16, header.len() - 2)
        content_length := string.parse_usize(length_str).unwrap_or(0)
        
        // Skip empty line
        io.read_line()
        
        // Read message content
        content := io.read_bytes(content_length)
        
        // Parse JSON
        msg_result := json.parse(content)
        msg_result.is_error() ? {
            io.eprintln("Failed to parse message: " + msg_result.unwrap_error())
            continue
        }
        
        msg := msg_result.unwrap()
        
        // Handle message
        msg.has("method") ? {
            method := msg.get("method").as_string()
            params := msg.get("params")
            
            response := match (method) {
                "initialize" => handle_initialize(server, params),
                "textDocument/didOpen" => {
                    handle_did_open(server, params)
                    null
                },
                "textDocument/didChange" => {
                    handle_did_change(server, params)
                    null
                },
                "textDocument/completion" => handle_completion(server, params),
                "textDocument/hover" => handle_hover(server, params),
                "textDocument/definition" => handle_definition(server, params),
                "shutdown" => {
                    io.eprintln("Shutting down...")
                    break
                },
                _ => null
            }
            
            // Send response if needed
            response != null && msg.has("id") ? {
                response_msg := json.object([
                    ("jsonrpc", json.string("2.0")),
                    ("id", msg.get("id")),
                    ("result", response)
                ])
                send_message(response_msg)
            }
        }
    }
    
    io.eprintln("Zen Language Server stopped")
    return 0
}