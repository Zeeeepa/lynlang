// Zen Language Server Protocol Implementation
// This LSP server provides IDE features for Zen language development

build = @std
io := build.import("io")
json := build.import("json")
net := build.import("net")
fs := build.import("fs")
string := build.import("string")
{ Vec, DynVec } = @std
map := build.import("map")
result := build.import("result")

// Import compiler modules for analysis
lexer := build.import("../compiler/lexer")
parser := build.import("../compiler/parser")
type_checker := build.import("../compiler/type_checker")
errors := build.import("../compiler/errors")

// LSP Message Types
Message: {
    jsonrpc: string,
    id: ?i32,
    method: ?string,
    params: ?json.Value,
    result: ?json.Value,
    error: ?ErrorResponse,
}

ErrorResponse: {
    code: i32,
    message: string,
    data: ?json.Value,
}

// LSP Initialize params
InitializeParams: {
    processId: ?i32,
    rootUri: ?string,
    capabilities: ClientCapabilities,
}

ClientCapabilities: {
    textDocument: ?TextDocumentClientCapabilities,
    workspace: ?WorkspaceClientCapabilities,
}

TextDocumentClientCapabilities: {
    synchronization: ?SynchronizationCapabilities,
    completion: ?CompletionCapabilities,
    hover: ?HoverCapabilities,
    definition: ?DefinitionCapabilities,
    references: ?ReferencesCapabilities,
}

// Server capabilities
ServerCapabilities: {
    textDocumentSync: i32,
    completionProvider: ?CompletionOptions,
    hoverProvider: bool,
    definitionProvider: bool,
    referencesProvider: bool,
    documentFormattingProvider: bool,
    documentSymbolProvider: bool,
    workspaceSymbolProvider: bool,
    codeActionProvider: bool,
    diagnosticProvider: bool,
}

CompletionOptions: {
    resolveProvider: bool,
    triggerCharacters: DynVec<string>,
}

// Text document types
TextDocumentItem: {
    uri: string,
    languageId: string,
    version: i32,
    text: string,
}

TextDocumentIdentifier: {
    uri: string,
}

VersionedTextDocumentIdentifier: {
    uri: string,
    version: i32,
}

Position: {
    line: i32,
    character: i32,
}

Range: {
    start: Position,
    end: Position,
}

Location: {
    uri: string,
    range: Range,
}

// Diagnostic types
Diagnostic: {
    range: Range,
    severity: i32,
    code: ?string,
    source: string,
    message: string,
    relatedInformation: ?DynVec<DiagnosticRelatedInformation>,
}

DiagnosticRelatedInformation: {
    location: Location,
    message: string,
}

// Completion types
CompletionItem: {
    label: string,
    kind: i32,
    detail: ?string,
    documentation: ?string,
    insertText: ?string,
    insertTextFormat: i32,
}

// LSP Server state
LSPServer: {
    documents: map.Map<string, TextDocumentItem>,
    root_uri: ?string,
    initialized: bool,
    shutdown_requested: bool,
    
    // Compiler instances for each document
    parsers: map.Map<string, parser.Parser>,
    type_checkers: map.Map<string, type_checker.TypeChecker>,
}

// Create a new LSP server
new_server = () LSPServer   {
    return LSPServer {
        documents: map.new<string, TextDocumentItem>(),
        root_uri: none,
        initialized: false,
        shutdown_requested: false,
        parsers: map.new<string, parser.Parser>(),
        type_checkers: map.new<string, type_checker.TypeChecker>(),
    }
}

// Handle incoming LSP message
handle_message = (server: &mut LSPServer, msg: Message) result.Result<Message, string> {
    msg.method? ? 
        | some(method) => {
            method ? 
                | "initialize" => handle_initialize(server, msg)
                | "initialized" => handle_initialized(server, msg)
                | "shutdown" => handle_shutdown(server, msg)
                | "textDocument/didOpen" => handle_did_open(server, msg)
                | "textDocument/didChange" => handle_did_change(server, msg)
                | "textDocument/didClose" => handle_did_close(server, msg)
                | "textDocument/completion" => handle_completion(server, msg)
                | "textDocument/hover" => handle_hover(server, msg)
                | "textDocument/definition" => handle_definition(server, msg)
                | "textDocument/references" => handle_references(server, msg)
                | "textDocument/formatting" => handle_formatting(server, msg)
                | "textDocument/documentSymbol" => handle_document_symbol(server, msg)
                | "workspace/symbol" => handle_workspace_symbol(server, msg)
                | "textDocument/codeAction" => handle_code_action(server, msg)
                | _ => {
                    return result.err("Method not found: " + method)
                }
        }
        | none => {
            return result.err("No method specified")
        }
}

// Initialize request handler
handle_initialize = (server: &mut LSPServer, msg: Message) result.Result<Message, string> {
    let params = parse_initialize_params(msg.params?)?
    
    server.root_uri = params.rootUri
    server.initialized = true
    
    let capabilities = ServerCapabilities {
        textDocumentSync: 1, // Full sync
        completionProvider: some(CompletionOptions {
            resolveProvider: false,
            triggerCharacters: DynVec.from_array([".", ":", "@"]),
        }),
        hoverProvider: true,
        definitionProvider: true,
        referencesProvider: true,
        documentFormattingProvider: true,
        documentSymbolProvider: true,
        workspaceSymbolProvider: true,
        codeActionProvider: true,
        diagnosticProvider: true,
    }
    
    return result.ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: none,
        params: none,
        result: some(json.object([
            ("capabilities", json.from_struct(capabilities)),
            ("serverInfo", json.object([
                ("name", json.string("zen-lsp")),
                ("version", json.string("0.1.0")),
            ])),
        ])),
        error: none,
    })
}

// Did open text document handler
handle_did_open = (server: &mut LSPServer, msg: Message) result.Result<Message, string> {
    let params = parse_did_open_params(msg.params?)?
    let document = params.textDocument
    
    // Store document
    map.insert(server.documents, document.uri.clone(), document)
    
    // Parse and analyze document
    analyze_document(server, document.uri)
    
    // Send diagnostics
    send_diagnostics(server, document.uri)
    
    return result.ok(empty_response())
}

// Analyze document for errors and symbols
analyze_document = (server: &mut LSPServer, uri: string) result.Result<(), string> {
    let doc = map.get(server.documents, uri)?
    
    // Create lexer and parser
    let lex = lexer.new(doc.text)
    let tokens = lexer.tokenize(lex)
    
    let p = parser.new(tokens)
    let ast = parser.parse_program(p)
    
    // Store parser
    map.insert(server.parsers, uri.clone(), p)
    
    // Type check if parsing succeeded
    ast ? 
        | ok(program) => {
            let tc = type_checker.new()
            let typed_ast = type_checker.check(tc, program)
            map.insert(server.type_checkers, uri, tc)
        }
        | err(e) => {
            // Store error for diagnostics
        }
    
    return result.ok(())
}

// Send diagnostics for a document
send_diagnostics = (server: &LSPServer, uri: string) result.Result<(), string> {
    let diagnostics = get_diagnostics(server, uri)?
    
    let notification = Message {
        jsonrpc: "2.0",
        id: none,
        method: some("textDocument/publishDiagnostics"),
        params: some(json.object([
            ("uri", json.string(uri)),
            ("diagnostics", json.array(diagnostics)),
        ])),
        result: none,
        error: none,
    }
    
    send_message(notification)
    return result.ok(())
}

// Get diagnostics for a document
get_diagnostics = (server: &LSPServer, uri: string) result.Result<DynVec<Diagnostic>, string> {
    let diagnostics = DynVec.new<Diagnostic>()
    
    // Get parser errors
    let p = map.get(server.parsers, uri)?
    p.errors.iter() |error| {
        let diag = Diagnostic {
            range: error_to_range(error),
            severity: 1, // Error
            code: none,
            source: "zen",
            message: error.message,
            relatedInformation: none,
        }
        DynVec.push(diagnostics, diag)
    }
    
    // Get type checker errors
    let tc = map.get(server.type_checkers, uri)?
    tc.errors.iter() |error| {
        let diag = Diagnostic {
            range: error_to_range(error),
            severity: 1, // Error
            code: none,
            source: "zen-type-checker",
            message: error.message,
            relatedInformation: none,
        }
        DynVec.push(diagnostics, diag)
    }
    
    return result.ok(diagnostics)
}

// Handle completion request
handle_completion = (server: &LSPServer, msg: Message) result.Result<Message, string> {
    let params = parse_completion_params(msg.params?)?
    let uri = params.textDocument.uri
    let position = params.position
    
    let items = get_completions(server, uri, position)?
    
    return result.ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: none,
        params: none,
        result: some(json.array(items.map(|item| json.from_struct(item)))),
        error: none,
    })
}

// Get completion items at position
get_completions = (server: &LSPServer, uri: string, pos: Position) result.Result<DynVec<CompletionItem>, string> {
    let items = DynVec.new<CompletionItem>()
    
    // Add keyword completions
    add_keyword_completions(items)
    
    // Add type completions
    add_type_completions(items)
    
    // Add stdlib module completions
    add_stdlib_completions(items)
    
    // Add local symbol completions
    add_local_completions(server, uri, pos, items)
    
    return result.ok(items)
}

// Add keyword completions
add_keyword_completions = (items: &mut DynVec<CompletionItem>)  {
    let keywords = [
        "return", "break", "continue", "loop",
        "struct", "enum", "type", "comptime", "pub", "mut",
        "true", "false", "none", "some",
    ]
    
    keywords.iter() |kw| {
        DynVec.push(items, CompletionItem {
            label: kw,
            kind: 14, // Keyword
            detail: some("keyword"),
            documentation: none,
            insertText: none,
            insertTextFormat: 1,
        })
    }
}

// Add type completions
add_type_completions = (items: &mut DynVec<CompletionItem>)  {
    let types = [
        "i8", "i16", "i32", "i64", "i128",
        "u8", "u16", "u32", "u64", "u128",
        "f32", "f64",
        "bool", "string", "void",
    ]
    
    types.iter() |ty| {
        DynVec.push(items, CompletionItem {
            label: ty,
            kind: 7, // Class/Type
            detail: some("primitive type"),
            documentation: none,
            insertText: none,
            insertTextFormat: 1,
        })
    }
}

// Add stdlib completions
add_stdlib_completions = (items: &mut DynVec<CompletionItem>)  {
    let modules = [
        "@std.io", "@std.fs", "@std.net", "@std.math",
        "@std.string", "@std.vec", "@std.map", "@std.set",
        "@std.json", "@std.xml", "@std.csv", "@std.yaml",
        "@std.http", "@std.concurrency", "@std.thread", "@std.sync",
        "@std.regex", "@std.test", "@std.bench", "@std.build",
    ]
    
    modules.iter() |mod| {
        DynVec.push(items, CompletionItem {
            label: mod,
            kind: 9, // Module
            detail: some("standard library module"),
            documentation: none,
            insertText: none,
            insertTextFormat: 1,
        })
    }
}

// Main entry point
main = () i32   {
    io.print("Zen Language Server starting...\n")
    
    let server = new_server()
    
    // Main message loop
    loop {
        let input = io.read_line()?
        input.is_empty() ? { break }
        
        // Parse JSON-RPC message
        let msg = parse_message(input)?
        
        // Handle message
        let response = handle_message(&mut server, msg)
        
        response ? 
            | ok(resp) => send_message(resp)
            | err(e) => {
                io.eprint("Error handling message: " + e + "\n")
            }
        
        server.shutdown_requested ? { break }
    }
    
    io.print("Zen Language Server stopped\n")
    return 0
}