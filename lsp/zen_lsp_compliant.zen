// Zen Language Server Protocol Implementation
// Fully compliant with Zenlang Language Specification v1.1.0

// Import core modules
{ build } = @std.build
core := build.import("../std/core")
{ Option, Result, Vec, HashMap, Ptr } := core

io := build.import("io")
json := build.import("json")
net := build.import("net")
fs := build.import("fs")
string := build.import("string")

// Import compiler modules for analysis
lexer := build.import("../compiler/lexer")
parser := build.import("../compiler/parser")
type_checker := build.import("../compiler/type_checker")
errors := build.import("../compiler/errors")

// LSP Message Types
Message: {
    jsonrpc: string,
    id: Option<i32>,
    method: Option<string>,
    params: Option<json.Value>,
    result: Option<json.Value>,
    error: Option<ErrorResponse>,
}

ErrorResponse: {
    code: i32,
    message: string,
    data: Option<json.Value>,
}

// LSP Initialize params
InitializeParams: {
    processId: Option<i32>,
    rootUri: Option<string>,
    capabilities: ClientCapabilities,
}

ClientCapabilities: {
    textDocument: Option<TextDocumentClientCapabilities>,
    workspace: Option<WorkspaceClientCapabilities>,
}

TextDocumentClientCapabilities: {
    synchronization: Option<SynchronizationCapabilities>,
    completion: Option<CompletionCapabilities>,
    hover: Option<HoverCapabilities>,
    definition: Option<DefinitionCapabilities>,
    references: Option<ReferencesCapabilities>,
}

SynchronizationCapabilities: {
    dynamicRegistration: Option<bool>,
    willSave: Option<bool>,
    willSaveWaitUntil: Option<bool>,
    didSave: Option<bool>,
}

CompletionCapabilities: {
    dynamicRegistration: Option<bool>,
    completionItem: Option<CompletionItemCapabilities>,
}

CompletionItemCapabilities: {
    snippetSupport: Option<bool>,
    commitCharactersSupport: Option<bool>,
}

HoverCapabilities: {
    dynamicRegistration: Option<bool>,
    contentFormat: Option<Vec<string>>,
}

DefinitionCapabilities: {
    dynamicRegistration: Option<bool>,
    linkSupport: Option<bool>,
}

ReferencesCapabilities: {
    dynamicRegistration: Option<bool>,
}

WorkspaceClientCapabilities: {
    applyEdit: Option<bool>,
    workspaceEdit: Option<WorkspaceEditCapabilities>,
}

WorkspaceEditCapabilities: {
    documentChanges: Option<bool>,
    resourceOperations: Option<Vec<string>>,
}

// Server capabilities
ServerCapabilities: {
    textDocumentSync: i32,
    completionProvider: Option<CompletionOptions>,
    hoverProvider: bool,
    definitionProvider: bool,
    referencesProvider: bool,
    documentFormattingProvider: bool,
    documentSymbolProvider: bool,
    workspaceSymbolProvider: bool,
    codeActionProvider: bool,
    diagnosticProvider: bool,
}

CompletionOptions: {
    resolveProvider: bool,
    triggerCharacters: Vec<string>,
}

// Text document types
TextDocumentItem: {
    uri: string,
    languageId: string,
    version: i32,
    text: string,
}

TextDocumentIdentifier: {
    uri: string,
}

VersionedTextDocumentIdentifier: {
    uri: string,
    version: i32,
}

Position: {
    line: i32,
    character: i32,
}

Range: {
    start: Position,
    end: Position,
}

Location: {
    uri: string,
    range: Range,
}

// Diagnostic types
Diagnostic: {
    range: Range,
    severity: i32,
    code: Option<string>,
    source: string,
    message: string,
    relatedInformation: Option<Vec<DiagnosticRelatedInformation>>,
}

DiagnosticRelatedInformation: {
    location: Location,
    message: string,
}

// Diagnostic severity levels
DIAGNOSTIC_ERROR := 1
DIAGNOSTIC_WARNING := 2
DIAGNOSTIC_INFORMATION := 3
DIAGNOSTIC_HINT := 4

// Completion types
CompletionItem: {
    label: string,
    kind: i32,
    detail: Option<string>,
    documentation: Option<string>,
    insertText: Option<string>,
    insertTextFormat: i32,
}

// Completion item kinds
COMPLETION_TEXT := 1
COMPLETION_METHOD := 2
COMPLETION_FUNCTION := 3
COMPLETION_CONSTRUCTOR := 4
COMPLETION_FIELD := 5
COMPLETION_VARIABLE := 6
COMPLETION_CLASS := 7
COMPLETION_INTERFACE := 8
COMPLETION_MODULE := 9
COMPLETION_PROPERTY := 10
COMPLETION_UNIT := 11
COMPLETION_VALUE := 12
COMPLETION_ENUM := 13
COMPLETION_KEYWORD := 14
COMPLETION_SNIPPET := 15

// LSP Server state
LSPServer: {
    documents: HashMap<string, TextDocumentItem>,
    root_uri: Option<string>,
    initialized: bool,
    shutdown_requested: bool,
    parsers: HashMap<string, parser.Parser>,
    type_checkers: HashMap<string, type_checker.TypeChecker>,
}

// Create a new LSP server
new_server = () LSPServer   {
    LSPServer {
        documents: HashMap:new(),
        root_uri: Option:None,
        initialized: false,
        shutdown_requested: false,
        parsers: HashMap:new(),
        type_checkers: HashMap:new(),
    }
}

// Handle incoming LSP message
handle_message = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    msg.method ?
        | Some -> method => {
            method == "initialize" ? | true => handle_initialize(server, msg)
                                    | false =>
            method == "initialized" ? | true => handle_initialized(server, msg)
                                     | false =>
            method == "shutdown" ? | true => handle_shutdown(server, msg)
                                  | false =>
            method == "textDocument/didOpen" ? | true => handle_did_open(server, msg)
                                              | false =>
            method == "textDocument/didChange" ? | true => handle_did_change(server, msg)
                                                | false =>
            method == "textDocument/didClose" ? | true => handle_did_close(server, msg)
                                               | false =>
            method == "textDocument/completion" ? | true => handle_completion(server, msg)
                                                 | false =>
            method == "textDocument/hover" ? | true => handle_hover(server, msg)
                                            | false =>
            method == "textDocument/definition" ? | true => handle_definition(server, msg)
                                                 | false =>
            method == "textDocument/references" ? | true => handle_references(server, msg)
                                                 | false =>
            method == "textDocument/formatting" ? | true => handle_formatting(server, msg)
                                                 | false =>
            method == "textDocument/documentSymbol" ? | true => handle_document_symbol(server, msg)
                                                      | false =>
            method == "workspace/symbol" ? | true => handle_workspace_symbol(server, msg)
                                          | false =>
            method == "textDocument/codeAction" ? | true => handle_code_action(server, msg)
                                                 | false => Result:Err("Method not found: $(method)")
        }
        | None => Result:Err("No method specified")
}

// Initialize request handler
handle_initialize = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_initialize_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    server.value.root_uri = params.rootUri
    server.value.initialized = true
    
    trigger_chars := Vec<string>:new()
    trigger_chars_ptr := Ptr:new(trigger_chars)
    trigger_chars_ptr.push(".")
    trigger_chars_ptr.push(":")
    trigger_chars_ptr.push("@")
    
    capabilities := ServerCapabilities {
        textDocumentSync: 1,
        completionProvider: Option:Some(CompletionOptions {
            resolveProvider: false,
            triggerCharacters: trigger_chars_ptr.value,
        }),
        hoverProvider: true,
        definitionProvider: true,
        referencesProvider: true,
        documentFormattingProvider: true,
        documentSymbolProvider: true,
        workspaceSymbolProvider: true,
        codeActionProvider: true,
        diagnosticProvider: true,
    }
    
    response := Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: Option:Some(json.object({
            "capabilities": capabilities,
            "serverInfo": {
                "name": "Zen Language Server",
                "version": "1.0.0",
            },
        })),
        error: Option:None,
    }
    
    Result:Ok(response)
}

// Initialized notification handler
handle_initialized = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    // No response needed for notification
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: Option:None,
        method: Option:None,
        params: Option:None,
        result: Option:None,
        error: Option:None,
    })
}

// Shutdown request handler
handle_shutdown = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    server.value.shutdown_requested = true
    
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: Option:Some(json.null()),
        error: Option:None,
    })
}

// Text document opened handler
handle_did_open = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_did_open_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Store the document
    server.value.documents.insert(params.textDocument.uri, params.textDocument)
    
    // Analyze the document and send diagnostics
    diagnostics := analyze_document(server, params.textDocument.uri)
    send_diagnostics(params.textDocument.uri, diagnostics)
    
    // No response for notification
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: Option:None,
        method: Option:None,
        params: Option:None,
        result: Option:None,
        error: Option:None,
    })
}

// Text document changed handler
handle_did_change = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_did_change_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Update the document
    doc := server.value.documents.get(params.textDocument.uri) ?
        | Some -> d => {
            // Update document text
            updated_doc := TextDocumentItem {
                uri: d.uri,
                languageId: d.languageId,
                version: params.textDocument.version,
                text: params.contentChanges[0].text,  // Assuming full sync
            }
            server.value.documents.insert(params.textDocument.uri, updated_doc)
        }
        | None => {}
    
    // Re-analyze and send diagnostics
    diagnostics := analyze_document(server, params.textDocument.uri)
    send_diagnostics(params.textDocument.uri, diagnostics)
    
    // No response for notification
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: Option:None,
        method: Option:None,
        params: Option:None,
        result: Option:None,
        error: Option:None,
    })
}

// Text document closed handler
handle_did_close = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_did_close_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Remove the document and associated data
    server.value.documents.remove(params.textDocument.uri)
    server.value.parsers.remove(params.textDocument.uri)
    server.value.type_checkers.remove(params.textDocument.uri)
    
    // Clear diagnostics
    send_diagnostics(params.textDocument.uri, Vec:new())
    
    // No response for notification
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: Option:None,
        method: Option:None,
        params: Option:None,
        result: Option:None,
        error: Option:None,
    })
}

// Completion request handler
handle_completion = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_completion_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Get completions
    items := get_completions(server, params.textDocument.uri, params.position)
    
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: Option:Some(json.array(items)),
        error: Option:None,
    })
}

// Hover request handler
handle_hover = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_hover_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Get hover info
    hover_info := get_hover_info(server, params.textDocument.uri, params.position)
    
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: hover_info ?
            | Some -> info => Option:Some(json.object({
                "contents": info,
                "range": Option:None,
            }))
            | None => Option:Some(json.null()),
        error: Option:None,
    })
}

// Go to definition handler
handle_definition = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_definition_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Find definition
    location := find_definition(server, params.textDocument.uri, params.position)
    
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: location ?
            | Some -> loc => Option:Some(json.object(loc))
            | None => Option:Some(json.null()),
        error: Option:None,
    })
}

// Find references handler
handle_references = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_references_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Find all references
    locations := find_references(server, params.textDocument.uri, params.position)
    
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: Option:Some(json.array(locations)),
        error: Option:None,
    })
}

// Document formatting handler
handle_formatting = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_formatting_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Format document
    edits := format_document(server, params.textDocument.uri)
    
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: Option:Some(json.array(edits)),
        error: Option:None,
    })
}

// Document symbols handler
handle_document_symbol = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_document_symbol_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Get document symbols
    symbols := get_document_symbols(server, params.textDocument.uri)
    
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: Option:Some(json.array(symbols)),
        error: Option:None,
    })
}

// Workspace symbols handler
handle_workspace_symbol = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_workspace_symbol_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Search workspace symbols
    symbols := search_workspace_symbols(server, params.query)
    
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: Option:Some(json.array(symbols)),
        error: Option:None,
    })
}

// Code actions handler
handle_code_action = (server: Ptr<LSPServer>, msg: Message) Result<Message, string>   {
    params := parse_code_action_params(msg.params) ?
        | Ok -> p => p
        | Err -> e => return Result:Err(e)
    
    // Get available code actions
    actions := get_code_actions(server, params.textDocument.uri, params.range)
    
    Result:Ok(Message {
        jsonrpc: "2.0",
        id: msg.id,
        method: Option:None,
        params: Option:None,
        result: Option:Some(json.array(actions)),
        error: Option:None,
    })
}

// Analyze document and generate diagnostics
analyze_document = (server: Ptr<LSPServer>, uri: string) Vec<Diagnostic>   {
    diagnostics := Vec<Diagnostic>:new()
    diagnostics_ptr := Ptr:new(diagnostics)
    
    doc := server.value.documents.get(uri) ?
        | Some -> d => {
            // Lexical analysis
            tokens := lexer.tokenize(d.text) ?
                | Ok -> t => t
                | Err -> e => {
                    // Add lexer error diagnostic
                    diag := Diagnostic {
                        range: Range {
                            start: Position { line: e.line, character: e.column },
                            end: Position { line: e.line, character: e.column + 1 },
                        },
                        severity: DIAGNOSTIC_ERROR,
                        code: Option:Some("LEX001"),
                        source: "zen-lsp",
                        message: e.message,
                        relatedInformation: Option:None,
                    }
                    diagnostics_ptr.push(diag)
                    return diagnostics_ptr.value
                }
            
            // Syntax analysis
            ast := parser.parse(tokens) ?
                | Ok -> a => a
                | Err -> e => {
                    // Add parser error diagnostic
                    diag := Diagnostic {
                        range: Range {
                            start: Position { line: e.line, character: e.column },
                            end: Position { line: e.line, character: e.column + 1 },
                        },
                        severity: DIAGNOSTIC_ERROR,
                        code: Option:Some("PARSE001"),
                        source: "zen-lsp",
                        message: e.message,
                        relatedInformation: Option:None,
                    }
                    diagnostics_ptr.push(diag)
                    return diagnostics_ptr.value
                }
            
            // Type checking
            type_errors := type_checker.check(ast) ?
                | Ok -> _ => Vec:new()
                | Err -> errors => errors
            
            // Add type error diagnostics
            type_errors.loop((err) => {
                diag := Diagnostic {
                    range: Range {
                        start: Position { line: err.line, character: err.column },
                        end: Position { line: err.line, character: err.column + err.length },
                    },
                    severity: DIAGNOSTIC_ERROR,
                    code: Option:Some("TYPE001"),
                    source: "zen-lsp",
                    message: err.message,
                    relatedInformation: Option:None,
                }
                diagnostics_ptr.push(diag)
            })
            
            // Check for language spec violations
            spec_violations := check_spec_compliance(d.text)
            spec_violations.loop((violation) => {
                diag := Diagnostic {
                    range: violation.range,
                    severity: DIAGNOSTIC_ERROR,
                    code: Option:Some("SPEC001"),
                    source: "zen-lsp",
                    message: violation.message,
                    relatedInformation: Option:None,
                }
                diagnostics_ptr.push(diag)
            })
        }
        | None => {}
    
    diagnostics_ptr.value
}

// Check for language spec compliance
check_spec_compliance = (text: string) Vec<SpecViolation>   {
    violations := Vec<SpecViolation>:new()
    violations_ptr := Ptr:new(violations)
    
    lines := text.split("\n")
    line_num := 0
    
    lines.loop((line) => {
        // Strip comments from the line before checking
        comment_pos := line.find("//")
        line_to_check := comment_pos ?
            | Some -> pos => line.substring(0, pos)
            | None => line
        
        // Skip empty lines and lines that are only comments
        line_to_check.trim().len() == 0 ?
            | true => {
                line_num = line_num + 1
                return
            }
            | false => {}
        
        // Check for forbidden keywords
        line_to_check.contains("if ") || line_to_check.contains("else ") || line_to_check.contains("match ") ?
            | true => {
                violation := SpecViolation {
                    range: Range {
                        start: Position { line: line_num, character: 0 },
                        end: Position { line: line_num, character: line.len() },
                    },
                    message: "Use of forbidden keyword. Use ? operator for pattern matching",
                }
                violations_ptr.push(violation)
            }
            | false => {}
        
        // Check for struct keyword
        line_to_check.contains("struct ") ?
            | true => {
                violation := SpecViolation {
                    range: Range {
                        start: Position { line: line_num, character: 0 },
                        end: Position { line: line_num, character: line.len() },
                    },
                    message: "Use of 'struct' keyword. Use Name = {} syntax",
                }
                violations_ptr.push(violation)
            }
            | false => {}
        
        // Check for raw pointer syntax
        line_to_check.contains("&") || line_to_check.contains("*") ?
            | true => {
                violation := SpecViolation {
                    range: Range {
                        start: Position { line: line_num, character: 0 },
                        end: Position { line: line_num, character: line.len() },
                    },
                    message: "Use of raw pointer syntax. Use Ptr<T> instead",
                }
                violations_ptr.push(violation)
            }
            | false => {}
        
        line_num = line_num + 1
    })
    
    violations_ptr.value
}

SpecViolation: {
    range: Range,
    message: string,
}

// Send diagnostics to client
send_diagnostics = (uri: string, diagnostics: Vec<Diagnostic>) void   {
    notification := Message {
        jsonrpc: "2.0",
        id: Option:None,
        method: Option:Some("textDocument/publishDiagnostics"),
        params: Option:Some(json.object({
            "uri": uri,
            "diagnostics": diagnostics,
        })),
        result: Option:None,
        error: Option:None,
    }
    
    send_message(notification)
}

// Send message to client
send_message = (msg: Message) void   {
    json_str := json.stringify(msg)
    content_length := json_str.len()
    
    io.print("Content-Length: $(content_length)\r\n\r\n$(json_str)")
}

// Main entry point
main = () void   {
    server := Ptr:new(new_server())
    
    loop {
        // Read LSP message from stdin
        msg := read_lsp_message() ?
            | Ok -> m => m
            | Err -> e => {
                io.error("Failed to read message: $(e)")
                continue
            }
        
        // Handle the message
        response := handle_message(server, msg) ?
            | Ok -> r => r
            | Err -> e => {
                // Send error response if this was a request
                msg.id ?
                    | Some -> id => {
                        error_response := Message {
                            jsonrpc: "2.0",
                            id: Option:Some(id),
                            method: Option:None,
                            params: Option:None,
                            result: Option:None,
                            error: Option:Some(ErrorResponse {
                                code: -32603,
                                message: e,
                                data: Option:None,
                            }),
                        }
                        send_message(error_response)
                    }
                    | None => {}
                continue
            }
        
        // Send response if needed
        response.id ?
            | Some -> _ => send_message(response)
            | None => {}
        
        // Check for shutdown
        server.value.shutdown_requested ?
            | true => break
            | false => {}
    }
}

// Placeholder functions for parsing params
parse_initialize_params = (params: Option<json.Value>) Result<InitializeParams, string>   {
    Result:Err("Not implemented")
}

parse_did_open_params = (params: Option<json.Value>) Result<DidOpenTextDocumentParams, string>   {
    Result:Err("Not implemented")
}

parse_did_change_params = (params: Option<json.Value>) Result<DidChangeTextDocumentParams, string>   {
    Result:Err("Not implemented")
}

parse_did_close_params = (params: Option<json.Value>) Result<DidCloseTextDocumentParams, string>   {
    Result:Err("Not implemented")
}

parse_completion_params = (params: Option<json.Value>) Result<CompletionParams, string>   {
    Result:Err("Not implemented")
}

parse_hover_params = (params: Option<json.Value>) Result<HoverParams, string>   {
    Result:Err("Not implemented")
}

parse_definition_params = (params: Option<json.Value>) Result<DefinitionParams, string>   {
    Result:Err("Not implemented")
}

parse_references_params = (params: Option<json.Value>) Result<ReferenceParams, string>   {
    Result:Err("Not implemented")
}

parse_formatting_params = (params: Option<json.Value>) Result<DocumentFormattingParams, string>   {
    Result:Err("Not implemented")
}

parse_document_symbol_params = (params: Option<json.Value>) Result<DocumentSymbolParams, string>   {
    Result:Err("Not implemented")
}

parse_workspace_symbol_params = (params: Option<json.Value>) Result<WorkspaceSymbolParams, string>   {
    Result:Err("Not implemented")
}

parse_code_action_params = (params: Option<json.Value>) Result<CodeActionParams, string>   {
    Result:Err("Not implemented")
}

// Placeholder functions for LSP features
get_completions = (server: Ptr<LSPServer>, uri: string, position: Position) Vec<CompletionItem>   {
    Vec:new()
}

get_hover_info = (server: Ptr<LSPServer>, uri: string, position: Position) Option<string>   {
    Option:None
}

find_definition = (server: Ptr<LSPServer>, uri: string, position: Position) Option<Location>   {
    Option:None
}

find_references = (server: Ptr<LSPServer>, uri: string, position: Position) Vec<Location>   {
    Vec:new()
}

format_document = (server: Ptr<LSPServer>, uri: string) Vec<TextEdit>   {
    Vec:new()
}

get_document_symbols = (server: Ptr<LSPServer>, uri: string) Vec<SymbolInformation>   {
    Vec:new()
}

search_workspace_symbols = (server: Ptr<LSPServer>, query: string) Vec<SymbolInformation>   {
    Vec:new()
}

get_code_actions = (server: Ptr<LSPServer>, uri: string, range: Range) Vec<CodeAction>   {
    Vec:new()
}

read_lsp_message = () Result<Message, string>   {
    Result:Err("Not implemented")
}

// Additional param types
DidOpenTextDocumentParams: {
    textDocument: TextDocumentItem,
}

DidChangeTextDocumentParams: {
    textDocument: VersionedTextDocumentIdentifier,
    contentChanges: Vec<TextDocumentContentChangeEvent>,
}

TextDocumentContentChangeEvent: {
    range: Option<Range>,
    rangeLength: Option<i32>,
    text: string,
}

DidCloseTextDocumentParams: {
    textDocument: TextDocumentIdentifier,
}

CompletionParams: {
    textDocument: TextDocumentIdentifier,
    position: Position,
    context: Option<CompletionContext>,
}

CompletionContext: {
    triggerKind: i32,
    triggerCharacter: Option<string>,
}

HoverParams: {
    textDocument: TextDocumentIdentifier,
    position: Position,
}

DefinitionParams: {
    textDocument: TextDocumentIdentifier,
    position: Position,
}

ReferenceParams: {
    textDocument: TextDocumentIdentifier,
    position: Position,
    context: ReferenceContext,
}

ReferenceContext: {
    includeDeclaration: bool,
}

DocumentFormattingParams: {
    textDocument: TextDocumentIdentifier,
    options: FormattingOptions,
}

FormattingOptions: {
    tabSize: i32,
    insertSpaces: bool,
}

DocumentSymbolParams: {
    textDocument: TextDocumentIdentifier,
}

WorkspaceSymbolParams: {
    query: string,
}

CodeActionParams: {
    textDocument: TextDocumentIdentifier,
    range: Range,
    context: CodeActionContext,
}

CodeActionContext: {
    diagnostics: Vec<Diagnostic>,
}

TextEdit: {
    range: Range,
    newText: string,
}

SymbolInformation: {
    name: string,
    kind: i32,
    location: Location,
    containerName: Option<string>,
}

CodeAction: {
    title: string,
    kind: Option<string>,
    diagnostics: Option<Vec<Diagnostic>>,
    edit: Option<WorkspaceEdit>,
    command: Option<Command>,
}

WorkspaceEdit: {
    changes: Option<HashMap<string, Vec<TextEdit>>>,
}

Command: {
    title: string,
    command: string,
    arguments: Option<Vec<json.Value>>,
}

// Export public API
export {
    LSPServer,
    new_server,
    handle_message,
    main,
}