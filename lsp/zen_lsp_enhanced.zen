// Enhanced Zen Language Server Protocol Implementation
// Provides comprehensive IDE support for Zen development

io = @std
fs = @std
string = @std
{ Vec, DynVec } = @std
json = @std
net = @std

// LSP Message types
LspMessage := {
    jsonrpc: string
    id: Option<i32>
    method: Option<string>
    params: Option<json.Value>
    result: Option<json.Value>
    error: Option<LspError>
}

LspError := {
    code: i32
    message: string
    data: Option<json.Value>
}

// Initialize request parameters
InitializeParams := {
    process_id: Option<i32>
    root_uri: Option<string>
    capabilities: ClientCapabilities
}

ClientCapabilities := {
    text_document: Option<TextDocumentClientCapabilities>
    workspace: Option<WorkspaceClientCapabilities>
}

TextDocumentClientCapabilities := {
    completion: Option<CompletionCapabilities>
    hover: Option<HoverCapabilities>
    signature_help: Option<SignatureHelpCapabilities>
    references: Option<ReferenceCapabilities>
    definition: Option<DefinitionCapabilities>
    formatting: Option<FormattingCapabilities>
    semantic_tokens: Option<SemanticTokensCapabilities>
}

WorkspaceClientCapabilities := {
    apply_edit: bool
    workspace_folders: bool
    configuration: bool
}

CompletionCapabilities := {
    dynamic_registration: bool
    completion_item: Option<CompletionItemCapabilities>
}

CompletionItemCapabilities := {
    snippet_support: bool
    commit_characters_support: bool
    documentation_format: DynVec<string>
    deprecated_support: bool
    preselect_support: bool
}

HoverCapabilities := {
    dynamic_registration: bool
    content_format: DynVec<string>
}

SignatureHelpCapabilities := {
    dynamic_registration: bool
    signature_information: Option<SignatureInformationCapabilities>
}

SignatureInformationCapabilities := {
    documentation_format: DynVec<string>
    parameter_information: Option<ParameterInformationCapabilities>
}

ParameterInformationCapabilities := {
    label_offset_support: bool
}

ReferenceCapabilities := {
    dynamic_registration: bool
}

DefinitionCapabilities := {
    dynamic_registration: bool
    link_support: bool
}

FormattingCapabilities := {
    dynamic_registration: bool
}

SemanticTokensCapabilities := {
    dynamic_registration: bool
    requests: SemanticTokensRequests
    token_types: DynVec<string>
    token_modifiers: DynVec<string>
    formats: DynVec<string>
}

SemanticTokensRequests := {
    range: bool
    full: Option<SemanticTokensFullOptions>
}

SemanticTokensFullOptions := {
    delta: bool
}

// Server capabilities
ServerCapabilities := {
    text_document_sync: TextDocumentSyncKind
    completion_provider: Option<CompletionOptions>
    hover_provider: bool
    signature_help_provider: Option<SignatureHelpOptions>
    definition_provider: bool
    references_provider: bool
    document_formatting_provider: bool
    document_range_formatting_provider: bool
    document_symbol_provider: bool
    workspace_symbol_provider: bool
    code_action_provider: bool
    code_lens_provider: Option<CodeLensOptions>
    document_link_provider: Option<DocumentLinkOptions>
    rename_provider: bool
    semantic_tokens_provider: Option<SemanticTokensOptions>
}

TextDocumentSyncKind: None, Full, Incremental

CompletionOptions := {
    resolve_provider: bool
    trigger_characters: DynVec<string>
}

SignatureHelpOptions := {
    trigger_characters: DynVec<string>
    retrigger_characters: DynVec<string>
}

CodeLensOptions := {
    resolve_provider: bool
}

DocumentLinkOptions := {
    resolve_provider: bool
}

SemanticTokensOptions := {
    legend: SemanticTokensLegend
    range: bool
    full: Option<SemanticTokensFullOptions>
}

SemanticTokensLegend := {
    token_types: DynVec<string>
    token_modifiers: DynVec<string>
}

// Document management
TextDocument := {
    uri: string
    language_id: string
    version: i32
    content: string
}

Position := {
    line: i32
    character: i32
}

Range := {
    start: Position
    end: Position
}

Location := {
    uri: string
    range: Range
}

Diagnostic := {
    range: Range
    severity: DiagnosticSeverity
    code: Option<string>
    source: Option<string>
    message: string
    tags: DynVec<DiagnosticTag>
    related_information: DynVec<DiagnosticRelatedInformation>
}

DiagnosticSeverity: Error, Warning, Information, Hint

DiagnosticTag: Unnecessary, Deprecated

DiagnosticRelatedInformation := {
    location: Location
    message: string
}

// Completion
CompletionItem := {
    label: string
    kind: CompletionItemKind
    detail: Option<string>
    documentation: Option<string>
    deprecated: bool
    preselect: bool
    sort_text: Option<string>
    filter_text: Option<string>
    insert_text: Option<string>
    insert_text_format: InsertTextFormat
    text_edit: Option<TextEdit>
    additional_text_edits: DynVec<TextEdit>
    commit_characters: DynVec<string>
    command: Option<Command>
}

CompletionItemKind: Text, Method, Function, Constructor, Field, Variable, Class, Interface, Module, Property, Unit, Value, Enum, Keyword, Snippet, Color, File, Reference, Folder, EnumMember, Constant, Struct, Event, Operator, TypeParameter

InsertTextFormat: PlainText, Snippet

TextEdit := {
    range: Range
    new_text: string
}

Command := {
    title: string
    command: string
    arguments: DynVec<json.Value>
}

// Hover
Hover := {
    contents: MarkupContent
    range: Option<Range>
}

MarkupContent := {
    kind: MarkupKind
    value: string
}

MarkupKind: PlainText, Markdown

// Signature Help
SignatureHelp := {
    signatures: DynVec<SignatureInformation>
    active_signature: Option<i32>
    active_parameter: Option<i32>
}

SignatureInformation := {
    label: string
    documentation: Option<MarkupContent>
    parameters: DynVec<ParameterInformation>
}

ParameterInformation := {
    label: string
    documentation: Option<MarkupContent>
}

// Document Symbols
DocumentSymbol := {
    name: string
    detail: Option<string>
    kind: SymbolKind
    deprecated: bool
    range: Range
    selection_range: Range
    children: DynVec<DocumentSymbol>
}

SymbolKind: File, Module, Namespace, Package, Class, Method, Property, Field, Constructor, Enum, Interface, Function, Variable, Constant, String, Number, Boolean, Array, Object, Key, Null, EnumMember, Struct, Event, Operator, TypeParameter

// Code Actions
CodeAction := {
    title: string
    kind: Option<CodeActionKind>
    diagnostics: DynVec<Diagnostic>
    is_preferred: bool
    edit: Option<WorkspaceEdit>
    command: Option<Command>
}

CodeActionKind: QuickFix, Refactor, RefactorExtract, RefactorInline, RefactorRewrite, Source, SourceOrganizeImports, SourceFixAll

WorkspaceEdit := {
    changes: HashMap<string, DynVec<TextEdit>>
}

// Language Server State
LanguageServer := {
    initialized: bool
    root_uri: Option<string>
    documents: HashMap<string, TextDocument>
    diagnostics: HashMap<string, DynVec<Diagnostic>>
    symbols: HashMap<string, DynVec<DocumentSymbol>>
    client_capabilities: Option<ClientCapabilities>
}

// Create new language server
create_server = () LanguageServer {
    return LanguageServer {
        initialized: false
        root_uri: Option.None
        documents: HashMap.new<string, TextDocument>()
        diagnostics: HashMap.new<string, DynVec<Diagnostic>>()
        symbols: HashMap.new<string, DynVec<DocumentSymbol>>()
        client_capabilities: Option.None
    }
}

// Handle initialize request
handle_initialize = (server: Ptr<LanguageServer>, params: InitializeParams) json.Value {
    server.initialized = true
    server.root_uri = params.root_uri
    server.client_capabilities = Option.Some(params.capabilities)
    
    capabilities := ServerCapabilities {
        text_document_sync: TextDocumentSyncKind.Full
        completion_provider: Option.Some(CompletionOptions {
            resolve_provider: false
            trigger_characters: DynVec.from_array([".", "@", ":"])
        })
        hover_provider: true
        signature_help_provider: Option.Some(SignatureHelpOptions {
            trigger_characters: DynVec.from_array(["(", ","])
            retrigger_characters: DynVec.new<string>()
        })
        definition_provider: true
        references_provider: true
        document_formatting_provider: true
        document_range_formatting_provider: true
        document_symbol_provider: true
        workspace_symbol_provider: true
        code_action_provider: true
        code_lens_provider: Option.None
        document_link_provider: Option.None
        rename_provider: true
        semantic_tokens_provider: Option.Some(SemanticTokensOptions {
            legend: SemanticTokensLegend {
                token_types: DynVec.from_array([
                    "namespace", "type", "class", "enum", "interface",
                    "struct", "typeParameter", "parameter", "variable",
                    "property", "enumMember", "event", "function",
                    "method", "macro", "keyword", "modifier", "comment",
                    "string", "number", "regexp", "operator"
                ])
                token_modifiers: DynVec.from_array([
                    "declaration", "definition", "readonly", "static",
                    "deprecated", "abstract", "modification",
                    "documentation", "defaultLibrary"
                ])
            }
            range: true
            full: Option.Some(SemanticTokensFullOptions { delta: false })
        })
    }
    
    return json.object([
        ("capabilities", json.to_value(capabilities))
    ])
}

// Check for import syntax errors
check_import_syntax = (content: string) DynVec<Diagnostic>   {
    diagnostics := DynVec.new<Diagnostic>()
    lines := string.split(content, "\n")
    
    in_comptime := false
    comptime_start_line := 0
    brace_depth := 0
    
    for i := 0; i < lines.len(); i = i + 1 {
        line := lines[i]
        trimmed := string.trim(line)
        
        // Track comptime blocks
        if string.starts_with(trimmed, "comptime") && string.contains(trimmed, "{") {
            in_comptime = true
            comptime_start_line = i
            brace_depth = 1
        }
        
        // Track braces in comptime
        if in_@comptime {
            for j := 0; j < string.len(line); j = j + 1 {
                ch := string.char_at(line, j)
                if ch == '{' {
                    brace_depth = brace_depth + 1
                } else if ch == '}' {
                    brace_depth = brace_depth - 1
                    if brace_depth == 0 {
                        in_comptime = false
                    }
                }
            }
        }
        
        // Check for imports
        if string.contains(line, ":= @std") || string.contains(line, ":= @compiler") {
            if in_@comptime {
                DynVec.push(&diagnostics, Diagnostic {
                    range: Range {
                        start: Position { line: i, character: 0 }
                        end: Position { line: i, character: string.len(line) }
                    }
                    severity: DiagnosticSeverity.Error
                    code: Option.Some("E001")
                    source: Option.Some("zen-lsp")
                    message: "Import statements are not allowed inside comptime blocks. Move imports to module level."
                    tags: DynVec.new<DiagnosticTag>()
                    related_information: DynVec.from_array([
                        DiagnosticRelatedInformation {
                            location: Location {
                                uri: ""
                                range: Range {
                                    start: Position { line: comptime_start_line, character: 0 }
                                    end: Position { line: comptime_start_line, character: 0 }
                                }
                            }
                            message: "Comptime block starts here"
                        }
                    ])
                })
            }
        }
        
        // Check for incorrect import patterns
        if string.contains(line, "comptime") && string.contains(line, "@std") {
            DynVec.push(&diagnostics, Diagnostic {
                range: Range {
                    start: Position { line: i, character: 0 }
                    end: Position { line: i, character: string.len(line) }
                }
                severity: DiagnosticSeverity.Error
                code: Option.Some("E002")
                source: Option.Some("zen-lsp")
                message: "Imports should not be wrapped with comptime"
                tags: DynVec.new<DiagnosticTag>()
                related_information: DynVec.new<DiagnosticRelatedInformation>()
            })
        }
    }
    
    return diagnostics
}

// Provide completion items
provide_completions = (server: Ptr<LanguageServer>, uri: string, position: Position) DynVec<CompletionItem>   {
    items := DynVec.new<CompletionItem>()
    
    // Get document
    doc := HashMap.get(server.documents, uri)
    if doc == Option.None {
        return items
    }
    
    // Standard library modules
    stdlib_modules := [
        "core", "io", "fs", "string", "vec", "math", "mem",
        "net", "http", "json", "concurrency", "crypto", "regex",
        "time", "process", "thread", "test", "log"
    ]
    
    // Check context for @std completion
    lines := string.split(doc.content, "\n")
    if position.line < lines.len() {
        line := lines[position.line]
        before_cursor := string.substring(line, 0, position.character)
        
        if string.ends_with(before_cursor, "@std.") {
            // Provide stdlib module completions
            for mod in stdlib_modules {
                DynVec.push(&items, CompletionItem {
                    label: mod
                    kind: CompletionItemKind.Module
                    detail: Option.Some("Standard library module")
                    documentation: Option.Some("Import " + mod + " module from standard library")
                    deprecated: false
                    preselect: false
                    sort_text: Option.None
                    filter_text: Option.None
                    insert_text: Option.Some(mod)
                    insert_text_format: InsertTextFormat.PlainText
                    text_edit: Option.None
                    additional_text_edits: DynVec.new<TextEdit>()
                    commit_characters: DynVec.new<string>()
                    command: Option.None
                })
            }
        } else if string.ends_with(before_cursor, ":= ") {
            // Suggest @std for imports
            DynVec.push(&items, CompletionItem {
                label: "@std"
                kind: CompletionItemKind.Snippet
                detail: Option.Some("Import from standard library")
                documentation: Option.Some("Import a module from the Zen standard library")
                deprecated: false
                preselect: true
                sort_text: Option.Some("0000")
                filter_text: Option.None
                insert_text: Option.Some("@std.$1")
                insert_text_format: InsertTextFormat.Snippet
                text_edit: Option.None
                additional_text_edits: DynVec.new<TextEdit>()
                commit_characters: DynVec.new<string>()
                command: Option.None
            })
        }
        
        // Keywords
        keywords := [
            "if", "else", "match", "for", "while", "loop", "return",
            "struct", "enum", "impl", "behavior", "comptime", "pub",
            "mut", "const", "fn", "type", "import", "export"
        ]
        
        for kw in keywords {
            DynVec.push(&items, CompletionItem {
                label: kw
                kind: CompletionItemKind.Keyword
                detail: Option.None
                documentation: Option.None
                deprecated: false
                preselect: false
                sort_text: Option.None
                filter_text: Option.None
                insert_text: Option.Some(kw)
                insert_text_format: InsertTextFormat.PlainText
                text_edit: Option.None
                additional_text_edits: DynVec.new<TextEdit>()
                commit_characters: DynVec.new<string>()
                command: Option.None
            })
        }
    }
    
    return items
}

// Handle text document changes
handle_did_change = (server: Ptr<LanguageServer>, uri: string, content: string, version: i32) void   {
    // Update document
    doc := HashMap.get_mut(server.documents, uri)
    if doc != Option.None {
        doc.content = content
        doc.version = version
    }
    
    // Check for errors
    diagnostics := check_import_syntax(content)
    HashMap.insert(server.diagnostics, uri, diagnostics)
    
    // Send diagnostics to client
    publish_diagnostics(uri, diagnostics)
}

// Publish diagnostics to client
publish_diagnostics = (uri: string, diagnostics: DynVec<Diagnostic>) void   {
    notification := json.object([
        ("jsonrpc", json.string("2.0")),
        ("method", json.string("textDocument/publishDiagnostics")),
        ("params", json.object([
            ("uri", json.string(uri)),
            ("diagnostics", json.to_value(diagnostics))
        ]))
    ])
    
    send_message(notification)
}

// Send message to client
send_message = (msg: json.Value) void   {
    content := json.stringify(msg)
    io.printf("Content-Length: {}\r\n\r\n{}", string.len(content), content)
    io.flush()
}

// Main server loop
main = () i32   {
    server := create_server()
    
    io.eprintln("Zen Language Server starting...")
    
    loop {
        // Read header
        header := io.read_line()
        if !string.starts_with(header, "Content-Length:") {
            continue
        }
        
        length_str := string.trim(string.substring(header, 15, string.len(header)))
        length := string.to_i32(length_str)?
        
        // Skip empty line
        io.read_line()
        
        // Read content
        content := io.read_bytes(length)
        
        // Parse JSON
        msg := json.parse(content)?
        
        // Handle message
        if msg.has("method") {
            method := msg.get("method").as_string()
            params := msg.get("params")
            
            response := match method {
                "initialize" => handle_initialize(&server, json.from_value<InitializeParams>(params))
                "textDocument/didOpen" => {
                    doc := json.from_value<TextDocument>(params.get("textDocument"))
                    HashMap.insert(server.documents, doc.uri, doc)
                    handle_did_change(&server, doc.uri, doc.content, doc.version)
                    json.null()
                }
                "textDocument/didChange" => {
                    uri := params.get("textDocument").get("uri").as_string()
                    changes := params.get("contentChanges")
                    if changes.len() > 0 {
                        content := changes[0].get("text").as_string()
                        version := params.get("textDocument").get("version").as_i32()
                        handle_did_change(&server, uri, content, version)
                    }
                    json.null()
                }
                "textDocument/completion" => {
                    uri := params.get("textDocument").get("uri").as_string()
                    position := json.from_value<Position>(params.get("position"))
                    items := provide_completions(&server, uri, position)
                    json.to_value(items)
                }
                _ => json.null()
            }
            
            // Send response if request (has id)
            if msg.has("id") {
                reply := json.object([
                    ("jsonrpc", json.string("2.0")),
                    ("id", msg.get("id")),
                    ("result", response)
                ])
                send_message(reply)
            }
        }
    }
    
    return 0
}