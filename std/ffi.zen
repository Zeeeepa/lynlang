// FFI Module - Foreign Function Interface with Builder Pattern
// Based on Zenlang Language Specification v1.1.0

// Import core types
build := @std.build
core := build.import("core")
{ Option, Result, Vec, HashMap, Ptr } := core

// Core FFI types for safe C interop
FnSignature = {
    params: Vec<Type>,
    returns: Type,
}

// Library builder for safe FFI
LibBuilder = {
    name: string,
    path:: Option<string>,
    functions:: HashMap<string, FnSignature>,
    constants:: HashMap<string, Type>,
    
    // Set library path
    path: (self: Ptr<LibBuilder>, p: string) Ptr<LibBuilder> {
        self.value.path = Option::Some(p)
        self
    },
    
    // Add a function binding
    function: (self: Ptr<LibBuilder>, name: string, sig: FnSignature) Ptr<LibBuilder> {
        self.value.functions.insert(name, sig)
        self
    },
    
    // Add a constant binding
    constant: (self: Ptr<LibBuilder>, name: string, t: Type) Ptr<LibBuilder> {
        self.value.constants.insert(name, t)
        self
    },
    
    // Build the library
    build: (self: Ptr<LibBuilder>) Library {
        path := self.value.path ?
            | Some -> p => p
            | None => default_lib_path(self.value.name)
        
        Library{
            name: self.value.name,
            path: path,
            functions: self.value.functions,
            constants: self.value.constants,
            handle: Option::None,
        }
    },
}

// Represents a loaded dynamic library
Library = {
    name: string,
    path: string,
    functions: HashMap<string, FnSignature>,
    constants: HashMap<string, Type>,
    handle:: Option<RawPtr<void>>,
    
    // Load the library
    load: (self: Ptr<Library>) Result<void, Error> {
        handle := dlopen(self.value.path, RTLD_LAZY)
        handle.is_null() ?
            | false => {
                self.value.handle = Option::Some(handle)
                Result::Ok(void)
            }
            | true => Result::Err(Error::LibraryNotFound(self.value.path))
    },
    
    // Get a function pointer
    get_function: (self: Ptr<Library>, name: string) Result<RawPtr<void>, Error> {
        self.value.handle ?
            | Some -> h => {
                sym := dlsym(h, name)
                sym.is_null() ?
                    | false => Result::Ok(sym)
                    | true => Result::Err(Error::SymbolNotFound(name))
            }
            | None => Result::Err(Error::LibraryNotLoaded)
    },
    
    // Get a constant value
    get_constant: (self: Ptr<Library>, name: string) Result<RawPtr<void>, Error> {
        self.get_function(name)  // Constants are just symbols
    },
    
    // Unload the library
    unload: (self: Ptr<Library>) void {
        self.value.handle ?
            | Some -> h => {
                dlclose(h)
                self.value.handle = Option::None
            }
            | None => {}
    },
}

// Main FFI interface
FFI = {
    // Create a new library builder
    lib: (name: string) Ptr<LibBuilder> {
        Ptr::new(LibBuilder{
            name: name,
            path: Option::None,
            functions: HashMap<string, FnSignature>::new(),
            constants: HashMap<string, Type>::new(),
        })
    },
}

// Helper to determine default library path based on platform
default_lib_path = (name: string) string {
    @std.target.os ?
        | .linux => "lib$(name).so"
        | .windows => "$(name).dll"
        | .macos => "lib$(name).dylib"
        | _ => "lib$(name).so"
}

// Low-level FFI functions (compiler intrinsics)
dlopen = (filename: string, flags: i32) RawPtr<void> {
    @intrinsic("dlopen", filename, flags)
}

dlsym = (handle: RawPtr<void>, symbol: string) RawPtr<void> {
    @intrinsic("dlsym", handle, symbol)
}

dlclose = (handle: RawPtr<void>) i32 {
    @intrinsic("dlclose", handle)
}

// Constants for dlopen
RTLD_LAZY := 0x0001
RTLD_NOW := 0x0002
RTLD_GLOBAL := 0x0100
RTLD_LOCAL := 0x0000

// Error types
Error =
    | LibraryNotFound(path: string)
    | SymbolNotFound(name: string)
    | LibraryNotLoaded
    | InvalidSignature(expected: FnSignature, got: FnSignature)

// Type representation for FFI
Type =
    | Void
    | Bool
    | I8 | I16 | I32 | I64
    | U8 | U16 | U32 | U64
    | F32 | F64
    | Usize
    | String
    | RawPointer(inner: Ptr<Type>)
    | Array(size: usize, element: Ptr<Type>)
    | Struct(fields: Vec<FieldType>)
    | Function(signature: FnSignature)

FieldType = {
    name: string,
    type: Type,
}

// Utility functions for creating types
type_void = () Type { Type::Void }
type_bool = () Type { Type::Bool }
type_i32 = () Type { Type::I32 }
type_i64 = () Type { Type::I64 }
type_u32 = () Type { Type::U32 }
type_u64 = () Type { Type::U64 }
type_f32 = () Type { Type::F32 }
type_f64 = () Type { Type::F64 }
type_string = () Type { Type::String }
type_raw_ptr = (inner: Type) Type { Type::RawPointer(Ptr::new(inner)) }

// Export public API
export {
    FFI,
    LibBuilder,
    Library,
    FnSignature,
    Type,
    Error,
    type_void,
    type_bool,
    type_i32,
    type_i64,
    type_u32,
    type_u64,
    type_f32,
    type_f64,
    type_string,
    type_raw_ptr,
}