// FFI Module - Foreign Function Interface with Builder Pattern
// Based on Zenlang Language Specification v1.1.0

// Core types
Option<T> =
    | Some(value: T)
    | None

Result<T, E> =
    | Ok(value: T)
    | Err(error: E)

// Ptr type for pointers
Ptr<T> = {
    value: T,
    address: usize,
    
    new: (value: T) Ptr<T> {
        // Compiler intrinsic to allocate on heap
        @intrinsic("ptr_new", value)
    },
}

// Vec type for dynamic arrays
Vec<T> = {
    data: Ptr<[?, T]>,
    len: usize,
    capacity: usize,
    
    new: () Vec<T> {
        Vec { 
            data: @intrinsic("vec_new"),
            len: 0,
            capacity: 0,
        }
    },
    
    push: (self: Ptr<Vec<T>>, item: T) void {
        @intrinsic("vec_push", self, item)
    },
}

// HashMap type for key-value pairs
HashMap<K, V> = {
    buckets: Ptr<[?, Bucket<K, V>]>,
    count: usize,
    
    new: () HashMap<K, V> {
        HashMap {
            buckets: @intrinsic("hashmap_new"),
            count: 0,
        }
    },
    
    insert: (self: Ptr<HashMap<K, V>>, key: K, value: V) void {
        @intrinsic("hashmap_insert", self, key, value)
    },
    
    get: (self: Ptr<HashMap<K, V>>, key: K) Option<V> {
        @intrinsic("hashmap_get", self, key)
    },
}

Bucket<K, V> = {
    key: K,
    value: V,
    next: Option<Ptr<Bucket<K, V>>>,
}

// Core FFI types for safe C interop
FnSignature: {
    params: Vec<Type>,
    returns: Type,
}

// Library builder for safe FFI
LibBuilder: {
    name: string,
    path: Option<string>,
    functions: HashMap<string, FnSignature>,
    constants: HashMap<string, Type>,
}

// Builder methods
set_path: (self: Ptr<LibBuilder>, p: string) Ptr<LibBuilder>  = {
    self.value.path = Some(p)
    self
}

add_function: (self: Ptr<LibBuilder>, name: string, sig: FnSignature) Ptr<LibBuilder>  = {
    self.value.functions.insert(name, sig)
    self
}

add_constant: (self: Ptr<LibBuilder>, name: string, t: Type) Ptr<LibBuilder>  = {
    self.value.constants.insert(name, t)
    self
}

build_library: (self: Ptr<LibBuilder>) Library  = {
    path := self.value.path ?
        | .Some -> p => p
        | .None => default_lib_path(self.value.name)
    
    Library{
        name: self.value.name,
        path: path,
        functions: self.value.functions,
        constants: self.value.constants,
        handle: None,
    }
}

// Represents a loaded dynamic library
Library: {
    name: string,
    path: string,
    functions: HashMap<string, FnSignature>,
    constants: HashMap<string, Type>,
    handle: Option<RawPtr<void>>,
}

// Library methods
load: (self: Ptr<Library>) Result<void, Error>  = {
    handle := dlopen(self.value.path, RTLD_LAZY)
    handle.address == 0 ?
        | false => {
            self.value.handle = Some(handle)
            Ok(void)
        }
        | true => Err(Error:LibraryNotFound(self.value.path))
}

get_function: (self: Ptr<Library>, name: string) Result<RawPtr<void>, Error>  = {
    self.value.handle ?
        | .Some -> h => {
            sym := dlsym(h, name)
            sym.address == 0 ?
                | false => Ok(sym)
                | true => Err(Error:SymbolNotFound(name))
        }
        | .None => Err(Error:LibraryNotLoaded)
}

get_constant: (self: Ptr<Library>, name: string) Result<RawPtr<void>, Error>  = {
    self.get_function(name)  // Constants are just symbols
}

unload: (self: Ptr<Library>) void  = {
    self.value.handle ?
        | .Some -> h => {
            dlclose(h)
            self.value.handle = None
        }
        | .None => {}
}

// Main FFI interface
FFI: {
    // Create a new library builder
    lib: (name: string) Ptr<LibBuilder> {
        Ptr:new(LibBuilder{
            name: name,
            path: None,
            functions: HashMap:new(),
            constants: HashMap:new(),
        })
    },
}

// Helper to determine default library path based on platform
default_lib_path: (name: string) string  = {
    @std.target.os ?
        | .linux => "lib$(name).so"
        | .windows => "$(name).dll"
        | .macos => "lib$(name).dylib"
        | _ => "lib$(name).so"
}

// RawPtr type for FFI
RawPtr<T> = {
    value: T,
    address: usize,
    
    from_address: (addr: usize) RawPtr<T> {
        @intrinsic("rawptr_from_address", addr)
    },
}

// Low-level FFI functions (compiler intrinsics)
dlopen: (filename: string, flags: i32) RawPtr<void>  = {
    @intrinsic("dlopen", filename, flags)
}

dlsym: (handle: RawPtr<void>, symbol: string) RawPtr<void>  = {
    @intrinsic("dlsym", handle, symbol)
}

dlclose: (handle: RawPtr<void>) i32  = {
    @intrinsic("dlclose", handle)
}

// Constants for dlopen
RTLD_LAZY := 0x0001
RTLD_NOW := 0x0002
RTLD_GLOBAL := 0x0100
RTLD_LOCAL := 0x0000

// Error types
Error: LibraryNotFound(path: string)
    | SymbolNotFound(name: string)
    | LibraryNotLoaded
    | InvalidSignature(expected: FnSignature, got: FnSignature)

// Type representation for FFI
Type: Void
    | Bool
    | I8
    | I16
    | I32
    | I64
    | U8
    | U16
    | U32
    | U64
    | F32
    | F64
    | Usize
    | String
    | RawPointer(inner: Ptr<Type>)
    | Array(size: usize, element: Ptr<Type>)
    | Struct(fields: Vec<FieldType>)
    | Function(signature: FnSignature)

FieldType: {
    name: string,
    type: Type,
}

// Utility functions for creating types
type_void: () Type  = { Void }
type_bool: () Type  = { Bool }
type_i32: () Type  = { I32 }
type_i64: () Type  = { I64 }
type_u32: () Type  = { U32 }
type_u64: () Type  = { U64 }
type_f32: () Type  = { F32 }
type_f64: () Type  = { F64 }
type_string: () Type  = { String }
type_raw_ptr: (inner: Type) Type  = { RawPointer(Ptr:new(inner)) }

// Example usage following the spec:
// sqlite := FFI.lib("sqlite3")
//     .set_path("/usr/lib/libsqlite3.so")
//     .add_function("sqlite3_open", {
//         params: vec![type_string(), type_raw_ptr(type_raw_ptr(type_void()))],
//         returns: type_i32(),
//     })
//     .add_function("sqlite3_close", {
//         params: vec![type_raw_ptr(type_void())],
//         returns: type_i32(),
//     })
//     .add_constant("SQLITE_OK", type_i32())
//     .build_library()