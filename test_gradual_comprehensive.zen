// Gradually build up the comprehensive test
{ io, Result, Option } = @std

// Test 3: Result<Option<T>, E>
test_result_option = () void {
    io.println("\nTest 3: Result<Option<T>, E>")
    
    get_result_option = () Result<Option<i32>, string> {
        Result.Ok(Option.Some(300))
    }
    
    result = get_result_option()
    opt = result.raise()
    
    opt ?
        | Some(v) { 
            io.println("  Expected: 300, Got: ${v}")
        }
        | None { io.println("  âœ— Got None unexpectedly") }
}

// Test 7: Variables holding nested generics
test_variable_type_inference = () void {
    io.println("\nTest 7: Variable type inference")
    
    // Store nested result in variable
    nested_result = Result.Ok(Result.Ok(600))
    
    // Extract through variable
    inner = nested_result.raise()
    value = inner.raise()
    
    io.println("  Expected: 600, Got: ${value}")
}

// Test 8: Complex nesting with closures
test_closure_nested = () void {
    io.println("\nTest 8: Closures returning nested generics")
    
    make_nested = () Result<Result<i32, string>, string> {
        inner_fn = () Result<i32, string> {
            Result.Ok(700)
        }
        Result.Ok(inner_fn())
    }
    
    result = make_nested()
    inner = result.raise()
    value = inner.raise()
    
    io.println("  Expected: 700, Got: ${value}")
}

main = () void {
    // test_result_option()
    // test_variable_type_inference()
    test_closure_nested()
}