// Test enum definitions from LANGUAGE_SPEC.zen

// Option type - fundamental to Zen's no-null philosophy
Option<T>: .Some(T) | .None

// Result type for error handling
Result<T, E>: .Ok(T) | .Err(E)

// Simple enum without payloads
FileMode: .ReadOnly | .WriteOnly | .ReadWrite | .Append | .CreateNew

// Enum with mixed payload types
Shape: .Circle(radius: f64) | .Rectangle(width: f64, height: f64) | .Point

// Game entity enum from spec
GameEntity: .Player | .Enemy | .Powerup

// IO Error types from spec
IOError: .FileNotFound
    | .PermissionDenied
    | .AlreadyExists
    | .BrokenPipe
    | .UnexpectedEof
    | .InvalidInput
    | .WriteZero
    | .ReadError
    | .WriteError
    | .Other

// Import io for testing
{ io } = @std

// Test basic enum usage
main = () void {
    // Option usage
    maybe_value: Option<i32> = .Some(42)
    maybe_value ?
        | .Some(val) { io.println("Got value!") }
        | .None { io.println("No value") }
    
    // Result usage
    result: Result<i32, IOError> = .Ok(100)
    result ?
        | .Ok(val) { io.println("Success!") }
        | .Err(e) { io.println("Error occurred") }
    
    // Simple enum pattern matching
    mode = FileMode.ReadOnly
    mode ?
        | .ReadOnly { io.println("Read only mode") }
        | .WriteOnly { io.println("Write only mode") }
        | _ { io.println("Other mode") }
    
    // Entity enum usage
    entity = GameEntity.Player
    entity ?
        | .Player { io.println("It's a player!") }
        | .Enemy { io.println("It's an enemy!") }
        | .Powerup { io.println("It's a powerup!") }
}